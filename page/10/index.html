<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/default_avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/default_avatar.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;chaomai.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;right&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:true,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="chaomai&#39;s blog">
<meta property="og:url" content="https://chaomai.github.io/page/10/index.html">
<meta property="og:site_name" content="chaomai&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chao Mai">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaomai.github.io/page/10/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;10&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>chaomai's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-34179929-2"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;UA-34179929-2&quot;,&quot;only_pageview&quot;:false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="chaomai's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">chaomai's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>Rss</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chao Mai</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chaomai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chaomai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:loneymai@gmail.com" title="E-Mail → mailto:loneymai@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/chaomai" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;chaomai" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://laike9m.com/" title="https:&#x2F;&#x2F;laike9m.com" rel="noopener" target="_blank">laike9m's blog</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2015/2015-03-10-analysis-reference-in-cpp-from-the-perspective-of-assembly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/2015-03-10-analysis-reference-in-cpp-from-the-perspective-of-assembly/" class="post-title-link" itemprop="url">从汇编的角度分析C++引用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-03-10 17:35:29" itemprop="dateCreated datePublished" datetime="2015-03-10T17:35:29+08:00">2015-03-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/2015-03-10-analysis-reference-in-cpp-from-the-perspective-of-assembly/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/2015-03-10-analysis-reference-in-cpp-from-the-perspective-of-assembly/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>C++中，引用为对象起了另外一个名字，引用类型refers to另外一种类型。引用和指针是不同的，可以汇编的角度来看引用。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2015/2015-03-10-analysis-reference-in-cpp-from-the-perspective-of-assembly/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2015/2015-02-06-type-safe-typedef-in-cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2015/2015-02-06-type-safe-typedef-in-cpp/" class="post-title-link" itemprop="url">C++中typedef的使用和类型安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-02-06 23:06:00" itemprop="dateCreated datePublished" datetime="2015-02-06T23:06:00+08:00">2015-02-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2015/2015-02-06-type-safe-typedef-in-cpp/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/2015-02-06-type-safe-typedef-in-cpp/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>传统的`typedef`机制允许对已存在的type提供synonym或者alias，被定义为新引入的alias的类型与被定义为原来类型的变量，完全一样，不会有一丁点行为上的差别，但是这种特性在某些场景下会有缺陷。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2015/2015-02-06-type-safe-typedef-in-cpp/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2014/2014-12-11-kbc-poker-2-briefly-reivew/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2014/2014-12-11-kbc-poker-2-briefly-reivew/" class="post-title-link" itemprop="url">入手KBC Poker 2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-12-11 23:20:42" itemprop="dateCreated datePublished" datetime="2014-12-11T23:20:42+08:00">2014-12-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/life/" itemprop="url" rel="index"><span itemprop="name">life</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2014/2014-12-11-kbc-poker-2-briefly-reivew/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/2014-12-11-kbc-poker-2-briefly-reivew/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="KBC-Poker-2"><a href="#KBC-Poker-2" class="headerlink" title="KBC Poker 2"></a>KBC Poker 2</h1><p>用倦Thindpad T420自带的键盘，也想尝试一下机械键盘的手感如何，就入手了一个机械键盘，KBC Poker 2。</p>
<p>入手Poker 2的原因不仅仅是Filco Minila Air和HHKB的价格有点高，还有一点吸引我的原因就是Poker 2支持全键位硬件可编程。</p>
<p>Poker 2已经是第二代了，相比起第一代，带来了许多的改进，网上的总结有这么几点：</p>
<blockquote><ul>
<li>保留了经典的US配列</li>
<li>增加了数控钢板，使得茶轴、青轴和红轴的手感大大增强，黑轴基本不变</li>
<li>内置7级亮度调节的DIY灯控支持，插上LED就会亮</li>
<li>全新加厚PBT键帽，带来目前最为细腻的PBT触感</li>
<li>增加了实用和进阶的附件六颗RGB加厚PBT套装和钢丝拔键器</li>
<li>换代的卫星轴进一步提升了手感，彻底让卫星轴翻身做主人</li>
<li>仍然保持一代的价格，加量完全不加价，499元</li>
<li>USB任意6键无冲</li>
<li>自带延时编程的全键位硬件可编程</li>
</ul>
</blockquote>

<p>键盘从淘宝上购买，只是中通快递，等得我整个人都不好了。。。</p>
<p>除了键盘外，还随带附送的配件：分离式可拆卸的USB数据线，一个钢丝拔键器，一套RGB的PBT材质键帽。换下原来的键帽，把六个RGB键帽装上以后，就是这样了。</p>
<p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_192835.jpg"></p>
<p>因为是60%尺寸的设计，省去了方向键和其他的一些功能键，改用Fn的组合键和Pn的编程键实现相应的功能，因此键盘更加玲珑小巧、方便携带。在文章的后面会给出自己修改键位的办法。</p>
<p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_192808.jpg"></p>
<p>键帽由于是PBT材质的，而且还是加厚的键帽，手感很不错，空格键上的”Enjoy your feeling”正是说明了这一点。</p>
<p>但是细节处的做工就不是那么精细了，键帽边缘有少许的毛刺。但我不是强迫症，平时使用根本看不见，So it doesn’t matter.</p>
<p>这次入手的Poker 2是茶轴的，网上茶轴的介绍如下：</p>
<blockquote><p>全面兼顾：茶轴</p>
<p>茶轴的手感比较均衡，也可说是较为中庸，带有段落感，触发键程为2.0mm。另外，其压力克数比较小，只有60g，敲击显得非常轻松，能兼顾打字和游戏使用。</p>
<p>敲击茶轴的感觉如同小范围内的极速轻金属碰撞，很神秘的那么一下，结合了青轴和黑轴的特点，或者看成它是最没有特点的一种特殊轴，这也是手感最类似于传统键盘的机械键盘，压力在黑轴和青轴中间。</p>
<p>它的段落感，你按下一个键后段落感可以给你确认感，同时压力不太大，适合那种瞬间飚快捷键的快手。</p>
</blockquote>

<p>由于没有使用过其他机械键盘，我只能和T420的键盘做对比。使用下来的感觉是，和T420的键盘相比，不需要多大的力量就可以触发，按下去的时候有段落感，触发段落感的力量也不大。用了Poker 2以后，感觉就是“回不去了。。。”。</p>
<p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_193448.jpg"></p>
<p>USB数据线的接口，看着像micro USB的，但其实不是，有点像以前老式的好记星的接口。</p>
<p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_193043.jpg"></p>
<p>背面有四个橡胶脚垫，不支持角度的调节，不过键盘正面的有弧度的设计，比较符合人体工程学，因此还是很舒适的。</p>
<p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_193117.jpg"></p>
<p>这里就是DIP开关。最早见到这个DIP开关是在HHKB上，Poker 2的DIP开关与HHKB的还是有所区别的。记得当初关注HHKB并不是因为机械键盘的缘故，而是Caps和Control键可以互换，加上当时在Ubuntu下开发，所以一直眼馋HHKB，只是价格的原因，一直没入手。</p>
<p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_193231.jpg"></p>
<h2 id="Poker-2总结"><a href="#Poker-2总结" class="headerlink" title="Poker 2总结"></a>Poker 2总结</h2><p>Poker 2使用了小尺寸的设计，精简了多余的按键，加上分离式可拆卸的USB，大大提升了便携性。总体来说，做工中规中矩，PBT加厚键帽，内置钢板，但不足的是小细节的地方，比如键帽的边缘。</p>
<h1 id="键位修改"><a href="#键位修改" class="headerlink" title="键位修改"></a>键位修改</h1><p>首先，用键盘编程在V键上，把Win键编程为：Pn+V。因为后面需要用开关把做Win改为左Fn，还有就是目前是在Windows下工作，Win键不可少，所以这里要提前设置Win的替代键位。</p>
<p>接下来，用键盘编程在L上，把Win+L键编程为：Pn+L；在，键上，把Win+Space编程为：Pn+，。其实这里不是必须的，我只是为了方便。</p>
<p>然后就是设置键盘后面的几个开关，背面的4个DIP开关的功能分别是：</p>
<ul>
<li>开关1：Caps与左Win切换</li>
<li>开关2：右Ctrl与`~切换</li>
<li>开关3：左Win与Fn切换</li>
<li>开关4：键盘写保护，键位编程</li>
</ul>
<p>将开关1和3都拨到ON的位置，效果：Caps变成了Fn，左Win变成了Caps。</p>
<p>到这里键位修改就完成了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2014/2014-03-31-cpp-object-oriented-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2014/2014-03-31-cpp-object-oriented-programming/" class="post-title-link" itemprop="url">C++面向对象程序设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-03-31 16:14:25" itemprop="dateCreated datePublished" datetime="2014-03-31T16:14:25+08:00">2014-03-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2014/2014-03-31-cpp-object-oriented-programming/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/2014-03-31-cpp-object-oriented-programming/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>基类中类型相关的函数与派生类不做改变直接继承的函数是不同的，当希望派生类定义合适自身的版本，此时基类就将这些函数声明为虚函数。</p>
<h1 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h1><p>基类<strong>通常都应该</strong>定义一个虚析构函数，即使该函数不执行任何实际操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Quote() = <span class="keyword">default</span>;</span><br><span class="line">  Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price)</span><br><span class="line">      : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h2><p>基类有两种成员函数，</p>
<ol>
<li>希望派生类进行覆盖的<ul>
<li>当使用指针或引用调用虚函数时，该调用将被动态绑定</li>
<li>任何<strong>除构造函数之外的非静态函数</strong>都可以是虚函数</li>
<li>如果某个函数在基类中被声明为虚函数，那么在派生类中<strong>隐式地</strong>也是虚函数</li>
</ul>
</li>
<li>希望派生类直接继承而不需要改变的<ul>
<li>如果不是虚函数，则其解析过程发生在编译时而非运行时</li>
</ul>
</li>
</ol>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>派生类能访问公有成员和受保护的成员，但<strong>不能访问私有成员</strong>（继承了，但无权限访问）。</p>
<h1 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h1><p>类派生列表中的访问说明是控制派生类从基类继承而来的成员<strong>是否对派生类的用户可见</strong>。如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。可以将<strong>公有派生类型</strong>的对象绑定到基类的引用或指针上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkQuote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BulkQuote() = <span class="keyword">default</span>;</span><br><span class="line">  BulkQuote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h2><p>派生类经常，<strong>但不总是</strong>，覆盖继承的虚函数。如果没有覆盖，则虚函数行为类似其他的普通成员，直接使用基类中的版本。</p>
<p>派生类必须对<strong>需要覆盖的</strong>重新声明，派生类可以在这样的函数前加上<code>virtual</code>，但<strong>并非必须</strong>。C++11允许显式地在声明的<strong>最后</strong>用<code>override</code>注明覆盖。</p>
<h2 id="派生类向基类的类型转换"><a href="#派生类向基类的类型转换" class="headerlink" title="派生类向基类的类型转换"></a>派生类向基类的类型转换</h2><p>一个派生类对象中，继承自基类的部分和派生类的部分<strong>不一定是连续存储的</strong>。</p>
<p>由于派生类对象中<strong>含有与其基类对应</strong>的组成部分，因此能将派生类对象当成基类对象来使用，能将基类指针或引用<strong>绑定到派生类对象中基类的部分上</strong>。这叫做<strong>派生类到基类的类型转换</strong>。</p>
<p>由于一个基类对象可能是派生类对象的一部分，也可能不是，因此<strong>不存在</strong>从基类到派生类的自动类型转换，<strong>即使</strong>一个基类的指针或引用已经绑定在一个派生类对象上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;</span><br><span class="line">BulkQuote bulk;</span><br><span class="line">Quote *p = &amp;item;</span><br><span class="line">p = &amp;bulk;</span><br><span class="line">Quote &amp;r = bulk;</span><br></pre></td></tr></table></figure>

<h2 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h2><p>每个类控制它自己的成员初始化过程。派生类并<strong>不能直接初始化</strong>继承自基类的成员。初始化时，<strong>先初始化基类的部分</strong>，然后<strong>按照声明的顺序</strong>（与初始化列表顺序无关）依次初始化派生类的成员。</p>
<p>如果不明确指明初始化，派生类的<strong>基类部分</strong>会像数据成员一样<strong>执行默认初始化</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BulkQuote::BulkQuote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty,</span><br><span class="line">                     <span class="keyword">double</span> disc)</span><br><span class="line">    : Quote(book, p), min_qty(qty), discount(disc) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>每个类负责定义各自的接口，要想与类对象交互，必须使用该类的接口，<strong>即使</strong>这个对象是派生类的基类部分也是如此。因此应当调用基类的构造函数初始化从基类继承而来的成员。</p>
<p>派生类的作用域<strong>嵌套</strong>在基类的作用域之内。</p>
<h2 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h2><p>如果基类定义了静态成员，则在<strong>整个继承体系中</strong>只存在该成员的<strong>唯一定义</strong>，每个静态成员只存在<strong>唯一的实例</strong>。</p>
<h2 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h2><p>派生类的声明<strong>不能包含</strong>派生列表。</p>
<h2 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h2><p>某个类要用作基类，必须<strong>已经定义</strong>，而非仅仅声明。因为派生类中，要使用继承自基类的成员，派生类必须知道他们是什么。</p>
<p>防止继承可以使用<code>final</code>。</p>
<h2 id="静态类型和动态类型"><a href="#静态类型和动态类型" class="headerlink" title="静态类型和动态类型"></a>静态类型和动态类型</h2><p>变量或表达式的静态类型：编译时总是已知的，变量声明时类型或表达式生成的类型。动态类型：变量或表达式表示的内存中对象的类型，运行时才可知。</p>
<p>基类指针或引用的静态类型<strong>可能与其</strong>动态类型<strong>不一致</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> ret = item.net_price(n);</span><br><span class="line">  os &lt;&lt; <span class="string">&quot;ISBN: &quot;</span> &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot;# sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; total due: &quot;</span> &lt;&lt; ret</span><br><span class="line">     &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面item的静态类型是<code>Quote&amp;</code>，动态类型直到运行时调用函数时才会知道。如果传入的是BulkQuote，则动态类型是BulkQuote。</p>
<p>由于一个基类对象可能是派生类对象的一部分，也可能不是，因此<strong>不存在</strong>从基类到派生类的自动类型转换，<strong>即使</strong>一个基类的指针或引用已经绑定在一个派生类对象上。如果需要转换，</p>
<ul>
<li>如果基类中有<strong>一个或多个虚函数</strong>，则可以使用dynamic_cast<strong>请求</strong>一个转换，该转换的安全检查将在运行时执行</li>
<li>如果已知转换时安全的，则可以使用static_cast强制覆盖编译器的检查</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BulkQuote <span class="title">bulk</span><span class="params">(<span class="string">&quot;awqef&quot;</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">0.5</span>)</span></span>;</span><br><span class="line">Quote *pq = &amp;bulk;</span><br><span class="line">BulkQuote *pb = pq; <span class="comment">// 错误</span></span><br><span class="line">BulkQuote *pb1 = <span class="keyword">dynamic_cast</span>&lt;BulkQuote *&gt;(pq);</span><br><span class="line">BulkQuote *pb2 = <span class="keyword">static_cast</span>&lt;BulkQuote *&gt;(pq);</span><br></pre></td></tr></table></figure>

<h2 id="派生类类型到基类类型的转换"><a href="#派生类类型到基类类型的转换" class="headerlink" title="派生类类型到基类类型的转换"></a>派生类类型到基类类型的转换</h2><p>派生类类型到基类类型的转换是<strong>不存在的</strong>。但可以向基类的拷贝/移动操作传递一个派生类对象，<strong>实际运行</strong>构造/赋值的运算符<strong>将是基类中定义的</strong>，此时只能处理基类自己的成员，忽略派生类定义的成员，派生类的部分被<strong>slice down</strong>。</p>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>由于<strong>运行时才知道</strong>调用了哪个版本的虚函数，因此<strong>所有虚函数必须有定义</strong>。被调用的函数是<strong>与绑定到指针或引用上的对象的动态类型相匹配的那个</strong>。</p>
<p>动态绑定<strong>只有</strong>当通过指针或引用调用虚函数时才会发生，只有在这种情况下对象的静态类型才可能会与动态类型不同。</p>
<h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><p>C++中的引用或指针的静态类型与动态类型不同，是C++支持多态性的<strong>根本</strong>所在。</p>
<p>当通过基类的指针或引用调用基类中的一个函数时，如果是虚函数，则运行时才会<strong>依据所绑定对象的真实类型</strong>（动态类型）来决定到底执行哪个版本。如果不是虚函数，则解析过程发生在编译时而非运行时。类似的，<strong>通过对象</strong>进行的函数调用（虚函数或非虚函数）也在编译时绑定。</p>
<h2 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h2><p>一旦某个函数被声明为虚函数，则在<strong>所有派生类中都是</strong>虚函数。</p>
<p>一个派生类的函数如果覆盖类某个继承而来的虚函数，这它的<strong>形参类型</strong>必须与被它覆盖的基类函数<strong>完全一致</strong>。同时，<strong>返回值</strong>也必须<strong>相同</strong>。但有下述例外，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> B* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function">D* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果虚函数的<strong>返回类型是类本身的指针或引用时</strong>，返回值可以不同，但要求<strong>从D到B的类型转换是可访问的</strong>。</p>
<h2 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h2><ul>
<li>如果派生类中的函数与虚函数<strong>名字相同</strong>、<strong>形参列表不同</strong>（返回值都ok），那么这是合法的，但这个函数与原有虚函数<strong>相互独立，并未覆盖</strong>。</li>
<li>如果派生类中的函数与虚函数<strong>名字相同</strong>、<strong>形参列表相同</strong>、<strong>返回值不同</strong>，那么这是错误。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  D();</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125; <span class="comment">// 错误</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">double</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125; <span class="comment">// ok，但与原有虚函数相互独立</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了避免出现上述的<code>double net_price(double n) const</code>，可以使用override来说明派生类中的虚函数。</p>
<p>只有基类出现过的虚函数，且派生类中的函数声明与虚函数一致时，才能override，否则就会报错。<br>如果某个函数被指定为final，则之后的<strong>任何尝试覆盖该函数的操作</strong>都将引发错误。</p>
<p>final和override出现在形参列表（包括const和引用修饰符 ）和位置返回类型**之后。</p>
<h2 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h2><p>如果某次函数调用使用了默认实参，则<strong>该实参值</strong>有本次调用的<strong>静态类型</strong>（基类中定义默认实参）决定。</p>
<h2 id="回避虚函数机制"><a href="#回避虚函数机制" class="headerlink" title="回避虚函数机制"></a>回避虚函数机制</h2><p>有时需要强制执行虚函数某个<strong>特定的版本</strong>，而<strong>不进行动态绑定</strong>。这时可以使用作用域运算符，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>调用将在编译时完成解析。</p>
<p>通常只有<strong>成员函数（或友元）中</strong>的代码才需要使用作用域运算符来回避虚函数机制。<br>下面的调用中，派生类的虚函数调用了基类的版本，如果不回避虚函数机制，那么将会导致无限递归。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">D::net_price</span><span class="params">(<span class="keyword">double</span> n)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Quote::net_price(n);</span><br><span class="line">  <span class="keyword">return</span> n * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>一个纯虚函数无须定义，其中<code>=0</code><strong>只能</strong>出现在<strong>类内部的虚函数声明的语句</strong>处。但<strong>也可以</strong>为纯虚函数<strong>提供定义</strong>，不过函数体<strong>必须定义在类外部</strong>。</p>
<p>含有（或者未经覆盖直接继承）的纯虚函数的类似<strong>抽象基类</strong>。</p>
<ul>
<li>抽象基类负责<strong>定义接口</strong>，而后续的其他类可以覆盖这个接口</li>
<li><strong>不能直接创建</strong>一个抽象基类的对象</li>
<li>如果<strong>派生类覆盖了纯虚函数</strong>，那么可以创建派生类的对象，否则不能。</li>
</ul>
<h2 id="派生类构造函数-1"><a href="#派生类构造函数-1" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h2><p>派生类构造函数只能<strong>初始化它的直接基类</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkQuote1</span> :</span> <span class="keyword">public</span> DiscQuote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BulkQuote1() = <span class="keyword">default</span>;</span><br><span class="line">  BulkQuote1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty,</span><br><span class="line">             <span class="keyword">double</span> disc)</span><br><span class="line">      : DiscQuote(book, price, qty, disc) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BulkQuote1包含三个子对象：空的BulkQuote1，DiscQuote和Quote。</p>
<h1 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h1><p>派生类的成员或友元<strong>只能通过派生类对象</strong>来访问基类受保护成员（只能访问派生类对象中的<strong>基类部分的</strong>受保护成员），派生类对于一个<strong>普通的基类对象</strong>中的受保护成员<strong>没有任何访问特权</strong>。</p>
<h2 id="public、private和protected继承"><a href="#public、private和protected继承" class="headerlink" title="public、private和protected继承"></a>public、private和protected继承</h2><p>派生访问说明符对于派生类的成员（及友元）<strong>能否访问</strong>其直接基类的成员<strong>没有什么影响</strong>，这是由<strong>基类中的访问说明符</strong>决定的。</p>
<p>派生访问说明符控制了派生类用户<strong>对于基类成员的访问权限</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivD</span> :</span> <span class="keyword">private</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrivD d;</span><br><span class="line">d.pub_mem(); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>public继承，成员将<strong>遵循原有的</strong>访问说明符</li>
<li>private继承，B的成员是<strong>私有的</strong></li>
<li>protected继承，B的成员是<strong>受保护的</strong></li>
</ul>
<p>继承自派生类（上面的PrivD）的新类，基类（B）成员的访问权限由派生类（PrivD）的访问说明符决定。即如果是private的，那么新类人不能访问基类（B）的成员。</p>
<h2 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h2><ul>
<li>对于用户代码，只有当D<strong>public继承</strong>B，时，用户代码才能使用D向B的转换</li>
<li>对于直接继承，<strong>无论是什么继承</strong>，<strong>D的成员函数和友元都能</strong>使用D向B的转换</li>
<li>对于间接继承，只有当D<strong>public或protected继承</strong>B时，<strong>D的派生类的成员函数和友元</strong>才能使用D向B的转换</li>
</ul>
<h2 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h2><p>友元不能传递和继承。</p>
<h2 id="改变成员的可访问性"><a href="#改变成员的可访问性" class="headerlink" title="改变成员的可访问性"></a>改变成员的可访问性</h2><p>可以用using将类的直接或间接基类中任何<strong>可访问成员</strong>（非私有）<strong>标记出来</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> prvi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivD</span> :</span> <span class="keyword">private</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">using</span> <span class="title">B::pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">using</span> B::prvi; <span class="comment">// 错误</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrivD d;</span><br><span class="line">d.pub_mem(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h2 id="默认继承保护级别"><a href="#默认继承保护级别" class="headerlink" title="默认继承保护级别"></a>默认继承保护级别</h2><ul>
<li>派生类是struct，默认public继承</li>
<li>派生类是class，默认是private继承</li>
</ul>
<h1 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h1><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><p>每个类都会定义自己的作用域。<br>Outside the class scope, ordinary data and function members may <strong>be accessed only through an object, a reference, or a pointer using a member access operator</strong> (§ 4.6, p.150). We access <strong>type members from the class using the scope operator</strong>. In either case, the name that follows the operator must be a member of the associated class.</p>
<h3 id="定义在类外部的成员"><a href="#定义在类外部的成员" class="headerlink" title="定义在类外部的成员"></a>定义在类外部的成员</h3><p>一旦遇到类名，定义的剩余部分就在类的作用域之内（参数列表和函数体）。返回类型中使用的名字都位于类的作用域之外。</p>
<h3 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h3><p>类的定义分作，</p>
<ol>
<li>编译类的声明</li>
<li>直到类全部可见后才编译函数体</li>
</ol>
<p>这种两阶段处理的方式<strong>只适用于成员函数中使用的名字</strong>，<strong>声明中</strong>使用的名字（包括返回值或参数列表中使用的名字），都必须确保在<strong>使用前可见</strong>。</p>
<p>要注意的是，如果成员使用了外层作用域中的某个名字，且该名字代表一种类型，这内层作用域<strong>不能</strong>重定义这个名字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> M;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">M <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">double</span> M; <span class="comment">// 错误</span></span><br><span class="line">  M bal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员函数中使用的名字查找顺序，</p>
<ol>
<li>成员函数内查找</li>
<li>类内查找</li>
<li>成员函数定义前的作用域内查找（包括<strong>类定义之前的</strong>全局作用域和<strong>成员函数定义前的</strong>全局作用域）</li>
</ol>
<h2 id="派生类的作用域"><a href="#派生类的作用域" class="headerlink" title="派生类的作用域"></a>派生类的作用域</h2><p>派生类的作用域<strong>嵌套</strong>在基类的作用域之内，如果一个名字在派生类的作用域内无法正确解析，则编译器将<strong>继续在外层的基类作用域</strong>中寻找改名字的定义。</p>
<h2 id="编译时进行名字查找"><a href="#编译时进行名字查找" class="headerlink" title="编译时进行名字查找"></a>编译时进行名字查找</h2><p>一个对象、引用或指针的<strong>静态类型</strong>决定了该对象的哪些成员是可见的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiscQuote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  std::pair&lt;std::size_t, double&gt; discount_policy() const &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;quantity, discount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BulkQuote bulk;</span><br><span class="line">BulkQuote *pbulk = &amp;bulk;</span><br><span class="line">Quote *pitem = &amp;bulk;</span><br><span class="line">pbulk-&gt;discount_policy(); <span class="comment">// ok</span></span><br><span class="line">pitem-&gt;discount_policy(); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>这与动态绑定不同。</p>
<h2 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h2><p>如果派生类重用定义在其直接基类或间接基类中的名字，则定义在内层作用域（派生类）的名字将<strong>隐藏</strong>定义在外层作用域（基类）中的名字。</p>
<p>但可以使用作用域运算符覆盖原有的查找规则。一般来说，除了覆盖继承而来的虚函数外，派生类<strong>最好不要</strong>重用其他定义在基类中的名字。</p>
<h2 id="名字查找先于类型检查"><a href="#名字查找先于类型检查" class="headerlink" title="名字查找先于类型检查"></a>名字查找先于类型检查</h2><p>查找顺序，</p>
<ol>
<li>先确定静态类型</li>
<li>在静态类型中查找member，找不到则顺着继承链向上找，最后没找到则报错</li>
<li>找到后检查函数调用是否合法</li>
<li>如果合法，<ul>
<li>是虚函数且通过引用或指针调用，编译器进行动态绑定</li>
<li>不是，编译器产生一个常规函数调用</li>
</ul>
</li>
</ol>
<p>声明在内层作用域的函数<strong>并不会重载</strong>声明在外层作用域的函数，派生类中的函数<strong>也不会重载</strong>基类中的成员，而是<strong>隐藏</strong>基类的成员，<strong>即使</strong>它们的<strong>形参列表不一致</strong>。</p>
<h2 id="虚函数的作用域"><a href="#虚函数的作用域" class="headerlink" title="虚函数的作用域"></a>虚函数的作用域</h2><p>假设形参列表不同，会发生隐藏，进而无法通过基类的引用或指针调用派生类的虚函数。</p>
<p>对应于之前提到的两个情况，</p>
<ul>
<li>如果派生类中的函数与虚函数<strong>名字相同</strong>、<strong>形参列表不同</strong>（返回值都ok），那么这是合法的，此时隐藏了原有虚函数。</li>
<li>如果派生类中的函数与虚函数<strong>名字相同</strong>、<strong>形参列表相同</strong>、<strong>返回值不同</strong>，那么这是错误，因为内层作用域中已经存在一个同名且同形参列表的函数了，不允许两个函数除返回值，其他要素都相同。</li>
</ul>
<h2 id="覆盖重载的函数"><a href="#覆盖重载的函数" class="headerlink" title="覆盖重载的函数"></a>覆盖重载的函数</h2><p>成员函数无论是否是虚函数都可被重载，派生类可以覆盖基类中重载函数的<strong>0个或多个实例</strong>。如果派生类希望<strong>所有的重载版本</strong>对于它来说<strong>都是可见的</strong>，那么派生类就必须<strong>覆盖所有的版本，或者一个也不覆盖</strong>。（如果只覆盖部分，此时会<strong>隐藏</strong>基类的重载函数）</p>
<p>简便的方法是<code>using + 名字</code>（不需要形参列表）。需要保证基类函数的每个实例在派生类中都是<strong>可访问的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> B::fcn; <span class="comment">// 如果没有，则下面的d.fcn()是错误的</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;derive &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line">d.fcn();</span><br><span class="line">d.fcn(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h1><p>如果一个类（基类或派生类）没有定义拷贝控制操作，则编译器会为它合成一个版本。</p>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>由于基类的引用或指针指向继承体系中的某个类型，有可能出现指针的静态类型与被删除对象的动态类型不符的情况。因此需要将析构函数定义为虚函数，以确保<strong>执行正确的析构函数</strong>版本。</p>
<p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生<strong>未定义的行为</strong>（只释放了基类部分的内存）。</p>
<p>基类的析构函数<strong>并不需要遵循三/五法则</strong>。虚析构函数（即使通过default的形式）将<strong>阻止合成移动操作</strong>。</p>
<h2 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h2><p>合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身的成员依次进行初始化、赋值或销毁。这些合成的成员还负责<strong>使用基类中对应的操作</strong>对一个对象的<strong>直接基类部分</strong>进行初始化、赋值或销毁。</p>
<p>无论是基类的合成版本还是自定义版本，都有上述的行为，唯一的要求是<strong>新颖的成员是可访问的</strong>，且<strong>不是一个被删除</strong>的函数。</p>
<h3 id="删除拷贝控制"><a href="#删除拷贝控制" class="headerlink" title="删除拷贝控制"></a>删除拷贝控制</h3><ul>
<li>如果<strong>基类</strong>的构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是<strong>被删除的</strong>，则派生类中的相应成员也是<strong>被删除的</strong></li>
<li>如果<strong>基类的析构函数</strong>是不可访问或删除的，则派生类的默认和拷贝构造函数是被删除的</li>
<li>如果<strong>派生类中</strong>显式请求编译器生成一个无法合成的移动操作，且基类中的对应操作是删除或不可访问的，派生类中的移动操作将是被删除的</li>
<li>如果基类的析构函数是删除或不可访问的，则派生类中的移动构造函数将是被删除的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  B() = <span class="keyword">default</span>;</span><br><span class="line">  B(<span class="keyword">const</span> B &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~B() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">b = b; <span class="comment">// ok</span></span><br><span class="line">b = <span class="built_in">std</span>::move(b); <span class="comment">// ok</span></span><br><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(b)</span></span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="built_in">std</span>::move(b))</span></span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>由于虚析构函数的存在，编译器不会合成移动操作，因此<strong>所有左值和右值的情况</strong>（即<code>b = b</code>，<code>b = std::move(b)</code>，<code>B b1(b)</code>和<code>B b2(std::move(b))</code>）都将用拷贝操作处理。又因为拷贝构造函数是删除的，因此两个对拷贝构造函数的调用是错误的。</p>
<p>如果基类没有默认、拷贝或移动构造函数，则一般派生类也不会定义（可以，但必须考虑如何处理基类部分的成员）。</p>
<h3 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h3><p>由于基类虚析构函数的存在，编译器不会合成移动操作。如果需要移动操作，则应该<strong>首先在基类中定义</strong>，与此同时必须<strong>显式地定义拷贝操作</strong>（否则会默认被定义为删除）。</p>
<h2 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h2><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动<strong>基类部分的成员</strong>。而析构函数只负责<strong>销毁派生类自己分配的资源</strong>，派生类对象的基类部分是自动销毁的。</p>
<h3 id="派生类的拷贝和构造函数"><a href="#派生类的拷贝和构造函数" class="headerlink" title="派生类的拷贝和构造函数"></a>派生类的拷贝和构造函数</h3><p>定义派生类的拷贝或移动构造函数时，通常<strong>使用对应基类的构造函数</strong>处理对象的基类部分。</p>
<p>如果未处理使用基类的拷贝或移动构造函数，则基类部分被默认初始化。</p>
<h3 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h3><ul>
<li>与拷贝和移动构造函数一样，必须<strong>显式</strong>地<strong>为基类部分赋值</strong></li>
<li>基类的运算符要能<strong>正确处理自赋值</strong>的情况</li>
<li>基类运算符将<strong>释放</strong>左侧运算对象的<strong>基类部分的旧值</strong></li>
</ul>
<h3 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h3><p>在析构函数执行完成以后，对象的成员会被隐式销毁，对象的<strong>基类部分</strong>也是<strong>隐式销毁</strong>的（基类的析构函数被自动调用执行），派生类<strong>只负责</strong>销毁由<strong>派生类自己分配的资源</strong>。</p>
<p>对象的销毁顺序<strong>与创建顺序相反</strong>，派生类的析构函数先执行。</p>
<h3 id="在构造函数和析构函数中调用虚函数"><a href="#在构造函数和析构函数中调用虚函数" class="headerlink" title="在构造函数和析构函数中调用虚函数"></a>在构造函数和析构函数中调用虚函数</h3><p>在构造或析构派生类对象的过程中，（从基类部分开始构造，派生类部分开始销毁）对象的类型就像是<em>发生了改变一样</em>。当前的构造函数或析构函数不能够调用未构造或已销毁的派生类版本的虚函数（可能会访问派生类部分的成员）。</p>
<p>如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数<strong>所属类型相对应</strong>的虚函数版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Erdos</span> &#123;</span></span><br><span class="line">  Erdos() &#123; whoAmIReally(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">whoAmIReally</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I really am Erdos\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fermat</span> :</span> <span class="keyword">public</span> Erdos &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">whoAmIReally</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I really am Fermat\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Erdos s; <span class="comment">// I really am Erdos</span></span><br><span class="line">Fermat f; <span class="comment">// I really am Erdos</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，<strong>并非是</strong>构造函数发生了继承。</p>
<h2 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h2><p>这里的构造函数<strong>并非以常规的方式继承</strong>而来，且类<strong>不能继承默认、拷贝和移动构造函数</strong>。如果派生类含有自己的数据成员，则它们被<strong>默认初始化</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkQuote2</span> :</span> <span class="keyword">public</span> DiscQuote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> DiscQuote::DiscQuote;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的的using<strong>并不是</strong>令DiscQuote的构造函数在这里可见，而是令编译器生成一个与DiscQuote的构造函数对应的派生类构造函数，即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BulkQuote2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty,</span><br><span class="line">           <span class="keyword">double</span> disc)</span><br><span class="line">    : DiscQuote(book, price, qty, disc) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>构造函数的using声明<strong>并不会改变该构造函数的访问级别</strong></li>
<li>一个using声明<strong>不能指定explicit或constexpr</strong>，基类的是什么，继承后的也是什么</li>
<li>当一个基类构造函数含有默认实参，这些<strong>实参并不会被继承</strong>，而是派生类会获得<strong>多个继承的构造函数</strong>，其中每个构造函数<strong>分别省略掉</strong>一个含有默认实参的形参。</li>
</ul>
<h3 id="何时不继承"><a href="#何时不继承" class="headerlink" title="何时不继承"></a>何时不继承</h3><ul>
<li>如果派生类定义的构造函数与基类的构造函数具有<strong>相同的参数列表</strong>，则该构造函数不会被继承</li>
<li>类<strong>不能继承默认、拷贝和移动构造函数</strong>，而是按照正常规则被合成。继承的构造函数<strong>不会被视为用户定义的构造函数</strong>（如果是，则不会合成默认构造函数），因此<strong>只包含</strong>继承的构造函数（无拷贝和移动构造函数）的类也会有合成的默认构造函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  C(<span class="keyword">const</span> C &amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C c; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkQuote2</span> :</span> <span class="keyword">public</span> DiscQuote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> DiscQuote::DiscQuote;</span><br><span class="line">  <span class="comment">// BulkQuote2(const BulkQuote2&amp; b) : DiscQuote(b) &#123;</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; &quot;copy BulkQuote2&quot; &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BulkQuote2 b; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>由于上面的BulkQuote2只有继承的构造函数，因此编译器会合成一个默认构造函数，故<code>BulkQuote2 b</code>正确。</p>
<h1 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; vq;</span><br><span class="line">vq.push_back(make_shared&lt;Quote&gt;(<span class="string">&quot;joininnaw&quot;</span>, <span class="number">15</span>));</span><br><span class="line">vq.push_back(make_shared&lt;BulkQuote&gt;(<span class="string">&quot;awfawnn&quot;</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">0.4</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;q : vq) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; q-&gt;net_price(<span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用vector存储Quote对象是不行的，因为会使用Quote的拷贝构造函数，派生类对象的派生类部分会被<strong>截断</strong>。</p>
<p>派生类的智能指针可以转换为基类的智能指针。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2014/2014-03-20-cpp-overload-operator-and-type-conversion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2014/2014-03-20-cpp-overload-operator-and-type-conversion/" class="post-title-link" itemprop="url">C++重载运算与类型转换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-03-20 20:01:13" itemprop="dateCreated datePublished" datetime="2014-03-20T20:01:13+08:00">2014-03-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2014/2014-03-20-cpp-overload-operator-and-type-conversion/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/2014-03-20-cpp-overload-operator-and-type-conversion/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>重载的运算符是具有<strong>特殊名字的函数</strong>，除函数调用运算符外，其他重载运算符<strong>不能含有默认实参</strong>。</p>
<ul>
<li>一个运算符函数，或者<strong>类的成员</strong>，或者<strong>至少含有一个类类型的参数</strong>。也就是说不能为内置类型重载运算符。</li>
<li>只能重载<strong>已有的</strong>运算符。</li>
<li>一个重载的运算符，其优先级和结合律与对应的内置运算符<strong>保持一致</strong>。</li>
<li>由于使用重载的运算符本质上是<strong>函数调用</strong>，因此对象求值顺序的规则<strong>无法应用</strong>到重载的运算符上。尤其是<code>&amp;&amp;</code>，<code>||</code>和<code>,</code>，两个运算对象<strong>总是会</strong>被求值。</li>
<li>通常情况下，不应该重载<code>&amp;&amp;</code>，<code>||</code>，<code>&amp;</code>和<code>,</code>，运算符。</li>
<li>一般来说，提供了某个重载运算符，也应该提供<strong>与此运算符相关的</strong>一系列运算符，如：算术运算符-&gt;对应的复合赋值运算符。</li>
</ul>
<h2 id="成员或者非成员"><a href="#成员或者非成员" class="headerlink" title="成员或者非成员"></a>成员或者非成员</h2><ul>
<li><p><code>=</code>，<code>[]</code>，<code>()</code>和<code>-&gt;</code>运算符**必须是成员。</p>
</li>
<li><p>复合赋值运算符<strong>一般来说应该是</strong>成员，但非必须。</p>
</li>
<li><p>改变对象状态或与给定类型密切相关的运算符，应该是成员。如：递增、解引用。</p>
</li>
<li><p>具有对称性的运算符可能转换任意一端的运算对象，通常应该是非成员。如：算术、相等性、关系和位运算符。如果想提供<strong>含有类对象的混合类型表达式</strong>，运算符必须是非成员函数。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> u = <span class="string">&quot;hi&quot;</span> + s; <span class="comment">// 如果是成员函数，则&quot;hi&quot;.operator+(s)，错误</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>对于友元要注意，在类内部虽然有友元声明，但这<strong>并非真正意义上的函数声明</strong>，因此在类外部还需要有函数声明。</p>
<h1 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h1><h2 id="lt-lt"><a href="#lt-lt" class="headerlink" title="&lt;&lt;"></a>&lt;&lt;</h2><ul>
<li><code>ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;item);</code></li>
<li>必须是<strong>非成员函数</strong>，否则左侧运算对象将是类的一个对象<br>  就算要是某个类的成员，也只能是istream或ostream的，然而并不能为标准库中的类添加成员，因此只能是非成员函数</li>
<li>不应该打印换行符</li>
</ul>
<h2 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h2><ul>
<li><p><code>istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;item);</code></p>
</li>
<li><p>必须处理输入可能失败的情况</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item) &#123;</span><br><span class="line">  <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">  is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">  <span class="keyword">if</span> (is) &#123;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    item = Sales_data();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>有时需要标识<strong>流的条件状态</strong></p>
</li>
</ul>
<h1 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h1><ul>
<li><p>通常把算术和关系运算符定义为非成员函数，使得左侧或右侧的运算对象可以转换</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> u = <span class="string">&quot;hi&quot;</span> + s; <span class="comment">// 如果是成员函数，则&quot;hi&quot;.operator+(s)，错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>这些运算符一般不需要改变运算对象的状态，所以形参是常量引用</p>
</li>
<li><p>一般使用<strong>复合赋值来实现</strong>算术运算符</p>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><ul>
<li>相等运算符应该具有<strong>传递性</strong></li>
<li>定义了<code>==</code>，也应该定义<code>!=</code></li>
</ul>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符应该，</p>
<ol>
<li>定义顺序关系，且与关联容器中对关键字的要求一致</li>
<li>Define a relation that is consistent with <code>==</code> if the class has both operators. In particular, if two objects are <code>!=</code>, then one object should be <code>&lt;</code> the other.</li>
</ol>
<p>如果存在唯一一种逻辑可靠的&lt;语义，才考虑定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="="></a>=</h2><ul>
<li>必须为成员函数</li>
<li><strong>必须先释放</strong>当前内存空间</li>
<li>如果不是拷贝赋值运算符和移动赋值运算符，则<strong>不必检查自赋值</strong>的情况。</li>
</ul>
<h2 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h2><ul>
<li>必须为成员函数</li>
<li>返回元素的引用</li>
<li>通常定义const和非const版本</li>
</ul>
<h1 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h1><p>由于改变了对象的状态，一般应为<strong>成员函数</strong>，且应该<strong>同时定义</strong>前置版本和后置版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回递增或递减后对象的引用</span></span><br><span class="line">StrBlobPtr &amp;<span class="keyword">operator</span>++();</span><br><span class="line">StrBlobPtr &amp;<span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的原值</span></span><br><span class="line">StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">// 形参不会被使用，仅仅是和前置版本进行区分</span></span><br><span class="line">StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="keyword">operator</span>--(<span class="number">0</span>); <span class="comment">// 调用后置版本的</span></span><br><span class="line">p.<span class="keyword">operator</span>--(); <span class="comment">// 调用前置版本的</span></span><br></pre></td></tr></table></figure>

<h1 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> &amp;StrBlobPtr::<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> p = check(curr, <span class="string">&quot;deference past end&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *StrBlobPtr::<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*(); &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-&gt;</code><strong>必须是类成员</strong>，<code>*</code>非必需，但<strong>通常也是</strong>。</li>
<li>定义为const是因为获取一个元素并不会改变对象的状态。</li>
<li>虽然可以让解引用返回任何想要的值或打印（不建议），但箭头运算符<strong>必须有成员访问的含义</strong>。重载箭头运算符时，可以改变的是箭头从哪个对象中获取成员。</li>
</ul>
<h1 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h1><p>函数调用运算符<strong>必须是</strong>成员函数。如果类定义了调用运算符，那么该类的对象叫做函数对象。调用函数对象实际上是在运行重载的调用运算符。</p>
<h2 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h2><p>编写lambda后，编译器将生成一个<strong>未命名类的未命名对象</strong>。这个类中有一个重载的函数调用运算符，且默认情况下这个成员是const（lambda不能改变捕获的变量），除非lambda被声明为mutable。</p>
<ul>
<li><p>引用捕获<br>  由程序确保lambda执行时所引用的对象确实存在，生成的类中无须保存为数据成员。</p>
</li>
<li><p>值捕获<br>  生成的类中需建立对象的数据成员，同时创建构造函数，用捕获的变量来初始化数据成员。</p>
</li>
</ul>
<p>lambda产生的类中，<strong>不包含默认构造函数、赋值运算符和默认析构函数</strong>，默认拷贝和默认移动构造函数视捕获的数据成员类型而定。</p>
<h1 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h1><p>标准库规定的函数<strong>对于指针同样适用</strong>。直接比较两个无关的指针将产生未定义的行为，但通过标准库定义的函数对象来比较是<strong>定义良好的</strong>。</p>
<p>关联容器使用<code>less&lt;key_type&gt;</code>对元素排序，因此可以直接定义一个指针的set或map，而无须声明<code>less</code>。</p>
<h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><p>C++中的可调用对象多种有，它们的类型是不同的，</p>
<ul>
<li>函数和函数指针<br>  类型由返回值类型和实参类型决定</li>
<li>lambda表达式<br>  每个lambda有唯一的未命名类类型</li>
<li>bind创建的对象</li>
<li>重载了函数调用运算符的类</li>
</ul>
<p>类型不同的可调用对象<strong>可能共享</strong>同一种调用形式。调用形式指明了<strong>调用返回的类型</strong>以及<strong>传递给调用的实参类型</strong>。一种调用形式对应一个函数类型。</p>
<p>定义<code>funcion</code>类型时，需要指明调用形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = &#123;&#123;<span class="string">&quot;+&quot;</span>, plus&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">                                               &#123;<span class="string">&quot;-&quot;</span>, minus&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">                                               &#123;<span class="string">&quot;*&quot;</span>, multiplies&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">                                               &#123;<span class="string">&quot;/&quot;</span>, divides&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">                                               &#123;<span class="string">&quot;%&quot;</span>, modulus&lt;<span class="keyword">int</span>&gt;()&#125;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="重载、类型转换"><a href="#重载、类型转换" class="headerlink" title="重载、类型转换"></a>重载、类型转换</h1><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类型的<strong>隐式转换</strong>机制，这种构造函数叫做转换构造函数。</p>
<p><strong>转换构造函数</strong>和<strong>类型转换运算符</strong>共同定义类类型转换，也叫用户定义的类型转换。</p>
<p>编译器<strong>一次只能执行一个</strong>用户定义的类型转换。</p>
<h2 id="隐式类型转换运算符"><a href="#隐式类型转换运算符" class="headerlink" title="隐式类型转换运算符"></a>隐式类型转换运算符</h2><ul>
<li><code>operator int() const;</code><br>  从类类型转换为int</li>
<li>无显示的返回类型和形参</li>
<li>返回一个对应类型的值</li>
<li>必须定义为成员函数</li>
<li>通常不应该改变转换对象的内容，一般被定义为const</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  S(<span class="keyword">const</span> S &amp;s) : val(s.val) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  S(S &amp;&amp;s) : val(s.val) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;move&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  S &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> S &amp;s) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy assign&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    val = s.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  S &amp;<span class="keyword">operator</span>=(S &amp;&amp;s) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;move assign&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    val = s.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;conversion-&gt;int&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S s; <span class="comment">// construct</span></span><br><span class="line">s = <span class="number">4</span>; <span class="comment">// construct， move assign</span></span><br><span class="line">s + <span class="number">3</span>; <span class="comment">// conversion-&gt;int</span></span><br><span class="line">s - s; <span class="comment">// conversion-&gt;int, conversion-&gt;int</span></span><br></pre></td></tr></table></figure>

<p>S虽然没有定义<code>-</code>，但隐式转换为int，可以执行内置的<code>-</code>。</p>
<p>虽然编译器一次只能执行一个用户定义的类型转换，但<strong>隐式的用户定义类型转换</strong>可以至于一个<strong>标准（内置）类型转换之前或之后</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double-&gt;int-&gt;S</span></span><br><span class="line">s = <span class="number">3.14</span>; <span class="comment">// construct， move assign</span></span><br><span class="line"><span class="comment">// S-&gt;int-&gt;double</span></span><br><span class="line">s + <span class="number">3.14</span>; <span class="comment">// conversion-&gt;int</span></span><br></pre></td></tr></table></figure>

<h2 id="显式类型转换运算符"><a href="#显式类型转换运算符" class="headerlink" title="显式类型转换运算符"></a>显式类型转换运算符</h2><p><code>explicit operator int() const;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S s;</span><br><span class="line">s + <span class="number">3</span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s) + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是当表达式<strong>作为条件</strong>时，编译器会将显式类型转换<strong>自动应用</strong>于它（仅仅是自动应用<code>explicit operator bool() const</code>，以转换为bool）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S s;</span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h2><p>必须确保类类型和目标类型之间<strong>只存在唯一一种</strong>转换方式。<strong>无法</strong>通过使用强制类型转换来解决二义性问题，强制类型转换也会面临二义性问题。</p>
<p>多重转换路径可能由于，</p>
<ul>
<li><p>两个类提供相同的类型转换</p>
</li>
<li><p>类定义了一组类型转换，它们的转换源（或者转换目标）类型本身可以通过其他类型转换联系在一起，由于<strong>所有算术类型转换的级别都一样</strong>，选择转换序列时会有<strong>多个转换序列</strong>，将会导致二义性。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  S();</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S s;</span><br><span class="line"><span class="keyword">int</span> a = s; <span class="comment">// 精确匹配</span></span><br><span class="line"><span class="keyword">float</span> b = s; <span class="comment">// 两个“可行函数”</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>如果已经定义了一个转换为算术类型的类型转换，<strong>不要</strong>再定义<strong>接受算术类型的重载运算符</strong>。在不定义以后，如果用户需要使用这样的运算符，则类型转换操作会转换此类型的对象，然后使用<strong>内置的运算符</strong>。</p>
</blockquote>
<h3 id="重载函数与转换构造函数"><a href="#重载函数与转换构造函数" class="headerlink" title="重载函数与转换构造函数"></a>重载函数与转换构造函数</h3><p>当调用重载的函数时，如果两个或多个类型转换都提供了可行的匹配，则这些类型转换一样好。</p>
<h3 id="重载函数与用户定义的类型转换"><a href="#重载函数与用户定义的类型转换" class="headerlink" title="重载函数与用户定义的类型转换"></a>重载函数与用户定义的类型转换</h3><p>当调用重载的函数时，如果两个或多个类型用户定义的转换都提供了可行的匹配，则这些类型转换一样好。此时，不考虑任何可能出现的标准类型转换级别。</p>
<p><strong>只有</strong>当重载函数能通过同一个类型转换函数得到匹配时（所有可行函数都请求同一个用户定义的类型转换），才考虑标准类型转换级别。</p>
<h2 id="函数匹配与重载运算符"><a href="#函数匹配与重载运算符" class="headerlink" title="函数匹配与重载运算符"></a>函数匹配与重载运算符</h2><p>表达式中运算符的候选函数集包括<strong>成员函数</strong>和<strong>非成员函数</strong>。</p>
<p>如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到<strong>重载运算符和内置运算符的二义性问题</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2014/2014-03-13-cpp-copy-control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2014/2014-03-13-cpp-copy-control/" class="post-title-link" itemprop="url">C++拷贝控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-03-13 20:41:20" itemprop="dateCreated datePublished" datetime="2014-03-13T20:41:20+08:00">2014-03-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2014/2014-03-13-cpp-copy-control/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/2014-03-13-cpp-copy-control/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="拷贝、赋值和销毁"><a href="#拷贝、赋值和销毁" class="headerlink" title="拷贝、赋值和销毁"></a>拷贝、赋值和销毁</h1><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数的第一个参数必须是一个引用类型，且几乎总是一个const引用。由于拷贝构造函数在多个情况下会被隐式使用，因此不能是explict的。</p>
<figure class="highlight plain"><figcaption><span>F &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public:</span><br><span class="line">  Foo();</span><br><span class="line">  Foo(const Foo&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h3><p>如果没有定义拷贝构造函数，编译器会定义一个合成拷贝构造函数。不同于合成默认构造函数r，即使自己定义了其它的拷贝构造函数，编译器也会合成一个拷贝构造函数。</p>
<p>合成拷贝构造函数会将<strong>参数的每个非static成员逐个拷贝</strong>到正在创建的对象中。拷贝方式依据成员类型而定，</p>
<ul>
<li>对于类类型，会使用其拷贝构造函数；</li>
<li>对于内置类型，会直接拷贝；</li>
<li>如果成员有数组类型，合成拷贝构造函数会<strong>逐元素</strong>的拷贝。</li>
</ul>
<p>合成的函数会被<strong>隐式地声明为内联的</strong>。</p>
<h3 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h3><p>直接初始化会选择<strong>与参数最匹配的构造函数</strong>。拷贝初始化是件右侧运算对象拷贝到正在创建的对象中。</p>
<p>拷贝初始化<strong>通常</strong>使用拷贝构造函数来完成，以下情况会发生拷贝初始化，</p>
<ul>
<li>用<code>=</code>定义变量；</li>
<li>将对象作为实参传递给一个非引用类型的形参；</li>
<li>用一个返回类型为非引用类型的函数返回一个对象；</li>
<li>用列表初始化一个数组中的元素或一个聚合类中的成员；</li>
<li>某些类类型会对它们所分配的对象使用拷贝初始化（如：容器的insert）。</li>
</ul>
<p>在进行拷贝初始化时，编译器<strong>可以跳过</strong>拷贝/移动构造函数，直接创建对象，但此时拷贝/移动构造函数必须<strong>存在且可访问</strong>。</p>
<p>如上文所说，拷贝构造函数会被隐式使用，下面是几个例子，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">C c;</span><br><span class="line"><span class="built_in">vector</span>&lt;C&gt; vc&#123;c&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中，对vector使用列表初始化时，c会被copy两次。1. initializer_list的构造函数会<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/20501638/stdvector-init-with-braces-call-copy-constructor-twice">copy一次</a>，2. 从initializer_list到设计存储位置还会copy一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(C c)</span> </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  tmp = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fr</span><span class="params">(C &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  tmp = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C obj;</span><br><span class="line"></span><br><span class="line">f(obj);</span><br><span class="line">f(C(<span class="number">1</span>));</span><br><span class="line">fr(obj);</span><br><span class="line">fr(C(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个f调用，首先会用obj对形参c做拷贝初始化，然后用拷贝赋值，将c赋值给tmp；</li>
<li><strong>第二个f调用，这里并没有用临时对象对形参c做拷贝初始化，而是用临时对象C(1)对tmp进行复制。</strong>因为有copy elision。</li>
<li>第一个fr调用，直接拷贝赋值，将obj赋值给tmp；</li>
<li>第二个fr调用是错误的，问题类似<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/4301179/why-is-taking-the-address-of-a-temporary-illegal">取临时对象的地址</a>，这里C(4)是rvalue表达式，而fr()需要一个左值作为参数。</li>
</ul>
<h2 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h2><p>拷贝赋值运算符执行与<strong>析构函数和拷贝构造函数</strong>相同的工作。<br>如果没有定义拷贝赋值运算符，编译器会定义一个合成拷贝赋值运算符。</p>
<h3 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h3><p>赋值运算符就是一个名为<strong>operator=**的函数，其参数表示要收费的运算对象。定义为成员函数的运算符，其左侧运算对象就绑定到</strong>隐式的this参数<strong>。返回值通常为</strong>左侧运算对象的引用**。</p>
<p>拷贝赋值运算符参数应为<strong>与所在类相同类型的参数</strong>。</p>
<h3 id="合成拷贝赋值运算符"><a href="#合成拷贝赋值运算符" class="headerlink" title="合成拷贝赋值运算符"></a>合成拷贝赋值运算符</h3><p>合成拷贝赋值运算符会将右侧运算对象的<strong>每个非static</strong>成员赋予左侧运算对象的相应成员。类似拷贝构造函数逐个拷贝成员，这一工作是由<strong>成员类型的拷贝赋值运算符</strong>完成的。如果是数组类型的成员，则<strong>逐个赋值数组元素</strong>。</p>
<p>如果<strong>自己定义的</strong>拷贝赋值运算符或拷贝构造函数<strong>没有处理成员中的数组</strong>，逐个拷贝/赋值不会发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  HasPtr(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s = <span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  HasPtr(<span class="keyword">const</span> HasPtr &amp;rhs) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps)), i(rhs.i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> *ps;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; sarr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HasPtr <span class="title">a</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">a.arr[<span class="number">0</span>] = <span class="number">232</span>;</span><br><span class="line">a.arr[<span class="number">1</span>] = <span class="number">232</span>;</span><br><span class="line">a.sarr[<span class="number">0</span>] = <span class="number">232</span>;</span><br><span class="line">a.sarr[<span class="number">1</span>] = <span class="number">232</span>;</span><br><span class="line"></span><br><span class="line">HasPtr b = a;</span><br><span class="line">HasPtr c;</span><br><span class="line">c = a;</span><br><span class="line">(*b.ps).append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *a.ps &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *b.ps &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *c.ps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// abc abca abc</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b.arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b.sarr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// user defined copy constructor</span></span><br><span class="line"><span class="comment">// 232 32627 32627</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.sarr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c.arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c.sarr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// synthesized copy-assignment operator</span></span><br><span class="line"><span class="comment">// 232 232 232</span></span><br></pre></td></tr></table></figure>

<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>销毁对象的<strong>非static</strong>成员。没有返回值，不接受参数（因此不能够被重载）。对于一个给定类，只会有唯一一个析构函数。</p>
<p>销毁顺序按照初始化顺序的<strong>逆序</strong>进行，销毁内置类型成员不需要做什么，销毁类类型成员需要<strong>执行成员自己的</strong>析构函数，销毁内置指针类型的成员<strong>不会delete</strong>所指向的对象。</p>
<p>析构函数在以下情况进行调用，</p>
<ul>
<li>变量离开其作用域；</li>
<li>一个对象呗销毁时，其成员也被销毁；</li>
<li>容器（标准库容器和数组）被销毁时，其元素被销毁；</li>
<li>对动态分配的对象，其指针使用delete；</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁。</li>
</ul>
<h3 id="合成析构函数"><a href="#合成析构函数" class="headerlink" title="合成析构函数"></a>合成析构函数</h3><p>合成析构函数函数体为空，当其函数体执行完以后，成员会被自动销毁。析构函数函数体并<strong>不直接销毁成员</strong>，成员是在析构函数函数体之后<strong>隐含的析构阶段</strong>中被销毁的。</p>
<h2 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h2><ul>
<li>需要析构函数的类也需要拷贝构造函数和拷贝赋值运算符。</li>
<li>需要拷贝操作的类也需要赋值操作，反之亦然，但<strong>不必然意味着也需要析构函数</strong>。</li>
<li>拷贝操作会带来额外的开销，在拷贝不必须的情况下，应加入移动操作。</li>
</ul>
<h2 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h2><p>类似<code>=default</code>，使用<code>=delete</code>可以定义删除的函数。<code>=delete</code>必须出现在函数第一次声明的时候，且可以回任何函数指定<code>=delete</code>。</p>
<p>如果一个类的析构函数或者一个成员的析构函数是<code>=delete</code>，那么将<strong>无法定义该类型的变量或创建该类的临时对象</strong>，可以new但无法delete。</p>
<p>关于合成拷贝控制成员，当<strong>不可能拷贝、赋值或销毁类的成员</strong>时，类的合成拷贝控制成员就被定义为删除的。</p>
<h1 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h1><h2 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h2><p>行为像值的类有自己状态，副本和原对象是完全独立的。</p>
<p>由于赋值操作会<strong>销毁左侧运算对象的资源</strong>，在对如下类定义拷贝赋值运算符时，需要考虑将一个对象赋值给自身的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr1</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  HasPtr1(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s = <span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  HasPtr1(<span class="keyword">const</span> HasPtr1 &amp;rhs) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps)), i(rhs.i) &#123;&#125;</span><br><span class="line">  HasPtr1 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr1 &amp;rhs);</span><br><span class="line">  ~HasPtr1() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">string</span> *ps;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果拷贝赋值运算符是这样的，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HasPtr1 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr1 &amp;rhs) &#123;</span><br><span class="line">  <span class="keyword">delete</span> ps;</span><br><span class="line">  ps = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">  ai = rhs.i;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">HasPtr1 h;</span><br><span class="line">h = h;</span><br></pre></td></tr></table></figure>

<p>将一个对象赋值给自身时，解引用<code>*rhs.ps</code>就是错误的，因为ps所指向的对象已经被delete了。因此需要<strong>用一个局部临时对象先保存右侧运算符对象的资源</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr1 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr1 &amp;rhs) &#123;</span><br><span class="line">  <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">  <span class="keyword">delete</span> ps;</span><br><span class="line">  ps = newp;</span><br><span class="line">  ai = rhs.i;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h2><p>行为像值的类共享状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr2</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  HasPtr2(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s = <span class="built_in">string</span>())</span><br><span class="line">      : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">  HasPtr2(<span class="keyword">const</span> HasPtr2 &amp;rhs) : ps(rhs.ps), i(rhs.i), use(rhs.use) &#123; ++*use; &#125;</span><br><span class="line">  HasPtr2 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr2 &amp;rhs);</span><br><span class="line">  ~HasPtr2() &#123;</span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ps;</span><br><span class="line">      <span class="keyword">delete</span> use;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> *ps;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">size_t</span> *use;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于以上类的拷贝构造函数，需要递增右侧运算对象的引用计数，递减左侧运算对象的引用计数。这里同样需要考虑同一个对象给自身赋值的情况，应该先递增右侧运算对象的引用计数，然后递减左侧的并检查，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HasPtr2 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr2 &amp;rhs) &#123;</span><br><span class="line">  ++*rhs.use;</span><br><span class="line">  <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">delete</span> use;</span><br><span class="line">  &#125;</span><br><span class="line">  ps = rhs.ps;</span><br><span class="line">  i = rhs.i;</span><br><span class="line">  use = rhs.use;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h1><p>如果一个类没有定义自己的swap，需要的时候将调用标准库的swap。一般来说，一次swap需要一次copy和两次assign，但这并不是必须要的。如果一个类有动态分配的内存，可以交换指针，而不是既copy又assign。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  swap(lhs.ps, rhs.ps);</span><br><span class="line">  swap(lhs.i, rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是：</p>
<ol>
<li>HasPtr的成员是内置类型，并没有特定版本的swap，因此上述swap中调用的是标准库的swap；</li>
<li>如果一个<strong>类的成员有自己类型特定的swap</strong>，那么调用std::swap就是错误的，标准库swap会进行不必要的copy。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  swap(lhs.h, rhs.h); <span class="comment">// 使用HasPtr的swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 如果存在类型特定的swap，其匹配程度会优于std中定义的版本。上面的<code>using std::swap;</code><strong>并未隐藏</strong>HasPtr的swap。</li>
</ol>
<h2 id="copy-and-swap"><a href="#copy-and-swap" class="headerlink" title="copy and swap"></a>copy and swap</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs) &#123;</span><br><span class="line">  swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的赋值运算符是用传值的方式。swap左侧运算对象和副本，然后销毁副本。</p>
<p>copy and swap天然就是<strong>异常安全</strong>的，因为可能抛出异常的情况就是传值时候的copy，如果此时抛出异常，左侧对象不会被修改。同时保证了<strong>自赋值的正确</strong>，因为是copy。</p>
<h1 id="move"><a href="#move" class="headerlink" title="move"></a>move</h1><h2 id="lvalue和rvalue"><a href="#lvalue和rvalue" class="headerlink" title="lvalue和rvalue"></a>lvalue和rvalue</h2><p>lvalue：有持久的状态，可以取地址。<br>rvalue：字面值常量或临时对象，不可以取地址。</p>
<h2 id="rvalue-reference"><a href="#rvalue-reference" class="headerlink" title="rvalue reference"></a>rvalue reference</h2><p>必须绑定到右值，即要求转换的表达式、字面值常量或返回右值的表达式。但<strong>不能直接绑定</strong>到一个左值上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i * <span class="number">42</span>; <span class="comment">// 错误i*42是右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i * <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = i * <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>由于rvalue reference只能绑定到临时对象，因此这个对象，</p>
<ul>
<li>将要被销毁</li>
<li>没有其他用户</li>
</ul>
<p>这意味着使用rvalue reference可以自由地<strong>接管</strong>所引用对象的资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = i * <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h2 id="右值引用类型变量"><a href="#右值引用类型变量" class="headerlink" title="右值引用类型变量"></a>右值引用类型变量</h2><p>进行右值引用后，得到的<strong>右值引用类型变量是左值</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = i * <span class="number">32</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0x71d77768be28</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;rr1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0x71d77768be2c</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误rr1是左值</span></span><br></pre></td></tr></table></figure>

<p>要将右值引用绑定到一个左值，应该显示地转换或move，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rri = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> &amp;&amp;&gt;(i);</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rri1 = <span class="built_in">std</span>::move(i);</span><br><span class="line"><span class="comment">// int &amp;&amp;rri2 = i;</span></span><br></pre></td></tr></table></figure>

<p>使用move后，不能对移后源对象的值做任何假设，<strong>不能使用移后源对象的值</strong>。<strong>除了对rri赋值或销毁外</strong>，不能再使用它。</p>
<h1 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h1><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>参数是一个右值引用，且<strong>任何额外的参数</strong>都必须有默认实参。完成移动后，必须保证<strong>销毁源对象是无害的</strong>。一旦完成移动，源对象必须<strong>不能再指向被移动的资源</strong>，资源所有权已归属新创建的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : elements(s.elements), first_free(s.first_free), cap(s.cap) &#123;</span><br><span class="line">  s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动构造函数通常<strong>不分配</strong>任何新内存，因此通常不抛出异常。为避免标准库<strong>为了处理可能抛出异常而做的额外工作</strong>，一种通知标准库的方法是指明<code>noexcept</code>。</p>
<h3 id="移动操作和异常"><a href="#移动操作和异常" class="headerlink" title="移动操作和异常"></a>移动操作和异常</h3><ul>
<li>虽然移动操作通常不抛出异常，但是抛出异常是允许的。</li>
<li>标准库能够对异常发生是其自身的行为提供保障。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;StrVec&gt; vs;</span><br><span class="line"><span class="comment">// reallocate vecotr</span></span><br><span class="line"><span class="built_in">std</span>::move(vs[i]);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码中，如果在reallocate时，<strong>移动了部分元素</strong>后抛出异常，那么问题就会发生，源vector已经改变，但是新空间有的元素还不存在。</li>
<li>如果vector使用拷贝构造函数且发生了异常，那么不会影响源vector。</li>
</ul>
<p>基于上面两点，<strong>除非vector知道</strong>元素类型的移动构造函数不会抛出异常，否则在reallocate时，就必须使用拷贝构造函数（即前面所说的，<em>为了处理可能抛出异常而做的额外工作</em>）。如果希望在类似reallocate 的情况下使用移动而非拷贝，就必须<strong>显式的告诉标准库</strong>移动构造函数可以安全使用。</p>
<h2 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h2><p>移动赋值运算符执行与<strong>析构函数和移动构造函数</strong>相同的工作。如果不抛出异常，则应该标记为<code>noexcept</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123; <span class="comment">// 处理自赋值</span></span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = rhs.elements;</span><br><span class="line">    first_free = rhs.first_free;</span><br><span class="line">    cap = rhs.cap;</span><br><span class="line">    rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里必须check是否是同一对象，因为<strong>此右值可能是move调用返回的结果</strong>，再者不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源。</p>
<h2 id="移后源对象必须可析构"><a href="#移后源对象必须可析构" class="headerlink" title="移后源对象必须可析构"></a>移后源对象必须可析构</h2><p>从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁，因此需确保移后源对象必须可析构。</p>
<p>移动操作还应保证对象仍是<strong>有效的</strong>，即可以安全地为其<strong>赋予新值</strong>或可以<strong>安全地使用</strong>而<strong>不依赖其当前值</strong>。</p>
<p>移动后，源对象的值是没有保证的，不应依赖移后源对象中的数据。</p>
<h1 id="合成移动操作"><a href="#合成移动操作" class="headerlink" title="合成移动操作"></a>合成移动操作</h1><h2 id="何时定义"><a href="#何时定义" class="headerlink" title="何时定义"></a>何时定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasX</span> &#123;</span></span><br><span class="line">  X mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x, x2 = <span class="built_in">std</span>::move(x); <span class="comment">// 合成移动构造函数</span></span><br><span class="line">hasX hx, hx2 = <span class="built_in">std</span>::move(hx); <span class="comment">// 合成移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>只有当一个类<strong>没有定义任何自己版本的拷贝控制成员</strong>，且类的<strong>每个非static数据成员都可以移动构造或移动赋值</strong>时，编译器才会合成移动构造函数和移动赋值运算符。</p>
<h2 id="何时删除"><a href="#何时删除" class="headerlink" title="何时删除"></a>何时删除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">  Y(<span class="keyword">const</span> Y &amp;y) &#123;&#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasY</span> &#123;</span></span><br><span class="line">  hasY() = <span class="keyword">default</span>;</span><br><span class="line">  hasY(hasY &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Y mem;</span><br><span class="line">&#125;;</span><br><span class="line">hasY hy, hy2 = <span class="built_in">std</span>::move(hy); <span class="comment">// call to implicitly-deleted default constructor of &#x27;hasY&#x27;</span></span><br></pre></td></tr></table></figure>

<p>移动操作永远<strong>不会隐式定义</strong>为delete。但如果<strong>显式地</strong>要求编译器生成=default的移动操作，且编译器<strong>不能移动所有成员</strong>时，移动操作会被定义为delete。</p>
<p>定义了一个移动构造函数或移动赋值运算符的类<strong>必须也定义</strong>拷贝操作，否则这些成员<strong>默认定义为delete</strong>。</p>
<h2 id="如果未定义"><a href="#如果未定义" class="headerlink" title="如果未定义"></a>如果未定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Foo() = <span class="keyword">default</span>;</span><br><span class="line">  Foo(<span class="keyword">const</span> Foo &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copied&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo;</span><br><span class="line"><span class="function">Foo <span class="title">foo1</span><span class="params">(foo)</span></span>; <span class="comment">// copied</span></span><br><span class="line"><span class="function">Foo <span class="title">foo2</span><span class="params">(<span class="built_in">std</span>::move(foo1))</span></span>; <span class="comment">// copied</span></span><br></pre></td></tr></table></figure>

<p>如果没有移动构造函数，就算试图调用move来移动，对象也会被拷贝。</p>
<p>这里与上面的hasY不同，hasY的移动构造函数是delete的（由于显式地要求生成，但编译器无法生成）。而这里的仅仅是未定义，函数匹配保证该类型的对象会被copy。</p>
<h2 id="copy-and-swap-again"><a href="#copy-and-swap-again" class="headerlink" title="copy and swap again"></a>copy and swap again</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hp</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Hp() = <span class="keyword">default</span>;</span><br><span class="line">  Hp(<span class="keyword">const</span> Hp &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copied&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  Hp(Hp &amp;&amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;moved&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  Hp &amp;<span class="keyword">operator</span>=(Hp rhs) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;assign&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Hp hp1;</span><br><span class="line">Hp hp2 = hp1; <span class="comment">// copied，拷贝构造函数</span></span><br><span class="line">Hp hp3 = <span class="built_in">std</span>::move(hp1); <span class="comment">// moved，移动构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">hp1 = hp3; <span class="comment">// copied assign，拷贝赋值运算符</span></span><br><span class="line">hp2 = <span class="built_in">std</span>::move(hp3); <span class="comment">// moved assign，移动赋值运算符</span></span><br></pre></td></tr></table></figure>

<p>这里除了拷贝构造函数，还有移动构造函数和赋值运算符。对于之前未定义移动构造函数的情况下，调用赋值运算符，初始化形参时<strong>总是进行拷贝</strong>。</p>
<p>现在拷贝初始化依赖于实参的类型，</p>
<ul>
<li>左值-&gt;使用<strong>拷贝构造函数</strong>进行初始化，赋值运算符为<strong>拷贝赋值运算符</strong></li>
<li>右值-&gt;使用<strong>移动构造函数</strong>进行初始化，赋值运算符为<strong>移动赋值运算符</strong></li>
</ul>
<p>从而单一的赋值运算符，实现了两种功能。</p>
<h2 id="copy-and-swap-idiom"><a href="#copy-and-swap-idiom" class="headerlink" title="copy and swap idiom"></a>copy and swap idiom</h2><p>上面的将拷贝赋值运算符和移动赋值运算符“合并”到一起的方式叫做copy and swap idiom。如果按照上面的方式实现了拷贝赋值运算符和移动赋值运算符，就<strong>不能</strong>再单独写两个拷贝赋值运算符和移动赋值运算符。</p>
<p>而两种实现拷贝赋值运算符和移动赋值运算符的<strong>效率</strong>是有区别的（C++ Primer 5th Chinese Edition, Exercise 15.53）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr3</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr3&amp;, HasPtr3&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> HasPtr3&amp; lhs, <span class="keyword">const</span> HasPtr3&amp; rhs);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  HasPtr3(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s = <span class="built_in">std</span>::<span class="built_in">string</span>())</span><br><span class="line">      : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  HasPtr3(<span class="keyword">const</span> HasPtr3&amp; hp) : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*hp.ps)), i(hp.i) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copied&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  HasPtr3(HasPtr3&amp;&amp; hp) <span class="keyword">noexcept</span> : ps(hp.ps), i(hp.i) &#123;</span><br><span class="line">    hp.ps = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;moved&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// = 4s</span></span><br><span class="line">  <span class="comment">// mixed 4.8s</span></span><br><span class="line">  HasPtr3&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr3&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = newp;</span><br><span class="line">    i = rhs.i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy assigned&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move 0.7s</span></span><br><span class="line">  <span class="comment">// mixed 4.8s</span></span><br><span class="line">  HasPtr3&amp; <span class="keyword">operator</span>=(HasPtr3&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ps;</span><br><span class="line">      ps = rhs.ps;</span><br><span class="line">      i = rhs.i;</span><br><span class="line">      rhs.ps = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;move assigned&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// = 6s</span></span><br><span class="line">  <span class="comment">// move 2.5s</span></span><br><span class="line">  <span class="comment">// mixed 8.8s</span></span><br><span class="line">  <span class="comment">// HasPtr3&amp; operator=(HasPtr3 rhs) &#123;</span></span><br><span class="line">  <span class="comment">// swap(*this, rhs);</span></span><br><span class="line">  <span class="comment">// #ifndef NDEBUG</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; &quot;assigned&quot; &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">// #endif</span></span><br><span class="line">  <span class="comment">// return *this;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  ~HasPtr3() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>* ps;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr3&amp; lhs, HasPtr3&amp; rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  swap(lhs.ps, rhs.ps);  <span class="comment">// swap the pointers, not the string data</span></span><br><span class="line">  swap(lhs.i, rhs.i);    <span class="comment">// swap the int members</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;swapped&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下，这里最好<strong>不要</strong>把对象的创建放到循环中去，<strong>每次构造和销毁的开销</strong>会使得两种拷贝和移动的区别不太明显，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HasPtr3 hp;</span><br><span class="line">HasPtr3 hp1;</span><br><span class="line">HasPtr3 hp2;</span><br><span class="line"><span class="keyword">auto</span> t0 = high_resolution_clock::now();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i) &#123;</span><br><span class="line">  hp = hp1;</span><br><span class="line">  hp = <span class="built_in">std</span>::move(hp2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> t1 = high_resolution_clock::now();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; duration_cast&lt;milliseconds&gt;(t1 - t0).count() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下（VMware 12, Archlinux x64, Intel i7-2620m），</p>
<table>
<thead>
<tr>
<th></th>
<th><code>hp = hp1;</code></th>
<th><code>hp = std::move(hp2);</code></th>
<th>mixed</th>
</tr>
</thead>
<tbody><tr>
<td><code>HasPtr3&amp; operator=(const HasPtr3&amp; rhs)</code></td>
<td>4s</td>
<td>N/A</td>
<td>4.8s</td>
</tr>
<tr>
<td><code>HasPtr3&amp; operator=(HasPtr3&amp;&amp; rhs) noexcept</code></td>
<td>N/A</td>
<td>0.7s</td>
<td>4.8s</td>
</tr>
<tr>
<td><code>HasPtr3&amp; operator=(HasPtr3 rhs)</code></td>
<td>6s</td>
<td>2.5s</td>
<td>8.8s</td>
</tr>
</tbody></table>
<p>可看出copy and swap idiom的效率是不如分开写好。</p>
<h1 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h1><p>一个移动迭代器通过改变给定迭代器的解引用运算符的行为来<strong>适配</strong>此迭代器。对移动迭代器<strong>解引用</strong>生成的是一个<strong>右值</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newe = uninitialized_copy(make_move_iterator(elements), make_move_iterator(cap), newb);</span><br></pre></td></tr></table></figure>

<p>通过调用<code>make_move_iterator</code>可将一个普通迭代器转换为一个移动迭代器。上面的代码中，传递给<code>uninitialized_copy</code>的是一个移动迭代器，解引用后得到的是右值，因此<code>uninitialized_copy</code>将使用移动构造函数来构造元素。</p>
<p>标准库<strong>不保证</strong>哪些算法适用于移动迭代器。只有确认对象在传递给函数后<strong>不再访问</strong>，才能将移动迭代器传递给算法。</p>
<h1 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h1><p>类似构造函数和赋值运算符，成员函数同样可以提供拷贝版本和移动版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>; <span class="comment">// 拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>; <span class="comment">// 移动</span></span><br></pre></td></tr></table></figure>

<p>拷贝版本接受能够<strong>转换</strong>为类型X的<strong>任何对象</strong>。使用<code>const X&amp;</code>是因为拷贝操作<strong>不应该改变该对象</strong>。</p>
<p>而移动版本接受<strong>非const右值</strong>，对于非const右值是精确匹配。从源对象移动数据时，显然需要更改源对象，所以是<code>X&amp;&amp;</code>。</p>
<h2 id="右值和左值引用成员函数"><a href="#右值和左值引用成员函数" class="headerlink" title="右值和左值引用成员函数"></a>右值和左值引用成员函数</h2><p>对于赋值运算符，为了<strong>强制左侧运算对象</strong>是一个左值，可以类似const，在参数列表后使用引用限定符，引用限定符可以是<code>&amp;</code>或<code>&amp;&amp;</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) &amp;; <span class="comment">// 只能向可修改的左值赋值</span></span><br></pre></td></tr></table></figure>

<p>const改变了this指针的类型，指明了this是指向常量的指针，这里类似，引用限定符说明了this<strong>可以指向</strong>一个<strong>左值还是右值</strong>。const和引用限定符只能用于<strong>非static</strong>成员函数。</p>
<h2 id="重载和引用函数"><a href="#重载和引用函数" class="headerlink" title="重载和引用函数"></a>重载和引用函数</h2><ul>
<li><p>当定义const成员函数是，可以根据有无const，定义两个重载版本。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当定义有引用限定符的成员函数时，如果定义<strong>两个或两个以上</strong>具有相同<strong>名字和参数列表</strong>的成员函数，就必须对*<em>所有重载函数</em>都加上引用限定符。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span> &amp;&amp;</span>;</span><br><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span> <span class="keyword">const</span></span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span> <span class="keyword">const</span> &amp;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2014/2014-03-03-cpp-dynamic-memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2014/2014-03-03-cpp-dynamic-memory/" class="post-title-link" itemprop="url">C++动态内存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-03-03 18:31:05" itemprop="dateCreated datePublished" datetime="2014-03-03T18:31:05+08:00">2014-03-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2014/2014-03-03-cpp-dynamic-memory/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/2014-03-03-cpp-dynamic-memory/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>静态内存：存储局部static对象、类static数据成员和定义在函数之外的变量。<br>static对象：使用之前分配，程序结束时销毁。</p>
<p>栈内存：保存定义在函数内部的非static对象。<br>栈对象：仅在定义的程序块运行时才存在。</p>
<p>动态内存（free store或heap）：存储动态分配的对象，需要<strong>显示地销毁</strong>，分配和销毁由<code>new</code>和<code>delete</code>完成。</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>最安全的分配和使用动态内存的方法是调用<code>make_shared</code>，返回指向在动态内存分配的对象的<code>shared_ptr</code>。<code>make_shared</code>类似<code>emplace</code>，使用<strong>参数来构造</strong>指定类型的对象，如果没有参数，则进行值初始化。</p>
<p>当进行copy或assign时，<strong>每个</strong><code>shared_ptr</code>会记录有多少个其他<code>shared_ptr</code>指向相同的对象。可看作<code>shared_ptr</code>有reference count，</p>
<ul>
<li><p>当发生以下情况时，count递增；</p>
<ol>
<li>copy或assign； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li>作为参数传给一个函数；</li>
<li>作为函数的返回值；</li>
</ol>
</li>
<li><p>当发生以下情况时，count递减；</p>
<ol>
<li>给<code>shared_ptr</code>赋予一个新的值； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 1</span></span><br><span class="line">r = q; <span class="comment">// ++q指向对象的ref count，--r指向对象的ref count；销毁r原来指向对象</span></span><br></pre></td></tr></table></figure></li>
<li><code>shared_ptr</code>被销毁；</li>
</ol>
</li>
</ul>
<p>count的递减由<code>shared_ptr</code>的析构函数完成，如果count<strong>变为0</strong>，<code>shared_ptr</code>会释放所管理的对象。</p>
<p>在某个scope中，只要能够使用<code>shared_ptr</code>，那么它的引用计数<strong>至少为1</strong>。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.get() <span class="comment">// 返回内置的指针</span></span><br><span class="line">p.use_count() <span class="comment">// 返回引用计数</span></span><br><span class="line">p.unique() <span class="comment">// 若引用计数为1，则返回true；否则false</span></span><br><span class="line">p.reset() <span class="comment">// 将p置空，若p是唯一指向对象的，则释放此对象</span></span><br><span class="line">p.reset(q) <span class="comment">// 令p指向内置指针q，若p是唯一指向对象的，则释放此对象</span></span><br><span class="line">p.reset(q, d) <span class="comment">// 同上，释放q时调用d</span></span><br></pre></td></tr></table></figure>

<p>使用<code>new</code>和<code>delete</code>会使得类对象的copy、assign和destroy<strong>不能依赖任何默认定义</strong>。</p>
<h3 id="自定义释放操作"><a href="#自定义释放操作" class="headerlink" title="自定义释放操作"></a>自定义释放操作</h3><p>默认情况下，shared_ptr指向的是动态内存，因此被销毁时，默认调用delete。可以自定义释放操作，提供其他的deleter。deleter的参数必须为<strong>该shared_ptr的内置指针类型</strong>。</p>
<h2 id="直接管理动态内存"><a href="#直接管理动态内存" class="headerlink" title="直接管理动态内存"></a>直接管理动态内存</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>默认情况下，new的对象是<strong>默认初始化</strong>的。也可以使用值初始化的方式来初始化new的对象（圆括号+参数），还可以使用列表初始化，以及值初始化（空括号）。</p>
<h3 id="自动推断类型"><a href="#自动推断类型" class="headerlink" title="自动推断类型"></a>自动推断类型</h3><p>可以使用auto从initializer来推断将要分配的对象类型，由于编译器<strong>需要从initializer来获得类型</strong>，因此圆括号中仅能有一个initializer，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="keyword">auto</span>(obj);</span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a, b, c&#125;; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">auto</span> p3 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h3 id="const对象"><a href="#const对象" class="headerlink" title="const对象"></a>const对象</h3><p>和其他const对象相同，必须初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *pcs = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>; <span class="comment">// 调用默认构造函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 只能显示初始化</span></span><br></pre></td></tr></table></figure>

<h3 id="bad-alloc"><a href="#bad-alloc" class="headerlink" title="bad_alloc"></a>bad_alloc</h3><p>如果内存不足，new失败，就会抛出<code>bad_alloc</code>，但可以告知不抛出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 失败则返回nullptr</span></span><br></pre></td></tr></table></figure>

<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>传递给delete的必须是指针，且必须指向动态分配的内存，或是一个<code>nullptr</code>。如果是动态分配的内存，或释放同一个指针多次，行为未定义。对const动态对象，销毁的方法也是一样的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用clang++ 3.7编译</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line"><span class="keyword">delete</span> pi; <span class="comment">// segmentation fault</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> pi2; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> *pd = <span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">double</span> *pd1 = pd;</span><br><span class="line"><span class="keyword">delete</span> pd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// pd不会被置为nullptr，空悬指针</span></span><br><span class="line"><span class="keyword">delete</span> pd; <span class="comment">// core dumpped</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">delete</span> pci;</span><br></pre></td></tr></table></figure>

<p>可以在delete后手动赋值为<code>nullptr</code>。但也仅仅只解决了<code>pd</code>的问题，多个指针指向同一个内存区域时，仍然有问题，<code>pd1</code>仍然指向原内存区域，还是空悬指针。</p>
<h2 id="shared-ptr和new"><a href="#shared-ptr和new" class="headerlink" title="shared_ptr和new"></a>shared_ptr和new</h2><p>可以用new返回的指针来初始化<code>shared_ptr</code>。由于接受智能指针的构造函数是explicit的，因此必须使用<strong>直接初始化</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误，此语句首先需要在int*和shared_ptr之间做隐式转换，然后再把临时的shared_ptr拷贝给p1。</span></span><br></pre></td></tr></table></figure>

<p><code>shared_ptr</code>定义了<code>get</code>函数，可以获得内置指针，指向<code>shared_ptr</code>管理的对象。通过这种方式得到的指针<strong>不能被delete</strong>，必须保证代码不会delete的情况下，才能使用get。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用clang++ 3.7编译</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>))</span></span>;</span><br><span class="line"><span class="keyword">int</span> *q = p.get();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sq</span><span class="params">(q)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *sq &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">delete</span> q; <span class="comment">// double free or corruption</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 错误，p指向的内存已被销毁</span></span><br><span class="line"><span class="comment">// double free or corruption</span></span><br></pre></td></tr></table></figure>

<p>上述代码在内部的scope中手动删除了p指向的内存，当这个scope结束时，sq被销毁，那部分内存<strong>还会被shared_ptr销毁一次</strong>。编译时不会报错，但运行时出现double free or corruption。<br><strong>就算没有delete</strong>，内部的scope结束，那部分内存被销毁，这段代码结束时，又一次被销毁，同样也会有double free or corruption。</p>
<h2 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h2><p>无论是函数正常结束或者发生异常，局部对象都会被销毁。智能指针被销毁时，如果引用计数为0，则释放内存。但new得到的内存不会被自动释放，如果有指向这块内存的指针，只有指针会被销毁。</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr<strong>拥有</strong>指向的对象。没有类似make_shared的函数，只能将其绑定到new返回的指针上。也是必须使用直接初始化。</p>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>除了将被销毁的unique_ptr外，<strong>不支持copy和assignment</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="literal">nullptr</span> <span class="comment">// 释放u指向的对象，并置空</span></span><br><span class="line">u.release() <span class="comment">// 放弃对指针的控制权，返回指针并将u置空</span></span><br><span class="line">u.reset() <span class="comment">// 类似shared_ptr，只是无需判断引用计数</span></span><br><span class="line">u.reset(q)</span><br><span class="line">u.reset(<span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义释放操作-1"><a href="#自定义释放操作-1" class="headerlink" title="自定义释放操作"></a>自定义释放操作</h3><p>不同于shared_ptr，unique_ptr在重载deleter时，需要<strong>提供deleter的类型</strong>。重载unique_ptr的deleter，会影响到unique_ptr的类型和如何构造或reset该类型的对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;objT, delT&gt; p(new objT, fcn);</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><ul>
<li><strong>不控制</strong>所指向对象的生命周期；</li>
<li>weak_ptr指向shared_ptr管理的对象；</li>
<li>将一个weak_ptr绑定到一个shared_ptr<strong>不会改变shared_ptr的引用计数</strong>；</li>
<li>一旦shared_ptr被销毁，所指对象就被释放。</li>
</ul>
<h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w = p <span class="comment">// p可以是weak_ptr或shared_ptr</span></span><br><span class="line">w.reset() <span class="comment">// 将w置空</span></span><br><span class="line">w.use_count()</span><br><span class="line">w.expired() <span class="comment">// 若w.use_count()为0，返回true，否则false</span></span><br><span class="line">w.lock() <span class="comment">// 若w.expired()为true，返回空的shared_ptr，否则返回指向w的对象的shared_ptr</span></span><br></pre></td></tr></table></figure>

<h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><p>分配动态数组的类必须<strong>定义自己的版本</strong>的操作来管理<strong>拷贝，复制以及销毁</strong>。</p>
<h2 id="new数组"><a href="#new数组" class="headerlink" title="new数组"></a>new数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br></pre></td></tr></table></figure>

<p><code>pia</code>中的元素是进行默认初始化的。但此时pia并<strong>不是一个数组</strong>类型的对象，只是一个数组元素类型的指针，因此不能够调用begin和end（它们<strong>使用数组的维度</strong>来得到首元素和尾后元素指针），也不能使用for。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>new的数组和单个对象一样，默认情况下，new的数组是<strong>默认初始化</strong>的。可以对数组中的元素进行值初始化和列表初始化，也和单个对象一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]();</span><br><span class="line"><span class="keyword">auto</span> *psa1 = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>](<span class="string">&quot;abd&quot;</span>, <span class="string">&quot;abc&quot;</span>, ...); <span class="comment">// 不能再这里提供initializer，因此不能用auto</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span>[<span class="number">10</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 剩下的元素进行值初始化</span></span><br></pre></td></tr></table></figure>

<p>如果new失败，类似bad_alloc，这里会抛出bad_array_new_length。</p>
<h3 id="new空数组"><a href="#new空数组" class="headerlink" title="new空数组"></a>new空数组</h3><p>这样做是合法的，得到的是一个合法的非空指针，相当与数组的尾后指针，不能解引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]; <span class="comment">// 合法，但不可以解引用</span></span><br></pre></td></tr></table></figure>

<h3 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 未定义</span></span><br></pre></td></tr></table></figure>

<p>释放时，按逆序销毁。p还可以为nullptr。</p>
<h3 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h3><p>标准库提供了一个管理new分配的数组的unique_ptr，但此unique_ptr<strong>不支持成员访问运算符</strong>。unique_ptr被销毁时，会自动使用<code>delete []</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T[]&gt; u</span><br><span class="line">unique_ptr&lt;T[]&gt; u(p)</span><br><span class="line">u[i]</span><br></pre></td></tr></table></figure>

<p>如果使用shared_ptr来管理，则必须<strong>提供自定义的删除器</strong>。如果没有提供，则shared_ptr会默认调用delete，行为未定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span> [] p; &#125;)</span></span>;</span><br><span class="line">*(sp.get() + <span class="number">5</span>) = <span class="number">2</span>; <span class="comment">// shared_ptr未定义下标运算符，且智能指针不支持指针算术运算</span></span><br></pre></td></tr></table></figure>

<h2 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  C(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : a_(a), b_(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C *<span class="keyword">const</span> pc = <span class="keyword">new</span> C[<span class="number">10</span>]; <span class="comment">// 错误</span></span><br><span class="line">C *<span class="keyword">const</span> pc1 = <span class="keyword">new</span> C[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>new把<strong>内存分配和对象构造</strong>组合在了一起，可能造成外的开销；同时若类没有默认构造函数，则不能够分配动态数组。</p>
<p>allocator<strong>分离</strong>内存分配和对象构造，避免不必要的开销。所分配的内存是原始的，未构造的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;C&gt;::size_type n = <span class="number">10</span>;</span><br><span class="line">allocator&lt;C&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); <span class="comment">// C *const p1 = alloc.allocate(10);</span></span><br><span class="line"><span class="keyword">auto</span> q = p;</span><br><span class="line">alloc.construct(q++, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 类似make_shared</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;a_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;b_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q-&gt;a_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q-&gt;b_ &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 错误，q指向的内存未构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">  alloc.destroy(--q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc.deallocate(p, n); <span class="comment">// 大小应和allocate时的一样</span></span><br></pre></td></tr></table></figure>

<h3 id="拷贝和填充未初始化内存"><a href="#拷贝和填充未初始化内存" class="headerlink" title="拷贝和填充未初始化内存"></a>拷贝和填充未初始化内存</h3><p>下列操作所需的内存是由<code>allocate</code>分配的，而<strong>不是系统分配</strong>的，因此<code>alloc_b</code>指向的内存必须足够大。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uninitialized_copy(b, e, alloc_b); <span class="comment">// 返回最后一个构造的元素之后的位置</span></span><br><span class="line">uninitialized_copy_n(b, n, alloc_b); <span class="comment">// 返回最后一个构造的元素之后的位置</span></span><br><span class="line">uninitialized_fill(alloc_b, alloc_e, t);</span><br><span class="line">uninitialized_fill_n(alloc_b, n, t);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2014/2014-02-28-cpp-associative-container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2014/2014-02-28-cpp-associative-container/" class="post-title-link" itemprop="url">C++关联容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-02-28 18:56:17" itemprop="dateCreated datePublished" datetime="2014-02-28T18:56:17+08:00">2014-02-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2014/2014-02-28-cpp-associative-container/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/2014-02-28-cpp-associative-container/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>关联容器支持普通容器操作，不支持，</p>
<ul>
<li>顺序容器位置相关的操作，<code>push_back</code>等；</li>
<li>构造函数或插入操作接受一个元素值和一个数量值得操作。</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>定义一个map时必须指定<strong>关键字类型和值类型</strong>，set只需<strong>关键字类型</strong>。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>可以用下面的方式来初始化，</p>
<ul>
<li>同类型容器的copy；</li>
<li>指定值范围（begin和end）；</li>
<li>列表初始化。</li>
</ul>
<h1 id="有序关联容器关键字类型的要求"><a href="#有序关联容器关键字类型的要求" class="headerlink" title="有序关联容器关键字类型的要求"></a>有序关联容器关键字类型的要求</h1><p>有序关联容器关键字类型必须定义<strong>元素比较的方法</strong>。默认情况下，使用<code>&lt;</code>进行比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list的iterator并无&lt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">int</span>&gt; ml; <span class="comment">// 声明不会报错</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line">ml[li.begin()] = <span class="number">0</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>对于有序容器，有序容器的关键字必须是<strong>严格弱序</strong>的，可看做“小于等于”。</p>
<h2 id="自定义比较操作"><a href="#自定义比较操作" class="headerlink" title="自定义比较操作"></a>自定义比较操作</h2><p>用于组织一个容器中元素的<strong>操作的类型</strong>也是容器类型的一部分，如果需要自定义操作，则在定义容器的时候就指明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boo <span class="title">compare</span><span class="params">(...)</span> </span>&#123; ... &#125;</span><br><span class="line">multiset&lt;Sales_sata, decltype(compare) *&gt; bookstore(compare);</span><br></pre></td></tr></table></figure>

<p>创建对象时，提供的操作类型（<strong>函数指针</strong>）必须与尖括号中的类型吻合。规则与函数的const形参和实参的规则一致，忽略top const。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> comp = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(const int, const int)&gt; m(comp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp1 = [](<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(int, int)&gt; m1(comp1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp2 = [](<span class="keyword">int</span>* <span class="keyword">const</span> a, <span class="keyword">int</span>* <span class="keyword">const</span> b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(int*, int*)&gt; m2(comp2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp3 = [](<span class="keyword">int</span>* a, <span class="keyword">int</span>* b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(int* const, int* const)&gt; m3(comp3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp4 = [](<span class="keyword">int</span>* a, <span class="keyword">int</span>* b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(const int*, const int*)&gt; m4(comp4); // 错误</span><br></pre></td></tr></table></figure>

<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>模板，接受两个类型名，pair的数据成员将有对应的类型，两个类型不要求一样。</p>
<p>创建对象时，pair的默认构造函数对数据成员进行<strong>值初始化</strong>（vector也可以）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br></pre></td></tr></table></figure>

<p>若函数返回pair，可<strong>对返回值</strong>进行列表初始化，不必显式构造返回值。</p>
<h1 id="关联容器的操作"><a href="#关联容器的操作" class="headerlink" title="关联容器的操作"></a>关联容器的操作</h1><p>map中，每个元素就是一个pair对象，由于关键字不可变，因此pair的<strong>关键字部分是const</strong>。set的关键字也是<code>const</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type v1; <span class="comment">// pair&lt;const string, int&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::key_type v2; <span class="comment">// string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::map_type v3; <span class="comment">// int</span></span><br></pre></td></tr></table></figure>

<h2 id="关联容器的迭代器"><a href="#关联容器的迭代器" class="headerlink" title="关联容器的迭代器"></a>关联容器的迭代器</h2><p>对关联容器迭代器解引用，可得到容器的<code>value_type</code>的引用。</p>
<p>对于set，虽然set定义了<code>iterator</code>和<code>const_iterator</code>，但是都不能改变set中的元素。</p>
<p>当迭代器遍历一个map，multimap，set或multiset时，按关键字升序遍历。</p>
<h2 id="关联容器和算法"><a href="#关联容器和算法" class="headerlink" title="关联容器和算法"></a>关联容器和算法</h2><p>由于关键字是<code>const</code>，因此不能用于修改或重排容器的算法（都需要向元素写入值）。只可用于读取元素的算法。</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p><code>insert</code>和<code>emplace</code>可以对关联容器进行插入，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c.insert(v)</span><br><span class="line">c.emplace(args)</span><br><span class="line"><span class="comment">// map和set返回pair&lt;iterator, bool&gt;，iterator指向有此关键字的元素，bool说明是否元素是否已经存在，即是否插入成功。multimap和multiset总是进插入，只返回bool。</span></span><br><span class="line"></span><br><span class="line">c.insert(b, e)</span><br><span class="line">c.insert(li)</span><br><span class="line"><span class="comment">// 返回void</span></span><br><span class="line"></span><br><span class="line">c.insert(p, v)</span><br><span class="line">c.emplace(p, args)</span><br><span class="line"><span class="comment">// p指明了从哪里开始新元素的存储位置</span></span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>关联容器有三个版本的erase，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c.erase(k)</span><br><span class="line"><span class="comment">// 删除所有key为k的元素，返回size_type，表明删除的数量</span></span><br><span class="line"></span><br><span class="line">c.erase(p)</span><br><span class="line"><span class="comment">// 返回被删除元素后的迭代器</span></span><br><span class="line"></span><br><span class="line">c.erase(b, e)</span><br><span class="line"><span class="comment">// 返回e</span></span><br></pre></td></tr></table></figure>

<h2 id="map的下标"><a href="#map的下标" class="headerlink" title="map的下标"></a>map的下标</h2><p>由于set并无关联值，下标操作对set无意义，故set不支持。multimap和multiset可能存在多个与某个key关联的值，故也不支持。</p>
<p>下标操作返回<code>mapped_type</code>，是左值。如果关键字不在map中，下标操作会，</p>
<ol>
<li><strong>创建一个元素并插入</strong>，关联值将进行<strong>值初始化</strong>；</li>
<li>提取元素并赋值。</li>
</ol>
<p>注意，</p>
<ol>
<li>与vector和string不同，map的下标操作和解引用返回的类型（<code>mapped_type</code>和<code>value_type</code>）不一样；</li>
<li>如果元素不存在，<code>at</code>并不会创建，而是抛出<code>out_of_range</code>；</li>
<li>下标操作可能会改变map，对const的map无法使用；</li>
<li>对于const的map，只要<code>at</code>不修改元素，就可以用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m.at(<span class="string">&quot;hello&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m[<span class="string">&quot;hello&quot;</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 错误，即使是普通访问</span></span><br><span class="line">m.at(<span class="string">&quot;hello&quot;</span>) = <span class="number">1</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><p>使用hash function和<code>==</code>来组织元素，用<code>hash&lt;key_type&gt;</code>类型的对象生成每个元素的hash值，有序关联容器的操作可以用于无序容器。</p>
<p>标准库为<strong>内置类型（包括指针类型）和部分标准库类型（包括string和智能指针）类型</strong>定义了hash。但不能直接把自定义类型作为key来定义无序容器，可以</p>
<ol>
<li>提供自己的hash模板版本；</li>
<li>定义hash function和<code>==</code>运算符。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; sd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;() (sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; lhs, <span class="keyword">const</span> Sales_data&amp;rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_multiset&lt;Sales_data, decltype(hasher)*, decltype(eqOp)*&gt; set(42, hasher,  eqOp);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chao Mai</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:{&quot;url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;,&quot;integrity&quot;:&quot;sha256-ncNI9OXOS5Ek4tzVYiOMmN&#x2F;KKCPZ6V0Cpv2P&#x2F;zHntiA&#x3D;&quot;}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{&quot;enable&quot;:true,&quot;shortname&quot;:&quot;chaomaisblog&quot;,&quot;count&quot;:true,&quot;i18n&quot;:{&quot;disqus&quot;:&quot;disqus&quot;}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
