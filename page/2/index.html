<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/default_avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/default_avatar.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;chaomai.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;right&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:true,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="chaomai&#39;s blog">
<meta property="og:url" content="https://chaomai.github.io/page/2/index.html">
<meta property="og:site_name" content="chaomai&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chao Mai">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaomai.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;2&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>chaomai's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-34179929-2"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;UA-34179929-2&quot;,&quot;only_pageview&quot;:false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="chaomai's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">chaomai's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>Rss</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chao Mai</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chaomai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chaomai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:loneymai@gmail.com" title="E-Mail → mailto:loneymai@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/chaomai" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;chaomai" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://laike9m.com/" title="https:&#x2F;&#x2F;laike9m.com" rel="noopener" target="_blank">laike9m's blog</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-12-02-redis-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-12-02-redis-list/" class="post-title-link" itemprop="url">redis list</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-12-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-02T00:00:00+08:00">2019-12-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-12-02-redis-list/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-12-02-redis-list/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>reids的list采用的是双向链表的实现，未使用dummy node。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>双端</li>
<li>无环</li>
<li>有头尾指针</li>
<li>有长度计数器</li>
<li>多态（使用<code>void*</code>来保存节点值，并提供<code>free</code>，<code>dup</code>，<code>match</code>来处理节点）</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-11-26-redis-sds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-11-26-redis-sds/" class="post-title-link" itemprop="url">redis sds</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-26T00:00:00+08:00">2019-11-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-11-26-redis-sds/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-11-26-redis-sds/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>sds主要由<code>len</code>，<code>alloc</code>和<code>buf</code>构成。其中<code>buf</code>是柔性数组，分配sds的时候，这个结构体会作为header。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有packed，那么sizeof(sdshdr32) =</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为sds分配空间，<code>initlen</code>是字符串的长度，1是末尾的’\0’。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="sdsnewlen、sdslen，sdsavail"><a href="#sdsnewlen、sdslen，sdsavail" class="headerlink" title="sdsnewlen、sdslen，sdsavail"></a>sdsnewlen、sdslen，sdsavail</h1><p><code>sdsnewlen</code>返回的是<code>char buf[]</code>首元素的地址，这个值作为<code>sds</code>指针的值。这是sds中巧妙的地方。但是如何获取header地址，以及访问成员？毕竟相关字段是在柔性数组的前面。</p>
<ul>
<li><p><code>sds - 1</code>就是<code>flag</code>，由<code>flag</code>可以得知header类型，也就知道header的长度，减去header的长度得到header的地址，访问<code>len</code>成员即可得知<code>buf</code>长度。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sdshdr5</code>是一个特别的类型，长度和类型都隐藏在了<code>flag</code>里面。<code>SDS_TYPE_5</code>存储的是长度小于<code>1 &lt;&lt; 5</code>的字符数组，也就是可以用5 bit来表示。这样加上3 bit的类型，合起来刚好8 bit，就是一个<code>flag</code>。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br></pre></td></tr></table></figure>

<p>  因此<code>flag</code>的3 lsb作为类型，5 msb作为长度。但<code>sdshdr5</code>无法记录空闲的空间，因此无法扩容。</p>
</li>
</ul>
<h1 id="sdsgrowzero"><a href="#sdsgrowzero" class="headerlink" title="sdsgrowzero"></a>sdsgrowzero</h1><ul>
<li>新长度小于1MB，则buf大小翻倍</li>
<li>新长度大于等于1MB，则buf加1MB</li>
</ul>
<h1 id="sdstrim"><a href="#sdstrim" class="headerlink" title="sdstrim"></a>sdstrim</h1><p>trim后并未释放buf的空间。</p>
<p>提供了<code>sdsRemoveFreeSpace</code>函数，可以完成在尾部没有空闲的空间。</p>
<h1 id="sds与c字符串的区别"><a href="#sds与c字符串的区别" class="headerlink" title="sds与c字符串的区别"></a>sds与c字符串的区别</h1><ul>
<li>参数时间获取字符串长度</li>
<li>记录长度，避免buffer overflow</li>
<li>空间预分配、惰性释放，减少重分配次数</li>
<li>二进制安全</li>
<li>兼容部分c字符串函数</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>sds的定义使用了pack，内存没有对齐的情况下，会影响cpu访问内存的性能，这个是如何解决的？</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a target="_blank" rel="noopener" href="https://youjiali1995.github.io/redis/learn-redis/">Redis源码阅读计划</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261663&idx=1&sn=949aec03a6edf0b2281d5d83147ba367&chksm=84479186b33018903b9a3664d4de17ab83b62760e456ffcf32e9319d03964892fac6d0a7c208&scene=21#wechat_redirect">Redis源码从哪里读起？</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b336601f265da598e13f917">Redis 深度历险：核心原理与应用实践</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-09-20-golang-traps-and-pitfalls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-09-20-golang-traps-and-pitfalls/" class="post-title-link" itemprop="url">go踩坑合集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-09-20 17:07:39" itemprop="dateCreated datePublished" datetime="2019-09-20T17:07:39+08:00">2019-09-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-09-20-golang-traps-and-pitfalls/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-09-20-golang-traps-and-pitfalls/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RWMutex-RLock重入导致死锁"><a href="#RWMutex-RLock重入导致死锁" class="headerlink" title="RWMutex RLock重入导致死锁"></a>RWMutex RLock重入导致死锁</h1><p>RWMutex，即读写锁，可以被多个的reader或一个writer获取使用。</p>
<h2 id="死锁例子"><a href="#死锁例子" class="headerlink" title="死锁例子"></a>死锁例子</h2><p>在使用RWMutex的时候，同一个reader是不应该连续调用<code>Rlock</code>多次的，这样做不但没有意义，还有可能导致死锁，具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> l = sync.RWMutex&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		l.RLock()</span><br><span class="line">		<span class="keyword">defer</span> l.RUnlock()</span><br><span class="line">		c &lt;- <span class="number">1</span></span><br><span class="line">		runtime.Gosched()</span><br><span class="line"></span><br><span class="line">		l.RLock()</span><br><span class="line">		<span class="keyword">defer</span> l.RUnlock()</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-c</span><br><span class="line">		l.Lock()</span><br><span class="line">		<span class="keyword">defer</span> l.Unlock()</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sync-RWMutex分析"><a href="#sync-RWMutex分析" class="headerlink" title="sync.RWMutex分析"></a>sync.RWMutex分析</h2><p>下面<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/master/src/sync/rwmutex.go">RWMutex的实现</a>，我们来看这段代码的具体执行。为了方便理解，把<code>if race.Enabled &#123;...&#125;</code>的相关代码都去除了。</p>
<ol>
<li><p><strong>goroutine 1</strong>：<code>l.RLock()</code></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 执行<code>l.RLock()</code>后，goroutine 1获得写锁。</p>
<ul>
<li>状态：获得读锁</li>
<li>readerCount = 1，readerWait = 0</li>
</ul>
</li>
<li><p><strong>goroutine 2</strong>：<code>l.Lock()</code></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// Wait for active readers.</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 由于goroutine 1已获得写锁，此时goroutine 2等待。</p>
<ul>
<li>状态：等待reader释放读锁</li>
<li>readerCount = 1 - rwmutexMaxReaders，readerWait = 1</li>
</ul>
</li>
<li><p><strong>goroutine 1</strong>：<code>l.RLock()</code></p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> goroutine 1发现readerCount为负，认为有writer获得了写锁，接着也进入了等待状态。</p>
<ul>
<li>状态：等待</li>
<li>readerCount = 2 - rwmutexMaxReaders，readerWait = 1</li>
</ul>
</li>
</ol>
<p>最后goroutine 1和goroutine 2都进入了等待状态。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>readerCount的作用？<br> 持有读锁的reader数。置为负时，代表了writer正在或者已经获得了读锁，此时其他reader不能再获得写锁。</p>
</li>
<li><p>readerWait的作用，以及在<code>Lock()</code>中，为何需要同时判断<code>r != 0</code>和<code>atomic.AddInt32(&amp;rw.readerWait, r) != 0</code>？<br> 置readerCount为负的时候，获得了写锁，但尚未RULock的reader数。writer需要等待这些reader执行结束。</p>
<ul>
<li><p>若<code>r == 0</code>，则无正在持有读锁的reader，可以直接完成读锁的加锁。</p>
</li>
<li><p>若<code>r != 0</code>，writer需要等待获得了写锁，但尚未RULock的reader执行结束。如何判断是否需要等待呢，即readerWait不为0的时候。同时reader决定是否能唤醒writer，也需要等到readerWait为0的时候。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw.w.Lock()</span><br><span class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">	<span class="comment">// 此刻起，其他reader不再能够获得读锁。</span></span><br><span class="line">	<span class="comment">// 此时，尚未释放写锁的reader数为readerWait个，等待他们结束才能完成读锁的加锁。</span></span><br><span class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">		runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="sync-WaitGroup使用的问题"><a href="#sync-WaitGroup使用的问题" class="headerlink" title="sync.WaitGroup使用的问题"></a>sync.WaitGroup使用的问题</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在实现一个需求的时候，需要等待一定数目的go协程执行完毕，但这个数目事先并不好确定。想到了可以用sync.WaitGroup来完成，在使用时候发现，<code>Wait()</code>没有生效，并未等待协程结束，代码大致如下，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;- ch:</span><br><span class="line">				fmt.Println(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">go</span> f()</span><br><span class="line">		<span class="keyword">go</span> f()</span><br><span class="line">		<span class="keyword">go</span> f()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后程序不会有任何的输出就退出了。</p>
<h2 id="sync-WaitGroup源码分析"><a href="#sync-WaitGroup源码分析" class="headerlink" title="sync.WaitGroup源码分析"></a>sync.WaitGroup源码分析</h2><blockquote>
<p>Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for.</p>
</blockquote>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;- ch:</span><br><span class="line">				fmt.Println(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> f()</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> f()</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> f()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18805416/waiting-on-an-indeterminate-number-of-goroutines">Waiting on an indeterminate number of goroutines</a></li>
</ol>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ctx context.Context, wg *sync.WaitGroup, retCh <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// process</span></span><br><span class="line">		<span class="comment">// send process result back</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				retCh &lt;- <span class="number">1</span></span><br><span class="line">				retCh &lt;- <span class="number">2</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				retCh &lt;- <span class="number">1</span></span><br><span class="line">				retCh &lt;- <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loop</span><span class="params">(ctx context.Context, wg *sync.WaitGroup, retCh <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> process(ctx, wg, retCh)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> ret := &lt;-retCh:</span><br><span class="line">				fmt.Println(ret)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	retCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> loop(ctx, wg, retCh)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-09-10-python-multiprocessing-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-09-10-python-multiprocessing-queue/" class="post-title-link" itemprop="url">python multiprocessing.Queue模块源码阅读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-09-10 12:35:20" itemprop="dateCreated datePublished" datetime="2019-09-10T12:35:20+08:00">2019-09-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-09-10-python-multiprocessing-queue/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-09-10-python-multiprocessing-queue/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前有记录过python <a href="/2018/2018-07-04-python-multiprocessing-communication">Queue</a>的使用，以及<a href="/2019/2019-09-09-python-multiprocessing-process">multiprocessing.Process模块</a>。现在看看<code>multiprocessing.Queue</code>的具体工作方式（本文基于Python 3.7.4）。</p>
<p><code>multiprocessing.Queue</code>定义在queues.py中，除此之外还定义了<code>SimpleQueue</code>和<code>JoinableQueue</code>，是FIFO队列。</p>
<p>类似<code>multiprocessing.Process</code>，首先导入了<code>context</code>，判断当前系统类型，并相应地使用对应的实现。使用的<code>multiprocessing.Queue()</code>的时候，实际上是调用了<code>context</code>中的<code>Queue()</code>方法，设置了<code>ctx</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Queue</span>(<span class="params">self, maxsize=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Returns a queue object&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">from</span> .queues <span class="keyword">import</span> Queue</span><br><span class="line">    <span class="keyword">return</span> Queue(maxsize, ctx=self.get_context())</span><br></pre></td></tr></table></figure>

<h1 id="SimpleQueue"><a href="#SimpleQueue" class="headerlink" title="SimpleQueue"></a>SimpleQueue</h1><p><code>SimpleQueue</code>很简单，其实就是一个带锁的pipe，</p>
<ul>
<li>主进程和子进程分别使用各自的lock，实现写入pipe和读取pipe是并发安全的<br>  之所以<code>put()</code>和<code>get()</code>可以使用不同的lock，是因为pipe两端的读写已经是并发安全的了。</li>
<li>用<code>multiprocessing.Pipe</code>来实现消息传递，支持多读多写</li>
</ul>
<blockquote>
<p>关于<code>os.pipe</code>和<code>multiprocessing.Pipe</code></p>
<ul>
<li><code>os.pipe</code>：在Linux上底层访问的是传统的POSIX pipes，单向，使用encode/decode序列化</li>
<li><code>multiprocessing.Pipe</code>：使用<code>multiprocessing.Connection</code>实现，在Linux上使用POSIX sockets完成数据发送，双向，使用pickle/unpickle序列化</li>
</ul>
</blockquote>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p><code>Queue</code>可以看做在<code>SimpleQueue</code>的基础上，增加了生产者端的发送buffer、支持设置队列大小，以及<code>get()</code>和<code>put()</code>的无阻塞调用。</p>
<p><img data-src="/images/2019/python%20queues.jpg" alt="python queues"></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>__init__()</code>初始化了这么几个比较重要的变量，</p>
<ul>
<li><code>_maxsize</code>：队列最大size</li>
<li><code>_reader</code>，<code>_writer</code>：<code>multiprocessing.Connection</code>实例，负责数据的收发</li>
<li><code>_rlock</code>：<code>multiprocessing.Lock</code>，进程间共享，保证<code>_reader.recv_bytes()</code>并发安全</li>
<li><code>_wlock</code>：<code>multiprocessing.Lock</code>，进程间共享，保证<code>_writer.send_bytes()</code>并发安全</li>
<li><code>_sem</code>：队列长度信号量，计数器初始化为<code>_maxsize</code></li>
<li><code>_notempty</code>：条件变量，同步生产者放入<code>_buffer</code>和<code>_buffer</code>中数据的发送</li>
<li><code>_buffer</code>：每个进程有自己独立的buffer，线程安全，size其实是由<code>_sem</code>来控制</li>
<li><code>_thread</code>：生产者数据发送线程</li>
</ul>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>首先<code>_sem.acquire()</code>，计数器-1，如果不为零，说明队列还可以写入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self._sem.acquire(block, timeout):</span><br><span class="line">    <span class="keyword">raise</span> Full</span><br></pre></td></tr></table></figure>

<p>然后获得<code>_notempty</code>的锁，如果发送线程未创建，则创建。追加元素至buffer后，<code>_notempty.notify()</code>通知发送线程。生产者中数据的发送由单独的线程完成，主线程只负责将数据放入buffer。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> self._notempty: <span class="comment"># acquire保护_notempty和_thread的修改</span></span><br><span class="line">    <span class="keyword">if</span> self._thread <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._start_thread()</span><br><span class="line">    self._buffer.append(obj)</span><br><span class="line">    self._notempty.notify()</span><br></pre></td></tr></table></figure>

<h2 id="feed线程"><a href="#feed线程" class="headerlink" title="feed线程"></a>feed线程</h2><p><code>_start_thread()</code>创建thread对象后，设置<code>daemon</code>属性为<code>True</code>，目的是随主线程的退出而退出，不必手动添加停止的逻辑。接着就启动线程。</p>
<p>具体发送时，不断等待buffer中有元素；如果buffer中有元素，<code>popleft()</code>并发送，直到发送完。</p>
<p>为何<code>_notempty</code>的锁在<code>popleft()</code>就释放了？</p>
<ol>
<li>buffer是<code>collections.deque</code>，本身就是并发安全的</li>
<li><code>_notempty</code>锁的目的其实是为了保护<code>_notempty</code>的修改，和<code>put()</code>中的目的类似，但并不是为了保护buffer<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        nacquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> buffer:</span><br><span class="line">                nwait()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            nrelease()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                obj = bpopleft()</span><br><span class="line">                <span class="keyword">if</span> obj <span class="keyword">is</span> sentinel:</span><br><span class="line">                    debug(<span class="string">&#x27;feeder thread got sentinel -- exiting&#x27;</span>)</span><br><span class="line">                    close()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># serialize the data before acquiring the lock</span></span><br><span class="line">                obj = _ForkingPickler.dumps(obj)</span><br><span class="line">                <span class="keyword">if</span> wacquire <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    send_bytes(obj)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    wacquire()</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        send_bytes(obj)</span><br><span class="line">                    <span class="keyword">finally</span>:</span><br><span class="line">                        wrelease()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># ......</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p><strong>对于<code>block=True</code>的情况</strong><br>类似<code>SimpleQueue</code>，一直等待<code>_reader.recv_bytes()</code>，直到收到数据。在<code>_reader.recv_bytes()</code>以后，<code>_sem.release()</code>，计数器+1，表示从队列消耗了一个元素。此时如果有进程调用<code>_sem.acquire()</code>并在等待，那么<code>_sem.release()</code>会唤醒其中一个等待的进程。</p>
<p><strong>对于<code>block=False</code>的情况</strong><br>由于不能阻塞，因此不能一直等待<code>_reader.recv_bytes()</code>。</p>
<ol>
<li>如果在<code>timeout</code>内<code>_rlock</code>都没有获得锁，则返回<code>Empty</code></li>
<li><code>_reader.poll()</code>（底层还是使用<code>select</code>来实现的）判断是否在<code>timeout</code>内<code>_reader</code>可读，如果不可读，则返回<code>Empty</code></li>
<li>最后<code>_reader.recv_bytes()</code>，并<code>_sem.release()</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, block=<span class="literal">True</span>, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> block <span class="keyword">and</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">with</span> self._rlock:</span><br><span class="line">            res = self._recv_bytes()</span><br><span class="line">        self._sem.release()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> block:</span><br><span class="line">            deadline = time.monotonic() + timeout</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._rlock.acquire(block, timeout):</span><br><span class="line">            <span class="keyword">raise</span> Empty</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> block:</span><br><span class="line">                timeout = deadline - time.monotonic()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self._poll(timeout): <span class="comment"># 此时的timeout已经减去了等待_rlock.acquire的时间</span></span><br><span class="line">                    <span class="keyword">raise</span> Empty</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self._poll():</span><br><span class="line">                <span class="keyword">raise</span> Empty</span><br><span class="line">            res = self._recv_bytes()</span><br><span class="line">            self._sem.release()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._rlock.release()</span><br><span class="line">    <span class="comment"># unserialize the data after having released the lock</span></span><br><span class="line">    <span class="keyword">return</span> _ForkingPickler.loads(res)</span><br></pre></td></tr></table></figure>

<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化和反序列化使用的是pickle来实现，那么如何判断消息的边界？<code>Connection</code>中定义了一个规则，在<code>header</code>存放长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_send_bytes</span>(<span class="params">self, buf</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(buf)</span><br><span class="line">    <span class="comment"># For wire compatibility with 3.2 and lower</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!i&quot;</span>, n)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">16384</span>:</span><br><span class="line">        <span class="comment"># The payload is large so Nagle&#x27;s algorithm won&#x27;t be triggered</span></span><br><span class="line">        <span class="comment"># and we&#x27;d better avoid the cost of concatenation.</span></span><br><span class="line">        self._send(header)</span><br><span class="line">        self._send(buf)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Issue #20540: concatenate before sending, to avoid delays due</span></span><br><span class="line">        <span class="comment"># to Nagle&#x27;s algorithm on a TCP socket.</span></span><br><span class="line">        <span class="comment"># Also note we want to avoid sending a 0-length buffer separately,</span></span><br><span class="line">        <span class="comment"># to avoid &quot;broken pipe&quot; errors if the other end closed the pipe.</span></span><br><span class="line">        self._send(header + buf)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recv_bytes</span>(<span class="params">self, maxsize=<span class="literal">None</span></span>):</span></span><br><span class="line">    buf = self._recv(<span class="number">4</span>)</span><br><span class="line">    size, = struct.unpack(<span class="string">&quot;!i&quot;</span>, buf.getvalue())</span><br><span class="line">    <span class="keyword">if</span> maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> size &gt; maxsize:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> self._recv(size)</span><br></pre></td></tr></table></figure>

<h2 id="close和join-thread"><a href="#close和join-thread" class="headerlink" title="close和join_thread"></a>close和join_thread</h2><p>由于生产者启动了一个线程来负责发送，元素首先append到buffer，然后发送。在进程结束时，如何确保元素发送完毕的问题？</p>
<p>在启动feed线程的时候，创建了两个<code>Finalize</code>对象，<code>_finalize_close</code>和<code>_finalize_join</code>，前者的优先级较高，并set了<code>_close</code>和<code>_jointhread</code>。当进程退出的时候，会自动地先后调用这两个函数（基于<code>atexit</code>实现），</p>
<ol>
<li><code>_finalize_close</code>：会append元素<code>_sentinel = object()</code>到buffer，feed线程如果看到<code>_sentinel</code>，会调用<code>close()</code>并停止服务</li>
<li><code>_finalize_join</code>：join feed线程</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self._joincancelled:</span><br><span class="line">    self._jointhread = Finalize(</span><br><span class="line">        self._thread, Queue._finalize_join,</span><br><span class="line">        [weakref.ref(self._thread)],</span><br><span class="line">        exitpriority=-<span class="number">5</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send sentinel to the thread queue object when garbage collected</span></span><br><span class="line">self._close = Finalize(</span><br><span class="line">    self, Queue._finalize_close,</span><br><span class="line">    [self._buffer, self._notempty],</span><br><span class="line">    exitpriority=<span class="number">10</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>模块同样也提供了<code>close()</code>和<code>join_thread()</code>方法，调用的其实就是<code>_close</code>和<code>_jointhread</code>。如果先手动调用，然后<code>aexit</code>调用，那不会回有问题？首次调用后，都会从<code>util</code>模块的<code>_finalizer_registry</code>中移除，因此不会存在重复调用<code>_finalize_close</code>和<code>_finalize_join</code>的问题。</p>
<h2 id="deadlock"><a href="#deadlock" class="headerlink" title="deadlock"></a>deadlock</h2><p>这几个stackoverflow（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31665328/python-3-multiprocessing-queue-deadlock-when-calling-join-before-the-queue-is-em">1</a>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31708646/process-join-and-queue-dont-work-with-large-numbers">2</a>，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26738648/script-using-multiprocessing-module-does-not-terminate">3</a>）的问题很类似，在官方的文档中也有提及（<a target="_blank" rel="noopener" href="https://docs.python.org/2.7/library/multiprocessing.html#pipes-and-queues">python 2</a>，<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/multiprocessing.html#all-start-methods">python 3</a>），总结下来就是，<em>join一个调用put的进程，且这个进程尚未把buffer中所有的元素写入pipe时</em>，可能会导致死锁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">q</span>):</span></span><br><span class="line">    q.put(<span class="string">&#x27;1&#x27;</span>*<span class="number">10000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(os.getpid())</span><br><span class="line">    q = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">    p = multiprocessing.Process(target=work, args=(q,))</span><br><span class="line"></span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    print(q.get())</span><br></pre></td></tr></table></figure>

<p>原因是，<code>Queue</code>使用了os的pipe来进行数据的传输，而pipe的大小是有限的。如果数据过大，<code>_writer.send_bytes()</code>在写入数据到pipe的时候会阻塞。如果此时join这个子进程，那进程本身已经卡住了，join永远等不到进程结束。</p>
<h1 id="JoinableQueue"><a href="#JoinableQueue" class="headerlink" title="JoinableQueue"></a>JoinableQueue</h1><p><code>JoinableQueue</code>基于<code>Queue</code>实现，覆盖了<code>put()</code>，并新增了，</p>
<ul>
<li><code>task_done()</code>：表示先前放入队列中的元素被取走了，由消费者调用</li>
<li><code>join()</code>：阻塞直到队列中所有元素都被取走</li>
</ul>
<h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p><code>__init__()</code>调用了<code>Queue</code>的初始化函数，并额外初始化了，</p>
<ul>
<li><code>_unfinished_tasks</code>：信号量，表示队列中当前未取走的元素</li>
<li><code>_cond</code>：条件变量，同步<code>join()</code>和<code>task_done()</code></li>
</ul>
<h2 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h2><p>和<code>Queue</code>的<code>put()</code>基本一致。多出来的一点是，每次<code>put()</code>都会对<code>_unfinished_tasks</code>的计数器+1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, obj, block=<span class="literal">True</span>, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">with</span> self._notempty, self._cond:</span><br><span class="line">        <span class="keyword">if</span> self._thread <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._start_thread()</span><br><span class="line">        self._buffer.append(obj)</span><br><span class="line">        self._unfinished_tasks.release()</span><br><span class="line">        self._notempty.notify()</span><br></pre></td></tr></table></figure>

<h2 id="task-done和join"><a href="#task-done和join" class="headerlink" title="task_done和join"></a>task_done和join</h2><p><code>task_done()</code>对<code>_unfinished_tasks</code>的计数器进行-1，如果计数器为0，则通知等待在<code>join()</code>的进程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_done</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self._cond:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._unfinished_tasks.acquire(<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;task_done() called too many times&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self._unfinished_tasks._semlock._is_zero():</span><br><span class="line">            self._cond.notify_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self._cond:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._unfinished_tasks._semlock._is_zero():</span><br><span class="line">            self._cond.wait()</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15720120/python-os-pipe-vs-multiprocessing-pipe">Python os.pipe vs multiprocessing.Pipe</a></li>
<li><a target="_blank" rel="noopener" href="https://laike9m.com/blog/daemon-is-not-daemon-but-what-is-it,97/">Daemon is not daemon, but what is it?</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.dreamfever.me/2019/04/21/python-zhong-de-multiprocess-queue/">Python 中的 multiprocess.Queue</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31665328/python-3-multiprocessing-queue-deadlock-when-calling-join-before-the-queue-is-em">Python 3 Multiprocessing queue deadlock when calling join before the queue is empty</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31708646/process-join-and-queue-dont-work-with-large-numbers">Process.join() and queue don’t work with large numbers</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26738648/script-using-multiprocessing-module-does-not-terminate">Script using multiprocessing module does not terminate</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/multiprocessing.html#all-start-methods">https://docs.python.org/3/library/multiprocessing.html#all-start-methods</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/42350933/joining-multiprocessing-queue-takes-a-long-time">Joining multiprocessing queue takes a long time</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-09-09-python-multiprocessing-process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-09-09-python-multiprocessing-process/" class="post-title-link" itemprop="url">python multiprocessing.Process模块源码阅读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-09-09 15:16:20" itemprop="dateCreated datePublished" datetime="2019-09-09T15:16:20+08:00">2019-09-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-09-09-python-multiprocessing-process/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-09-09-python-multiprocessing-process/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前有记录过<a href="/2018/2018-07-04-python-multiprocessing-communication">python进程间通信</a>的几个方式，现在来看看这个模块的具体的是怎样工作的（本文基于Python 3.7.4）。</p>
<p><code>multiprocessing.Process</code>典型的使用方式为，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;hello&#x27;</span>, name)</span><br><span class="line"></span><br><span class="line">p = multiprocessing.Process(target=f, args=(<span class="string">&#x27;world&#x27;</span>,))</span><br><span class="line">p.start()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>

<p>以这段代码为例，看看进程的执行过程。</p>
<p><img data-src="/images/2019/python%20process.jpg" alt="python process"></p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p><code>import multiprocessing</code>，导入multiprocessing的时候，做了一些初始化的工作。</p>
<ol>
<li>multiprocessing的包导入了<code>context</code>，这个模块主要是判断当前系统类型，并相应地使用对应的实现。在<code>sys.platform != &#39;win32&#39;</code>的系统上，例如：mac和linux，默认使用<code>fork</code>来创建子进程。</li>
<li><code>context</code>模块中，<ul>
<li>导入了<code>process</code></li>
<li>定义了<code>Process</code>类，这个类继承自<code>process.BaseProcess</code>，覆盖了<code>process.BaseProcess</code>的<code>_Popen</code>方法，目的是根据系统类型，在初始化的时候根据系统类型，选择相应的<code>Popen</code>实现</li>
</ul>
</li>
<li><code>process</code>模块中，<ul>
<li>导入了<code>util</code>，注册了<code>_exit_function</code>，被注册的函数会在解释器正常终止时执行（子进程主动调用，主进程自动调用）</li>
<li>此时在父进程里，初始化了几个<code>process</code>模块的全局变量，<ul>
<li><code>_current_process</code>：代表当前进程</li>
<li><code>_process_counter</code>：进程数计数器</li>
<li><code>_children</code>：子进程的集合</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="创建Process实例"><a href="#创建Process实例" class="headerlink" title="创建Process实例"></a>创建<code>Process</code>实例</h2><p><code>p = multiprocessing.Process(target=f, args=(&#39;world&#39;,))</code>，实际上是调用<code>process.BaseProcess</code>的<code>__init__()</code>方法进行初始化，并使用了<code>process</code>模块的全局变量初始化实例变量，以及获取当前进程的pid，</p>
<ul>
<li><code>count = next(_process_counter)</code></li>
<li><code>self._identity = _current_process._identity + (count,)</code></li>
<li><code>self._config = _current_process._config.copy()</code></li>
<li><code>self._parent_pid = os.getpid()</code></li>
</ul>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>p.start()</code>创建子进程，首先做了几个检查，</p>
<ol>
<li>如果已经创建了子进程，那么不能再次创建</li>
<li>只能start由当前进程创建的<code>Process</code>实例</li>
<li>不允许创建daemon进程的子进程</li>
</ol>
<p>接着<code>_children</code>中清理当前已经结束的进程，然后调用<code>self._Popen(self)</code>开始创建子进程。使用<code>os.fork()</code>创建子进程，用法和posix的fork一样，不多说。要注意的一点是，调用<code>os.pipe()</code>创建了<code>parent_r</code>和<code>child_w</code>，而<code>parent_r</code>将会被用于<code>join()</code>的实现。</p>
<p>子进程中，执行<code>_bootstrap()</code>进行初始化和运行<code>target</code>，</p>
<ol>
<li>初始化了<code>process</code>模块的全局变量，<code>_current_process</code>、<code>_process_counter</code>、<code>_children</code></li>
<li>清空<code>util._finalizer_registry</code>，执行<code>util._run_after_forkers()</code></li>
<li><code>run()</code>运行<code>target</code></li>
<li><code>util._exit_function()</code>做进程结束后的收尾工作<ul>
<li><code>util._exit_function()</code>会调用<code>_run_finalizers()</code>，这个函数会把优先级高于<code>minpriority</code>的<code>finalizer</code>执行一遍  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_finalizers</span>(<span class="params">minpriority=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Run all finalizers whose exit priority is not None and at least minpriority</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Finalizers with highest priority are called first; finalizers with</span></span><br><span class="line"><span class="string">    the same priority will be called in reverse order of creation.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>默认情况下子进程的<code>_finalizer_registry</code>是空的，没有任何的<code>finalizer</code>会被执行，但可以通过<code>multiprocessing.util.Finalize</code>手动的进行注册，来完成一些收尾工作，例如：关闭db连接。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Finalize</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Class which supports object finalization using weakrefs</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj, callback, args=(<span class="params"></span>), kwargs=<span class="literal">None</span>, exitpriority=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">        _finalizer_registry[self._key] = self</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>创建子进程的时候，也创建了pipe <code>parent_r</code>，并set <code>self.sentinel = parent_r</code>，且关闭了<code>child_w</code>。此时唯一打开<code>child_w</code>的进程是子进程，唯一打开<code>parent_r</code>的是主进程。主进程调用<code>join()</code>时，实际上是等待<code>parent_r</code>变为可读状态（<code>wait</code>返回）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.connection <span class="keyword">import</span> wait</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> wait([self.sentinel], timeout):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>那么何时<code>wait</code>返回？<code>wait</code>循环调用<code>select</code>，当<code>parent_r</code> ready的时候，wait返回，</p>
<ul>
<li><code>parent_r</code>可读</li>
<li>所有writing side被关闭</li>
</ul>
<p>当子进程结束的时候，os会关闭这个进程关联的所有fd，又因为主进程已经关闭了<code>child_w</code>，所以此时<code>parent_r</code> ready，主进程中的<code>join()</code>也就返回了。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing — Process-based parallelism</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19265191/why-should-you-close-a-pipe-in-linux">Why should you close a pipe in linux?</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-08-28-notes-of-raft-refloated/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-08-28-notes-of-raft-refloated/" class="post-title-link" itemprop="url">Raft Refloated Do We Have Consensus?笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-08-28 16:32:52" itemprop="dateCreated datePublished" datetime="2019-08-28T16:32:52+08:00">2019-08-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/distritubed-system/" itemprop="url" rel="index"><span itemprop="name">distritubed system</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-08-28-notes-of-raft-refloated/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-08-28-notes-of-raft-refloated/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>文章主要使用实验验证了raft是否如原论文所阐述的易于理解和实现。重新阐述了raft，使用OCaml实现了raft，开发了一个事件驱动的模拟器来进行测试，重现了raft原论文中的测试，并提出了几个优化。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>对于raft的性能，raft原论文中提到了两点，</p>
<ol>
<li>典型的情况下，leader复制entry的时间。</li>
<li>最坏情况下，leader失败后，选举出新leader的时间。<ol>
<li>选举能否快速收敛？</li>
<li>集群能达到的最小下线时间是什么？</li>
</ol>
</li>
</ol>
<h2 id="典型的情况下，leader复制entry的时间"><a href="#典型的情况下，leader复制entry的时间" class="headerlink" title="典型的情况下，leader复制entry的时间"></a>典型的情况下，leader复制entry的时间</h2><p>需要耗费一个rtt来复制到多数派server，可以做batching和piplining优化。</p>
<h2 id="最坏情况下，leader失败后，选举出新leader的时间"><a href="#最坏情况下，leader失败后，选举出新leader的时间" class="headerlink" title="最坏情况下，leader失败后，选举出新leader的时间"></a>最坏情况下，leader失败后，选举出新leader的时间</h2><p>关于这点，raft原论文中使用5个server的集群做了两个测试。为了模拟最坏情况，</p>
<ul>
<li>每次测试server都有不一样长度的log，使得有的candidate不能成为leader。</li>
<li>为了制造易于出现split vote的环境，在每次终止leader前，都同步地广播heartbeat，目的是重置election timeout。</li>
</ul>
<p><img data-src="/images/2019/15674125053563.jpg" alt="-w302"></p>
<p>两个测试表明了：</p>
<ol>
<li>election time中加入少量的随机，能够明显的减少选举新leader的时间，减少split vote的出现。</li>
<li>集群的最小下线时间随着election time的减少而减少，但如果少于broadcast time，那么会集群产生不必要选举，降低可用性。</li>
</ol>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>本文中提出了几个优化，</p>
<ol>
<li>Different Follower and Candidate Timers</li>
<li>Binary Exponential Backoff</li>
<li>Combined</li>
</ol>
<p><img data-src="/images/2019/15674141041720.jpg" alt="-w293"></p>
<h2 id="Different-Follower-and-Candidate-Timers"><a href="#Different-Follower-and-Candidate-Timers" class="headerlink" title="Different Follower and Candidate Timers"></a>Different Follower and Candidate Timers</h2><p>raft原论文建议$\textit{candidate timeout} = \textit{follower timeout} ∼ U(T, 2T), T=150ms$，但在高竞争的情况下，例如：$U(150ms, 151ms)$，将两个时间设置在不同的范围，可以大大减少选举leader的时间。</p>
<h2 id="Binary-Exponential-Backoff"><a href="#Binary-Exponential-Backoff" class="headerlink" title="Binary Exponential Backoff"></a>Binary Exponential Backoff</h2><p>类似tcp超时重传的指数回退。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-08-19-6.824-Spring-2018-Lecture-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-08-19-6.824-Spring-2018-Lecture-6/" class="post-title-link" itemprop="url">6.824 2018 Lecture 6 Fault Tolerance Raft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-08-19 19:56:05" itemprop="dateCreated datePublished" datetime="2019-08-19T19:56:05+08:00">2019-08-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/distritubed-system/" itemprop="url" rel="index"><span itemprop="name">distritubed system</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-08-19-6.824-Spring-2018-Lecture-6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-08-19-6.824-Spring-2018-Lecture-6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-Section-6-to-end-论文"><a href="#Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-Section-6-to-end-论文" class="headerlink" title="Readings - In Search of an Understandable Consensus Algorithm (Extended Version) (Section 6 to end)论文"></a>Readings - In Search of an Understandable Consensus Algorithm (Extended Version) (Section 6 to end)论文</h1><h2 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h2><p>实际应用中，常常会有配置变更的需求，即：成员变更。手动的方式有下面两种，</p>
<ul>
<li>把集群整体下线，配置修改完毕以后再上线是可行的，但会造成服务不可用。</li>
<li>新server可以通过获取其ip来替换集群成员，需要保证被替换的server不会再加入集群。</li>
</ul>
<p>但这两个方式都有明显的弊端，且任何手动的步骤都有引起错误的可能。</p>
<p>配置切换需要保证安全性，在同一个term内，集群不能够同时存在两个leader。由于无法一次性原子的切换所有server的配置，一次增减多个server并直接切换配置可能会出现disjoint majorities的情况。</p>
<p>raft变更的方案有两种：</p>
<ol>
<li>single-server change</li>
<li>使用joint consensus</li>
</ol>
<h3 id="single-server-change"><a href="#single-server-change" class="headerlink" title="single-server change"></a>single-server change</h3><p>每次增减一个server。</p>
<p><strong>配置的变更</strong><br>具体变更过程如下，</p>
<ol>
<li>leader收到变更请求，AppendEntries RPC按新配置发送$C_{new}$。</li>
<li>每个server收到$C_{new}$后<em>立即生效</em>。</li>
<li>新配置下，$C_{new}$复制到大多数server，则达成committed。<ul>
<li>此时，就算有剩下的server未得到新配置，也不会构成多数派，</li>
<li>且，未得到新配置的server也不被选举为leader。</li>
</ul>
</li>
</ol>
<p>$C_{new}$提交后，</p>
<ol>
<li>leader可以响应client，告知本次配置变更已经完成。</li>
<li>如果配置是移除一个server，那么这个server可以下线了。</li>
<li>可以开始下一次配置更新。</li>
</ol>
<p><strong>安全性</strong><br><img data-src="/images/2019/15662026435774.jpg" alt="-w543"></p>
<p>总共有四种情况：</p>
<table>
<thead>
<tr>
<th></th>
<th>member change</th>
<th>变更后达成disjoint majorities的条件</th>
</tr>
</thead>
<tbody><tr>
<td>奇数个成员，增加一个</td>
<td>2k+1 -&gt; 2k+2</td>
<td>old = k+1, new = k+2</td>
</tr>
<tr>
<td>奇数个成员，减少一个</td>
<td>2k+1 -&gt; 2k</td>
<td>old = k+1, new = k+1</td>
</tr>
<tr>
<td>偶数个成员，增加一个</td>
<td>2k -&gt; 2k+1</td>
<td>old = k+1, new = k+1</td>
</tr>
<tr>
<td>偶数个成员，减少一个</td>
<td>2k -&gt; 2k-1</td>
<td>old = k+1, new = k</td>
</tr>
</tbody></table>
<p>任意一种情况对应的条件都是不可能<em>同时</em>达成的，因为要求的成员数目都大于真正的成员数目，不会产生同一个term两个leader的现象。换句话说，旧配置集群与新配置集群的<em>任意多数派必然有交集</em>，即：至少存在一个voter（接受旧leader的$C_{new}$，并且为新leader投票），不会出现disjoint majorities。</p>
<p>因此增减一个server情况，直接切换配置是安全的。</p>
<p>这个交集也保证了在变更配置的过程中，在$C_{old}$中、以及变更期间复制的日志，最后一定会出现在$C_{new}$。</p>
<p><strong>何时开始下一次变更</strong><br>能够开始下一次配置更新的<em>前提是当前的配置已经commit</em>，否则无法保证安全性。如果server在$C_{new}$commit以后才使用$C_{new}$，会带来很多不必要的、额外的维护工作，</p>
<ol>
<li>leader很难知道旧配置集群的多数派使用$C_{new}$的时间。</li>
<li>需要跟踪哪些server知道了commit，且做持久化。但这些是raft本身不具备的功能。</li>
<li>如果leader改变了，那么需要移除$C_{new}$的entry，此时，server还需要准备回滚到上一个配置。</li>
</ol>
<p><strong>majority的是对谁而言的</strong><br>对于选举和append entry，都是仅由<em>调用方</em>来判断是否达成多数派，接收方不负责，否则会存在类似“鸡生蛋蛋生鸡”的问题。</p>
<p><strong>可用性</strong><br>配置变更给保证集群的可用性带来了几个问题。</p>
<ol>
<li><p>Catching up new servers<br> <img data-src="/images/2019/15662894360490.jpg" alt="-w517"></p>
<p> 一个新server加入集群，新server通常并不包含任何entry，那么可能需要花费较长的时间来同步日志。在这段时间，集群更容易出现不可用的问题。例如：3-&gt;4，此时要求的majority是3，但是s3挂了。</p>
<p> 为了最小化不可用的出现，需要<em>保证不可用的时间在一次election timeout内</em>。</p>
<p> <img data-src="/images/2019/15662902585664.jpg" alt="-w530"></p>
<p> 具体方法是，</p>
<ul>
<li>新加入的server先作为non-voting成员。</li>
<li>复制到新server的过程分为多个round，每个round都复制leader所有的entry。</li>
<li>当前复制的round内，leader可能又有新的entry了，下一个round会进行复制。</li>
<li>在固定round内（例如：10），如果最后一个round的时间 &lt; election timeout，此时假设不存在更多的entry会导致明显的不可用，添加新server。</li>
<li>否则leader终止变更配置。</li>
</ul>
</li>
<li><p>Removing the current leader<br> 如果使用joint Consensus，或没有leadership transfer的情况下，需要一个leader下线的方法：旧leader等到$C_{new}$ commit以后让位（转变为follower状态）。</p>
<p> 在commit之前，当前leader管理集群不包含leader自己，复制和投票的时候不把自己算入majority。</p>
</li>
<li><p>Disruptive servers<br> 被排除在$C_{new}$之外的server，由于不再收到heartbeat，会不断的发起投票。虽然新选出的leader始终会出现在$C_{new}$中，但是这干扰了集群正常的工作。</p>
<p> 第一个思路是引入一个Pre-Vote阶段，在发起选举前，检查自己是否有成为leader的资格，即：candidate的log比大多数server更新。但并不总是有效。例如：{ABCD}-&gt;{ABC}的时候，A是Leader，在尝试复制$C_{new}$到BC的时候，D可能发起了Pre-Vote，D的log相对于BC足够新，可以获得BC的投票成为leader。因此检查log的方式是不可行的。</p>
<p> raft使用的方式是，如果一个server获得上一次heartbeat的时间在最小election timeout内，这个server收到RequestVote时就不更新term或投票。</p>
<p> 如果确实需要发起选举，例如：进行leadership transfer的时候，可以用一个标志位来区分。</p>
</li>
</ol>
<p><strong>bug in single-server change</strong><br>如果配置变更是在同一个term内完成的，那么不会有问题。但如果出现在跨term且并发的配置变更，就不一定了。</p>
<p>例如先后增减一个server，具体过程如下，<br><img data-src="/images/2019/15663835361828.jpg" alt="-w630"></p>
<p>2中，s1把D复制到s1和s5然后挂了，接着s2接受s2、s3、s4的投票（使用C判断majority）成为term2的leader。5中，s2把E复制到s2和s3，并标记为committed（使用E判断majority）。然后s1恢复，接受s1、s4、s5的投票（使用D判断majority）成为term3的leader，继续复制D，最后在7中覆盖已提交的E。</p>
<p>这个问题类似<a href="/2019/2019-07-15-6.824-Spring-2018-Lecture-5/#%E5%AE%89%E5%85%A8%EF%BC%88Safety%EF%BC%89">提交上一个term的entry</a>，解决方法是一样的，<em>leader当选以后，直到当前term的entry提交以后，才能开始下一次配置变更</em>。可以通过append一个no-op entry来实现。</p>
<p>原文的single-server change保证了，在同一个term内不会出现未提交的configuration entry。这个patch保证了，来自先前term未提交的configuration entry永远不会被提交。</p>
<p>回到前面的例子，3中s2成为term2的leader以后立即append no-op entry，此时使用C判断majority，假设复制到s2、s3、s4的index 2。接着s2继续把E复制到s2和s3。如果接下来s1恢复并发生了选举，s1不可能成为leader，因而避免了已提交的E被覆盖的情况。</p>
<h3 id="使用joint-consensus"><a href="#使用joint-consensus" class="headerlink" title="使用joint consensus"></a>使用joint consensus</h3><p>这个方法并不建议在工程中使用，更简单的single-server change足以将集群变更为任何期望的配置。</p>
<p><img data-src="/images/2019/15663598511958.jpg" alt="-w344"></p>
<p><strong>joint consensus</strong><br>joint consensus状态混合了新旧配置，允许每个server在不同的时间安全地切换配置，且在这个过程中能持续提供服务，这个状态中，</p>
<ul>
<li>entry会被复制到所有新旧配置。</li>
<li>来自任何配置的机器都可以被选举为leader。</li>
<li>选举和append的majority，需要分别来自新旧配置。</li>
</ul>
<p>相比single-server change，joint consensus引入了一个中间的entry $C_{old,new}$，具体过程是，</p>
<ol>
<li>将新旧配置存储到$C_{old,new}$，并复制，进入joint consensus状态。</li>
<li>每个server收到$C_{old,new}$后<em>立即生效</em>，leader使用$C_{old,new}$来判断是否提交。<br> $C_{old,new}$复制的过程中，如果leader挂了，那么新的leader可能在$C_{old,new}$或$C_{old}$中选举出。无论leader来自哪个配置，$C_{new}$不能单方进行决策。</li>
<li>$C_{old,new}$提交后，leader可以复制$C_{new}$。<br> 一旦$C_{old,new}$提交，$C_{new}$或$C_{old}$都不能单方进行决策。</li>
<li>leader使用$C_{new}$来判断是否提交，提交后，完成配置变更。</li>
</ol>
<p><strong>安全性</strong><br>在joint consensus过程中，发生选举时，可能从以下情况选出leader（按joint consensus的步骤顺序列举），</p>
<ol>
<li>来自$C_{old}$，log不包含$C_{old,new}$。</li>
<li>来自$C_{old}$，log包含$C_{old,new}$。</li>
<li>来自$C_{new}$，log包含$C_{old,new}$。</li>
<li>来自$C_{new}$，log包含$C_{new}$。</li>
</ol>
<p>而任何两个leader的组合都是不可能同时出现的。</p>
<table>
<thead>
<tr>
<th>leader组合</th>
<th>不可能出现的原因</th>
</tr>
</thead>
<tbody><tr>
<td>1+1 or 4+4</td>
<td>选举规则限制</td>
</tr>
<tr>
<td>1+2</td>
<td>先看2的选举，需要分别来自新旧配置的多数派，此时已经不能再从$C_{old}$中选举1</td>
</tr>
<tr>
<td>1+3</td>
<td>类似1+2</td>
</tr>
<tr>
<td>1+4</td>
<td>a. 先看4，既然$C_{new}$出现了，那么$C_{old,new}$肯定提交了，这个提交需要分别来自新旧配置的多数派，因此$C_{old}$中不包含$C_{old,new}$的server无法选举为leader</br>b. $C_{new}$是在$C_{old,new}$提交后才复制，如果选举出4，1就不会存在</td>
</tr>
<tr>
<td>2+2</td>
<td>类似1+2</td>
</tr>
<tr>
<td>2+3</td>
<td>类似1+2</td>
</tr>
<tr>
<td>2+4</td>
<td>类似1+2</td>
</tr>
<tr>
<td>3+3</td>
<td>类似1+2</td>
</tr>
<tr>
<td>3+4</td>
<td>类似1+2</td>
</tr>
</tbody></table>
<p>因此不会出现disjoint majorities的情况。</p>
<p><strong>是否受single-server change的bug影响</strong><br>不受。</p>
<h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>raft的日志随着客户端不断的请求增长。一旦entry已经提交并执行，那么中间的状态和操作就不再需要，可以被压缩。</p>
<p>文章讨论了几种进行日志压缩的方法，</p>
<ul>
<li>Snapshotting memory-based state machines</li>
<li>Snapshotting disk-based state machines</li>
<li>Incremental cleaning approaches</li>
<li>Leader-based approaches</li>
</ul>
<p>这几个方法有一些核心概念基本都是相通的，</p>
<ol>
<li>每个server独立的负责日志压缩，而非由leader集中决定。</li>
<li>raft向状态机转移维护prefix of the log的职责。</li>
<li>raft丢弃部分日志前缀a prefix of the log后，状态机会承担两个新的职责<ol>
<li>如果server重启，状态机在apply entry前，需要先load那些被丢弃的日志。</li>
<li>为了落后较多的server或新server能够追上，状态机可能需要输出一个状态的镜像。</li>
</ol>
</li>
</ol>
<h3 id="Snapshotting-memory-based-state-machines"><a href="#Snapshotting-memory-based-state-machines" class="headerlink" title="Snapshotting memory-based state machines"></a>Snapshotting memory-based state machines</h3><p>适用于状态机的数据是存放在内存的情况。每个server独立的创建已经提交entry的snapshot。主要过程是，</p>
<ul>
<li>状态机序列化当前状态。</li>
<li>一旦状态机完成snapshot的写入以后，日志就可以被截断了，raft首先保存snapshot中lastIncludedIndex和lastIncludedTerm，以及这个index对应的lastIncludedConf。</li>
<li>raft可以丢弃截止index的entry和先前的snapshot。</li>
</ul>
<p><img data-src="/images/2019/15663712160542.jpg" alt="-w318"></p>
<p><strong>InstallSnapshot</strong><br>为了落后较多的server或新server能够追上，这个方法里使用InstallSnapshot来实现。leader仅当丢弃了需要复制的next entry的时候，才发送snapshot，snapshot以chunks的形式有序发送。</p>
<p><strong>并发创建</strong><br>创建snapshot时，状态机需要维持一个不变的状态，但进行序列化和落盘需要较长的时间，因此创建的过程需要与普通操作并发执行。可以使用copy-on-write实现，有两种方法，</p>
<ol>
<li>状态机使用不可变数据结构。</li>
<li>依赖os的copy-on-write支持，例如：linux的fork。</li>
</ol>
<p>copy-on-write占用额外的内存，在创建的过程中，占用的额外内存与状态的修改成正相关，因此需要事先计划和管理。如果在snapshot的过程中，内存满了，那么server只能暂停服务，此时集群可能还是可用的。最好不要终止稍后重试，下次创建的时候很可能还会有类似的问题。</p>
<p><strong>何时创建</strong><br>如果创建的过于频繁，会浪费磁盘带宽和其他资源，如果过于稀少，会导致创建出过大的snapshot，增加传输和回放的时间。</p>
<p>有这么几个判断的方法，</p>
<ul>
<li>如果size(log)明显大于一个预定的值。<br>  当这个值明显大于snapshot的大小时，磁盘写入开销会很小。但对于较小的状态机，需要等待较长的时间才会有满足大小要求的log。</li>
<li>如果size(log)大于size(snapshot)的倍数。<br>  不过判断当前状态机的snapshot大小并不容易。</li>
<li>如果size(log)大于size(prev snapshot)的倍数，expansion factor。<br>  expansion factor控制了磁盘带宽的开销。</li>
</ul>
<p>还可以仅在少数派server上创建snapshot，不影响服务client。</p>
<h2 id="Client交互"><a href="#Client交互" class="headerlink" title="Client交互"></a>Client交互</h2><h3 id="查找cluster"><a href="#查找cluster" class="headerlink" title="查找cluster"></a>查找cluster</h3><p>如果配置固定，这个过程很简单。难点在于成员不断变更的情况，可用的方法有，</p>
<ul>
<li>广播，但受限于特定的网络环境。</li>
<li>使用外部的目录服务，例如：DNS。需要在变更的过程中增减相应的server。</li>
</ul>
<h3 id="路由请求到leader"><a href="#路由请求到leader" class="headerlink" title="路由请求到leader"></a>路由请求到leader</h3><p>client的请求是由leader处理的，因此client需要找到leader，可以随机的选取一个server发起请求，如果不是leader，server拒绝，client重试直到找到为止，尝试次数期望是$(n+1)/2$。在此基础上可以做一些优化，</p>
<ul>
<li>server拒绝的时候返回leader。</li>
<li>server做代理，转发请求到leader。</li>
</ul>
<p>还需要避免过期的leader信息导致处理client请求的时候产生不必要的延迟，</p>
<ul>
<li>leader：如果产生网络分区，且client向拥有少数派的leader发送了请求，在分区恢复前，这个请求一直都无法得到处理。因此当<em>超过election timeout以后，leader都没有向多数派成功的发送心跳，那么leader让位</em>。</li>
<li>follower：如果follower发起新的选举或者term变更，那么follower丢弃当前维护的leader信息。</li>
<li>client：当丢失与某个server的连接，应该随机选取一个server进行重试。</li>
</ul>
<h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>截止目前，raft提供了at-least-once的语义。client重试、以及网络导致请求重复会导致命令被执行多次。但是at-least-once对于一个基于共识的系统是不够的，raft需要<em>可线性化的语义</em>，通过对请求去重，可以实现这一点。</p>
<p><strong>使用session去重</strong><br>每个client分配一个唯一id，每个请求分配一个唯一的递增序号。server维护每个client的session，这个session跟踪了每个client的最新序号和对应的response，如果收到了一个已经处理过的序号，那么直接返回。</p>
<p>这样每个命令就做到了以log中第一次出现的顺序立即生效且只执行一次。</p>
<p>对于来自同一个client的并发请求，server维护一个&lt;序号，response&gt;的集合。每个请求中携带一个client未收到的最小序号，server丢弃小于这个序号的response。</p>
<p><strong>session保存的多久</strong><br>受存储的限制，session不能永久保存，server需要对何时过期session达成共识。</p>
<ul>
<li>一个方法是设置存储session数的上限，并使用lru淘汰session。</li>
<li>另一个方法是基于对时间源达成的共识来淘汰session（原文中的描述不是非常清晰，待补充）。</li>
</ul>
<p><strong>处理session过期的client请求</strong><br>当session过期后，client还继续操作时，这被看做异常情况（待补充）。</p>
<h3 id="更高效的处理read-only请求"><a href="#更高效的处理read-only请求" class="headerlink" title="更高效的处理read-only请求"></a>更高效的处理read-only请求</h3><p>raft日志的目的是以相同的顺序把变更复制到server上，并保证读写时候的线性一致性语义。read-only命令只涉及查询状态机，可以绕开日志的复制，避免同步磁盘写入，会大大的提升性能。但如果没有额外的控制，client会读取到过期的值。</p>
<p>为了使得绕开raft日志的read-only请求保持线性一致性，针对每次read-only请求，leader需要，</p>
<ol>
<li>如果当前term还没有提交过entry，等待直到有。如果是刚成为leader，则需要先提交一个no-op entry。</li>
<li>leader将当前的commit index记录到本地变量<em>readIndex</em>，这个会作为read-only操作的下界。</li>
<li>leader需要自己的身份是有效的，不存在在自己不知情的情况下（网络分区）选举出了新的leader。这里的方法与<a href="#%E8%B7%AF%E7%94%B1%E8%AF%B7%E6%B1%82%E5%88%B0leader">路由请求到leader</a>中避免过期的leader类似，如果成功向多数派发送了heartbeat，那么leader可以知道在发送heartbeat的时候，身份仍然是有效的。</li>
<li>leader等待lastApplied &gt;= readIndex，此时的readIndex是<em>能保证线性一致性的最小index</em>。</li>
<li>leader向自己的状态机发起查询请求，并返回结果。</li>
</ol>
<p><strong>优化leadership确认</strong><br>每次查询请求都需要执行3，可以把所有累计的查询通过一次heartbeat来确认leadership。</p>
<p><strong>follower分担read-only负载</strong><br>同样需要保证不读取到过期的数据，保证线性一致性。为此follower可以向leader发送一个<em>查询当前readIndex的请求</em>，然后leader执行上面的1-3，follower执行4-5。</p>
<p><strong>使用时钟减少heartbeat带来的延迟</strong><br>虽然有batch优化，read-only查询仍然需要做一次heartbeat来确认leadership，可以用时钟来避免heartbeat带来的延迟。</p>
<p><img data-src="/images/2019/15668148723093.jpg" alt="-w262"></p>
<ul>
<li>leader使用heartbeat来维持一个lease，如果leader成功向多数派发送了heartbeat，那么leader可以认为在接下来的election time时间内都不会有新的leader产生，这个lease可以扩展到$start+\frac{\textit{election timeout}}{\textit{clock drift bound}}$，在这个时间之前都不用执行上面的步骤3。</li>
<li>在进行leadership transfer的时候需要将lease主动过期，因为会导致更早的产生新leader。</li>
</ul>
<p><em>要注意的是</em>，使用lease的方式假设了server之间时钟漂移的上界（在给定的一段时间内，没有server的时钟增加的时间会超过这个上界），找到并维护这个值会增加额外的运维成本。如果假设失效了，系统可能会返回任意过期的信息。</p>
<p>可以使用一个的扩展来增强对client提供的保证，<em>即使上述假设失效的情况下，读操作满足线性一致性</em>，不至于错的离谱。具体方法是，</p>
<ol>
<li>server返回client的时候，带上状态机状态对应的index。</li>
<li>client跟踪自己看到的与结果对应的最新index，发送请求的时候带上这个index。</li>
<li>如果server收到的index &gt; lastApplied，那么server暂时不处理这次请求。</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>创建snapshot的时候，有什么限制？<ul>
<li>不能丢弃未提交的和未执行的</li>
<li>已执行的entry可能需要用于使其他server更新</li>
</ul>
</li>
<li>snapshot和log的关系？<br> snapshot反映的是已经执行的log。</li>
<li>server持久化了哪些数据在磁盘上？<ul>
<li>截止到某个entry的snapshot + 后续的log = server完整的log。</li>
<li>其他状态信息，如：currentTerm，votedFor等。</li>
</ul>
</li>
<li>如果某个follower落后了，同时leader丢弃了follower的所需的log，怎么办？<br>  nextIndex将无法会退到那个entry，leader会使用InstallSnapshot RPC。</li>
<li>leader何时会向落后follower发送InstallSnapshot RPC？<br> 上面的问题即为答案。</li>
<li>为何leader不仅仅丢弃所有follower都有的entry？<ul>
<li>每个server是独立创建snapshot的。</li>
<li>少数落后或失败的follower会导致leader log的持续增加。</li>
</ul>
</li>
<li>snapshot包含什么信息？<ul>
<li>term</li>
<li>lastIncludedIndex</li>
<li>lastIncludedTerm of lastIncludedIndex</li>
<li>lastIncludedConf at lastIncludedIndex</li>
<li>snapshot data</li>
</ul>
</li>
<li>follower InstallSnapshot RPC的流程是什么？<ul>
<li>检查term</li>
<li>检查是否已包含lastIncludedIndex/lastIncludedTerm</li>
<li>set lastApplied = lastIncludedIndex，写入data</li>
<li>使用snapshot重置状态机</li>
</ul>
</li>
<li>server收到InstallSnapshot RPC以后，有没有可能会导致状态机的状态回退？<br> 不会。follower会检查是否已经包含lastIncludedIndex/lastIncludedTerm。</li>
<li>为什么在处理read-only请求的时候需要提交一个no-op entry？<br>问题类似于<a href="/2019/2019-07-15-6.824-Spring-2018-Lecture-5/#%E5%AE%89%E5%85%A8%EF%BC%88Safety%EF%BC%89">提交上一个term的entry</a>，新leader并不知道先前term的entry是否已提交。需要append一个no-op entry，如果成功提交，那么表示在此之前的所有entry都是已提交了的。</li>
<li>配置变更时，从集群移除的server如果发起选举，会[影响集群的可用性](#single-server change)，为何不直接把离开集群的server关闭？<br>$C_{new}$不会复制到那些离开集群的server，因此无法做到$C_{new}$提交以后，就立即下线这些server。在关闭前的这段时间里，这些server可能会影响集群的可用性。</li>
<li>joint consensus过程中，选举和提交需要同时获得新旧配置的多数派，这对性能的影响有多大？<ul>
<li>在大多数不发生错误的情况下，获得新旧配置的多数派应该是一个比较快的过程。</li>
<li>获得新旧配置的多数派仍然会比普通的commit要慢，但考虑到配置变更并不经常发生，所以这个代价可以忍。</li>
</ul>
</li>
<li>joint consensus过程中，选举和提交需要同时获得新旧配置的多数派是否是必须的？<br>是，这是为了确保安全性所必须的。在joint consensus关于[安全性的讨论中](#使用joint consensus)，列举了如果leader失败，发生选取时的情况，除特殊的两个外，获得新旧配置多数派的要求<em>避免了disjoint majority出现</em>。</li>
<li>配置变更时，新server是作为non-voting成员加入的，这个要求为何可以提升可用性？<br>当$C_{old,new}$提交以后，集群才可以继续处理请求。而$C_{old,new}$的提交需要新配置的多数派复制成功，空server会拖慢达这个过程。</li>
<li>离开集群的server发起投票会影响集群的可用性，为何不直接使用当前配置来判断，看发起请求的server是否在配置中？</li>
<li>joint consensus的起止时刻是什么？<ul>
<li>开始：leader append $C_{old,new}$。</li>
<li>终止：<ul>
<li>leader未成功提交$C_{old,new}$就挂了。</li>
<li>leader成功提交$C_{new}$。</li>
</ul>
</li>
</ul>
</li>
<li>配置的entry是否可能被后续leader覆盖？<br>可能。如果前任leader未成功提交$C_{old,new}$就挂了。</li>
<li>如果log和创建的snapshot大小差别不大，那snapshot是否还有用（例如：k/v server大量插入新key）？<br>有。<ul>
<li>避免raft log entry一直占用内存。</li>
<li>恢复服务时，使用snapshot可能会比直接使用log能更快（比如snapshot数据的组织方式更好）。</li>
</ul>
</li>
<li>InstallSnapshot会占用带宽不？<br>会，如果状态很大的话。可以用一些方式来减少InstallSnapshot RPC的调用，<ul>
<li>考虑让leader保留更久的log，来应对follower的lag或暂时的下线。</li>
<li>只发送两个server diff的部分。</li>
</ul>
</li>
<li>follower的entry是否有可能不在收到的snapshot里面？<br>有可能，例如：leader尚未提交的entry。</li>
<li>InstallSnapshot是否是原子的？如果在InstallSnapshot执行途中，follower挂了，重发InstallSnapshot是否ok？<br>是原子的、幂等的。</li>
</ol>
<h1 id="Lecture"><a href="#Lecture" class="headerlink" title="Lecture"></a>Lecture</h1><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>raft牺牲了性能来换取简洁的设计：</p>
<ol>
<li>follower拒绝乱序的append，不允许日志有空洞。</li>
<li>尚未支持batch或pipeline方式的append。</li>
<li>对于大的状态，snapshot比较浪费。</li>
<li>慢leader会影响系统的性能。</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a target="_blank" rel="noopener" href="http://loopjump.com/raft_one_server_reconfiguration/">Raft One-Server成员变更</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30706032">一文看尽 Raft 一致性协议的关键点</a></li>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/ongardie/a11f32b70581e20d6bcd">ongardie/raft-single-server-changes-safety</a></li>
<li><a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!topic/raft-dev/t4xj6dJTP6E">bug in single-server membership changes</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/peterbourgon/raft/blob/master/JOINT-CONSENSUS.md">raft/JOINT-CONSENSUS.md</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-08-16-ddia-chapter1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-08-16-ddia-chapter1/" class="post-title-link" itemprop="url">DDIA 第一章 可靠、可扩展、可维护的应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-08-16 00:22:53" itemprop="dateCreated datePublished" datetime="2019-08-16T00:22:53+08:00">2019-08-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/distritubed-system/" itemprop="url" rel="index"><span itemprop="name">distritubed system</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-08-16-ddia-chapter1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-08-16-ddia-chapter1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据密集型应用"><a href="#数据密集型应用" class="headerlink" title="数据密集型应用"></a>数据密集型应用</h1><p>现在的很多应用是<em>数据密集型</em>的，数据是这些应用的主要挑战-数据的总量、数据的复杂度和数据变化的速度。</p>
<p>很多数据密集型的应用都是基于已有的数据系统提供的常用功能来构建的。例如：</p>
<ul>
<li>存储数据，以便自己或其他应用能够找到（基于数据库实现此功能）</li>
<li>记住一个昂贵操作的结果，来加速读取（缓存）</li>
<li>允许用户通过关键词搜索数据，或多种方式过滤数据（搜索索引）</li>
<li>发送消息到另一个进程进行异步处理（流式处理）</li>
<li>定时处理大量累积的数据（批处理）</li>
</ul>
<p>由于数据系统的抽象，这些功能都看似很简单。但是，数据系统在逐渐变得相似，不同的数据系统可能同时具有多种特性，例如：Redis的cache和消息队列功能；应用程序越来越宽泛的需求使得单一数据系统无法完成，需要使用程序代码来组合不同的数据系统；同一需求，可能有多种方式和数据系统来实现。因此选择合适的数据系统和权衡架构的设计是一个值得思考的问题。</p>
<h1 id="设计数据系统的原则"><a href="#设计数据系统的原则" class="headerlink" title="设计数据系统的原则"></a>设计数据系统的原则</h1><ul>
<li>可靠性（Reliability）<br>  就算出现问题的时候（硬件或软件错误，人为错误），系统都应该应该持续的正确工作（在期望的水平上提供正确的功能）。</li>
<li>可扩展性（Scalability）<br>  随着系统的增长（数据量、流量或数据复杂度），应该有合理的方法来应对这些增长。</li>
<li>可维护性（Maintainability）<br>  随着时间的推移，许多人都会参与系统相关的工作（开发和运维，他们保证系统现有行为正常、并使系统能够应对新的情况），他们应该高效的工作。</li>
</ul>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>系统具有容错性（fault-tolerant或resilient）。系统在遇到<strong>特定错误的时候</strong>，也能按预期正常工作。</p>
<blockquote>
<p>这里原文特别区别了fault和failure。fault指的是系统组件的运作偏离了预期，而failure指的是系统整体无法提供服务。设计一个完全没有fault的系统是不可能的，但是可以通过设计fault-tolerant机制来避免fault导致failure。<br>下面，failure会写为系统故障。</p>
</blockquote>
<p><strong>硬件故障</strong><br>每个硬件都有预期的寿命，系统使用的硬件规模够大、运行时间够长时，硬件总会出故障。</p>
<p>通过软件和硬件层面冗余的方式，可以避免出现硬件故障时无法提供服务。</p>
<p><strong>软件错误</strong><br>硬件错误的发生相对独立，但是软件错误更加难以预期，往往会导致很多的系统错误。</p>
<p>通过完善的考虑系统的假设和交互、测试、进程隔离、监控、允许进程挂了后重启等方式来避免软件错误。</p>
<p><strong>人为错误</strong><br>系统的设计、构建和运维是由人来进行的，但人是不可靠的。</p>
<p>通过如下方式来减少人为错误：</p>
<ul>
<li>以最小化错误机会的方式来设计系统。例如：设计良好的抽象、API和管理界面来避免“做错误的事”。</li>
<li>解耦人们最容易犯的错和犯错的地方。例如：提供完整功能的非生产环境sanbox。</li>
<li>完善的测试。例如：从单元测试到整个系统集成测试。</li>
<li>提供快速和简单的错误恢复机制。例如：快速的回滚配置，上线新代码应逐步从小范围内到大范围，提供重新计算数据的工具来修复老数据错误。</li>
<li>详尽和清晰的监控。例如：性能计数和错误率。</li>
</ul>
<h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>即便一个系统现在能够可靠的工作，这不意味着未来也能。一个常见的原因就是负载的增加。当讨论可扩展性时，常常需要考虑，“如果系统以一个特定的方式增长，应该怎么办？”，“如何增加计算资源来应对额外的负载？”。</p>
<p><strong>描述负载</strong><br>首先需要简洁的描述负载，负载可以使用几个数字来描述，叫做负载参数（load parameters），参数的选择依赖于系统的架构，例如：</p>
<ul>
<li>web服务器每秒的请求个数。</li>
<li>数据库的读写比例。</li>
<li>聊天室同时活跃的用户数。</li>
<li>cache命中率。</li>
</ul>
<p><strong>描述性能</strong><br>一旦有了系统负载的描述，那么可以讨论负载增加时会发生什么，可以有两个角度：</p>
<ul>
<li>负载增加时，如果保持系统资源不变，系统的性能会怎样？</li>
<li>负载增加时，为了保持系统性能不变，需要增加多少资源？</li>
</ul>
<p>讨论这两个问题需要描述性能，</p>
<ol>
<li>吞吐量（批处理系统）</li>
<li>响应时间（在线系统）<ul>
<li>平均响应时间。</li>
<li>百分比响应时间。<br>  例如：p50，取time的中位数，如果是200ms，那么代表50%的响应时间小于200ms。类似的还有p90，p99。</li>
<li>高百分比响应时间，又叫做尾部延迟（tail latencies）。</li>
</ul>
</li>
</ol>
<p>性能与可用性一起被用在SLOs（service level objectives）和SLAs（service level agreements）中，规约定义了服务期望的性能和可用性。</p>
<p>高百分比响应时间常常受队列延迟（queueing delay）的影响，少量慢请求会阻塞后续请求的处理，这个现象又叫做head-of-line blocking。</p>
<p>如果一个请求需要进一步使用更多的后端调用来完成，那么一个较慢的调用就会拖慢整个请求，这叫做尾部延迟放大（tail latency amplification）。</p>
<p><strong>应对负载的方法</strong></p>
<ol>
<li>scaling up<br> 垂直缩放，迁移到性能更强的机器。</li>
<li>scaling out<br> 水平缩放，把负载分布到多个小机器上。也叫做share-nothing architecture。</li>
</ol>
<p>实际工程上可能会混用两种方法，几个性能较强的机器可能比非常多的小机器来的划算。把无状态的服务分布到多个机器较为容易，但是把一个有状态的数据系统分布式化会引入很多额外的复杂性。</p>
<p>大规模分布式系统架构往往是针对应用高度定制化的，并不存在一个通用的分布式架构。因为要解决的问题可能是读为主、写为主、大量数据的存储为主、数据的复杂度、响应时间、访问方式，或者是前面各种因素的混合。</p>
<h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>软件开发的主要成本并不在最初的开发，而是持续的维护-修bug、运维、排错、兼容性的平台等。主要关注以下方面，</p>
<ol>
<li>可操作性，便于运维团队的维护。<br> 需要提供：<ul>
<li>完善的监控</li>
<li>自动化和集成工具</li>
<li>避免依赖特定的机器</li>
<li>文档</li>
<li>良好的默认行为，并提供修改默认行为的方法</li>
<li>自我恢复，并提供手动操作的方法</li>
<li>可预测的行为</li>
</ul>
</li>
<li>简单，管理复杂性，便于其他开发者理解系统。<br> 好的抽象可以隐藏复杂的细节。</li>
<li>可进化，便于修改和增加系统功能，又叫做可扩展性（extensibility）、可修改性（modifiability）、可塑性（plasticity）。<br> 增加数据系统的敏捷性。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chao Mai</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:{&quot;url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;,&quot;integrity&quot;:&quot;sha256-ncNI9OXOS5Ek4tzVYiOMmN&#x2F;KKCPZ6V0Cpv2P&#x2F;zHntiA&#x3D;&quot;}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{&quot;enable&quot;:true,&quot;shortname&quot;:&quot;chaomaisblog&quot;,&quot;count&quot;:true,&quot;i18n&quot;:{&quot;disqus&quot;:&quot;disqus&quot;}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
