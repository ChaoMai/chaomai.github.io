<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/default_avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/default_avatar.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;chaomai.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;right&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:true,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="chaomai&#39;s blog">
<meta property="og:url" content="https://chaomai.github.io/page/3/index.html">
<meta property="og:site_name" content="chaomai&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Chao Mai">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaomai.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;page&#x2F;3&#x2F;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>chaomai's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-34179929-2"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;UA-34179929-2&quot;,&quot;only_pageview&quot;:false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="chaomai's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">chaomai's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>Rss</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chao Mai</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chaomai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chaomai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:loneymai@gmail.com" title="E-Mail → mailto:loneymai@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/chaomai" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;chaomai" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://laike9m.com/" title="https:&#x2F;&#x2F;laike9m.com" rel="noopener" target="_blank">laike9m's blog</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-07-15-6.824-Spring-2018-Lecture-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-07-15-6.824-Spring-2018-Lecture-5/" class="post-title-link" itemprop="url">6.824 2018 Lecture 5 Fault Tolerance Raft</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-07-15 15:13:32" itemprop="dateCreated datePublished" datetime="2019-07-15T15:13:32+08:00">2019-07-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/distritubed-system/" itemprop="url" rel="index"><span itemprop="name">distritubed system</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-07-15-6.824-Spring-2018-Lecture-5/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-07-15-6.824-Spring-2018-Lecture-5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-to-end-of-Section-5-论文"><a href="#Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-to-end-of-Section-5-论文" class="headerlink" title="Readings - In Search of an Understandable Consensus Algorithm (Extended Version) (to end of Section 5)论文"></a>Readings - In Search of an Understandable Consensus Algorithm (Extended Version) (to end of Section 5)论文</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>共识算法（Consensus algorithms）允许一组机器作为一个一致的组工作，这个组可以在某些成员失败的情况下存活。Paxos是过去10多年最常被讨论的共识算法，但是难以理解且不便于实现。提出Raft的主要目标是可理解性。通过解耦leader选举、log复制和安全，以及减少状态空间，来增加可理解性。</p>
<p><strong>多副本状态机（Replicated state machine）与共识算法</strong><br>共识算法常常出现在多副本状态机的讨论中。</p>
<p><img data-src="/images/2019/15633494887544.jpg" alt="-w384"></p>
<p>多副本状态机常用于解决分布式系统中的各种容错问题，使用复制log来实现，每个状态机以相同的顺序执行相同的命令，最终算出相同的状态和结果。保证replicated log的一致是由共识算法来实现的。</p>
<p>共识算法一般有以下几个特征：</p>
<ul>
<li>安全：<em>非拜占庭条件</em>（网络问题、丢包、乱序）下，不返回任何错误的结果。</li>
<li>可用性：大多数server可用，则系统整体可用。</li>
<li>不依赖时间来保证日志的一致性。</li>
<li>大多数server执行完毕则返回，少量慢server不影响系统性能。</li>
</ul>
<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>raft的工作过程是，首先选举leader，leader会负责管理replicated log。leader接受来自client的log，复制到其他机器，并在安全的时候通知其他机器把log输入状态机。</p>
<p>raft可以解耦为以下三个部分：</p>
<ol>
<li>leader选举（Leader election）</li>
<li>日志复制（Log replication）</li>
<li>安全（Safety）</li>
</ol>
<p>在理解这三个部分前，有几个基本概念需要知道，<br><strong>server 状态</strong></p>
<ul>
<li>leader：只能有一个leader</li>
<li>follower：只响应来自其他server的请求</li>
<li>candidate：用于选举</li>
</ul>
<p><img data-src="/images/2019/15633584684199.jpg" alt="-w433"></p>
<p><strong>时间</strong><br>raft把时间分为terms，term由一个递增的数字标识，表示<em>current term</em>。每个term以leader选举作为起始，如果未选举出leader，那么下一个term继续选。term内选举出的leader管理集群直到term结束。</p>
<p><img data-src="/images/2019/15633589391342.jpg" alt="-w351"></p>
<p>不同的server可能观察到不同的term转换，server使用current term（在server通信的时候发送）作为逻辑时钟，来确保能够探测到过期的信息。</p>
<p><strong>通信</strong><br>使用rpc。基本的共识算法使用两种rpc，</p>
<ol>
<li>RequestVote RPCs：candidates调用，来进行拉票，用于选主。</li>
<li>AppendEntries RPCs：leader发起，用于复制日志和心跳。</li>
</ol>
<h3 id="leader选举（Leader-election）"><a href="#leader选举（Leader-election）" class="headerlink" title="leader选举（Leader election）"></a>leader选举（Leader election）</h3><p>选举过程为，follower在election timeout内都没有收到leader的通信，则转换为candidate状态，并自增当前term、为自己投票、向其他server发送RequestVote RPCs。candidate维持在这个状态，直到下列情况出现：</p>
<ol>
<li>获得了相同term的多数派的投票，赢得选举。<br> 一旦candidate赢得选举，就转换为leader，并向其他server发送heartbeat，宣告leadership。</li>
<li>收到AppendEntries RPCs，其他candidate赢得了选举，成为leader。<ol>
<li>如果leader的term &gt;= 自己的term，那么这个leader是合法的，自己转换为follower状态。</li>
<li>如果leader的term &lt; 自己的term，那么拒绝这个rpc，自己维持在candidate状态。</li>
</ol>
</li>
<li>election timeout后，未获得足够的选票。<br> 多个candidate可能同时发起选举，发生了split vote，导致任何一个都无法获得多数派的投票。自增term，开始下一次选举。</li>
</ol>
<p>在下面的状态图中，状态转换的上方表示触发转换的event，下方表示发生转换时执行的action。</p>
<p><img data-src="/images/2019/leader%20election.jpg" alt="leader election"></p>
<p>选举安全性：</p>
<ul>
<li>在每个term内，每个server只能至多为一个candidate投票。</li>
</ul>
<p>在选举过程中，raft使用随机election timeout来保证，</p>
<ul>
<li>split votes（没有任何candidate能获得大多数投票）会很少出现。<br>  比较常见的是，C先timeout，然后投票给自己，并发送RequestVote RPCs，最终win。<br>  <img data-src="/images/2019/15634274004241.jpg" alt="-w397"></li>
<li>且split votes能够被快速解决。如果出现split votes，candidate先等待随机election timeout。</li>
</ul>
<h3 id="日志复制（Log-replication）"><a href="#日志复制（Log-replication）" class="headerlink" title="日志复制（Log replication）"></a>日志复制（Log replication）</h3><p><strong>如何复制</strong></p>
<ol>
<li>leader追加log entry。</li>
<li>AppendEntries RPC。</li>
<li>当log entry被安全复制（成为<em>committed</em> log entry，leader更新commit index），<ul>
<li>leader apply log entry，然后返回结果到client。</li>
<li>leader AppendEntries RPC通知follower committed entry，follower apply log entry。</li>
</ul>
</li>
</ol>
<p>如果follower失败、运行缓慢、丢包，leader重试AppendEntries RPC（就算leader已经返回client结果），直到所有follower最终收到所有log entry。raft保证了committed entry是<em>持久化的</em>，且最终能被所有可用的状态机执行。</p>
<p>那什么时候才算log entry被安全复制？当创建log entry的leader把entry复制到大多数server上以后。这同时也提交了在leader中所有先前的log，包括被前leader创建的log。</p>
<p><strong>应对出错</strong><br>raft在复制log时会维护如下性质来保证Log Matching Property（log consistency），</p>
<ul>
<li>如果两个entry在不同的log中有相同的index和term，那么它们的cmd是相同的。<br>  因为leader至多只创建一个带有相同index和term的entry，且entry不会在log中改变位置。</li>
<li>如果两个entry在不同的log中有相同的index和term，那么所有先前的log都是相同的。<br>  consistency check：AppendEntries RPC发送新的entry时，会包含前一个entry，如果follower没有找到与前一个entry相同的index和term，那么follower不会写入新的entry。</li>
</ul>
<p>根据以上两点，结合数学归纳法可知，Log Matching Property可以被满足。在正常情况下，leader和follower的log是保持一致的。</p>
<p>如果leader或follower崩溃引起了log不一致，如何恢复一致性？leader会强制follower复制自己的log，</p>
<ol>
<li>leader维护了<code>&#123;follower: nextIndex&#125;</code>，表示下一个将会发送到follower的entry。</li>
<li>leader启动时，将<code>nextIndex</code>置为<code>max(self log index) + 1</code>。</li>
<li>如果follower的日志不一致，那么接下来的AppendEntries RPC consistency check会失败。leader会将<code>nextIndex - 1</code>并重试，直到成功。</li>
</ol>
<h3 id="安全（Safety）"><a href="#安全（Safety）" class="headerlink" title="安全（Safety）"></a>安全（Safety）</h3><p>任何实现了日志复制的系统，都必须满足：一旦entry已经applied到状态机，那么任何其他状态机都不能为这条entry apply一个不同的值。</p>
<p>截止目前所描述的leader选举，存在的问题是，如果follower未收到leader的提交，那么当它成为leader以后，就会用自己的log覆盖其他server的。</p>
<p><strong>选举约束</strong><br>任何基于leader的共识算法，leader必须最终包含所有committed entry。raft需要保证所有committed entry，都出现在后续每个新的leader中，而这个保证确保了本节内容开头的安全性要求。</p>
<p>在选举的时候，使用voting process来避免未包含所有committed entry的candidate赢得选举。由于candidate在选举的时候需要联系大多数server，即只需要求每个committed entry必须出现在至少一个server（选举时联系的server）里面即可（抽屉原理）。</p>
<p>如果candidate包含的日志与大多数server包含的log<em>至少一样新</em>，那么这个candidate就包含了所有的log。具体判断方法是，</p>
<ol>
<li>在RequestVote RPC进行投票时，rpc包含了candidate最后一个entry的index和term。</li>
<li>如果voter（收到rpc call的一方）的log是更新的，即，<br> $$(lastTerm_v &gt; lastTerm_c) || ((lastTerm_v == lastTerm_c) \&amp;\&amp; (lastIndex_v &gt; lastIndex_c))$$<br> 那么voter拒绝此次投票。</li>
</ol>
<p><strong>提交上一个term的entry</strong><br>新leader能否直接提交上一个term的entry？</p>
<p><img data-src="/images/2019/15637956361681.jpg" alt="-w463"></p>
<p>c中s1成为term4的leader后继续复制term2的日志index2，此时日志已经复制到大多数机器上。按照之前的规则，s1可以认为日志已经是committed。但如果接着s5成为了leader（接受s3和s4的投票），s5会覆盖s1已经commit的日志。</p>
<p>因此不能仅通过副本数判断先前term的日志是不是committed，还需要满足<em>至少有一个属于当前term的log也复制到大多数server</em>，才能认为是。</p>
<h3 id="follower和candidate崩溃"><a href="#follower和candidate崩溃" class="headerlink" title="follower和candidate崩溃"></a>follower和candidate崩溃</h3><p>raft rpc是幂等的，leader无限重试。</p>
<h3 id="时间和可用性"><a href="#时间和可用性" class="headerlink" title="时间和可用性"></a>时间和可用性</h3><p>raft的安全性不依赖时间。但是系统的可用性依赖时间，这里有尤其指的是leader选举。election timeout需要满足下面的要求，raft才能选举并保持一个稳定的leader，</p>
<p>$$broadcastTime \ll electionTimeout \ll MTBF$$</p>
<h3 id="Leadership-transfer"><a href="#Leadership-transfer" class="headerlink" title="Leadership transfer"></a>Leadership transfer</h3><p>本质上还是使用leader选举的机制，通过主动触发目标server进行选举来实现来迁移，与后面的配置变更不同。过程如下：</p>
<ol>
<li>旧leader暂停服务。</li>
<li>旧leader进行正常的日志复制过程，把log复制到目标server。</li>
<li>旧leader发送TimeoutNow到目标server，触发目标server开始选举（相当于调快了timer，触发了election timeout）。</li>
<li>目标server大概率会比其他server先发起选举，并成为下一个term的leader。</li>
<li>选举成功后，旧leader收到heartbeat，出让leadership，至此transfer完成。</li>
</ol>
<p>如果迁移过程未在一个election timeout内完成，那么终止迁移。如果迁移成功了，但是旧leader误以为失败了，那最坏情况是进行一次额外的选举。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>日志复制时每个步骤都有可能出现错误，如何处理？<br> raft并不允许“false positives”的出现（返回client执行成功了，但实际上没有成功），但是可能会有“false negatives”的出现，告知client失败了，但实际上是成功了。为了避免false negatives，client必须重试直到成功，且每次只能有一个未完成的command，相应地，raft也必须提供去重机制。</p>
</li>
<li><p>为什么不能直接复制上一个term未committed的entry？</p>
</li>
<li><p>raft为何能够防止脑裂？<br> 2f+1个server，成为leader需要获得大多数server（f+1个）的投票。如果发生网络分区，必然有一个partition的分区少于f+1个。这个分区里面，</p>
<ul>
<li>如果没有leader，那么也不可能选举出leader。</li>
<li>如果有leader，由于日志无法被安全复制，因此不会对client做出任何承诺（不会成为committed entry，也不会被apply到状态机）。</li>
</ul>
</li>
<li><p>为什么需要leader？</p>
<ul>
<li>简化复制日志的过程。</li>
<li>保证所有的副本都以相同的顺序执行相同的命令。</li>
</ul>
</li>
<li><p>server变为candidate后会发生什么？<br> 开始选举：inc term，vote self，发送RequestVote RPC。可能结果如下，</p>
<ul>
<li>赢得选举。<br>  变为leader。</li>
<li>选举失败，收到来自其他leader的AppendEntries RPC。<br>  变为follower。</li>
<li>既没有赢得选举，也没有收到来自其他leader的AppendEntries RPC。<br>  维持candidate。election timeout，开始下一次选举。<br>  如果一直无法获得大多数server的投票，这个过程会一直重复，term会一直增加。<br>  <em>此时，如果client有请求会发生什么？</em></li>
</ul>
</li>
<li><p>如何保证同一个term内只有一个leader？</p>
<ul>
<li>leader需要获得来自大多数server的投票。</li>
<li>在同一个term内，每个candidate只能投票一次。</li>
<li>在同一个term内，至多只有一个server能获得大多数server的投票（即使出现网络分区）。</li>
</ul>
</li>
<li><p>什么情况下选举会失败？</p>
<ul>
<li>大多数server都失败了。</li>
<li>两个server获得了相同票数（例如：2f+1个server，挂了一个server）。</li>
</ul>
</li>
<li><p>选举失败会发生什么？<br> election timeout，开始下一次选举。</p>
</li>
<li><p>如何设置election timeout？</p>
<ul>
<li>$broadcastTime \ll electionTimeout \ll MTBF$</li>
<li>random</li>
<li>至少是几个heartbeat间隔</li>
</ul>
</li>
<li><p>replicated和committed entry的区别？</p>
<ul>
<li>replicated是做了复制，可能被覆盖。</li>
<li>committed，已提交，不会丢失。</li>
</ul>
</li>
<li><p>每个副本的日志会完全一致吗？<br>不会，可能落后，可能会有临时的不一致。但最终会一致，且状态机执行的命令是一致的。</p>
</li>
<li><p>为什么leader不能直接提交上一个term的entry？以及如何避免直接提交带来的问题？<br>提交时，需要等到至少一个当前term的entry也安全复制以后。</p>
</li>
<li><p>leader在什么时候覆盖follower的entry是合法的？<br>uncommitted entry。</p>
</li>
<li><p>leader覆盖follower的entry时，可能会覆盖committed entry吗？<br>不会。</p>
<ol>
<li>先看entry成为committed时，发生了什么。log entry需要安全复制，即发送到大多数server上。</li>
<li>candidate成为leader，需要联系大多数server，以保证自身的log与大多数server的一样新（选举约束）。因此成为leader的candidate一定包含了所有committed entry。</li>
</ol>
</li>
<li><p>如果下图中的leader（for term 8）挂了，a、d和f，哪个会被选举为leader？谁投的票？新leader产生后，哪些entry一定会保留下来？<br><img data-src="/images/2019/15639591300953.jpg" alt="-w478"></p>
<p>a-f每个server最多可能获得投票的情况如下：<br>a：a，b，e，f<br>b：b，f<br>c：a，b，c，e，f<br>d：a，b，c，d，e，f<br>e：b，e<br>f：f</p>
<p>所以a或d可能成为leader，一定会保留下的log是111445566。</p>
</li>
<li><p>如果server刚开始选举，此时收到了来自leader的AppendEntries RPC（假设leader与这个server都是处于同一个term），此时要怎么处理？</p>
<ul>
<li>candidate成为leader后，应该立即发送心跳来避免发生多余的选举。</li>
<li>如果发生这个情况，由于term一样，leader会忽略RequestVote RPC。</li>
</ul>
</li>
<li><p>如果leader完成复制，更新自身的commit index，且完成了apply，但在通知follower commit index前挂了（或丢失了leader资格），这个entry最终会丢失吗？</p>
</li>
<li><p>lastApplied是否应该做持久化？<br>这个地方有点争议。在<a target="_blank" rel="noopener" href="https://github.com/ongardie/dissertation">ongardie/dissertation</a>的Errata中，指明了lastApplied是否做持久化应该与状态机一致。但在<a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/raft-qa/">Raft Q&amp;A</a>中的说法是，状态机如果做持久化，那么也应该负责记住执行了哪些log。</p>
</li>
<li><p>follower拒绝AppendEntries RPC时，如何快速的解决冲突？<br>follower拒绝时，返回冲突entry的term，以及这个term首个entry的index。</p>
<ul>
<li>如果leader有这个entry，那么移动nextIndex到冲突的那个entry。</li>
<li>如果leader没有这个entry，那么移动nextIndex到那个term的首个index。</li>
</ul>
<p>还可以使用二分法，查找首个冲突的entry，这可以实现在最坏情况下的最佳时间复杂度。</p>
</li>
</ol>
<h1 id="Lab-2A-Raft"><a href="#Lab-2A-Raft" class="headerlink" title="Lab 2A: Raft"></a>Lab 2A: Raft</h1><h2 id="锁的使用建议"><a href="#锁的使用建议" class="headerlink" title="锁的使用建议"></a>锁的使用建议</h2><p>这个<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">lecture</a>说了几点关于锁的建议，我觉得最重要的一点是，</p>
<blockquote>
<p>Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held.</p>
</blockquote>
<p>在减少锁的粒度的时候，可能也把变量的write和read分开了，进而导致在read的时候，变量已经被其他线程改变了。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a target="_blank" rel="noopener" href="http://catkang.github.io/2017/11/30/raft-safty.html">Why Raft never commits log entries from previous terms directly</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a89084103b6e">raft之 为什么不能直接commit 上一个term的entry</a></li>
<li><a target="_blank" rel="noopener" href="https://yuerblog.cc/2018/07/28/understand-raft/">raft本质理解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCy1xUHx0OWo3gnBC8AbnUqg">Raft user study lectures</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.com/presentations/raft-consensus-algorithm/">The Raft Consensus Algorithm</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ongardie/dissertation">ongardie/dissertation</a></li>
<li><a target="_blank" rel="noopener" href="https://runway.systems/?model=github.com/ongardie/runway-model-raft">ongardie/runway-model-raft</a></li>
<li><a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/raft-qa/">Raft Q&amp;A</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-07-11-6.824-Spring-2018-Lecture-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-07-11-6.824-Spring-2018-Lecture-4/" class="post-title-link" itemprop="url">6.824 2018 Lecture 4 Primary-Backup Replication</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-07-11 17:46:17" itemprop="dateCreated datePublished" datetime="2019-07-11T17:46:17+08:00">2019-07-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/distritubed-system/" itemprop="url" rel="index"><span itemprop="name">distritubed system</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-07-11-6.824-Spring-2018-Lecture-4/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-07-11-6.824-Spring-2018-Lecture-4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Readings-Practical-System-for-Fault-Tolerant-Virtual-Machines-Fault-Tolerant-Virtual-Machines论文"><a href="#Readings-Practical-System-for-Fault-Tolerant-Virtual-Machines-Fault-Tolerant-Virtual-Machines论文" class="headerlink" title="Readings - Practical System for Fault-Tolerant Virtual Machines Fault-Tolerant Virtual Machines论文"></a>Readings - Practical System for Fault-Tolerant Virtual Machines Fault-Tolerant Virtual Machines论文</h1><p>这篇论文讨论的主从复制与常见的相比，非常极端和雄心勃勃，论文基于vm构建了一个os级别的主从复制系统，较为细致的讨论了主从复制的设计和实现。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>主从复制是实现server容错的常用方法，如果primary挂了，backup可以继续提供服务。将primary的全量数据同步到backup是比较耗费带宽的操作。更好的方法是将server视为确定状态机，基本思路是把primary和backup置为相同的初始状态，并保证二者都能以相同的顺序收到相同的输入。由于存在某些操作是非确定的（如：中断和获得当前时间），因此还需要额外的协同。</p>
<h2 id="FT协议"><a href="#FT协议" class="headerlink" title="FT协议"></a>FT协议</h2><h3 id="Deterministic-Replay"><a href="#Deterministic-Replay" class="headerlink" title="Deterministic Replay"></a>Deterministic Replay</h3><p>为了实现在backup进行replay，需要保证：</p>
<ol>
<li>正确的捕获所有输入和非确定的操作，以保证backup的确定性执行。</li>
<li>在backup上正确的replay。</li>
<li>对性能没有影响。</li>
</ol>
<blockquote>
<p>论文中关于非确定的操作，零零散散在不少地方提到，不过总结下来其实就是，这个操作不是pure function，结果受除输入的外部状态影响。更具体的就是，非确定操作使用到的资源是与其他（来自vm或hypervisor）的进程共享的，竞争导致了非确定的结果。</p>
<p>在多核系统上，上述的竞争会更复杂，这也是为什么论文没有在多核系统上实现的原因。</p>
</blockquote>
<h3 id="FT协议-1"><a href="#FT协议-1" class="headerlink" title="FT协议"></a>FT协议</h3><p>primary的日志实时的通过logging channel发送到backup。为了保证在切换的时候，backup能够以与primary相同状态进行服务，需要满足：</p>
<p><strong>Output Requirement</strong>：如果primary失败，backup接替了primary，backup的执行需要保证所有的输出都与primary的一致。</p>
<p>只要满足Output Requirement，在发生主从切换的时候，client就感知不到打断和不一致。为了保证Output Requirement，需要backup在收到能够产生那个output的input之前，primary推迟输出，也就是下面的规则：</p>
<p><strong>Output Rule</strong>：只有当backup收到能够产生一个output的log，并返回ack（表示已经存入log buffer）给primary，primary才能输出。</p>
<blockquote>
<p>除了VM-FT有，在其他的多副本系统上都以某种形式出现着。</p>
</blockquote>
<p><img data-src="/images/2019/15628165996172.jpg" alt="-w470"></p>
<p>primary等待ack不必阻塞系统当前的执行。</p>
<h3 id="检测和响应失败"><a href="#检测和响应失败" class="headerlink" title="检测和响应失败"></a>检测和响应失败</h3><p>检测失败：</p>
<ul>
<li>server之间的heartbeat</li>
<li>logging channel的traffic是否一直存在</li>
</ul>
<p>如何避免split-brain：</p>
<ul>
<li>共享磁盘存储，原子的检测标志位</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="FT-VM启动"><a href="#FT-VM启动" class="headerlink" title="FT VM启动"></a>FT VM启动</h3><ul>
<li>使用基于VMware VMotion实现的FT VMotion完成clone，primary的中断小于1s。</li>
<li>使用VMware vShpere实现的集群服务来选择最佳server创建backup。</li>
</ul>
<h3 id="logging-channel管理"><a href="#logging-channel管理" class="headerlink" title="logging channel管理"></a>logging channel管理</h3><p><img data-src="/images/2019/15628298304504.jpg" alt="-w322"></p>
<p><strong>log buffer的局限：</strong><br>primary（或backup）的log buffer满了（或空了），primary（或backup）需要等待至log buffer可用为止，此时会暂停对client的服务。</p>
<p>主从切换的时间=检测primary失败的时间+backup消费log buffer的时间，为了减少切换的时间，在backup无法及时消费log的时候，会减慢primary的速度（限制CPU）。</p>
<h3 id="FT-VM上的操作"><a href="#FT-VM上的操作" class="headerlink" title="FT VM上的操作"></a>FT VM上的操作</h3><p>除VMotion外的所有运维操作（例如：调整cpu限制），都必须在primary上完成，然后通过特殊的日志项目发送到backup。</p>
<h3 id="关于磁盘io的实现问题"><a href="#关于磁盘io的实现问题" class="headerlink" title="关于磁盘io的实现问题"></a>关于磁盘io的实现问题</h3><ol>
<li>磁盘访问时的竞争会导致非确定的操作。<ul>
<li>检测这样的io竞争，并在primary和backup上以相同顺序执行。</li>
</ul>
</li>
<li>使用DMA时，对磁盘和内存的访问会导致非确定的操作。<ul>
<li>对磁盘的读写，改为读写bounce buffer。</li>
<li>只有当数据全部读到buffer以后，FT才会<em>从读指令处</em>恢复primary/backup的执行，避免二者出现差异（如果直接依赖DMA读取，primary和backup可能会在不可预知的时间点发生缺页中断，从而导致不一致）。</li>
</ul>
</li>
<li>primary在磁盘io完成前就挂了。<ul>
<li>backup切换为primary以后，无从得知io是否已经完成。FT会在backup上重试（前两点已经消除了导致非确定结果的操作）未完成的io操作。</li>
<li>那么<em>如何判断未完成的io操作是哪些</em>？io完成以后，设备会产生一个中断，如果某个io log缺少相应的中断，那么就需要重试。</li>
</ul>
</li>
<li>primary在磁盘io完成后挂了<ul>
<li>backup同样无从得知io是否已经完成。此时重新执行写磁盘是幂等的（而对于网络io，tcp会忽略重复的包）。</li>
</ul>
</li>
</ol>
<h3 id="关于网络io的实现问题"><a href="#关于网络io的实现问题" class="headerlink" title="关于网络io的实现问题"></a>关于网络io的实现问题</h3><p>hypervisor对vm buffer的更新导致了非确定操作，改为由vm触发hypervisor的中断，并记录到log。</p>
<h2 id="其他设计"><a href="#其他设计" class="headerlink" title="其他设计"></a>其他设计</h2><h3 id="非共享磁盘"><a href="#非共享磁盘" class="headerlink" title="非共享磁盘"></a>非共享磁盘</h3><p>优势：</p>
<ul>
<li>磁盘作为vm的内部状态，primary写磁盘时不必等待backup的ack。</li>
</ul>
<p>缺点：</p>
<ul>
<li>backup失败、执行FT VMotion时，需要同步磁盘数据。</li>
<li>需要使用其他方法来解决split-brain，例如：另外一个server作为共享存储；多个机器进行投票选主。</li>
</ul>
<h3 id="backup上执行read"><a href="#backup上执行read" class="headerlink" title="backup上执行read"></a>backup上执行read</h3><p>在从执行read，论文考虑的点并不是可以增加系统的read上限，而是考虑不发送read log可以减少logging channel的带宽。</p>
<p>具体看在backup上执行read，需要注意的点是：</p>
<ul>
<li>如果primary成功，backup失败，backup需要重试，直到成功。</li>
<li>如果primary失败，那么尝试读取的内存必须发送到backup。</li>
<li>如果primary执行了读，然后是写，那么在backup也必须按照这个顺序来执行。</li>
</ul>
<h1 id="Lecture"><a href="#Lecture" class="headerlink" title="Lecture"></a>Lecture</h1><h2 id="Fault-tolerance"><a href="#Fault-tolerance" class="headerlink" title="Fault tolerance"></a>Fault tolerance</h2><p><strong>理想的特性</strong></p>
<ul>
<li>可用性</li>
<li>强一致性</li>
<li>对client和server software透明</li>
<li>高效</li>
</ul>
<p><strong>容错，容什么错？</strong></p>
<ul>
<li>Fail-stop failures</li>
<li>Independent failures</li>
<li>Network drops some/all packets</li>
<li>Network partition</li>
</ul>
<p>不包括：</p>
<ul>
<li>Incorrect execution</li>
<li>Correlated failures</li>
<li>Configuration errors</li>
<li>Malice</li>
</ul>
<h2 id="Fault-tolerant-MapReduce-master"><a href="#Fault-tolerant-MapReduce-master" class="headerlink" title="Fault tolerant MapReduce master"></a>Fault tolerant MapReduce master</h2><p>lab 1中的woker由于是无状态的，且mapper和reducer执行的都是pure function，因此实现容错很简单。</p>
<p>master实现容错，需要考虑：</p>
<ul>
<li>需要复制什么状态？应用程序级？指令级？（woker list、完成的job、空闲的worker、tcp连接状态、程序memory和stack、cpu寄存器？）</li>
<li>primary是否需要等待backup？</li>
<li>什么时候切换到backup？</li>
<li>切换时是否能被观察到？</li>
<li>如何快速的切换？</li>
</ul>
<p><strong>主要方法有</strong></p>
<ol>
<li>State transfer，简单，但是state可能会很大，传输很慢<ul>
<li>主副本执行服务</li>
<li>primary把新状态发送到backup</li>
</ul>
</li>
<li>Replicated state machine，高效但复杂<ul>
<li>所有副本执行所有的操作</li>
<li>如果所有副本有相同的起始状态、相同的操作、相同的顺序、deterministic，那么就会有相同的最终状态</li>
<li>例如：VM-FT，GFS</li>
</ul>
</li>
</ol>
<h2 id="VM-FT"><a href="#VM-FT" class="headerlink" title="VM-FT"></a>VM-FT</h2><p>VM-FT是一个replicated state machine。</p>
<p>为了避免primary和backup出现差异，backup必须在指令流的相同位置、以相同的顺序看到相同事件。对于普通的指令，这个是比较容易实现的。FT对中断和磁盘/网络io会做特殊的处理。</p>
<p>例如：时钟中断</p>
<p><img data-src="/images/2019/ft%20time%20interrupt.jpg" alt="ft time interrupt"></p>
<h2 id="FT的有缺点"><a href="#FT的有缺点" class="headerlink" title="FT的有缺点"></a>FT的有缺点</h2><p><strong>适用场景</strong></p>
<ol>
<li>重要且低延迟的服务，例如：name server。</li>
<li>不便于修改的服务。</li>
</ol>
<p><strong>不适用的情况</strong></p>
<ol>
<li>高吞吐量的服务<ul>
<li>state仅仅是应用程序级别的，降低了开销，实现更高的性能。</li>
<li>例如：GFS适用应用程序级别的state。</li>
</ul>
</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="http://alvaro-videla.com/2013/12/failure-modes-in-distributed-systems.html">FAILURE MODES IN DISTRIBUTED SYSTEMS</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-05-26-6.824-Spring-2018-Lecture-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-05-26-6.824-Spring-2018-Lecture-3/" class="post-title-link" itemprop="url">6.824 2018 Lecture 3 GFS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-26 08:38:33" itemprop="dateCreated datePublished" datetime="2019-05-26T08:38:33+08:00">2019-05-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/distritubed-system/" itemprop="url" rel="index"><span itemprop="name">distritubed system</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-05-26-6.824-Spring-2018-Lecture-3/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-05-26-6.824-Spring-2018-Lecture-3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Readings-The-Google-File-System论文"><a href="#Readings-The-Google-File-System论文" class="headerlink" title="Readings - The Google File System论文"></a>Readings - The Google File System论文</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GFS是由Google设计和实现的，以满足Google对数据处理快速正常的需求。GFS和先前的分布式文件系统有很多相似的目标，例如：性能、可扩展性、可靠性和可用性。然而，GFS的设计是由Google对应用负载和技术环境的关键（当前和预期的）观察驱动的，这反映了与早期文件系统设计假设的显著不同。Google重新审视传统的选择，并探索在设计领域探索了彻底不同的观点。</p>
<ul>
<li>组件故障是常态而非例外。<br>  因此持续的监控、错误监测、容错和自动恢复是系统不可缺少的。</li>
<li>传统标准的文件是巨大的，常常很多GB。处理包含数十亿个对象、很多TB、且快速增长的数据集时，即便文件系统可以支持，也很难管理数十亿个约KB大小的文件。<br>  因此设计假设和参数，例如IO操作和block大小必须被重新审视。</li>
<li>大多数文件修改都是通过追加新数据的方式，而非覆盖已有的数据。对文件的随机写几乎已经不存在了。一旦写入，文件就是只读的，且常常只是顺序读。<br>鉴于这样对大文件的访问模式，追加成为了性能优化和原子保证的的关注点，而在client上对数据块的缓存失去了吸引力。</li>
<li>应用程序和文件系统api的协同设计，通过提升灵活性，有益于整个系统。</li>
</ul>
<h2 id="设计概览"><a href="#设计概览" class="headerlink" title="设计概览"></a>设计概览</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>虽然GFS没有实现例如POSIX的标准API，但也提供了一组熟悉的文件系统接口。文件以层次结构的方式用目录组织起来，并用路径名来标识。GFS支持<em>create，delete，open，close，read</em>和<em>write</em>文件。GFS还支持<em>snapshot</em>和<em>record append</em>。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>一个GFS集群由一个<em>master</em>和多个<em>chunkserver</em>构成，可以被多个<em>client</em>访问。</p>
<p><img data-src="/images/2019/15584874415545.jpg" alt="-w757"></p>
<p>文件被切分为固定大小的<em>chunks</em>。每个chunk都由一个不可变，且全局唯一的64位<em>chunk handle</em>标识，这个chunk handle在创建chunk时master分配的。chunkservers把chunk作为linux文件存储在本地磁盘上，并通过指定的chunk handle和byte range来读写文件。为了reliability（可靠性），每个chunk会在多个chunkservers上有复制。</p>
<p>master维护这整个文件系统的metadata，包括namespace，访问控制信息，文件到chunk的映射，以及chucks的当前位置。master还可控制着系统级别的活动，例如chuck租约管理，孤儿chunk的垃圾回收，以及chunkservers之间的chunk迁移。master定期与每个chunkserver以HeartBeat消息的形式进行通信，完成指令的发送和状态的收集。</p>
<p>client与master通信来进行metadata相关的操作，数据相关的通信是直接与chunkserver进行的。</p>
<p>client和chunkserver都不需要缓存数据。client缓存数据的收益很小，因为大多数程序都是流式读取大文件或者数据量太大而无法缓存。client不用缓存数据消除了缓存一致性的问题，简化了系统设计。但client会缓存metadata。chunkserver不必缓存文件数据，因为chunk都是以本地文件的形式保存的，linux buffer cache会把常访问的数据放入内存。</p>
<h3 id="单一master"><a href="#单一master" class="headerlink" title="单一master"></a>单一master</h3><p>单一master极大的简化了设计，并使master能够使用全局信息来进行复杂的chunk布局和复制决策。然而当读写时，必须最小化master的参与，这样master才不会成为瓶颈。client进行读写时，先询问master应该连接哪个chunkserver，并缓存这个信息一段时间，然后直接与这个chunkserver交互来完成后续的操作。</p>
<h3 id="chunk-size"><a href="#chunk-size" class="headerlink" title="chunk size"></a>chunk size</h3><p>chunk size是关键设计参数之一。GFS使用一个远大于典型文件系统的block size，64MB。每个chunk副本都以普通linux文件的形式存储在chunkserver，并在需要的时候扩展。惰性空间分配避免了由于内部碎片导致的空间浪费。</p>
<p>大型chunk size有这些优势，</p>
<ul>
<li>减少了client与master交互的需求。<br>  读写同一个chunk只需要向master请求一次chunk的位置信息。</li>
<li>由于chunk较大，client也较为可能在一个给定的chunk上进行很多的操作。<br>  通过在较长时间内保持与chunkserver的TCP连接，可以减少网络开销。</li>
<li>减少了存储在master上metadata的大小。<br>  由此可以将metadata放入内存。</li>
</ul>
<p>然而大型chunk size，即便有惰性空间分配，也存在弊端，</p>
<ul>
<li>chunkserver的热点访问。<br>  一个小文件仅有为数不多的chunks组成，可能就一个。如果大量的client都访问同一个文件，那么存储这些chunk的chunkserver可能会成为热点。</li>
</ul>
<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>mater主要存储3类metadata：</p>
<ul>
<li>文件和chunk namespace</li>
<li>文件到chunks的映射关系</li>
<li>每个chunk副本的位置</li>
</ul>
<p>其他metadata还包括所有权和权限、每个chunk的版本、引用计数（用于实现copy-on-write）。</p>
<p>所有的metadata都是存储在内存中的。</p>
<ul>
<li>前两种还会进行持久化存储（使用write-ahead log），这是通过把记录修改到操作日志、在master落盘、以及在远程机器上存放副本来实现的。</li>
<li>对于最后一种metadata，master并不会做持久化存储。在master启动和有chunkserver加入集群的时候，master会询问每一个chunkserver存放的chunks。</li>
</ul>
<p><strong>In-Memory Data Structures</strong><br>由于metadata是存放在内存中的，因此mater的操作很快，除此之外还能完成定期在后台较快的完整扫描。这个定期扫描用于实现chunk的gc，chunkserver故障时副本重新复制，以及chunk的迁移。</p>
<p>一个潜在的问题是存储的chunk数目受限于内存的大小。但由于每个chunk的metadata少于64byte，且文件的namespace数据也少于64byte，并且启用了前缀压缩，因此这不是一个严重的问题。如果确实有必要支持更大的文件系统，加内存即可。</p>
<p><strong>Chunk Locations</strong><br>master并不对chunk locations做持久化。master启动时，会向所有chunkserver请求。之后，由于master控制着所有chunks的放置，并通过心跳消息来监控chunkserver，master能够确保自身的信息是最新的。</p>
<p>为什么不做持久化？</p>
<ol>
<li>消除了master和chunkserver的同步问题。<br> chunkserver可能加入、离开、重启、重命名、故障等。</li>
<li>chunkserver对自己有和没有哪些chunk有最终的话语权。<br> 在master维护此信息的一致视图是没有意义的，chunkser可能出现1中的各种问题。</li>
</ol>
<p><strong>Operation Log</strong><br>操作日志对GFS很重要，</p>
<ul>
<li>包含了metadata关键修改的历史记录，并持久化。</li>
<li>作为逻辑时间戳，定义了并发操作的顺序。<br>  文件和chunks，以及它们的版本，全都在创建的时候被逻辑时间唯一且永久的标识。</li>
</ul>
<p>可靠性保证，</p>
<ul>
<li>仅当metadata的修改完成持久化以后，这些修改才对client可见。</li>
<li>在多个远程机器上有复制。<ul>
<li>仅当把相应的log记录写入本地和远程机器的磁盘后，才响应client。</li>
<li>master会批量flush日志，来减少flush和复制对整个集群吞吐量的影响。</li>
</ul>
</li>
<li>master通过重放操作日志来恢复文件系统的状态。<ul>
<li>为了减少启动的时间，需要保证log较小。</li>
<li>当log增长超过特定大小时，master会checkpoint自身的状态，以便可以在恢复时载入最后一个checkpoint并重放在那之后的log。</li>
</ul>
</li>
</ul>
<p>checkpoint和恢复，</p>
<ul>
<li>checkpoint类似于压缩后的B树，可以直接map到内存，并用用户namespace的查找，且不需要额外的解析。</li>
<li>master创建checkpoint时，会切换到新log文件，并在另外的线程中创建checkpoint（包含了checkpoint前的所有修改），避免延误当前的修改。</li>
<li>恢复只需要最近的一个<em>完整</em>（需要检测是否完整）checkpoint和后续的log文件。更老的checkpoint和log是可以释放的。</li>
</ul>
<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>GFS有一个宽松的一致性模型，这在支持高度分布式应用的同时，也相对简单和高效。</p>
<p><strong>Guarantees by GFS</strong><br>文件namespace修改（例如：创建文件）是原子的，由master专门执行。namespace锁保证了原子性和正确性；master的操作日志定义了这些操作的全局顺序。</p>
<p>一个文件区域有两种状态，</p>
<ol>
<li>consistent：无论client从哪个副本读取，都能看到相同的数据。</li>
<li>defined：在文件数据修改后，如果文件区域是consistent的，并且client能看到所有写入到文件的修改。</li>
</ol>
<p>数据修改包含，</p>
<ol>
<li>写入<ul>
<li>写入操作会把数据写到应用程序指定的文件offset。</li>
</ul>
</li>
<li>追加<ul>
<li>即使在并发修改存在的情况下，追加会把数据在GFS选择的offset处<em>至少一次原子</em>追加一次。</li>
<li>这个offset会返回给client，标记了一个defined文件区域的起始位置，这个区域包含了已追加记录。</li>
<li>GFS可能会插入填充或重复记录项。他们占据的区域被认为是inconsistent，且占用户数据总量的很小一部分。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Write</th>
<th>Record Append</th>
</tr>
</thead>
<tbody><tr>
<td>Serial success</td>
<td>defined（同时也是consistent）</td>
<td>defined interspersed with inconsistent</td>
</tr>
<tr>
<td>Concurrent success</td>
<td>consistent but undefined<br>1. 所有client都能看到相同的数据。<br>2. 但是这些数据并不能反映任何修改所写入的内容。<br>3. 这些数据一般包含混合了多个修改的片段。</td>
<td>defined interspersed with inconsistent</td>
</tr>
<tr>
<td>Failure</td>
<td>inconsistent（同时也是undefined）</td>
<td>inconsistent</td>
</tr>
</tbody></table>
<p>如何区分defined和undefined的文件区域？</p>
<p><em>在一些列的成功修改后，被修改的文件区域保证是defined</em>（？），且包含了最后一次修改所写入的数据。GFS通过以下方式来实现这个保证，</p>
<ol>
<li>在所有的副本上以相同的顺序对chunk进行修改。</li>
<li>用chunk版本号来检测过期的副本（由于chunkserver下线导致缺失修改）。<br> 过期的副本不会参与到修改或返回给client，会尽早的被gc掉。</li>
</ol>
<blockquote>
<p>不过这里我存疑，例如：concurrent write，并不能保证defined。</p>
</blockquote>
<p>某些client会cache chunk的位置。由于cache的timeout，读取到过期数据的时间窗是有限的。另外，对于大多数文件都是追加操作，一个过期的副本通常会返回过早结束（a premature end of chunk）的文件块，而非过期的数据。</p>
<p>在修改完成很长时间后，机器故障也会破坏或摧毁数据。GFS通过master和chunkserver定期的握手来检测失效的chunkserver，并通过校验和来检查数据损坏。当问题出现时，数据会尽快的从有效的副本进行恢复。如果在GFS来不及反应（没有足够的处理时间）的时候，所有的副本都丢失了，那应用能收到错误，而不是看到损坏的数据。</p>
<p><strong>Implications for Applications</strong><br>GFS应用可以通过一些已经用于其他目的的简单技术来适应宽松一致性模型，</p>
<ul>
<li>依赖追加而非覆盖，以及checkpointing<ul>
<li>例如：writer从头生成一个文件，待所有数据写入完毕以后，原子的把文件进行重命名。也可以定期创建checkpoints记录成功写入了多少。checkpoints也可以包含应用级别的校验和。readers只检查和处理至最后一个checkpoint之间的文件区域，这些文件区域是defined。</li>
<li>追加远比随机写要高效和有弹性的多。</li>
<li>checkpoint允许writer以增量的方式重新写入，并避免reader处理那些从应用的角度看仍是不完整的数据，尽管这些数据已被成功写入。</li>
</ul>
</li>
<li>写入时自我校验和自我识别的记录<ul>
<li>记录是以至少追加一次的语义来记录每个writer的输出的，因而reader需要处理偶然的填充和重复的情况。</li>
<li>writer写入的每个记录都包含额外的信息，例如校验和，用于验证。reader用校验和来识别并丢弃填充数据，以及记录片段。</li>
<li>如果无法容忍偶然出现的重复（例如，这些数据会触发非幂等的操作），那可以通过记录中的唯一标识来进行过滤。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Checkpointing allows writers to restart incrementally and keeps readers from processing successfully written file data that is still incomplete from the application’s perspective.<br>我没有完全理解所谓的从应用的角度看仍是不完整的数据，是指的最后一个checkpoint之后的那些数据？</p>
</blockquote>
<h2 id="系统交互"><a href="#系统交互" class="headerlink" title="系统交互"></a>系统交互</h2><p>GFS的设计可以最大限度的减少master参与到所有的操作。</p>
<h3 id="租约和修改顺序"><a href="#租约和修改顺序" class="headerlink" title="租约和修改顺序"></a>租约和修改顺序</h3><p>文件的修改发生在chunk的所有副本上，GFS使用租约来维护副本之间一致的修改顺序。master会将一个chunk的租借给其中一个副本，这个部分叫做主副本。主副本选择对chunk所有修改的序列顺序，所有的副本在应用这些修改的时候都会遵循这个顺序。最后，全局的修改顺序，首先由master选择的租借授权顺序定义（先选择某个副本为primary，然后可能又选择了另一个为primary），并在租期内由主副本分配的序列号定义。</p>
<p>租约机制的好处是最小化master的管理开销。</p>
<ul>
<li>租约起始的timeout是60s，但只要chunk还在被修改，主副本可以无限次的请求，然后（一般情况下）得到timeout的扩展。</li>
<li>timeout扩展的请求的授权是存放在master和所有chunkservers定期交互的心跳包里面的。</li>
<li>master可能会在租约过期前撤销（例如master要禁止一个正在rename的文件的修改）。</li>
<li>即使master丢失了与primary的通信，master也可以在老的租约过期后，将新的租约授权给另一个副本。</li>
</ul>
<p><img data-src="/images/2019/15589671997749.jpg" alt="-w368"></p>
<p>下面以写入为例说明整个过程，</p>
<ol>
<li>client向master请求持有租约的chunkserver以及其他副本的位置。如果租约未被持有，master会授权一个副本。</li>
<li>master返回给client primary的标识和其他副本的位置。client cache这些数据，且仅在无法连接到primary或primary不在持有租约的时候才会联系master。</li>
<li>client将数据推送到所有副本，任何顺序均可。每个chunkserver会将这些数据存储在内部的LRU缓存中，直至数据被使用或过期。</li>
<li>一旦所有副本确认收到数据以后，client向primary发送写请求。写请求标识了先前推送到所有副本的数据。<ul>
<li>primary为所有收到的修改（可能来自多个client）分配连续的序列号，序列号提供了必要的序列化（necessary serialization）。</li>
<li>primary将修改以序列号顺序应用到本地状态。</li>
</ul>
</li>
<li>primary向所有从副本转发写请求。每个从副本都以primary分配的相同序列号顺序应用修改。</li>
<li>所有从副本回复primary，表明已完成操作。</li>
<li>primary回复client。</li>
</ol>
<p>如果上述过程出错，</p>
<ul>
<li>任何副本发生错误，都会汇报给client。</li>
<li>如果在primary发生错误，序列号将不会被分配和转发。</li>
<li>client的请求被认为已失败，被修改的文件区域将处于不一致状态。</li>
<li>client会做重试，先会重试步骤3~7，如果不行，会完全从头重试写入。</li>
</ul>
<p>如果存在另一个并发写入到相同位置的client，</p>
<ul>
<li>前一个client写入的内容被后一个写入的覆盖</li>
<li>所有副本都有相同的数据，但是混合了来自两个client的数据，consistent but undefined。</li>
</ul>
<p>如果一个写入的数据很大或跨越了chunk的边界，GFS client会把数据打散成多个写操作。这些写操作遵循了上述流程，但是可能会与其他client的并发写操作交替和被覆盖。因此文件区域将会出现consistent but undefined的情况。</p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>从控制流解耦数据流是为了高效的使用网络，</p>
<ol>
<li>最大化利用每个机器的网络带宽<ul>
<li>数据以流水线的方式，沿着精心挑选的chunkservers链进行线性的推送，而非以其他拓扑形式来推送（例如：树）。</li>
<li>这样每个机器的所有出口带宽都会用书尽可能快的传输数据，而非将带宽拆分到多个接收者。</li>
</ul>
</li>
<li>避免网络瓶颈和高延迟的链路<ul>
<li>交换机链路通常有这两个问题。</li>
<li>每个机器会把数据转发到网络拓扑中最近（通过ip地址来估算）的且未收到数据的机器。</li>
</ul>
</li>
<li>最小化推送所有数据的延迟<ul>
<li>通过在TCP连接上以pipelining的方式进行数据传输来实现</li>
<li>一旦某个chunkserver收到一份数据，就立即开始转发。立即转发并不会降低接收数据的速度。</li>
<li>pipelining在使用全双工链路交换网络的情况下很有用。</li>
<li>在没有网络拥塞的情况下，传输一份R个副本B byte的数据，理想的时间开销是<code>B/T + RL</code>，T是网络吞吐量，L是机器间的传输延迟。</li>
</ul>
</li>
</ol>
<h3 id="Atomic-Record-Appends"><a href="#Atomic-Record-Appends" class="headerlink" title="Atomic Record Appends"></a>Atomic Record Appends</h3><p>GFS提供了原子追加记录的操作，叫做record append。</p>
<ul>
<li>传统的写操作中，client指定data需要写入的offset。并发写入到同一个区域是不可序列化的。</li>
<li>record append中，client指定data，GFS在自己选择的offset处以原子的方式至少一次追加数据到文件末尾，并将offset返回给client。</li>
</ul>
<p>record append是一种修改操作，遵循前面描述的控制流。</p>
<ol>
<li>client向文件最后一个chunk的所有副本推送数据，然后向primary发送请求。</li>
<li>primary检查追加到当前chunk是否会导致chunk超出大小限制。<ul>
<li>如果是，那么填充当前chunk，并告知从副本也填充。返回client需要在下一个chunk上重试。</li>
<li>追加记录被限制在<code>0.25 * maximum chunk size</code>，以限制碎片在可接受的范围内。</li>
<li>如果没有超过，那么primary进行追加，并告知从副本也在相同的offset追加，最后返回client操作成功。</li>
</ul>
</li>
<li>如果在任何副本上追加失败，client会重试。</li>
</ol>
<p>重试追加时，</p>
<ul>
<li>重试的结果是，同一个chunk的副本可能会包含不同的数据，可能包括部分或全部相同的记录。</li>
<li>GFS并不保证所有副本每个字节都是相同的，只能保证数据会以一个原子单位的形式至少一次写入。</li>
<li>对于一个成功的写入操作，数据一定写在某个chunk的<em>所有副本的相同offset位置</em>。在这之后，所有副本都至少与记录的结尾一样长。因此任何后续的记录，即使另一个副本成为primary的情况下，都会被分配到更高的offset，或者另一个chunk。</li>
</ul>
<h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>GFS使用copy-on-write的方式来实现文件或目录的快照，创建snapshot的速度很快。</p>
<ul>
<li>master收到快照请求时，首先撤销将要做snapshot的所有授权chunk的租约。</li>
<li>租约撤销或过期后，master在磁盘记录操作日志。接着通过复制文件或目录树的metadata，把日志应用到内存状态。新创建的文件快照与原文件指向相同的chunks。</li>
<li>client写入某个chunk C时，先通过master找到primary。master发现引用计数不唯1，选择一个新的chunk handle C’，并通知相关chunkserver本地复制创建C’。</li>
<li>最后client遵循前面的过程进行写入。</li>
</ul>
<blockquote>
<p>对目录进行snapshot的时候，复制的metadata是什么？</p>
</blockquote>
<h2 id="master操作"><a href="#master操作" class="headerlink" title="master操作"></a>master操作</h2><p>master执行，</p>
<ul>
<li>所有namespace的操作。</li>
<li>管理chunk副本的放置、创建、复制、以及与各种系统级活动协调来保证：chunk是完全备份的、平衡chunkserver的负载、回收未使用的空间。</li>
</ul>
<h3 id="namespace管理和锁"><a href="#namespace管理和锁" class="headerlink" title="namespace管理和锁"></a>namespace管理和锁</h3><p>GFS使用<em>完整路径名到metadata</em>的map来从逻辑上表示namespace。存储的时候使用前缀压缩。</p>
<p>锁以及加锁方式，</p>
<ul>
<li>namespace树的每个节点（绝对文件名或绝对目录名）都有关联的读写锁，读写锁是惰性分配的。</li>
<li>master进行每个操作前，都会对路径名<code>/d1/d2/.../dn</code>的每一级父目录加上读锁，并对<code>/d1/d2/.../dn/leaf</code>加上读锁或写锁，leaf可能是文件或目录。<br>  这里不需要对父级目录加写锁，因为并没有真正意义上的父级目录，也没有需要避免并发修改的数据。只要能防止被删除、重命名或被snapshot即可。</li>
<li>锁是以一个一致的全序来获取的，以避免死锁。首先按namespace树的层级排序，然后按同一级的字典序排序。</li>
</ul>
<h3 id="副本放置"><a href="#副本放置" class="headerlink" title="副本放置"></a>副本放置</h3><p>副本放在分布在多个机器内是不够的，还需要分布在不同的机架，放置策略有两个目的：</p>
<ul>
<li>最大化数据可靠性和可用性。</li>
<li>最大化带宽利用。</li>
</ul>
<h3 id="Creation，Re-replication，Rebalancing"><a href="#Creation，Re-replication，Rebalancing" class="headerlink" title="Creation，Re-replication，Rebalancing"></a>Creation，Re-replication，Rebalancing</h3><p>chunks在三种情况下会进行创建：</p>
<ol>
<li>master创建新chunk。<br> 创建时会考虑这些因素，<ul>
<li>chunkserver磁盘使用率低于平均值。</li>
<li>限制每个chunkserver最近创建数。结合上一点，如果不限制，那么对于一个空chunkserver，迁移时繁重的写操作，会导致磁盘I/O过高。</li>
<li>跨多个机架。</li>
</ul>
</li>
<li>副本数低于目标值（由于机器不可达、副本损坏、目标值增加），master重新创建副本。<ul>
<li>每个需要被re-replicated的chunk的优先级由多个指标衡量：低于目标值多少？优先为存在的文件（live files）创建而不是最近被删除的。优先创建任何阻塞了client操作的的chunk。</li>
<li>创建时，chunkserver会从有效的副本直接复制，会考虑1中的各种因素。</li>
<li>为了避免对client流量的影响，master会限制集群和每个chunkserver的clone数目。chunkserver会限制从源chunkserver的读请求来实现限速。</li>
</ul>
</li>
<li>平衡磁盘空间和负载。<ul>
<li>master定期进行rebalance，一般来说选择移除磁盘空闲空间低于平均值的。</li>
<li>新chunkserver会被逐渐的填满，而非立即将新chunk和写流量都直接打上去。</li>
</ul>
</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>当文件删除的时候，GFS不会立即回收物理存储。GFS会在定期的gc期间，在文件和chunk级别进行回收。</p>
<h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>当文件被删除的时候，</p>
<ul>
<li>master立即记录删除日志，并将文件重命名到一个包含删除时间的隐藏名字。</li>
<li>master定期扫描文件系统的namespace时，删除存在3天以上（可配置）的隐藏文件，这有效的切断了与chunks的连接。</li>
<li>master定期扫描chunk namespace，识别出孤儿chunk，并清除它们的metadata。</li>
<li>chunkserver与master的心跳包汇报了有哪些chunks，master告知哪些是已经不在metadata中的，可以自由删除。</li>
</ul>
<p>这个删除机制相比立即删除，有很多好处，</p>
<ul>
<li>在机器故障很常见的大规模分布式系统中，这个机制简单可靠。<br>  chunk的创建可能只在部分chunkserver上成功；副本删除消息可能丢失，master必须重发。</li>
<li>将存储回收合并到了mater常规的后台活动里。<br>  可以批量完成，开销被均摊了。</li>
<li>仅在master相对空闲的时候完成。</li>
<li>延迟回收提供了应对意外、不可逆删除的保障。</li>
</ul>
<p>最大的缺点是，延迟机制妨碍了用户在存储紧张的时候，对空间使用的调优。</p>
<ul>
<li>GFS通过加快对再次明确删除已删除的文件的回收来解决这一问题。</li>
<li>GFS还允许对namespace的不同部分设置不同的复制和回收机制。</li>
</ul>
<h2 id="过期副本检测（Stale-Replica-Detection）"><a href="#过期副本检测（Stale-Replica-Detection）" class="headerlink" title="过期副本检测（Stale Replica Detection）"></a>过期副本检测（Stale Replica Detection）</h2><p>副本在chunkserver失败且错过修改的时候会过期。</p>
<ul>
<li>master维护了一个<em>chunk version number</em>来区分最新和过期的副本。在授权租约前，master会增加chunk version number，并通知所有最新的副本。master和所有副本都会将版本号进行持久化存储。</li>
<li>失败的chunkserver在重启后，master通过心跳包可得知副本过期。</li>
<li>反过来，如果chunkserver的版本号高于master记录的，master会假设在授权的时候自己失败了，并把更高的版本号作为最新的。</li>
<li>过期的副本使用gc进移除。</li>
<li>mater把primary返回给client的时候，以及通知chunkserver进行clone副本的时候，会带上版本号，二者会检查版本号以保证访问到最新的数据。</li>
</ul>
<h2 id="容错和诊断"><a href="#容错和诊断" class="headerlink" title="容错和诊断"></a>容错和诊断</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>GFS通过两个简单却有效的策略来实现系统高可用：快速恢复、副本。</p>
<ul>
<li>快速恢复<ul>
<li>master和chunkserver可快速启动。</li>
<li>不区分正常和非正常终止。</li>
</ul>
</li>
<li>chunk副本<ul>
<li>除副本外，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Erasure_code">erasure coding</a>对于只读的场景，也是有用的。</li>
</ul>
</li>
<li>master副本<ul>
<li>为了master状态的可靠性，操作日志和checkpoint会被复制到多个机器上。只有<em>flush到本地和所有远程机器</em>上的修改，才认为是已经提交了的。</li>
<li>提交与写入数据的顺序是什么，在写入数据完成前还是后？</li>
<li>如果在log复制到多个机器前，master挂了？如果未复制log无法恢复？</li>
<li>shadow master<ul>
<li>提供了文件系统的只读访问，因为log可能落后于master；不可写，会导致脑裂。</li>
<li>与primary相同的顺序apply操作日志。</li>
<li>启动时定位chunk副本的位置（启动后就不会很频繁），并定期与chunkserver通信监控它们的状态。</li>
<li>仅当primary更新副本位置时，需要依赖master。</li>
<li>可被晋升为master。</li>
</ul>
</li>
<li>主从切换是如何进行的？</li>
</ul>
</li>
</ul>
<h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><ul>
<li>chunkserver使用checksum来检查数据损坏。<ul>
<li>直接对比两个chunkserver上的副本是不不现实的。</li>
<li>两个不同的副本<em>可能是</em>合法的（详见<a href="#Atomic-Record-Appends">Atomic Record Appends</a>）。</li>
<li>每个chunkserver必须独立维护checksum来维护副本完整性。</li>
</ul>
</li>
</ul>
<p>chunk结构：</p>
<ul>
<li>细分为64KB block。</li>
<li>每个block都有32bit checksum。</li>
<li>保留在内存中，且与log一起持久化存储，和用户数据分离。</li>
</ul>
<p>对于读操作：</p>
<ul>
<li>在返回给client或chunkserver前，会检查与读取范围重叠的部分。因此损坏的数据不会传播开。</li>
<li>如果checksum不匹配，返回错误给请求方，并通知master。请求方会读取其他副本，master会从其他副本clnoe数据。新副本到位后，通知chunkserver删除错误的副本。</li>
</ul>
<p>checksum对（读和追加）性能的影响较小：</p>
<ol>
<li><p>读</p>
<ul>
<li>绝大多数读只跨越少数几个block，因此只需要对少量数据进行校验checksum。</li>
<li>GFS client在读取是对尝试对齐checksum block的边界。</li>
<li>checksum的查找和比较不需要做I/O，checksum的计算可以和I/O同时进行。</li>
</ul>
</li>
<li><p>追加</p>
<ul>
<li><p>只需要增量的更新最后一个block的last partial checksum，并计算后续新block的checksum。</p>
</li>
<li><p>计算last partial checksum block已经损坏，现在无法检测到它，新的checksum也将与存储的数据不匹配，并且在下次读取时将像往常一样检测到损坏。</p>
<blockquote>
<p>现在无法检测到它（we fail to detect it now），这具体指的是？</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>但对于覆盖现有chunk某个range的写操作，必须先读取和检查被覆盖range的首个和最后一个block（为了避免新的checksums可能隐藏存在于未被覆盖区域内的数据损坏），然后写入，最后计算和存储新的checksum。</p>
<h3 id="诊断工具"><a href="#诊断工具" class="headerlink" title="诊断工具"></a>诊断工具</h3><p>大规模和细致的诊断日志可以极大帮助问题隔离、debug和性能分析，且只有很小的开销。</p>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><p>以下问题部分是我自己提出，部分来自<a target="_blank" rel="noopener" href="https://github.com/feixiao/Distributed-Systems/blob/master/Lec03_GFS/Question.md">Distributed-Systems/Lec03_GFS/Question.md</a></p>
<ul>
<li>为什么存储三个副本？而不是两个或者四个？</li>
<li>为什么不适用RAID？<br>  重点是整机的容错，而非存储设备的容错。</li>
<li>chunk的大小为何选择64MB？这个选择主要基于哪些考虑？<ul>
<li>减少了client与master交互的需求。</li>
<li>由于chunk较大，client也较为可能在一个给定的chunk上进行很多的操作。</li>
<li>减少了存储在master上metadata的大小。</li>
</ul>
</li>
<li>master的checkpoint与application checkpointing的区别是什么？</li>
<li>论文提到append机制可以用于multiple-producer/single-consumer queues，这个具体是如何实现的？</li>
<li>GFS主要支持追加（append）、改写（overwrite）操作比较少。为什么这样设计？如何基于一个仅支持追加操作的文件系统构建分布式表格系统Bigtable？</li>
<li>为什么要将数据流和控制流分开？如果不分开，如何实现追加流程？<ul>
<li>最大化利用每个机器的网络带宽</li>
<li>避免网络瓶颈和高延迟的链路</li>
<li>最小化推送所有数据的延迟</li>
</ul>
</li>
<li>GFS有时会出现重复记录或者补零记录（padding），为什么？</li>
<li>租约（lease）是什么？在GFS起什么作用？它与心跳（heartbeat）有何区别？</li>
<li>GFS追加操作过程中如果备副本（secondary）出现故障，如何处理？如果主副本（primary）出现故障，如何处理？</li>
<li>GFS master需要存储哪些信息？master数据结构如何设计？</li>
<li>假设服务一千万个文件，每个文件1GB，master中存储的元数据大概占用多少内存？</li>
<li>master如何实现高可用性？</li>
<li>负载的影响因素有哪些？如何计算一台机器的负载值？</li>
<li>master新建chunk时如何选择chunkserver？如果新机器上线，负载值特别低，如何避免其他chunkserver同时往这台机器迁移chunk？</li>
<li>如果某台chunkserver报废，GFS如何处理？</li>
<li>如果chunkserver下线后过一会重新上线，GFS如何处理？</li>
<li>如何实现分布式文件系统的快照操作？</li>
<li>chunkserver数据结构如何设计？</li>
<li>磁盘可能出现“位翻转”错误，chunkserver如何应对？</li>
<li>chunkserver重启后可能有一些过期的chunk，master如何能够发现？</li>
</ul>
<h1 id="Lectures"><a href="#Lectures" class="headerlink" title="Lectures"></a>Lectures</h1><h2 id="什么是一致性？"><a href="#什么是一致性？" class="headerlink" title="什么是一致性？"></a>什么是一致性？</h2><ul>
<li>正确性条件</li>
<li>重要但是当存在数据副本的时候难以实现，尤其是应用并发访问时</li>
<li>弱一致性<br>  <code>read()</code>可能返回过期的数据。</li>
<li>强一致性<br>  <code>read()</code>使用返回最近<code>write()</code>的数据。</li>
</ul>
<h2 id="“理想”的一致性模型"><a href="#“理想”的一致性模型" class="headerlink" title="“理想”的一致性模型"></a>“理想”的一致性模型</h2><ul>
<li>一个存在副本的FS行为和不存在副本的FS一样。</li>
<li>读可以观察到最近的写。</li>
</ul>
<h2 id="实现“理想”的一致性模型的挑战"><a href="#实现“理想”的一致性模型的挑战" class="headerlink" title="实现“理想”的一致性模型的挑战"></a>实现“理想”的一致性模型的挑战</h2><ul>
<li>并发</li>
<li>机器失败：任何操作都可能失败</li>
<li>网络分区：每个机器/磁盘不是总能访问到的</li>
<li>为什么这些挑战难以克服？<ul>
<li>需要c/s间的通信：可能影响性能</li>
<li>复杂的协议：难以正确的实现</li>
<li>不少系统没有提供理想的一致性模型</li>
</ul>
</li>
</ul>
<h2 id="GFS是否实现了“理想”的一致性模型"><a href="#GFS是否实现了“理想”的一致性模型" class="headerlink" title="GFS是否实现了“理想”的一致性模型"></a>GFS是否实现了“理想”的一致性模型</h2><ul>
<li>对于目录：实现了<ul>
<li>强一致性，只有一个副本</li>
<li>不是高可用，可扩展性受限</li>
</ul>
</li>
<li>对于文件：不总是</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>GFS优秀的地方：<ul>
<li>顺序读写性能高</li>
<li>追加</li>
<li>吞吐量大</li>
<li>数据容错</li>
</ul>
</li>
<li>GFS不好的地方：<ul>
<li>master容错</li>
<li>小文件（master是瓶颈）</li>
<li>client可能看到过期的数据</li>
<li>追加可能重复</li>
</ul>
</li>
</ul>
<h1 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h1><ul>
<li>Lecture 3没有关于GFS的实验，不过我找到了<a target="_blank" rel="noopener" href="https://bitbucket.org/abcdabcd987/ppca-gfs/src/master/">ppca-gfs</a>，看介绍是上交ACM班一个课程的作业，就用这个来补上GFS的实验吧。</li>
<li>lab的代码在<a target="_blank" rel="noopener" href="https://github.com/chaomai/mit-6.824/tree/master/ppca-gfs">github.com/chaomai/mit-6.824</a></li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a target="_blank" rel="noopener" href="http://queue.acm.org/detail.cfm?id=1594206">Case Study GFS: Evolution on Fast-forward</a></li>
<li><a target="_blank" rel="noopener" href="http://highscalability.com/blog/2010/9/11/googles-colossus-makes-search-real-time-by-dumping-mapreduce.html">Google’s Colossus Makes Search Real-Time By Dumping MapReduce</a></li>
<li>大规模分布式存储系统：原理解析与架构实战</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-05-23-apache-yarn-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-05-23-apache-yarn-notes/" class="post-title-link" itemprop="url">Apache Hadoop YARN笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-23 21:49:24" itemprop="dateCreated datePublished" datetime="2019-05-23T21:49:24+08:00">2019-05-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/yarn/" itemprop="url" rel="index"><span itemprop="name">yarn</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-05-23-apache-yarn-notes/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-05-23-apache-yarn-notes/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>YARN（Yet Another Resource Negotiator）是Hadoop的资源管理系统。</p>
<p>YARN把资源管理和任务的调度/监控拆分到了独立的进程，即ResourceManager（RM）和每个程序的ApplicationMaster，一个程序要么是一个单独的job或者是由DAG表示的多个job。</p>
<p>RM和NodeManager（NM）构成了数据计算的框架。RM拥有最大的权利来决断系统中每个程序所需的资源。NM是每个机器上的一个代理，负责container的管理，监控它们资源使用（cpu、内存、磁盘、网络），并汇报给RM。</p>
<p>每个程序的ApplicationMaster是框架的特定库，负责与RM协商资源，并与NMs一起工作来执行和监控任务。</p>
<p>RM有两个组成部分：Scheduler和ApplicationsManager（AM）。</p>
<p>Scheduler，在容量和队列的限制下，负责为各种程序分配资源。Scheduler只负责调度，不负责监控和跟踪程序的状态；也不为由于程序错误或硬件错误导致的任务失败提供重启保证。Scheduler基于程序的资源需求来执行调度功能；进一步说，是基于对资源的抽象，即Container（cpu、内存、磁盘、网络）来进行调度的。</p>
<p>Scheduler有一个可插拔策略，负责在各种队列和程序之间对集群资源进行划分。例如当前的scheduler有CapacityScheduler和FairScheduler。</p>
<p>AM负责接收job的提交、协商第一个container来运行程序的ApplicationMaster，以及为出错的ApplicationMaster container提供重启服务。每个程序的ApplicationMaster负责与Scheduler协商资源适当的的container，并追踪它们的状态和监控进度。</p>
<p>通过ReservationSystem，YARN还支持资源预定。</p>
<h1 id="YARN应用的运行"><a href="#YARN应用的运行" class="headerlink" title="YARN应用的运行"></a>YARN应用的运行</h1><p><img data-src="/images/2019/15585937581379.jpg"></p>
<h2 id="资源请求"><a href="#资源请求" class="headerlink" title="资源请求"></a>资源请求</h2><p>YARN的资源请求模型会考虑，</p>
<ul>
<li>每个容器需要的资源。</li>
<li>局部性（主要指数据的局部性）。<br>  例如如果使用了HDFS的数据，会优先使用存放副本的结点，其次是存有这些副本的机架，最后才是集群的任意结点。</li>
</ul>
<p>YARN应用可以在任意时刻提出资源的申请，</p>
<ul>
<li>在一开始就申请所有的资源。</li>
<li>以动态的方式，在需要更多资源的时候提出。</li>
</ul>
<h2 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h2><p>按照应用的类型，应用的生命周期会有较大差异，主要分为以下3个模型，</p>
<ol>
<li>一个应用对应一个用户的job，例如MR任务。</li>
<li>一个应用对应一个工作流或用户jobs的session，container可以在job之间复用，并cache数据，例如Spark。</li>
<li>一个长期运行的应用被多个用户共享。这样的应用一般作为协调者的角色存在。</li>
</ol>
<h1 id="YARN优势"><a href="#YARN优势" class="headerlink" title="YARN优势"></a>YARN优势</h1><ul>
<li>可扩展性（Scalability）<br>  每个应用都有一个专门的application master，分离了资源调度和task管理。就MR任务而言，这模型与Google MapReduce论文中所述的模型更加接近，即，一个master协调worker上的map和reduce任务。</li>
<li>可用性（Availability）<br>  拆分RM和application master简化了高可用的实现。先为RM提供高可用，再为YARN应用提供高可用。</li>
<li>利用率（Utilization）<br>  相比MapReduce 1，精细化了资源的管理，应用可以按需请求资源。</li>
<li>多租户（Multitenancy）<br>  YARN支持除MapReduce外的其他分布式计算框架。</li>
</ul>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><p>YARN有3中调度器：FIFO调度器、容量调度器和公平调度器。</p>
<h2 id="关于container"><a href="#关于container" class="headerlink" title="关于container"></a>关于container</h2><p>vcore是一个host的cpu核心占用比例。</p>
<p>container是，</p>
<ul>
<li>cpu（vcore）、内存、磁盘、网络的抽象。</li>
<li>在有task或ApplicationMaster运行的时候，表示一个已分配的资源。</li>
<li><em>不同</em>于docker中的container概念。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerLaunchContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add the list of &lt;em&gt;commands&lt;/em&gt; for launching the container. All</span></span><br><span class="line"><span class="comment">   * pre-existing List entries are cleared before adding the new List</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> commands the list of &lt;em&gt;commands&lt;/em&gt; for launching the container</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Public</span></span><br><span class="line">  <span class="meta">@Stable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setCommands</span><span class="params">(List&lt;String&gt; commands)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FIFO调度器（FIFO-Scheduler）"><a href="#FIFO调度器（FIFO-Scheduler）" class="headerlink" title="FIFO调度器（FIFO Scheduler）"></a>FIFO调度器（FIFO Scheduler）</h2><p>按提交的顺序运行应用，首先为第一个应用分配资源，如果可以满足，再依次为其他应用服务。</p>
<h2 id="容量调度器（Capacity-Scheduler）"><a href="#容量调度器（Capacity-Scheduler）" class="headerlink" title="容量调度器（Capacity Scheduler）"></a>容量调度器（Capacity Scheduler）</h2><p>为每个组织分配一个专门的队列，每个队列可配置为使用一定量的集群资源，队列可以再进行划分。同一个队列内使用FIFO策略进行调度。</p>
<p>关于资源的使用，</p>
<ul>
<li>队列中单个任务使用的资源不会超过队列的容量。</li>
<li>如果队列满，且集群有空闲的资源，调度器可以把资源分配给此队列（可配置），弹性队列。</li>
<li>正常情况下，容量调度器不会抢占容器，因此如果一个队列随着使用，资源不够时，只能等待其他队列释放资源。<br>  容量调度器也可以执行work-preserving preemption，RM会请求应用返回容器。</li>
</ul>
<h2 id="公平调度器（Fair-Scheduler）"><a href="#公平调度器（Fair-Scheduler）" class="headerlink" title="公平调度器（Fair Scheduler）"></a>公平调度器（Fair Scheduler）</h2><ul>
<li>每个队列有权重元素，用于fair share的计算。</li>
<li>默认队列和动态创建的队列，权重为1（默认队列的可配置）。</li>
<li>调度器会使用最小资源数量来进行资源分配进行优先排序。如果两个队列的资源都低于fair share额度，那么远低于最小资源数量的队列，会被有限分配资源。</li>
</ul>
<h3 id="队列放置"><a href="#队列放置" class="headerlink" title="队列放置"></a>队列放置</h3><p>公平调度器使用一个规则的系统来判断应用所属队列。</p>
<h3 id="饥饿和抢占"><a href="#饥饿和抢占" class="headerlink" title="饥饿和抢占"></a>饥饿和抢占</h3><p>FairShare的计算会被用于判断饥饿以及是否进行抢占。在计算FairShare时，有两种：</p>
<ul>
<li>Steady FairShare，按照配置文件中所有queue的weight，计算出的。</li>
<li>Instantaneous FairShare，，按照配置文件中所有queue的weight，仅对包含活动应用程序的queue计算出的。</li>
</ul>
<p>在配置<code>yarn.scheduler.fair.preemption</code>和<code>yarn.scheduler.fair.preemption.cluster-utilization-threshold</code>后，抢占会启用。</p>
<p><strong>饥饿</strong>有两种：</p>
<ul>
<li><p>FairShare Starvation<br>  判定条件为：</p>
<ol>
<li><p>未获得所要求的资源。</p>
</li>
<li><p>应用程序资源使用低于Instantaneous FairShare。</p>
</li>
<li><p>应用程序的资源使用低于fairSharePreemptionThreshold，并持续fairSharePreemptionTimeout。</p>
<p>要注意的是，在同一个队列里面，如果存在多个应用程序，它们会平均的分摊Instantaneous FairShare。因此可能存在队列整体不是饥饿状态，但是每个应用程序是。</p>
</li>
</ol>
</li>
<li><p>MinShare Starvation<br>  判定条件为：</p>
<ol>
<li>未获得所要求的资源。</li>
<li>应用程序资源使用低于MinShare。</li>
<li>应用程序的资源使用低于MinShare，并持续MinSharePreemptionTimeout。</li>
</ol>
</li>
</ul>
<p>决定需要进行抢占的时候，可能在多个队列中都有可抢占的container，决定container是否可以被抢占，需要满足：</p>
<ul>
<li>所在队列是可抢占的。</li>
<li>杀死container以后不会导致应用程序的资源低于Instantaneous FairShare。</li>
</ul>
<p>启用抢占<strong>并不能</strong>保证队列或应用程序能够获得所有的Instantaneous FairShare。只能最终保证脱离饥饿的状态，即获得fairSharePreemptionThreshold份额的资源。</p>
<p>FairShare Starvation、MinShare Starvation以及抢占的关系如下：</p>
<p><img data-src="/images/2019/15598134204968.jpg"></p>
<h3 id="Best-Practice"><a href="#Best-Practice" class="headerlink" title="Best Practice"></a>Best Practice</h3><ul>
<li>一般<strong>不建议</strong>配置MinShare Starvation或minimum resources。<br>  增加复杂性的同时，并不能带来多少好处。</li>
<li>如果配置minimum resources，所有minimum resources的加和不能超出总的资源数。</li>
</ul>
<h2 id="延迟调度"><a href="#延迟调度" class="headerlink" title="延迟调度"></a>延迟调度</h2><p>局部性是YARN调度时优先考虑的，但如果发现所请求的节点资源不够，那么任务可能就会被调度到其他节点上了。此时如果等待几秒，能够增加在所请求节点上分配到container的机会。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a target="_blank" rel="noopener" href="http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html">Apache Hadoop YARN</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.cloudera.com/blog/2015/09/untangling-apache-hadoop-yarn-part-1/">Untangling Apache Hadoop YARN</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.cloudera.com/blog/2018/06/yarn-fairscheduler-preemption-deep-dive/">YARN FairScheduler Preemption Deep Dive</a></li>
<li>Hadoop - The Definitive Guide</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-05-13-notes-of-python-concurrency-from-the-ground-up/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-05-13-notes-of-python-concurrency-from-the-ground-up/" class="post-title-link" itemprop="url">David Beazley - Python Concurrency From the Ground Up笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-13 00:17:47" itemprop="dateCreated datePublished" datetime="2019-05-13T00:17:47+08:00">2019-05-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/concurrency/" itemprop="url" rel="index"><span itemprop="name">concurrency</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-05-13-notes-of-python-concurrency-from-the-ground-up/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-05-13-notes-of-python-concurrency-from-the-ground-up/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Python Concurrency From the Ground Up，来自<a target="_blank" rel="noopener" href="https://pythonhunter.org/episodes/1">捕蛇者说</a>的推荐，是David Beazley在PyCon 2015上的talk。在这个talk中，他边讲边写、外加开点玩笑，可以说David在各种意义上，都是并发的专家，很值得一看。视频和代码如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=MCs5OvhV9S4">David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dabeaz/concurrencylive">dabeaz/concurrencylive</a></li>
</ul>
<p>本文记录了这个talk的主要内容，并加上了我自己的理解。</p>
<p>这个talk从零实现了一个能支持多客户端并发访问的server，server计算了菲波那切数列第n项的值，为了展示blocking调用，用的是普通的递归实现<code>fib(n) = fib(n-1) + fib(n-2)</code>。同时还写了两个简单的client来测试server性能：<code>perf1.py</code>无限循环<code>fib(30)</code>，并输出每次调用的时间；<code>perf2.py</code>无限循环<code>fib(1)</code>，测试ops，这个调用是立即返回的。</p>
<h1 id="版本1：简单单线程"><a href="#版本1：简单单线程" class="headerlink" title="版本1：简单单线程"></a>版本1：简单单线程</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_server</span>(<span class="params">address</span>):</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        print(<span class="string">&quot;Connection&quot;</span>, addr)</span><br><span class="line">        fib_handler(client)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        req = client.recv(<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> req:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n = <span class="built_in">int</span>(req)</span><br><span class="line">        result = fib(n)</span><br><span class="line">        resp = <span class="built_in">str</span>(result).encode(<span class="string">&#x27;ascii&#x27;</span>) + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">        client.send(resp)</span><br><span class="line">    print(<span class="string">&quot;Closed&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个实现的问题是，server无法同时响应多个client。当某个client连接上后，<code>fib_handler(client)</code>会执行到这个client断开为止。</p>
<h1 id="版本2：多线程"><a href="#版本2：多线程" class="headerlink" title="版本2：多线程"></a>版本2：多线程</h1><p>在版本1的基础上，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_server</span>(<span class="params">address</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        print(<span class="string">&quot;Connection&quot;</span>, addr)</span><br><span class="line">        Thread(target=fib_handler, args=(client,), daemon=<span class="literal">True</span>).start()</span><br></pre></td></tr></table></figure>

<p>此时server可以响应多个client。但是由于GIL的存在，python是无法利用多个cpu核心的，因此，</p>
<ol>
<li><code>perf1.py</code>的结果（每次调用的时间）会随着<code>perf1.py</code>实例的增加而增加。同一时刻只能响应一个client，其他的等待，因此每次调用的时间大概是<code>单个client调用时间的均值 * perf1.py实例个数</code>。</li>
<li><code>perf2.py</code>的结果（ops）会受其他调用的影响，ops会下降，<code>n</code>越大，下降越多。David这里提到了，GIL的一个特性是会把优先级给到计算更加密集的任务上，而os的调度却不会受这个影响，运行时间短的任务优先级更高。</li>
</ol>
<p>python的每个线程实际上都有os实际的线程与其对应，用<code>ps -o cmd,nlwp &lt;pid&gt;</code>可看，但为何如此调度与其实现有关。对于os，Linux 2.6.23开始采用的是<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt">Completely Fair Scheduler</a>；FreeBSD和macOS采用的是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scheduling_(computing)">Multilevel feedback queue</a>的调度算法，这也就解释了上述为什么运行时间较短的任务优先级更高。因为总能在规定的时间片内运行完成，不会被调度到后面的队列。</p>
<h1 id="版本3：多线程-进程池"><a href="#版本3：多线程-进程池" class="headerlink" title="版本3：多线程+进程池"></a>版本3：多线程+进程池</h1><p>在版本2的基础上，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor <span class="keyword">as</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        future = pool.submit(fib, n)</span><br><span class="line">        result = future.result()</span><br></pre></td></tr></table></figure>

<p>由于需要与子进程通信，需要序列化和反序列化数据，引入了额外的开销，因此<code>perf2.py</code>的ops会下降；但与此同时，server端处理计算任务是在单独的进程中，相当于计算任务的调度是由os来完成了，结合<a href="#%E7%89%88%E6%9C%AC2%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B">版本2：多线程</a>中对os调度的解释，基本不受其他计算更加密集的任务影响。</p>
<h1 id="版本4：事件循环和协程"><a href="#版本4：事件循环和协程" class="headerlink" title="版本4：事件循环和协程"></a>版本4：事件循环和协程</h1><p>回看前三个版本的server，使用线程，本质上是为了解决blocking。而blocking主要发生在等待io的时候，可以考虑只有当io ready的时候才去处理socket。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">tasks = deque()</span><br><span class="line">recv_wait = &#123; &#125;   <span class="comment"># Mapping sockets -&gt; tasks (generators)</span></span><br><span class="line">send_wait = &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">any</span>([tasks, recv_wait, send_wait]):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> tasks:</span><br><span class="line">            <span class="comment"># No active tasks to run</span></span><br><span class="line">            <span class="comment"># wait for I/O</span></span><br><span class="line">            can_recv, can_send, _ = select(recv_wait, send_wait, [])</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> can_recv:</span><br><span class="line">                tasks.append(recv_wait.pop(s))</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> can_send:</span><br><span class="line">                tasks.append(send_wait.pop(s))</span><br><span class="line"></span><br><span class="line">        task = tasks.popleft()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            why, what = <span class="built_in">next</span>(task)   <span class="comment"># Run to the yield</span></span><br><span class="line">            <span class="keyword">if</span> why == <span class="string">&#x27;recv&#x27;</span>:</span><br><span class="line">                <span class="comment"># Must go wait somewhere</span></span><br><span class="line">                recv_wait[what] = task</span><br><span class="line">            <span class="keyword">elif</span> why == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">                send_wait[what] = task</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;ARG!&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            print(<span class="string">&quot;task done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSocket</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sock</span>):</span></span><br><span class="line">        self.sock = sock</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">self, maxsize</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;recv&#x27;</span>, self.sock</span><br><span class="line">        <span class="keyword">return</span> self.sock.recv(maxsize)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;send&#x27;</span>, self.sock</span><br><span class="line">        <span class="keyword">return</span> self.sock.send(data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;recv&#x27;</span>, self.sock</span><br><span class="line">        client, addr = self.sock.accept()</span><br><span class="line">        <span class="keyword">return</span> AsyncSocket(client), addr</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.sock, name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_server</span>(<span class="params">address</span>):</span></span><br><span class="line">    sock = AsyncSocket(socket(AF_INET, SOCK_STREAM))</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = <span class="keyword">yield</span> <span class="keyword">from</span> sock.accept()  <span class="comment"># blocking</span></span><br><span class="line">        print(<span class="string">&quot;Connection&quot;</span>, addr)</span><br><span class="line">        tasks.append(fib_handler(client))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        req = <span class="keyword">yield</span> <span class="keyword">from</span> client.recv(<span class="number">100</span>)   <span class="comment"># blocking</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> req:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n = <span class="built_in">int</span>(req)</span><br><span class="line">        result = fib(n)</span><br><span class="line">        resp = <span class="built_in">str</span>(result).encode(<span class="string">&#x27;ascii&#x27;</span>) + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> client.send(resp)    <span class="comment"># blocking</span></span><br><span class="line">    print(<span class="string">&quot;Closed&quot;</span>)</span><br><span class="line"></span><br><span class="line">tasks.append(fib_server((<span class="string">&#x27;&#x27;</span>,<span class="number">25000</span>)))</span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<p>这个版本的核心在<code>def run()</code>，利用<code>yield</code>实现了协程。当遇到io时，<code>yield</code>跳出当前执行，<code>select</code>判断io ready后，才去读写socket。要注意的是，这个版本虽然没有使用多线程，但server是可以服务多个client的，因为在某个client的socket没有ready的时候，server可以做其他的事情。不过由于是单线程，对于所有client提交的计算任务，server只能逐一执行。协程并不能帮助解决多线程中GIL的问题，因为并没有利用到多个cpu核心，<a href="#%E7%89%88%E6%9C%AC2%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B">版本2：多线程</a>的两个性能问题，这里都存在。</p>
<p>我觉得这里的<code>yield</code>和事件循环是用的很出彩，换做是我，我首先考虑到的是<code>select</code>出ready的socket，然后进行读写。弊端在于需要把业务逻辑套在一个大循环里面，每次都先调用<code>select</code>，在不同的socket ready的时候，使用相应的业务逻辑进行处理。</p>
<h1 id="版本5：事件循环和协程-多进程"><a href="#版本5：事件循环和协程-多进程" class="headerlink" title="版本5：事件循环和协程+多进程"></a>版本5：事件循环和协程+多进程</h1><p>在版本4的基础上，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        future = pool.submit(fib, n)</span><br><span class="line">        result = future.result()    <span class="comment">#  Blocks</span></span><br></pre></td></tr></table></figure>

<p>考虑到上一个版本无法利用多个cpu核心进行计算，那么如果像<a href="#%E7%89%88%E6%9C%AC3%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B+%E8%BF%9B%E7%A8%8B%E6%B1%A0">版本3：多线程+进程池</a>一样把<code>fib</code>放入<code>pool</code>中，是否能解决问题呢？放入以后，会发现当某个协程执行到’future.result()’的时候就会阻塞，直到<code>pool</code>中的任务计算完毕，相当于server主线程会逐一等待每个计算任务。<a href="#%E7%89%88%E6%9C%AC2%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B">版本2：多线程</a>的两个问题，仍然存在。</p>
<h1 id="版本6：事件循环和协程-多进程"><a href="#版本6：事件循环和协程-多进程" class="headerlink" title="版本6：事件循环和协程+多进程"></a>版本6：事件循环和协程+多进程</h1><p>在版本5的基础上，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">future_wait = &#123; &#125;</span><br><span class="line"></span><br><span class="line">future_notify, future_event = socketpair()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">future_done</span>(<span class="params">future</span>):</span></span><br><span class="line">    tasks.append(future_wait.pop(future))</span><br><span class="line">    future_notify.send(<span class="string">b&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">future_monitor</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;recv&#x27;</span>, future_event</span><br><span class="line">        future_event.recv(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">tasks.append(future_monitor())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        task = tasks.popleft()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            why, what = <span class="built_in">next</span>(task)   <span class="comment"># Run to the yield</span></span><br><span class="line">            <span class="keyword">if</span> why == <span class="string">&#x27;recv&#x27;</span>:</span><br><span class="line">                <span class="comment"># Must go wait somewhere</span></span><br><span class="line">                recv_wait[what] = task</span><br><span class="line">            <span class="keyword">elif</span> why == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">                send_wait[what] = task</span><br><span class="line">            <span class="keyword">elif</span> why == <span class="string">&#x27;future&#x27;</span>:</span><br><span class="line">                future_wait[what] = task</span><br><span class="line">                what.add_done_callback(future_done)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        future = pool.submit(fib, n)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;future&#x27;</span>, future</span><br><span class="line">        result = future.result()    <span class="comment">#  Blocks</span></span><br></pre></td></tr></table></figure>

<p>最后这个实现首先将<code>result = fib(n)</code>，放入了<code>pool</code>并得到一个<code>future</code>，<code>yeild</code>之后为这个future添加计算完成后的回调<code>future_done</code>。这个<code>pool</code>可以是线程池（无法利用多个cpu），也可以是进程池。比较hacking的地方是用<code>socketpair</code>把计算ready转变了socket ready。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除去实现中用到的一些技巧，这个talk把GIL和blocking的影响、要用什么样的方式来绕开这些问题，以及事件循环和协程讲的很明白。</p>
<p>P.S. 小插曲，现场写的时候，David把</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can_recv, can_send, _ = select(recv_wait, send_wait, [])</span><br></pre></td></tr></table></figure>

<p>写成了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can_recv, can_send, [] = select(recv_wait, send_wait, [])</span><br></pre></td></tr></table></figure>

<p>最后有个提问者表示，<em>the empty listing was just some incredible next-level thing that I was just not capable of</em>。</p>
<p>至于为什么unpack到空list，原因如下，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先unpack到一个变量的list是可以的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, [x, y] = <span class="number">1</span>, <span class="number">2</span>, [<span class="number">10</span>, <span class="number">20</span>]  <span class="comment"># a=1, b=2, x=10, y=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果对一个空list进行unpack，由于没有东西可以unpack，所以可以解到另一个空的list里面</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, [] = <span class="number">1</span>, <span class="number">2</span>, []   <span class="comment"># a=1, b=2</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-05-12-night-sky-in-kunming-and-baotou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-05-12-night-sky-in-kunming-and-baotou/" class="post-title-link" itemprop="url">云南昆明和内蒙包头的星空</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-12 13:55:23" itemprop="dateCreated datePublished" datetime="2019-05-12T13:55:23+08:00">2019-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/photography/" itemprop="url" rel="index"><span itemprop="name">photography</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-05-12-night-sky-in-kunming-and-baotou/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-05-12-night-sky-in-kunming-and-baotou/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一直很想拍到繁星点点的夜空，毕竟自己拍到和看网上别人拍的照片是完全不一样的体验。</p>
<p>下面两张图片，分别拍摄于过年时的云南昆明和五一的内蒙包头，用lr进行了简单的调整。</p>
<p><img data-src="/images/2019/DSC02905.jpg"><br><em>云南昆明，2019-02-08 23:57</em></p>
<p><img data-src="/images/2019/DSC04001.jpg"><br><em>内蒙包头，2019-05-02 23:49</em></p>
<p>两张的拍摄参数类似，受限于光圈不大，并且为了画面相对纯净调低了iso，因此为了得到足够多的进光量，就拉长了曝光时间，其实可以考虑拍摄多张进行叠加的（懒…。拍摄的时候还缺少三脚架，都是随手找几块砖头堆起来。</p>
<p>看来为了以后的户外拍摄，又得剁手了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-03-17-golang-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-03-17-golang-notes/" class="post-title-link" itemprop="url">Go笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-03-17 14:22:40" itemprop="dateCreated datePublished" datetime="2019-03-17T14:22:40+08:00">2019-03-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-03-17-golang-notes/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-03-17-golang-notes/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="文档和资源"><a href="#文档和资源" class="headerlink" title="文档和资源"></a>文档和资源</h1><ul>
<li><a target="_blank" rel="noopener" href="https://golang.org/ref/spec">语言规范</a></li>
<li><a target="_blank" rel="noopener" href="https://golang.org/doc/cmd">go命令行文档</a></li>
<li><a target="_blank" rel="noopener" href="https://golang.org/pkg/">包列表</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki">go wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.golang.org/index">The Go Blog</a></li>
</ul>
<h1 id="要注意的点"><a href="#要注意的点" class="headerlink" title="要注意的点"></a>要注意的点</h1><ul>
<li><a href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B">关于引用类型</a></li>
<li><a href="#Slice">Slice的内部存储</a></li>
<li><a href="#Slice">Slice的for range</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3">method sets和calls</a></li>
</ul>
<h1 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h1><p>每个go程序都由package构成。</p>
<h2 id="Exported-name"><a href="#Exported-name" class="headerlink" title="Exported name"></a>Exported name</h2><p>在一个包中，如果一个name是以大写字母开头的，那么这个name将会被从这个包中导出。</p>
<p>当import一个包的时候，只能引用<strong>被导出</strong>的name。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数名称在前，类型在后，<a target="_blank" rel="noopener" href="https://blog.golang.org/gos-declaration-syntax">Go’s Declaration Syntax</a>。</p>
<p>当多个连续的函数参数有共同的类型是，可以省略不写除最后一个外的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>一个函数可以返回任意个数的结果。</p>
<p>返回值可以是有名字的。当<code>return</code>不带任何参数时，函数返回named return values，这叫做”naked” return。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">	y = sum - x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>var</code>声明多个变量时，只能写最后一个的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c, python <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="comment">// var c int, python bool</span></span><br></pre></td></tr></table></figure>

<p>如果声明时给出了初始值，那么会以初始值的类型作为变量的类型，此时声明中的类型可省略。</p>
<p>在函数内部可以用短变量声明<code>:=</code>来声明变量，类型由值的类型来决定。但在函数外部，由于所有语句都需要以关键字开头，因此不可用这个方法。</p>
<p><strong>初始化</strong><br>在声明变量的时候，变量的值总是会被初始化，要么是用指定的值，要么是零值（变量类型的默认值）。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line">     <span class="comment">// represents a Unicode code point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure>

<p>声明变量但不显式给出初始值，变量会被赋予零值。数值类型：<code>0</code>，bool类型：<code>false</code>，string：<code>&quot;&quot;</code>。</p>
<h2 id="类型转换和推断"><a href="#类型转换和推断" class="headerlink" title="类型转换和推断"></a>类型转换和推断</h2><p>在进行类型转换时，go只能使用<strong>显式</strong>类型转换。</p>
<p>使用<code>:=</code>或<code>var =</code>声明变量、未指明类型、但给出初始值时，变量的类型由对初始值进行类型推断得到。如果右侧是数值常量，那么变量的类型可能是<code>int</code>，<code>float64</code>，<code>complex128</code>。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>只可以用<code>const</code>来声明。数值常量可表示任意精度，且不会溢出。一个未指定类型的常量由上下文来决定其类型。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在程序运行期间，始终存在。声明和初始化方式与普通变量相同，需要在函数外部声明。</p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比c语言，括号可选、大括号必须</span></span><br><span class="line"><span class="comment">// 不可以使用var的方式声明</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化语句和循环的每次更新可省略</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可当做while使用</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限循环</span></span><br><span class="line"><span class="keyword">for</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比c语言，括号可选、大括号必须</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用短语句，在判断之前执行，语句中声明的变量仅在if和后续的else语句块中可用</span></span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// else不能换行写</span></span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>求值顺序，按case的顺序，自上向下进行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比c语言，</span></span><br><span class="line"><span class="comment">// break可选，不写时自动提供</span></span><br><span class="line"><span class="comment">// case不必是integer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">     fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> ...</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不带条件的switch相当于switch true</span></span><br><span class="line"> <span class="keyword">switch</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">     fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>使用<code>defer</code>时，被<code>defer</code>的函数会被push到一个stack，参数会<strong>立即计算</strong>，但函数结束时，stack中的函数才会被pop出来执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;in func t: %s\n&quot;</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(t(<span class="string">&quot;you&quot;</span>))</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// in func t: you</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// you</span></span><br></pre></td></tr></table></figure>

<p><code>defer</code>的函数可以读取和赋值到函数的返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c返回2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c1</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c1返回1</span></span><br></pre></td></tr></table></figure>

<p><strong>defer、panic和recover</strong><br>当调用<code>panic</code>时，所有<code>defer</code>的函数都被正常执行。然后函数返回到调用者。</p>
<p><code>recover</code>仅在<code>defer</code>的函数中有用，正常执行时调用，只会返回<code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from f.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// g发生panic后，这个deferred的函数会执行，并捕获panic</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered in f&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Calling g.&quot;</span>)</span><br><span class="line">    g(<span class="number">0</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from g.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Panicking!&quot;</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Defer in g&quot;</span>, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Printing in g&quot;</span>, i)</span><br><span class="line">    g(i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><p>关于slice，map和channel，某些书中会将它们描述为引用，但从实现上看（例如：<a target="_blank" rel="noopener" href="https://golang.org/src/runtime/slice.go">slice</a>、<a target="_blank" rel="noopener" href="https://golang.org/src/runtime/map.go">map</a>、<a target="_blank" rel="noopener" href="https://golang.org/src/runtime/chan.go">chan</a>），这些类型不过只是封装了底层指针的struct，且go spec也早就在文档中<a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/b34f0551387fcf043d65cd7d96a0214956578f94">移除</a>了reference一词的使用，而在THE WAY TO GO一书中虽然使用了reference一词，但也明确指出，</p>
<blockquote>
<p>A reference type variable r1 contains the address (a number) of the memory location where the value of r1 is stored.<br>…<br>When assigning r2 = r1, only the reference (the address) is copied.<br>…<br>In Go pointers (see § 4.9) are reference types, as well as slices (ch 7), maps (ch 8) and channels (ch 13). ……</p>
</blockquote>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>存储了内存地址，零值为<code>nil</code>。<code>&amp;</code>获得变量的地址，<code>*</code>解引用。</p>
<p>对比c的指针，go的指针无法进行算数运算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure>

<p><strong>指针的类型转换</strong><br><code>unsafe.Pointer</code>：<code>type Pointer int</code>，代表了变量的内存地址，可以将任意变量的内存地址与<code>Pointer</code>指针相互转换。<br><code>uintptr</code>：<code>type uintptr int</code>，<code>Pointer</code>无法进行加减运算，需要转换为<code>uintptr</code>才可以，可以将<code>Pointer</code>与<code>uintptr</code>指针相互转换。<br><code>unsafe.Offsetof</code>：可以得到字段在结构体内的偏移量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*T &lt;=&gt; unsafe.Pointer &lt;=&gt; <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = Vertex &#123;<span class="number">50</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// *Vertex =&gt; Pointer =&gt; *int =&gt; int</span></span><br><span class="line"><span class="keyword">var</span> x = *(*<span class="keyword">int</span>)(unsafe.Pointer(&amp;v))</span><br><span class="line"><span class="comment">// *Vertex =&gt; Pointer =&gt; uintptr =&gt; Pointer =&gt; *int =&gt; int</span></span><br><span class="line"><span class="keyword">var</span> y = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span><br><span class="line"><span class="keyword">var</span> y = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v)) + unsafe.Offsetof(v.Y))</span><br></pre></td></tr></table></figure>

<h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><p>字段的集合，使用<code>.</code>来访问字段。首字母大写和小写分别代表公开和私有。私有变量只有同一个package才可以访问。</p>
<p>对于struct指针，可以使用<code>(*p).X</code>或直接使用<code>p.X</code>来进行访问。对比c，go不能用<code>-&gt;</code>来访问成员。</p>
<p><strong>初始化</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多行的形式指定一个或多个字段的值的时候，最后的逗号不可以省略。如果只是一行，最后的逗号的可选</span></span><br><span class="line"><span class="comment">// 如果没有指定字段值，那么会使用相应类型默认的零值进初始化。</span></span><br><span class="line"><span class="keyword">var</span> v1 = Vertex &#123;</span><br><span class="line">    X: <span class="number">1</span>,</span><br><span class="line">    Y: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = Vertex &#123;</span><br><span class="line">    X: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v3 = Vertex &#123; X: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 零值结构体实际分配了结构体的内存空间</span></span><br><span class="line"><span class="keyword">var</span> v4 = Vertex &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> v5 = Vertex &#123; <span class="number">1</span>, <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> v6 *Vertex = &amp;Vertex &#123; <span class="number">1</span>,<span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> v7 *Vertex = <span class="built_in">new</span>(Vertex)</span><br><span class="line"><span class="keyword">var</span> v8 Vertex</span><br><span class="line"></span><br><span class="line"><span class="comment">// nil结构体不会分配结构体内存</span></span><br><span class="line"><span class="keyword">var</span> v9 *Vertex = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>copy</strong></p>
<ul>
<li>结构体之间的copy是深拷贝，不共享结构体内部字段。</li>
<li>结构体指针的copy是浅拷贝，共享内部字段。</li>
</ul>
<p><strong>组合</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    v Vertex</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名组合，此时外部的结构体在使用时，可以直接使用内部结构体的成员和方法。如果内部和外部存在相同名字的方法，会调用外部结构体的方法。</span></span><br><span class="line"><span class="keyword">type</span> Circle2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Vertex</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>和c一样，数组的大小也是数组类型的一部分，声明数组时必须有大小，通过下标访问数组中的元素。</p>
<p>程序执行时，go会检查访问是否越界。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a[<span class="number">10</span>] <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">6</span>] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b[<span class="number">6</span>] <span class="keyword">int</span> = [<span class="number">6</span>] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">c := [<span class="number">6</span>] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">d := [...] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125; <span class="comment">// 自动推断长度</span></span><br><span class="line">e := [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">2</span>: <span class="number">20</span>&#125; <span class="comment">// len(e) = 5, e[1] = 10, e[2] = 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组字面值</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同类型（长度和元素类型）的数组可以相互赋值，会copy数组的内容</span></span><br><span class="line"><span class="keyword">var</span> e[<span class="number">6</span>] <span class="keyword">int</span></span><br><span class="line">e = a</span><br></pre></td></tr></table></figure>

<p><strong>内部存储</strong><br>连续分配的内存区域。</p>
<p><strong>copy</strong><br>数组的类型由元素的类型和数组的大小决定，相同类型的数组之间才可以copy。拷贝一个数组，数组的内部的元素也会被逐一拷贝，因此作为变量传递时，需要注意copy的开销。</p>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>slice的类型为<code>[]int</code>，对数组进行，</p>
<ul>
<li><code>a[low_index:high_index]</code>后得到，区间是前闭后开，可以省略<code>low_index</code>或<code>high_index</code>，默认值分别为<code>0</code>和数组长度。<br>  <code>cap(a)</code> = <code>len(array) - low_index</code></li>
<li><code>a[low_index:high_index:cap_index]</code>后得到，区间是“闭、开、开”。<code>cap_index</code>代表可用到的底层数组的最大index，必须小于<code>len(array)</code>。<br>  <code>cap(a)</code> = <code>cap_index - low_index</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a[<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">4</span>]</span><br><span class="line">a[:]</span><br><span class="line">b := []<span class="keyword">string</span> &#123;<span class="number">99</span>: <span class="string">&quot;&quot;</span>&#125; <span class="comment">// len(b) = 100, cap(b) = 100</span></span><br></pre></td></tr></table></figure>

<p><strong>内部存储</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       +---------------+</span><br><span class="line">slice: |pointer|len|cap|</span><br><span class="line">       +--+------------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">       +--v--------------+</span><br><span class="line">array: |item1|item2|...  |</span><br><span class="line">       +-----------------+</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> address = (**[<span class="number">10</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;s)) <span class="comment">// 底层数组的地址</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">len</span> = (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">cap</span> = (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">16</span>)))</span><br></pre></td></tr></table></figure>

<p><strong>slice和array</strong><br>slice本身并不存储任何数据，仅仅是数组选定区间的描述，和数组共享底层的数据。<code>len()</code>和<code>cap()</code>对应了slice的长度，和底层数组从<code>low</code>起的大小，即：<code>len(array) - low</code>。</p>
<p>对已有slice再做一次slice，实际上是改变slice对底层数组的引用范围。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125; <span class="comment">// len(s)=6, cap(s)=6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice the slice to give it zero length.</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend its length.</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>slice字面值类似数组的，区别是没有大小。底层实际上创建了相同大小的数组，然后再创建slice。</p>
<p><strong>nil slice</strong><br>一个nil slice，是未初始化的slice，<code>len</code>和<code>cap</code>都为0，且不会分配底层的数组，数组指针为<code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p><strong>空slice</strong><br>一个空slice的<code>len</code>和<code>cap</code>都为0，且不会分配底层的数组，数组指针值不为空，但是也未分配底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">b := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当想声明一个空的slice时，nil slice和空slice都可以，两者在功能上完全等价，但是更<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices">推荐</a>nil slice。但二者进行序列化的时候，结果会不同，nil slice会编码为null，而空slice是<code>[]</code>。</p>
<p><strong>make slice</strong><br>通过<code>make</code>来创建动态长度的数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5, cap(a)=5</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><strong>append</strong><br><code>append</code>函数能够将相同类型元素追加至现有slice，若底层数组大小不够，则会重新分配内存，并将slice指向新数组。</p>
<p>如果发生了扩容，且有另一个slice存在，那么另一个slice的仍然指向老的数组。</p>
<p>扩容时，如果<code>cap &lt; 1024</code>，那么会扩100%，否则扩25%。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure>

<p><strong>range</strong><br>除了普通方法遍历slice，还能使用<code>range</code>，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i是index，v是相应元素的copy。</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可忽略i或v的赋值</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>当使用<code>range</code>返回的值，<code>v</code>时，<strong>要注意的是</strong><code>range</code>返回的是<strong>元素的copy</strong>，而不是引用，如果对齐进行<code>&amp;</code>，那么得不到期望的结果。具体来说，Go会使用<strong>同一个</strong>变量，在每轮迭代中保存元素的copy。可以使用<a target="_blank" rel="noopener" href="https://github.com/kyoh86/scopelint">kyoh86/scopelint</a>来检查代码中的unpinned variables。</p>
<ol>
<li><p>取地址。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Println(&amp;v, &amp;a[i]) <span class="comment">// v的地址保持不变，且不等于a中任意元素的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个原因还有可能导致使用goroutine时出现<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/CommonMistakes#using-goroutines-on-loop-iterator-variables">意外</a>。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于closure已经绑定到了val，又因为goroutine可能在for结束后才执行</span></span><br><span class="line"><span class="comment">// 因此打印出的可能全都是values的最后一个值。</span></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> valslice &#123;</span><br><span class="line">	val := valslice[i] <span class="comment">// val在每次迭代中都会分配新的</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>copy</strong><br>slice的copy是浅拷贝，两个slice共享底层数组。本质上copy的是：指向底层数组的指针、<code>len</code>和<code>cap</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125; <span class="comment">// len(s)=6, cap(s)=6</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br></pre></td></tr></table></figure>

<p>go还提供了一个函数<code>copy</code>来实现数组内容的copy，copy时，会以目的切片的容量为准。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []T)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>结合slice的内部存储、<code>append</code>和拷贝，有的使用场景不注意可能导致意料之外的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncSlice</span><span class="params">(s []<span class="keyword">int</span>, t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[<span class="number">0</span>]++</span><br><span class="line">	s = <span class="built_in">append</span>(s, t)</span><br><span class="line">	s[<span class="number">0</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	FuncSlice(a, <span class="number">4</span>)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1 1 2 3]</span></span><br></pre></td></tr></table></figure>

<p>具体过程分析如下：</p>
<ol>
<li><code>s[0]++</code>：<code>a</code>和<code>s</code>都指向同一个底层数组<code>arr1</code>，此时<code>a-&gt;arr1</code>，<code>s-&gt;arr1</code>，修改了<code>arr1</code>。</li>
<li><code>append</code>：由于扩容，<code>append</code>返回了一个新的底层数组<code>arr2</code>，<code>a-&gt;arr1</code>，<code>s-&gt;arr2</code>。</li>
<li><code>s[0]++</code>：修改了<code>arr2</code>，<code>arr1</code>不变。</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>一个仅做了声明的map是<code>nil</code>，需要使用<code>make</code>来进行初始化。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的key，使用这些类型会造成编译错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">    <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map字面值和struct字面值类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123; <span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当最上层的类型只是类型名的时候，可以省略。</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: &#123; <span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;, <span class="comment">//最后的逗号不可缺少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mil map</strong><br>nil map未进行初始化，不能用于存储key-value。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br></pre></td></tr></table></figure>

<p><strong>make map</strong><br>通过<code>make</code>来创建map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p><strong>range</strong><br>类似slice，且slice中存在的问题，map中也同样存在。由于无法获取index，因此只能通过每轮迭代创建变量来解决。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k是key，v是相应元素的copy。</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可忽略k或v的赋值</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作</strong></p>
<ul>
<li>新增和更新：<code>m[key] = elem</code></li>
<li>访问key的值：<code>elem = m[key]</code>，如果不存在，那么<code>elem</code>为此类型的零值，但如果值真的是零值，那通过这个方法来判断key是否存在就失效了。</li>
<li>删除：<code>delete(m, key)</code></li>
<li>test：<code>var elem, ok = m[key]</code>，如果不存在，那么<code>elem</code>为此类型的零值。</li>
</ul>
<h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><h3 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h3><p>rune字面值代表一个rune常量，是一个标识Unicode code point的整型值。<code>alias for int32</code>。</p>
<p>rune字面值可以用<code>&#39;单个字符&#39;</code>来表示，可以用<code>\</code>转义的多个字符来表示，具体见<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Rune_literals">Rune literals</a>。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string字面值代表了包含一系列字符的string常量，只读。有两种形式：raw string字面值和interpreted string字面值。</p>
<ul>
<li>raw string字面值，是经过未转义处理的，在raw string内部，可以出现任意字符。string中出现的<code>&#39;\r&#39;</code>会被忽略。</li>
<li>interpreted string字面值，go会进行转义处理。具体见<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#String_literals">String literals</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;\U000065e5\U0000672c\U00008a9e&quot;)    \\ 日本語</span><br><span class="line"></span><br><span class="line">fmt.Println(&#96;\U000065e5\U0000672c\U00008a9e&#96;)    \\ \U000065e5\U0000672c\U00008a9e</span><br></pre></td></tr></table></figure>

<p><strong>内部存储</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            +---------------+</span><br><span class="line">byte slice: |pointer|len|cap|</span><br><span class="line">            +--+------------+</span><br><span class="line">               |</span><br><span class="line">               |</span><br><span class="line">            +--v------------+</span><br><span class="line">array:      |item1|item2|...|</span><br><span class="line">            +---^-----------+</span><br><span class="line">                |</span><br><span class="line">            +---+-----------+</span><br><span class="line">string:     |pointer|len|cap|</span><br><span class="line">            +---------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello，你好&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, *(*[<span class="number">2</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;a)))    \\ [<span class="number">4</span>b9f3c e]</span><br><span class="line"></span><br><span class="line">b := a</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, *(*[<span class="number">2</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;b)))    \\ [<span class="number">4</span>b9f3c e]</span><br></pre></td></tr></table></figure>

<p>由于底层存储是数组，因此可以做slice，但要注意的是，这里本质上是对字节来做slice，因此如果slice的Unicode code point不是一个完整的字符，那么打印的时候，是不会正确显示的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello，你好&quot;</span></span><br><span class="line">b := a[<span class="number">0</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(b)    \\ Hello，�</span><br></pre></td></tr></table></figure>

<p>从字符串得到字节slice或者从字节slice得到字符串，会发生底层数组的copy。如果想避免copy，可以手动一个string或slice，获得一个原始string或者slice的“reference”，这种方式不可以通过slice修改string，因为修改后，“reference”到的原有string失效了，可能会被gc回收。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello，World&quot;</span></span><br><span class="line">b := []<span class="keyword">byte</span>(a) <span class="comment">// copy</span></span><br><span class="line">c := <span class="keyword">string</span>(b) <span class="comment">// copy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动构造</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strhead = *(*[<span class="number">2</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">    <span class="keyword">var</span> slicehead [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    slicehead[<span class="number">0</span>] = strhead[<span class="number">0</span>]</span><br><span class="line">    slicehead[<span class="number">1</span>] = strhead[<span class="number">1</span>]</span><br><span class="line">    slicehead[<span class="number">2</span>] = strhead[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;slicehead))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2str</span><span class="params">(bs []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历</strong></p>
<ul>
<li>按字节遍历：通过下标。</li>
<li>按字符遍历：range方式遍历。</li>
</ul>
<h2 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h2><p>函数也是值，可作为参数传递，作为返回值返回。</p>
<p>闭包（closure）是function value引用了函数体外部的变量，函数可以访问和修改这些变量。换句话说，闭包包含了<strong>函数、以及所在的环境的上下文</strong>。</p>
<h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><h2 id="方法集（method-sets）和调用"><a href="#方法集（method-sets）和调用" class="headerlink" title="方法集（method sets）和调用"></a>方法集（method sets）和调用</h2><p><a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Method_sets">方法集</a>和<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Calls">函数调用</a>的规范明确了一个类型<strong>有哪些方法</strong>，以及<strong>在什么时候可以调用</strong>什么样的方法。go wiki上关于这两个概念有比较详细的<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/MethodSets">例子</a>。</p>
<p><strong>method set</strong></p>
<ol>
<li><p>对于一个接口类型，接口是方法集。</p>
</li>
<li><p>对于一个类型<code>T</code>，所有receiver为T的方法是方法集。</p>
<p> 对于类型T对应的指针类型<code>*T</code>，所有receiver为<code>T</code>或<code>*T</code>的方法是方法集。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Type</th>
<th>method sets</th>
</tr>
</thead>
<tbody><tr>
<td>interface type</td>
<td>interface</td>
</tr>
<tr>
<td>T</td>
<td>func (T) f()</td>
</tr>
<tr>
<td>*T</td>
<td>func (*T) f(), func (T) f()</td>
</tr>
</tbody></table>
<p>一个类型<code>T</code>的方法集决定了，这类型<code>T</code>的接口类型的实现，和使用<code>T</code>作为receiver时可以被调用的方法。</p>
<p><strong>call</strong><br>对于一个方法调用<code>x.m()</code>，</p>
<ol>
<li><p>如果<code>x</code>的method set包含<code>m()</code>，且调用时的参数列表合法，那么这个调用是合法的。</p>
</li>
<li><p>如果<code>x</code>可以<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Address_operators">取地址的</a>，并且<code>&amp;x</code>的method set包含<code>m()</code>，那么<code>x.m()</code>等价于<code>(&amp;x).m()</code>。</p>
<p> <em>map元素和interface存储的具体值不可取地址。</em></p>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是带有特殊receiver参数（<code>func</code>和函数名之间）的函数。这个receiver不必是struct，但要求receiver的类型定义必须在同一个package里面，且不能直接将内置类型作为receiver。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Point receiver</strong><br>若要修改字段，则必须使用point receiver，<strong>无论变量本身是否是指针类型</strong>，<strong>非指针receiver调用时发生了copy</strong>。</p>
<p>从这里可以得出使用point receiver的场景：1. 避免copy；2. 修改值本身。一般来说，某个类型的receiver应该<strong>统一</strong>，要么是point receive，要么是普通receiver。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123; v.X = v.X * f ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Scale2</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123; v.X = v.X * f ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若v不是指针类型，那么go会把<code>v.Scale</code>自动转换为<code>（&amp;v）.Scale</code>。</li>
<li>反过来，若v是指针类型，在调用<code>Scale2</code>时，go会把<code>v.Scale2</code>转换为<code>（*v).Scale2</code>。</li>
</ul>
<p>对比c++的成员函数，<code>this</code>指针类似于point receiver，但go的普通receiver是不同于c++的。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是方法签名的集合。</p>
<p>接口的实现是隐式的，无需类似<code>implement</code>的关键字。隐式实现<strong>解耦</strong>接口的定义和实现，在package中，接口的定义可以出现在方法和类型定义之后。注意方法的实现<strong>区分普通receiver和point receiver</strong>。</p>
<p>一个接口值可以被赋值为<strong>任何实现了接口中所有方法的值</strong>。接口值底层实际包含了具体值的类型，接口值可以看做是值和具体类型的元组。调用接口值的方法，实际上会调用具体类型的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123; Abs() <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyInt)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">int64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(<span class="number">1</span>)</span><br><span class="line">i := MyInt(<span class="number">2</span>)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f</span><br><span class="line">a = i</span><br><span class="line">a = &amp;v</span><br><span class="line"></span><br><span class="line"><span class="comment">// a = v</span></span><br><span class="line"><span class="comment">// error，Vertex没有实现Abs()，*Vertex才实现了Abs()</span></span><br></pre></td></tr></table></figure>

<p>对比c++的多态，c++中通过继承基类，并覆盖基类的虚函数，在运行时进行动态绑定，以此实现多态。go的接口方法定义可以看做是基类和虚函数，而<code>a = f</code>相当于将子类的指针赋值给基类指针，这样完成了动态绑定。</p>
<p>不同的点还是receiver，实现接口的方法时，go区分了point receiver和普通receiver。</p>
<p><strong>内部存储</strong><br>实现上，一个接口值底层包含了指向类型和数据的指针。</p>
<p>接口类型之间的赋值和类型转换是共享数据的，而结构体之间的赋值、结构体转接口、接口转结构体，都会导致数据的copy。</p>
<p><strong>空的具体类型值</strong><br>如果接口的具体类型值是空的，那么将会使用<code>nil</code> receiver来调用方法，不引发空指针异常。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123; Abs() <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i Abser</span><br><span class="line"><span class="keyword">var</span> v *Vertex</span><br><span class="line">i = v</span><br><span class="line"></span><br><span class="line">i.Abs()</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">v.Abs()</span><br></pre></td></tr></table></figure>

<p><strong>空的接口值</strong><br>会发生运行时错误，没有具体的<code>Abs</code>方法可以调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123; Abs() <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="keyword">var</span> i Abser</span><br><span class="line">i.Abs()</span><br></pre></td></tr></table></figure>

<p><strong>空接口</strong><br>空接口的值可以包含任何类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var i interface &#123;&#125;</span><br><span class="line">i &#x3D; 32</span><br><span class="line">i &#x3D; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; i &#x3D; 100000000000000000000000000</span><br><span class="line">&#x2F;&#x2F; overflows int</span><br></pre></td></tr></table></figure>

<p><strong>接口变量的赋值</strong><br>对于数值类型，底层的具体类型<strong>只能是</strong><code>int</code>，<code>float64</code>，<code>complex128</code>。</p>
<p><strong>类型断言</strong><br>类型断言提供了访问接口底层具体类型值的能力。</p>
<ul>
<li><code>t := i.(T)</code>断言接口<code>i</code>拥有具体类型<code>T</code>，并把类型<code>T</code>的值赋值给<code>t</code>。如果不是类型<code>T</code>，则触发panic。</li>
<li>test：<code>t, ok := i.(T)</code>断言不正确的情况，不触发panic，而是<code>ok</code>为false，且t为类型<code>T</code>的零值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">100000000000000000000000000</span> <span class="comment">// overflow</span></span><br><span class="line">a := i.(<span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">100000</span></span><br><span class="line">a := i.(<span class="keyword">int64</span>) <span class="comment">// int</span></span><br></pre></td></tr></table></figure>

<p>Type swtiches是允许断言多个类型的结构。类似switch语句，但是每个case是特定的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果test成功，那么v会转换为相应的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// here v has type T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// here v has type S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// no match; here v has the same type as i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比scala的pattern matching，go的type swtiches像，但不是pattern matching。scala的pattern matching会检查值和pattern是否匹配，能够把值解构为构成值的各部分。<strong>猜测</strong>go的type swtiches是类型字符串是否相等的test。</p>
<h2 id="一些内置的接口"><a href="#一些内置的接口" class="headerlink" title="一些内置的接口"></a>一些内置的接口</h2><p><strong>Stringer</strong><br>类似python的<code>__str__</code>，定义在<code>fmt</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A ...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">a := A()</span><br><span class="line">fmt.Println(a) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p><strong>error</strong><br>类似Stringer，fmt在print的时候也会查找<code>error</code>接口。从fmt的实现上看，是error<strong>优先</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>error</code>更适合用于专门定义的错误类型。否则功能上，<code>stringer</code>和<code>error</code>就冗余了。</p>
<p>可以使用<code>fmt.Errorf</code>或<code>errors.New</code>来创建<code>error</code>类型的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Errorf(<span class="string">&quot;math: square root of negative number %g&quot;</span>, f)</span><br></pre></td></tr></table></figure>

<p><strong>Reader</strong><br>io包定义了<code>io.Reader</code>接口，代表读取stream，有多个实现（文件、网络等）。</p>
<p>其中<code>func (T) Read(b []byte) (n int, err error)</code>方法使用现有数据填充<code>b</code>，并返回填充的字节数和<code>error</code>。stream结束时，<code>error</code>为<code>io.EOF</code>。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>由go运行时管理的轻量级线程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure>

<p>参数的计算在当前goroutine中完成，函数<code>f</code>的调用发生在新的goroutine。所有子协程都是平级的关系（包括在子协程内部启动另一个协程）。</p>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>channel是带类型的管道（typed conduit），每次只能发送或接受一个元素。默认情况下，发送方和接收方会一直阻塞到另一方ready，每次只能唤醒一个发送或接受方。</p>
<p><strong>方向</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T <span class="comment">// 可以发送和接受类型为T的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- T <span class="comment">// 可以发送类型为T的数据</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> T <span class="comment">// 可以接受类型为T的数据</span></span><br></pre></td></tr></table></figure>

<p><strong>unbuffered channel</strong><br>unbuffered channel必须保证先有goroutine正在接收，否则发送方会一直阻塞到有goroutine来接收为止。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// len(ch) == 0, cap(ch) == 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// block</span></span><br><span class="line">v := &lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先有goroutine正在接收</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := &lt;-ch</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>buffered channel</strong><br><code>ch := make(chan int, 100)</code>，buffered channel在满或空的情况下，分别会导致发送方和接收方阻塞。</p>
<p><strong>range</strong><br><code>for i := range ch</code>可以从channel逐个接收值，直到channel被关闭。</p>
<p><strong>close</strong></p>
<ul>
<li>发送方可以通过<code>close(ch)</code>来告诉接收方没有后续的值会发送。如果向关闭的channel发送元素，那么会导致抛出异常。</li>
<li>接收方可以使用<code>v, ok := &lt;-ch</code>判断channel是否被关闭。如果从一个已经关闭的channel接收元素，会返回channel类型的零值，因此是不能用这个方式来判断channel是否关闭的。</li>
</ul>
<p><strong>select</strong><br>select语句可以让goroutine等待多个通信操作（发送或接受都可以），block直到其中某个case能执行。如果同时有多个case能执行，则随机选择一个。</p>
<p>若存在default，则当没有case ready的时候，执行default，因此可以通过default实现非阻塞式的发送或接受。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// receiving from c would block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go Concurrency Patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a></li>
</ul>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>go内存模型</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><h2 id="static-build"><a href="#static-build" class="headerlink" title="static build"></a>static build</h2><p><code>go build</code>启用race，也需要启用cgo。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>抛开go的运行时环境和gc不说，go很像c，同时还有着少量函数式语言的特性。</p>
<p>go中，我很喜欢的几点是：</p>
<ol>
<li>变量和函数的声明简洁清晰</li>
<li>goroutine</li>
<li>提供了CSP来实现goroutine之间的通信</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-03-05-python-symtable-module-package/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/2019-03-05-python-symtable-module-package/" class="post-title-link" itemprop="url">python符号表、module和package</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-03-05 22:12:40" itemprop="dateCreated datePublished" datetime="2019-03-05T22:12:40+08:00">2019-03-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-03-05-python-symtable-module-package/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-03-05-python-symtable-module-package/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="symbol-table"><a href="#symbol-table" class="headerlink" title="symbol table"></a>symbol table</h1><p>symbol table（符号表）是用于编译器或解释器中的一个数据结构，存储了源码中每个符号以及关联的信息。不同的作用域可能会有各自的符号表。在静态语言中，符号表尤为重要。</p>
<h2 id="python-variable"><a href="#python-variable" class="headerlink" title="python variable"></a>python variable</h2><p>python中的变量与c/c++的不一样，是绑定到对象的symbolic name。<code>aa</code>，<code>bb</code>都是绑定到一个list对象的名字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aa = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">bb = aa</span><br><span class="line">aa[<span class="number">0</span>] = <span class="number">666</span></span><br></pre></td></tr></table></figure>

<h2 id="python-symbol-table"><a href="#python-symbol-table" class="headerlink" title="python symbol table"></a>python symbol table</h2><p>虽然python是动态语言，没有编译时类型检查，但python也有符号表。python的符号表通过编译器由AST生成，用于计算每个标识符的作用域，最终符号表和AST会被共同用于生成字节码。<code>symtable</code>模块提供了关于标识符的作用域等信息，还能够输出在这些作用域中引用到的变量是哪个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">aa</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        bb = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> aa + bb + cc</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">src = <span class="built_in">open</span>(<span class="string">&#x27;add.py&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line"><span class="keyword">import</span> symtable</span><br><span class="line">table = symtable.symtable(src, <span class="string">&#x27;src.py&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_symbol</span>(<span class="params">sym</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">type</span>(sym) == symtable.Symbol</span><br><span class="line">    print(<span class="string">&quot;Symbol:&quot;</span>, sym.get_name())</span><br><span class="line">    <span class="keyword">for</span> prop <span class="keyword">in</span> [</span><br><span class="line">            <span class="string">&#x27;referenced&#x27;</span>, <span class="string">&#x27;imported&#x27;</span>, <span class="string">&#x27;parameter&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;declared_global&#x27;</span>, <span class="string">&#x27;local&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;free&#x27;</span>, <span class="string">&#x27;assigned&#x27;</span>, <span class="string">&#x27;namespace&#x27;</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">getattr</span>(sym, <span class="string">&#x27;is_&#x27;</span> + prop)():</span><br><span class="line">            print(<span class="string">&#x27;    is&#x27;</span>, prop)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table.get_children()[<span class="number">0</span>].get_children()[<span class="number">0</span>].get_symbols():</span><br><span class="line">    describe_symbol(i)</span><br><span class="line"></span><br><span class="line">Symbol: bb</span><br><span class="line">    <span class="keyword">is</span> referenced</span><br><span class="line">    <span class="keyword">is</span> local</span><br><span class="line">    <span class="keyword">is</span> assigned</span><br><span class="line">Symbol: aa</span><br><span class="line">    <span class="keyword">is</span> referenced</span><br><span class="line">    <span class="keyword">is</span> free</span><br><span class="line">Symbol: cc</span><br><span class="line">    <span class="keyword">is</span> referenced</span><br><span class="line">    <span class="keyword">is</span> <span class="keyword">global</span></span><br></pre></td></tr></table></figure>

<p>free variable：如果变量在一个代码块内使用（在代码内被绑定），但是并没有在其中定义，那么这个变量是自由变量。顺便提一句，使用了自由变量的函数就是闭包（closure）。<br>global variable：如果变量代码在模块级别被绑定，这个变量是全局变量。<br>local variable：如果变量在代码块内被绑定，这个变量是局部变量。</p>
<h1 id="python-module"><a href="#python-module" class="headerlink" title="python module"></a>python module</h1><p>module（模块）是一个包含python定义和语句的文件，文件名由module名和<code>.py</code>后缀构成。module名可由全局变量<code>__name__</code>获取。这个文件可被作为脚本使用或用于repl中，module中的定义可以被其他module或mainmodule导入。</p>
<p>例如：<code>p.py</code>，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>在repl中，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把module名p加入当前的符号表</span></span><br><span class="line"><span class="keyword">import</span> p</span><br><span class="line">p.add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Symbol: p</span><br><span class="line">    <span class="keyword">is</span> imported</span><br><span class="line">    <span class="keyword">is</span> local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把p中的add导入当前符号表</span></span><br><span class="line"><span class="keyword">from</span> p <span class="keyword">import</span> add</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Symbol: add</span><br><span class="line">    <span class="keyword">is</span> imported</span><br><span class="line">    <span class="keyword">is</span> local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把p中的除_开头的所有名字导入当前符号表</span></span><br><span class="line"><span class="keyword">from</span> p <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>一个module，可以包含可执行语句和函数定义，这些语句是用于初始化module的，仅仅在第一次导入这个模块的时候执行，作为脚本运行的时候也会执行。module作为脚本执行的时候，<code>__name__</code>会被设置为<code>&quot;__main__&quot;</code>，很常见的一个语句是<code>if __name__ == &quot;__main__&quot;:</code>，作为脚本执行的时候，运行<code>if</code>内的语句。</p>
<p>每个module有自己私有的符号表。module内部的全局变量不会与外部的产生冲突，另一个角度看，如果知道模块内的全局变量名称，可以通过<code>modname.itemname</code>的方式访问到。通过<code>dir()</code>函数可以得到module内定义的名字。</p>
<p>导入module时，module名字的search path为，</p>
<ol>
<li><p>内置的module</p>
</li>
<li><p><code>sys.path</code><br> 这个变量的值由下列几项初始化得到，</p>
<ul>
<li><p>脚本当前目录</p>
</li>
<li><p><code>PYTHONPATH</code>环境变量</p>
</li>
<li><p>the installation-dependent default</p>
<p><code>sys.path</code>初始化以后，可以在程序中修改。</p>
</li>
</ul>
</li>
</ol>
<h2 id="python-package"><a href="#python-package" class="headerlink" title="python package"></a>python package</h2><p>package是一种通过<code>modnameA.submodnameB</code>来组织module的方式。python会把包含<code>__init__.py</code>文件的文件夹当做package。<code>__init__.py</code>文件可以直接留空，也可以加入初始化package的代码或设置<code>__all__</code>变量（用于控制<code>from package imrpot *</code>的时候，导入哪些）。</p>
<p>导入的方式为，</p>
<ul>
<li><code>from package import item</code>。import语句首先测试item是否在package中定义，如果没有，那么假设item是一个module并尝试load。最终如果没有找到，那么会抛出<code>ImportError</code>异常。</li>
<li><code>import item.subitem.subsubitem</code>，最后一个item可以是module或package，但不能是类、函数或变量，其他必须是package。</li>
</ul>
<h1 id="class和module"><a href="#class和module" class="headerlink" title="class和module"></a>class和module</h1><p>在使用的时候，class和module有一些相似的地方，但是二者完全不同。</p>
<ul>
<li>class是创建带有属性和方法的实例的蓝图，支持继承等。这些module都不能做。</li>
<li>module仅仅只是组织代码的方式。</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1">Python internals: Symbol tables, part 1</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/2/library/symtable.html">symtable — Access to the compiler’s symbol tables¶</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chao Mai</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:{&quot;url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;,&quot;integrity&quot;:&quot;sha256-ncNI9OXOS5Ek4tzVYiOMmN&#x2F;KKCPZ6V0Cpv2P&#x2F;zHntiA&#x3D;&quot;}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{&quot;enable&quot;:true,&quot;shortname&quot;:&quot;chaomaisblog&quot;,&quot;count&quot;:true,&quot;i18n&quot;:{&quot;disqus&quot;:&quot;disqus&quot;}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
