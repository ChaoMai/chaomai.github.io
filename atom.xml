<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Building Things]]></title>
  <subtitle><![CDATA[Just want to know how it works!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://chaomai.github.io/"/>
  <updated>2016-02-01T15:00:12.259Z</updated>
  <id>http://chaomai.github.io/</id>
  
  <author>
    <name><![CDATA[Chao Mai]]></name>
    <email><![CDATA[loneymai@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Home Is Our World]]></title>
    <link href="http://chaomai.github.io/2016/02/01/2016-2016-02-01-home-is-our-world/"/>
    <id>http://chaomai.github.io/2016/02/01/2016-2016-02-01-home-is-our-world/</id>
    <published>2016-02-01T14:48:59.000Z</published>
    <updated>2016-02-01T15:00:12.259Z</updated>
    <content type="html"><![CDATA[<p>临近春节，想起了前两个月重温的游戏，HomeWorld。</p>
<p>2008年，高中时，我首次接触到了HomeWorld 2，游戏的画面和操作深深的震撼我。这个游戏是首个完全的3D RTS、视角能够3D旋转、舰船可以在空间中任意移动，不限于一个平面、舰船精细的建模和纹理，这些让我很长时间都沉浸在游戏当中。</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/homeworld_hyper%20space%20jump.jpg" alt=""></p>
<p>后来了解到这个游戏是一个系列，还有1999年发布的HomeWorld和2000的Homeworld: Cataclysm，而二代是2003年的，一代发布之初就夺得了多项重量级的大奖。由于从二代到一代画面和操作的落差有点大，最后没有把一代通关。对于Homeworld: Cataclysm，当时没有买到游戏cd，也找不到下载，这一作也没有玩，</p>
<p>玩过二代以后，就一直关注着这个游戏的后续进展。在街边买过“HomeWorld 3”（其实是2代+高达Mod），发现Relic在2003年就公布了HomeWorld的源码以后，也在Linux下折腾过一代。</p>
<p>一代和二代的开发团队是Relic，也叫水雷社，进入游戏时的水雷动画，至今还历历在目。Relic的第一个作品便是Homeworld，后续开发的游戏也基本都是RTS的。二代发布半年后，也就是2004年，THQ收购Sierra旗下的Relic，随之被收购的还有HomeWorld系列的知识产权。当时了解到这里才意识到，续作恐怕是没戏了。</p>
<p>直到2013年事情出现了转机，THQ破产，旗下游戏的所有权被拍卖。Gearbox最终收购下HomeWorld系列，随后便宣布重制一代和二代，但没有重制Cataclysm的消息，说是源码丢了。。。</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/homeworld_homeworld.jpg" alt=""></p>
<p>去年末，重制版发布半年多，我入手了。时隔7年，终于是把一代通关，也重温了二代的战役。</p>
<h1 id="u753B_u9762"><a href="#u753B_u9762" class="headerlink" title="画面"></a>画面</h1><p>二代的重制版相比起原版，由于引擎就是二代所用的升级版，画面上的提升不算很大，新鲜感少些，提升最大的是一代。一代的重制可谓是非常出色，精细的模型、游戏开头的黑白动画重画、即时演算动画的内容也与原作一致。</p>
<h1 id="u97F3_u4E50_u548C_u914D_u97F3"><a href="#u97F3_u4E50_u548C_u914D_u97F3" class="headerlink" title="音乐和配音"></a>音乐和配音</h1><p>Paul Ruskay是HomeWorld系列的配乐的作曲者，他最值得瞩目的作品便是HomeWorld的配乐，带有中东气息的配乐和吟唱为Ruskay赢得了很多奖项。一代和二代的背景音乐都是相当不错的，很好的展现了在无垠的太空中的孤独和壮丽的奇观。</p>
<p>还有一个不得不提的声音，从游戏伊始直至结束的旁白和Bentusi的配音都是由Campbell Lane完成的，他被很多玩家誉为The Last Bentusi，The Voice of Bentusi。旁白的厚重感和沧桑感为游戏增色不少，而Bentusi这一种族神秘和古老的特点，完全就是由配音体现的。不幸的是2014年初，老头子因肺癌去世。</p>
<p>一代的主题曲Homeworld (The Ladder)是游戏的点睛之笔，主唱Anderson的填词很好的诠释了Hiigarans和他们返回家乡的历程。由于版权问题，重制版中并未包含。</p>
<h1 id="u5267_u60C5"><a href="#u5267_u60C5" class="headerlink" title="剧情"></a>剧情</h1><p>HomeWorld其实只有一个主题，回家。</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/homeworld_path.jpg" alt=""></p>
<p>Peter Watts创作了一代和二代的剧情。一代，Hiigarans先被流放，而后拓荒者Kushan经历千山万水，重重阻难，最终回到家乡Hiigara的故事，而二代重夺Hiigara要逊色一些。</p>
<h1 id="You_are_here"><a href="#You_are_here" class="headerlink" title="You are here"></a>You are here</h1><p>隔了7年，重新再玩HomeWorld，我已经不像当时，被Kushan、受难的Hiigara和舍生取义的Bentusi打动。但游戏制作人员名单最后的一个画面打动了我，随着音乐结束，屏幕上的星星越来越多时，一个箭头指向了一个星星，</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/homeworld_you%20are%20here.jpg" alt=""></p>
<p>这即代表了玩家多年的等待，也说出了在这浩瀚宇宙中，人类不过是沧海一粟。</p>
<p>感谢Peter Watts、Paul Ruskay、Campbell Lane，感谢Relic、Sierra和Gearbox。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>临近春节，想起了前两个月重温的游戏，HomeWorld。</p>
<p>2008年，高中时，我首次接触到了HomeWorld 2，游戏的画面和操作深深的震撼我。这个游戏是首个完全的3D RTS、视角能够3D旋转、舰船可以在空间中任意移动，不限于一个平面、舰船精细的建模和纹理]]>
    </summary>
    
      <category term="homeworld" scheme="http://chaomai.github.io/tags/homeworld/"/>
    
      <category term="game" scheme="http://chaomai.github.io/categories/game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[素数相关问题及算法]]></title>
    <link href="http://chaomai.github.io/2016/01/18/2016-2016-01-18-the-prime-and-realted-algorithms/"/>
    <id>http://chaomai.github.io/2016/01/18/2016-2016-01-18-the-prime-and-realted-algorithms/</id>
    <published>2016-01-18T07:38:59.000Z</published>
    <updated>2016-01-18T08:12:06.004Z</updated>
    <content type="html"><![CDATA[<h1 id="u8BD5_u9664_u6CD5"><a href="#u8BD5_u9664_u6CD5" class="headerlink" title="试除法"></a>试除法</h1><p>根据素数的定义，对于自然数$n$，只要能够找到除了1和它本身以外，能够整除该数的正整数，那么它就不是素数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> &amp;&amp; i != n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又因为，如果$d$是$n$的约数，那么$n=d \times n/d$，故$n/d$也是，且$\min{d, n/d} \leq \sqrt{n}$,</p>
<p>因此只需要测试到$\sqrt{n}$即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// i won't equal to n, so i != n is unnecessary.</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法需要约$2^{n/2}/((n/2)\ln 2)$次测试。</p>
<h1 id="u57C3_u6C0F_u7B5B"><a href="#u57C3_u6C0F_u7B5B" class="headerlink" title="埃氏筛"></a>埃氏筛</h1><p>对于单个小整数，试除法尚可，但是如果要枚举$n$以内的素数，使用试除法就需要对$n$以内的所有自然数都做测试，效率太低。</p>
<p>埃拉托斯特尼筛法，简称埃氏筛，从2开始，将每个素数的所有倍数标记为合数，如果这个$n$小于最后一个标出的素数的平方，那么所有小于$n$且未标记的都是素数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isPrime(n, <span class="literal">true</span>);</span><br><span class="line">isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i * i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i * j &lt;= n) &#123;</span><br><span class="line">            isPrime[i * j] = <span class="literal">false</span>;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>埃氏筛的时间复杂度为$O(n\log n \log n)$，但这个方法最大的问题在于，需要的内存随着$n$的增大而增大。</p>
<h1 id="u6574_u6570_u5206_u89E3"><a href="#u6574_u6570_u5206_u89E3" class="headerlink" title="整数分解"></a>整数分解</h1><h2 id="u8BD5_u9664_u6CD5-1"><a href="#u8BD5_u9664_u6CD5-1" class="headerlink" title="试除法"></a>试除法</h2><p>分解整数，普通方法是用短除法，从最小的素数除起，知道结果为素数为止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然是从最小的素数除起，上述代码在每次<code>++i</code>后，为什么不检测<code>i</code>是否为素数？</p>
<p>原因是，内层循环相当于已经把当前<code>i</code>的所有倍数去除了，类似埃氏筛，故下次取到的能够整除$n$的<code>i</code>是素数。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Trial_division" target="_blank" rel="external">Trial division</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="external">Sieve of Eratosthenes</a></li>
<li><a href="http://algorithm.yuanbin.me/zh-hans/basics_algorithm/math/prime.html" target="_blank" rel="external">Prime</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u8BD5_u9664_u6CD5"><a href="#u8BD5_u9664_u6CD5" class="headerlink" title="试除法"></a>试除法</h1><p>根据素数的定义，对于自然数$n$，只要能够找到除了1和它本身以外，能够整除该]]>
    </summary>
    
      <category term="prime" scheme="http://chaomai.github.io/tags/prime/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="algorithms" scheme="http://chaomai.github.io/categories/programming/algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++虚函数]]></title>
    <link href="http://chaomai.github.io/2016/01/04/2016-2016-01-04-cpp-virtual-function/"/>
    <id>http://chaomai.github.io/2016/01/04/2016-2016-01-04-cpp-virtual-function/</id>
    <published>2016-01-04T13:03:55.000Z</published>
    <updated>2016-01-05T13:38:40.935Z</updated>
    <content type="html"><![CDATA[<p>C++中有编译时多态和运行时多态，运行时多态是由虚函数实现的。虚函数是用过虚函数表（vftable，virtual function table）来实现的，这个表包含了这个类的虚函数地址，解决了继承、覆盖。当使用父类指针来操作一个子类对象的时候，通过子类对象的虚函数表指针（vfptr，virtual function table pointer）找到子类的vftable，进而找到应该调用的函数。</p>
<h1 id="u865A_u51FD_u6570_u8868"><a href="#u865A_u51FD_u6570_u8868" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>当一个类声明了虚函数或者继承了带有虚函数的父类，这个类就会有自己的vftable。vftable的实现大都为一个函数指针数组，每个函数指针指向该类的一个虚函数，同时该类的每个对象都会包含一个vfptr，vfptr指向vftable。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::a"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::b"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::c"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::d"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个<code>Base</code>类型对象，<code>Base b</code>，<code>b</code>的vfptr如下：</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/cpp_virtual_function_base_b.png" alt=""></p>
<ul>
<li>address of vfptr: <code>&amp;b</code>,</li>
<li>address of vftable: <code>*(int*)(&amp;b)</code>,</li>
<li>address of the first function in vftable: <code>(int*)(*(int*)(&amp;b))</code>,</li>
<li>the first function pointer: <code>(void(*)(void))*(int*)(*(int*)(&amp;b))</code>,</li>
<li>the second function pointer: <code>(void(*)(void))*((int*)*(int*)(&amp;b) + 1)</code> or <code>(void(*)(void))*(int*)(*(int*)(&amp;b) + 4)</code>,</li>
<li>the third function pointer: <code>(void(*)(void))*((int*)*(int*)(&amp;b) + 2)</code> or <code>(void(*)(void))*(int*)(*(int*)(&amp;b) + 8)</code>.</li>
</ul>
<h1 id="u4E00_u822C_u7EE7_u627F"><a href="#u4E00_u822C_u7EE7_u627F" class="headerlink" title="一般继承"></a>一般继承</h1><h2 id="u65E0_u865A_u51FD_u6570override"><a href="#u65E0_u865A_u51FD_u6570override" class="headerlink" title="无虚函数override"></a>无虚函数override</h2><p>对于一般继承、无虚函数override的情况，虚函数按照声明顺序放在表中，父类的虚函数在子类的虚函数前。</p>
<h2 id="u6709_u865A_u51FD_u6570override"><a href="#u6709_u865A_u51FD_u6570override" class="headerlink" title="有虚函数override"></a>有虚函数override</h2><p>如果有覆盖，那么被覆盖的虚函数被替换为子类中的函数，没有被覆盖的虚函数不变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::a"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::ad"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::bd"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::cd"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个<code>Base</code>类指针，<code>Base* bd = new Derived()</code>，<code>bd</code>的vfptr下如下：</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/cpp_virtual_function_derived_bd.png" alt=""></p>
<p>上图并未列出在<code>Derived</code>定义的三个函数，查看<code>bd</code>处内存，</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/cpp_virtual_function_derived_bd_mem.png" alt=""></p>
<p>前12 byte是前面列出的，接下来的12 byte就是<code>Derived::ad()</code>、<code>Derived::bd()</code>和<code>Derived::cd()</code>，可以通过<code>((void(*)(void))*((int*)*(int*)bd + 3))()</code>等调用。</p>
<h1 id="u591A_u91CD_u7EE7_u627F"><a href="#u591A_u91CD_u7EE7_u627F" class="headerlink" title="多重继承"></a>多重继承</h1><h2 id="u65E0_u865A_u51FD_u6570override-1"><a href="#u65E0_u865A_u51FD_u6570override-1" class="headerlink" title="无虚函数override"></a>无虚函数override</h2><p>对于没有虚函数覆盖的多重继承，每个父类都有自己的虚函数表，按照声明顺序，子类的成员函数被放到了第一个父类的表中。</p>
<h2 id="u6709_u865A_u51FD_u6570override-1"><a href="#u6709_u865A_u51FD_u6570override-1" class="headerlink" title="有虚函数override"></a>有虚函数override</h2><p>如果有虚函数覆盖，那么每个父类虚函数表中被覆盖的虚函数被替换为子类的函数指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::a"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::b"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::c"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::d"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::a"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::b"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::c"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::d"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base, <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::a"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::ad"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::bd"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::cd"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义一个<code>Base</code>类指针，<code>Base* bd = new Derived()</code>，<code>bd</code>的vfptr下如下：</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/cpp_virtual_function_multi_derived_bd.png" alt=""></p>
<p>三个vfptr可分别由<code>(int*)*(int*)bd</code>、<code>(int*)*((int*)bd+1)</code>和<code>(int*)*((int*)bd+2)</code>得到，或者以数组的方式<code>(int*)(((int*)bd)[0])</code>、…。</p>
<h1 id="u8BBF_u95EEnon-public_u51FD_u6570"><a href="#u8BBF_u95EEnon-public_u51FD_u6570" class="headerlink" title="访问non-public函数"></a>访问non-public函数</h1><p>只要有类中定义了虚函数，那么一定有虚函数表。通过指针访问虚函数表的方式，就算虚函数是non-public的，也能够访问到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Derived1 &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived1::ad"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived1::bd"</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived1::cd"</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived1* bd1 = <span class="keyword">new</span> Derived1();</span><br><span class="line">pf = (<span class="keyword">void</span>(*)(<span class="keyword">void</span>))*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)bd1);</span><br><span class="line">pf();</span><br></pre></td></tr></table></figure>
<h1 id="u7F16_u8BD1_u73AF_u5883"><a href="#u7F16_u8BD1_u73AF_u5883" class="headerlink" title="编译环境"></a>编译环境</h1><p>Visual Studio 2015, platform x86。在Visual Studio 2015、platform x86下, <code>sizeof(int) = 4</code>, <code>sizeof(int*) = 4</code>。</p>
<p>如果是x64，则<code>sizeof(int*) = 8</code>，那么无论是在LP64（Linux常用）下，还是在LLP64（Windows）下，<code>(int*)(*(int*)(&amp;b))</code>并不能得到vftable中第一个函数的正确地址，解引用截断了高4 byte，把高4 byte的值作为<code>int</code>。如果vftable的正确地址是<code>0x00007ff6 1f5aaf08</code>，那么<code>(int*)(*(int*)(&amp;b))</code>得到的是<code>0x00000000 1f5aaf08</code>。</p>
<p>与此同时，不同的编译器对vfptr和vftable可能有不同的实现方式，上述访问方法不一定能够在其他编译器中使用。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="http://www.viva64.com/en/t/0012/" target="_blank" rel="external">Data model</a></li>
<li><a href="http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/" target="_blank" rel="external">C++虚函数浅析</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/1948051" target="_blank" rel="external">C++ 虚表解析</a></li>
<li><a href="http://www.rudy-yuan.net/archives/128/" target="_blank" rel="external">对陈皓博客《C++虚函数解析》的补充</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[C++中有编译时多态和运行时多态，运行时多态是由虚函数实现的。虚函数是用过虚函数表（vftable，virtual function table）来实现的，这个表包含了这个类的虚函数地址，解决了继承、覆盖。当使用父类指针来操作一个子类对象的时候，通过子类对象的虚函数表指针（vfptr，virtual function table pointer）找到子类的vftable，进而找到应该调用的函数。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CKDTree(3)]]></title>
    <link href="http://chaomai.github.io/2015/12/13/2015-2015-12-13-ckd-3/"/>
    <id>http://chaomai.github.io/2015/12/13/2015-2015-12-13-ckd-3/</id>
    <published>2015-12-13T06:19:05.000Z</published>
    <updated>2015-12-12T06:39:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Basic_Idea"><a href="#Basic_Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h1><p>使用的方法同样来自Trevor Brown。在他的论文，Range Queries in Non-blocking k-ary Search Trees中，阐述了如何实现range query。</p>
<p>由于进行range query时，需要tree局部的一个constant view，因此snapshot是一个合适的工具。</p>
<p>在update操作中，这里方法比先前的方法多了一个操作：每个leaf都带有一个<code>dirty</code> field。每次进行update时，就把old leaf的<code>dirty</code>设为dirty（实现的时候，是把update info放到<code>dirty</code>）。</p>
<p>进行snapshot的时候，</p>
<ol>
<li>把所有leaf都放到一个list，<code>snap</code>里面，</li>
<li>检测<code>snap</code>中每个leaf的<code>dirty</code>。如果发现<code>dirty</code>已被设置为update info，那么就help update info，并重新开始snapshot。</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>Range Queries in Non-blocking k-ary Search Trees, Trevor Brown, Hillel Avni</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇是实现concurrent KDTree snapshot的第3个方法，也是打算写的最后一个方法。使用的方法来自的Range Queries in Non-blocking k-ary Search Trees。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="snapshot" scheme="http://chaomai.github.io/tags/snapshot/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes of Range Queries in Non-Blocking K-Ary Search Trees]]></title>
    <link href="http://chaomai.github.io/2015/12/12/2015-2015-12-12-notes-of-k-ary-range-query/"/>
    <id>http://chaomai.github.io/2015/12/12/2015-2015-12-12-notes-of-k-ary-range-query/</id>
    <published>2015-12-12T06:20:46.000Z</published>
    <updated>2015-12-12T06:18:44.170Z</updated>
    <content type="html"><![CDATA[<h1 id="Approaches_to_Range_Queries"><a href="#Approaches_to_Range_Queries" class="headerlink" title="Approaches to Range Queries"></a>Approaches to Range Queries</h1><ul>
<li>STM</li>
<li>Lock</li>
<li>Persistent data structures</li>
<li>Snapshot<ul>
<li>Ctrie</li>
<li>Snap</li>
</ul>
</li>
</ul>
<h1 id="Range_Query_in_k-ary_Search_Trees"><a href="#Range_Query_in_k-ary_Search_Trees" class="headerlink" title="Range Query in k-ary Search Trees"></a>Range Query in k-ary Search Trees</h1><h2 id="dirty_field"><a href="#dirty_field" class="headerlink" title="dirty field"></a><code>dirty</code> field</h2><p>The <code>dirty</code> field is set to dirty when the leaf is affected by some update operations (<code>helpInsert</code> and <code>helpMark</code>).</p>
<h2 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a><code>Validate</code></h2><p>The <code>Validate</code> check all leaves stored in <code>snap</code>. If any <code>dirty</code> field is true, than <code>Validate</code> returns false.</p>
<h2 id="Range_Query"><a href="#Range_Query" class="headerlink" title="Range Query"></a>Range Query</h2><p>The abridged <code>RangeQuery</code> follows few steps,</p>
<ol>
<li>Use DFS to populate <code>snap</code> with all leaves that may contain a key in range.</li>
<li>Invoke <code>Validate</code> to check all the leaves stored in <code>snap</code>. If <code>Validate</code> returns false, than retry.</li>
<li>Extract all keys in range from <code>snap</code> and return.</li>
</ol>
<h1 id="Differences_between_snaphots_in_BST_and_range_query_in_k-ary_search_trees"><a href="#Differences_between_snaphots_in_BST_and_range_query_in_k-ary_search_trees" class="headerlink" title="Differences between snaphots in BST and range query in k-ary search trees"></a>Differences between snaphots in BST and range query in k-ary search trees</h1><table>
<thead>
<tr>
<th>-</th>
<th style="text-align:center">snapshots in BST</th>
<th style="text-align:center">range query in k-ary search trees</th>
</tr>
</thead>
<tbody>
<tr>
<td>Efficiency</td>
<td style="text-align:center">low (iterate all nodes while checking)</td>
<td style="text-align:center">high</td>
</tr>
<tr>
<td>Scope</td>
<td style="text-align:center">global</td>
<td style="text-align:center">partial</td>
</tr>
</tbody>
</table>
<p><em>Just personal opinion, may contain errors.</em></p>
<h1 id="Some_Doubts"><a href="#Some_Doubts" class="headerlink" title="Some Doubts"></a>Some Doubts</h1><h2 id="Theorem_3_in_Proof"><a href="#Theorem_3_in_Proof" class="headerlink" title="Theorem 3 in Proof"></a>Theorem 3 in Proof</h2><p>In the paper,</p>
<blockquote>
<p>Theorem 3. All operations are non-blocking.</p>
</blockquote>
<p>After discussing this with Keren, both of us feel it should be a bug.</p>
<p>But actually it’s correct.</p>
<blockquote>
<p>My question:<br>If the update operations are always exist (insertion and deletion are frequently invoked), than <code>RangeQuery</code> cannot return. So the <code>RangeQuery</code> is actually blocked by these update operations.</p>
<p>Answer from Brown:<br>However, your intuition about range queries blocking is not quite correct. What you are referring to is <strong>starvation</strong>. <strong>Starvation can happen in any algorithm that is not wait-free.</strong> In order to be non-blocking, the algorithm simply needs to guarantee that, if operations are performed infinitely often, then operations will succeed infinitely often. (I.e., the system, as a whole, makes progress, even if some thread(s) starve.) Equivalently, a non-blocking progress guarantee simply states that it is impossible for /all/ threads to block forever. In your example, the fact that a range query is blocked by updates is not a problem, because the updates make progress.</p>
</blockquote>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>Non-blocking k-ary Search Trees, Trevor Brown, Joanna Helga</li>
<li>Range Queries in Non-blocking k-ary Search Trees, Trevor Brown, Hillel Avni</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇是k-ary的第二篇，为k-ary加入了range query，列举了range query的各种实现方法：STM，lock，Persistent data structures和snapshots，并说明各种方法的优劣，提出了range query的新方法。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes of Non-Blocking K-Ary Search Trees]]></title>
    <link href="http://chaomai.github.io/2015/11/30/2015-2015-11-30-notes-of-k-ary/"/>
    <id>http://chaomai.github.io/2015/11/30/2015-2015-11-30-notes-of-k-ary/</id>
    <published>2015-11-30T07:09:25.000Z</published>
    <updated>2015-11-30T08:33:19.523Z</updated>
    <content type="html"><![CDATA[<h1 id="About_k-ary_Search_Trees"><a href="#About_k-ary_Search_Trees" class="headerlink" title="About k-ary Search Trees"></a>About k-ary Search Trees</h1><ul>
<li>No duplicate key</li>
<li>Leaf-oriented k-ST</li>
<li>Each leaf has zero children and at most k - 1 keys</li>
<li>Each internal node has exactly k children and k − 1 keys (in increasing order)</li>
</ul>
<p>Non-blocking k-ary Search Trees需要平衡，tree的深度和每个internal node进行search和update时的work总量。</p>
<p>大的k–&gt;减少tree的depth，但是增加了每个internal node进行search和update时的work总量。</p>
<p>k = 4的时候，在高contention和低contention的情况下，性能都是最好的。<br>高contention时，较少的小k减少了update时影响到的key的数目，增加了并行度；低contention时，较少的depth加快了search，加快了update。</p>
<h1 id="From_BST_to_k-ary_Search_Trees"><a href="#From_BST_to_k-ary_Search_Trees" class="headerlink" title="From BST to k-ary Search Trees"></a>From BST to k-ary Search Trees</h1><ul>
<li>Insert: the BST’s insertion -&gt; sprouting insertion</li>
<li>Delete: the  BST’s deletion -&gt; pruning deletion</li>
<li>Coordination: extended from BST</li>
</ul>
<h1 id="Data_Structure"><a href="#Data_Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><h2 id="Nodes"><a href="#Nodes" class="headerlink" title="Nodes"></a>Nodes</h2><p>Each <strong>leaf</strong> has zero children and <strong>at most</strong> k − 1 keys (zero keys is permitted). Each <strong>internal node</strong> has exactly k children and k − 1 keys. Inside each node, keys are maintained in <strong>increasing order</strong>.</p>
<h2 id="Dummy_Nodes"><a href="#Dummy_Nodes" class="headerlink" title="Dummy Nodes"></a>Dummy Nodes</h2><p>Dummy nodes are used in BST to avoid special cases when there is no parent or grandparent to flag and mark. The following pruning deletion operation will meet similar problem. When perform pruning deletion, the leaf may <em>won’t have a parent or grandparent</em>. To avoid dealing with that, <strong>dummy nodes</strong> and <strong>empty leaves</strong> used again when initializing the tree.</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/k-ary_dummy.png" alt=""></p>
<ul>
<li>Dummy nodes: each have k − 1 keys valued $\infty$.</li>
<li>Empty leaves: 2k - 1 empty keys in total.</li>
</ul>
<h1 id="Sequential_Operations"><a href="#Sequential_Operations" class="headerlink" title="Sequential Operations"></a>Sequential Operations</h1><h2 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h2><p>Search for the key first.</p>
<h3 id="Sprouting_Insertion"><a href="#Sprouting_Insertion" class="headerlink" title="Sprouting Insertion"></a>Sprouting Insertion</h3><p>If the leaf is full, replaces the leaf by a <em>newly created</em> subtree.</p>
<p>The newly created subtree:</p>
<ul>
<li>The k - 1 greatest keys among the original k - 1 keys and the new key.</li>
<li>The children are k (the original k - 1 keys and the new key) <em>new</em> nodes.</li>
</ul>
<h3 id="Simple_Insertion"><a href="#Simple_Insertion" class="headerlink" title="Simple Insertion"></a>Simple Insertion</h3><p>If the leaf is full, replaces the leaf by a <em>newly</em> leaf with k keys (the original k - 1 keys and the new key).</p>
<h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h2><p>First search for the key.</p>
<h3 id="Pruning_Deletion"><a href="#Pruning_Deletion" class="headerlink" title="Pruning Deletion"></a>Pruning Deletion</h3><p>If the leaf has one key <strong>and</strong> the parent of leaf has <em>exactly two non-empty children</em>, replace the parent with the sibling of leaf.</p>
<h3 id="Simple_Deletion"><a href="#Simple_Deletion" class="headerlink" title="Simple Deletion"></a>Simple Deletion</h3><p>If the leaf has more than one key <strong>or</strong> the parent of leaf has more than two non-empty children, replace the leaf by a <em>new</em> leaf with key removed.</p>
<h1 id="Coordination"><a href="#Coordination" class="headerlink" title="Coordination"></a>Coordination</h1><p>Interleaved execution between concurrent updates in some particular order may cause problems (of cause).</p>
<p>The Coordination is similar to BST, but here the scheme is extended.</p>
<p>The following <code>UpdateStep</code> (<code>ReplaceFlag</code>, <code>PruneFlag</code> and <code>Mark</code>) objects is just like lock.</p>
<h2 id="ReplaceFlag"><a href="#ReplaceFlag" class="headerlink" title="ReplaceFlag"></a>ReplaceFlag</h2><p>For both types of insertion and simple deletion.</p>
<h2 id="PruneFlag"><a href="#PruneFlag" class="headerlink" title="PruneFlag"></a>PruneFlag</h2><p>For pruning deletion.</p>
<h2 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h2><p>Before an internal node is to disappear from the tree, it must ﬁrst be marked. Once a internal node is marked, its child pointer will never be changed.</p>
<h2 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h2><p>Initial stat of the <code>pending</code> filed in internal node.</p>
<h1 id="Help_Mechanism"><a href="#Help_Mechanism" class="headerlink" title="Help Mechanism"></a>Help Mechanism</h1><p>If an operation is unexpectedly delayed while holding access to a ﬂagged or marked node, the progress cannot be guaranteed. So helping mechanism is necessary. The method taken here is similar to the one in BST.</p>
<p>But the helping <strong>should not be abused</strong>. To avoid many <em>duplicate operation</em>, the helping is used in limited cases.</p>
<h1 id="On_The_Whole"><a href="#On_The_Whole" class="headerlink" title="On The Whole"></a>On The Whole</h1><p>Just for clear the thought.</p>
<p>The following picture isn’t presented in the paper. Because the idea in the paper is similar to BST. So it easy to imitate the original one in BST.</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/k-ary_states.png" alt=""></p>
<p><code>ReplaceFlag</code> is used in simple insertion, sprouting insertion and simple deletion. So the original notations, <code>ichild ...</code>, <code>dchild ...</code>, etc won’t apply.</p>
<h1 id="Differences_between_BST_and_k-ary_Search_Trees"><a href="#Differences_between_BST_and_k-ary_Search_Trees" class="headerlink" title="Differences between BST and k-ary Search Trees"></a>Differences between BST and k-ary Search Trees</h1><h2 id="Deletion-1"><a href="#Deletion-1" class="headerlink" title="Deletion"></a>Deletion</h2><p>There two types of deletion in k-ary Search Trees. And a particular interleave of insertion and deletion would result in key lost.</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/k-ary_deletion.png" alt=""></p>
<p>Suppose there are some nodes in k-ary search tree (see above figure) and two threads concurrently perform update.</p>
<ul>
<li>Thread ti: insert d at b (the order doesn’t mater)</li>
<li>Thread td: delete b</li>
</ul>
<p>The following operation sequence is executed (direction of child isn’t mentioned, but it should be fairly easy to see),</p>
<ol>
<li>td: <code>PruneFlag</code> gp</li>
<li>ti: <code>ReplaceFlag</code> p<br>from now on, the p won’t be marked by td until ti finished.</li>
<li>ti: Finish insertion and <code>Clean</code> p</li>
<li>td: Mark p</li>
<li>td: Change the pointer in gp to s</li>
</ol>
<p><strong>Consequence:</strong> Insertion of key, d is lost. :(</p>
<p>The problem is that pruning deletion changes the child of gp to the child of p without knowing the modification in the another child of p.</p>
<p>Above problem won’t happen in BST’s deletion, <em>since the new node (internal node or leaf) is always built from scratch.</em></p>
<p>So the <code>pending</code> of p must be read before <code>PruneFlag</code> set at gp and checked when performing mark cas. If any insertion occurred, the <code>pending</code> of p will be bound to changed and deletion will perform backtracking cas and restart.</p>
<p>BTY: In BST and k-ary search tree, the <code>pending</code> of p is already  read by the end of search and the above prerequisites in implementation is <strong>already done</strong>. <em>But it has special purpose and meaning here.</em></p>
<h1 id="Some_Doubts"><a href="#Some_Doubts" class="headerlink" title="Some Doubts"></a>Some Doubts</h1><h2 id="CAS_and_CASet"><a href="#CAS_and_CASet" class="headerlink" title="CAS and CASet"></a>CAS and CASet</h2><p>In k-ary search trees, CASet (compare-and-set) is used to implement CAS.But the prerequisites is the algorithm doesn’t suffer from the ABA problem.</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="type">CAS</span>(expect, value)</span><br><span class="line">  <span class="literal">result</span> = read(x)</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">result</span> != expect) <span class="keyword">return</span> <span class="literal">result</span></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="type">CASet</span>(expect, value)) <span class="keyword">return</span> expect</span><br><span class="line">  <span class="keyword">return</span> read(x)</span><br></pre></td></tr></table></figure>
<p>The reason why these algorithms doesn’t suffer from ABA problem is quite clear for me. But what does the prerequisites (doesn’t suffer from the ABA) for?</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>Non-blocking k-ary Search Trees, Trevor Brown, Joanna Helga</li>
<li>Non-blocking Binary Search Trees, Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Brown在Toronto大学读PhD期间写过2篇关于k-ary的文章，他读PhD期间的导师是Ellen，而Ellen正是写了Non-blocking Binary Search Trees的那位。这篇文章里看到了好几个methods或者ideas是extended from Non-blocking Binary Search Trees。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CKDTree (2)]]></title>
    <link href="http://chaomai.github.io/2015/11/24/2015-2015-11-24-ckd-2/"/>
    <id>http://chaomai.github.io/2015/11/24/2015-2015-11-24-ckd-2/</id>
    <published>2015-11-24T07:17:25.000Z</published>
    <updated>2015-12-12T06:38:18.413Z</updated>
    <content type="html"><![CDATA[<h1 id="Basic_Idea"><a href="#Basic_Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h1><p>这里使用的方法是Trevor Brown的non-blocking binary search tree的<a href="http://www.cs.utoronto.ca/~tabrown/ksts/StaticDictionary5.java" target="_blank" rel="external">实现</a>里面提到的，并没有在论文里说明。</p>
<p>基本思想非常简单，</p>
<ol>
<li>读取并保存所有node；</li>
<li>接着检查已保存的node与当前tree里的node是否都一样，发现不一样的，重新snapshot；</li>
<li>基于已保存的node，构建一棵新的tree，返回snapshot。</li>
</ol>
<p>这里的snapshot和上一篇中的就有很大不同。上一篇的snapshot基本上可以算作是在调用<code>snapshot()</code>的时候，tree的状态（特殊情况下需要retry）；而这里的必须保证，从第1步完成读取的时刻起，到第2步检查结束，都没有update发生，才能返回snapshot。</p>
<p>要注意的是，在第1和2步中，需要保存和检查所有的node（internal node和leaf）。这不同于使用GCAS的snapshot，只update internal node，在某些时刻，某些leaf实际上是共享的。</p>
<h1 id="size_in_Snapshot"><a href="#size_in_Snapshot" class="headerlink" title="size in Snapshot"></a><code>size</code> in Snapshot</h1><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="http://www.cs.utoronto.ca/~tabrown/ksts/StaticDictionary5.java" target="_blank" rel="external">http://www.cs.utoronto.ca/~tabrown/ksts/StaticDictionary5.java</a>, Trevor Brown</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇记录了另一种简单的方法来实现concurrent KDTree snapshot，当然简单是有代价的，那就是在snapshot的时候不允许并发的update（inset，delete）。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="snapshot" scheme="http://chaomai.github.io/tags/snapshot/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CKDTree (1)]]></title>
    <link href="http://chaomai.github.io/2015/11/20/2015-2015-11-20-ckd-1/"/>
    <id>http://chaomai.github.io/2015/11/20/2015-2015-11-20-ckd-1/</id>
    <published>2015-11-20T07:55:08.000Z</published>
    <updated>2015-11-20T08:01:47.646Z</updated>
    <content type="html"><![CDATA[<p>Concurrent KDTree with Snapshots, implemented in Java. This article is about some details in implementation.</p>
<h1 id="Basic_Idea"><a href="#Basic_Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h1><p>The methods used in this structure is heavily based on ideas in CTrie (snapshot) and Non-blocking Binary Search Trees (search, insert and delete).</p>
<ul>
<li>RDCSS</li>
<li>GCAS</li>
<li>Mark and Flag</li>
<li>Leaf-oriented tree</li>
</ul>
<h1 id="Problems_and_Solutions_in_Implementation"><a href="#Problems_and_Solutions_in_Implementation" class="headerlink" title="Problems and Solutions in Implementation"></a>Problems and Solutions in Implementation</h1><p>下面是实现的时候遇到的问题和自己对一些细节的思考，有的已经在两篇论文里面有所记录，但是自己没注意，又踩坑了，还有的是这个结构的设计隐含的问题。</p>
<h2 id="Dummy_Nodes"><a href="#Dummy_Nodes" class="headerlink" title="Dummy Nodes"></a>Dummy Nodes</h2><p>由于Non-blocking Binary Search Trees中的insert操作是需要mark parent的，因此，对于一棵空的tree（有一个root），parent并不存在，insert无法适用于这样的情况。delete也有类似的问题。</p>
<p>为了避免结点数目很少的时候需要考虑很多复杂的情况，Non-blocking Binary Search Trees里提到了使用两个key为$\infty_1$，$\infty_2$（其中$\infty_1 &lt; \infty_2$）的Dummy nodes，$\infty_1 &lt; \infty_2$这样的关系是为了保证Binary Search Trees的性质。</p>
<p>由于Java中，无法使用<code>Double.POSITIVE_INFINITY</code>来得到两个key，使得$\infty_1 &lt; \infty_2$，所以就干脆不管他们的关系，root的左右child都使用<code>Double.POSITIVE_INFINITY</code>作为key。</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/ckd1_2015%2011%2018%2016%2042%20Office%20Lens.jpg" alt=""></p>
<p>这样一来，</p>
<ol>
<li>只有在insert第一个key或者delete最后一个key的时候需要操作leaf dummy node。</li>
<li>除（1）以外，所有update都发生在上图三角形的sub tree里面。</li>
</ol>
<h2 id="Right_Child_of_Root"><a href="#Right_Child_of_Root" class="headerlink" title="Right Child of Root"></a>Right Child of Root</h2><p>既然没有key会进入root的right child，那么为什么不把root的right child设置为<code>null</code>。</p>
<p>不行，这个也是在写后续代码的时候发现的。进行<code>helpMark1</code>和<code>helpMark2</code>的时候，需要判断<code>GCAS</code>处理grand parent哪边的child，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (info.p == info.gp.GCAS_READ_LEFT_CHILD(<span class="keyword">this</span>)) &#123;</span><br><span class="line">  direction = Direction.LEFT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  direction = Direction.RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要delete的leaf是children of the left child of root，也就是说此时tree里面只有一个key。存在这么一种可能性，同时有多个thread来进行delete，其中一个thread已经成功进行了delete，其他某些的thread还没有执行上述代码。当开始执行以后，就会发现<code>p</code>不等于<code>gp</code>（即root）的left child，此时如果root的right为<code>null</code>，那么就会出错。</p>
<p><code>helpMark1</code>和<code>helpMark2</code>都包含上述操作，只是仅仅<code>helpMark1</code>才会触发问题。</p>
<h2 id="Type_Test_in_helpMarked1"><a href="#Type_Test_in_helpMarked1" class="headerlink" title="Type Test in helpMarked1"></a>Type Test in <code>helpMarked1</code></h2><p>当要delete的leaf，它的sibling是leaf时，<code>helpMarked1</code>来处理这种的情况。</p>
<p>在single thread的情况下，<code>helpDelete</code>在判断sibling的类型以后，如果是leaf，那么<code>helpMarked1</code>就会执行。</p>
<p>在multithread的情况下，某个thread看到update信息以后就直接执行<code>helpMarked1</code>，但是此时sibling的类型是不知道的。因为从update信息被发布，到<code>helpMarked1</code>被执行，sibling可能早就被其他thread改变了，如果变为internal node，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Leaf&lt;V&gt; ns = <span class="keyword">new</span> Leaf&lt;&gt;(sibling.key, ((Leaf&lt;V&gt;) sibling).value);</span><br></pre></td></tr></table></figure>
<p>那么上述代码就会报错。</p>
<h2 id="Mark_in_helpDelete"><a href="#Mark_in_helpDelete" class="headerlink" title="Mark in helpDelete"></a>Mark in <code>helpDelete</code></h2><p>Non-blocking Binary Search Trees提到marked的结点是不可更改的，实现的时候没有很在意，测试的时候就遇到了麻烦。</p>
<p><code>helpDelete</code>（1）首先mark parent，（2）read leaf的sibling，（3）根据sibling的类型来进行后续的操作。</p>
<p>（1）和（2）的顺序是不能改的，这也是mark的意义所在。mark以后，<code>helpMarked1</code>和<code>helpMarked2</code>中还会再次读取sibling，并用于构造新的node，然后<code>GCAS</code> grand parent的child。如果不能保证<code>helpDelete</code>中leaf的sibling在后续的操作中不变，那么构造出的新node很可能就是错的。</p>
<h2 id="startGen_in_searchKey"><a href="#startGen_in_searchKey" class="headerlink" title="startGen in searchKey"></a><code>startGen</code> in <code>searchKey</code></h2><p>这个结构使用了Ctrie里GCAS的idea，在search的时候来update从root到leaf的path。search使用的version number是在开始进行search前从root里read的。为什么不到每个node的时候就read一次version number？</p>
<p>因为如果在search到某个内部的结点的时候，执行了snapshot操作，那么root的version number就变了。此时search中read root的version number，就会造成path的错误更新，上半部分是老的version number，下面有一条新的version number的分支。</p>
<h2 id="Retry_after_GCAS_in_searchKey"><a href="#Retry_after_GCAS_in_searchKey" class="headerlink" title="Retry after GCAS in searchKey"></a>Retry after <code>GCAS</code> in <code>searchKey</code></h2><p><code>searchKey</code>中，如果发现要前往的branch是internal node，并且version低于<code>startGen</code>，那么就需要创建那个internal node新版本的copy，然后把cur node的branch设置为那个新版的node。</p>
<p>接下来，首先想到的是在cur node处重试（即下面代码里的<code>continue;</code>），但是如果<code>continue</code>了，那么<code>gp</code>，<code>gpupdate</code>和<code>depth</code>就会被“提前”更新（cur没有往下走，它们却被更新了），尤其是<code>depth</code>，可能被重复的加上了<code>p</code>的<code>skippedDepth</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cur <span class="keyword">instanceof</span> InternalNode) &#123;</span><br><span class="line">  gp = p;</span><br><span class="line">  gpupdate = pupdate;</span><br><span class="line">  ...</span><br><span class="line">  depth += p.skippedDepth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keyCompare(key, cur.key, depth++) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (left <span class="keyword">instanceof</span> InternalNode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left.gen != startGen) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> SearchRes.RESTART;</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>效率低些，但是更为稳妥的办法就是完全重新开始，<code>return SearchRes.RESTART;</code>。</p>
<h2 id="RDCSS"><a href="#RDCSS" class="headerlink" title="RDCSS"></a>RDCSS</h2><p><img src="http://7vilyb.com1.z0.glb.clouddn.com/ckd1_2015%2011%2019%2016%2026%20Office%20Lens.jpg" alt=""></p>
<h2 id="size_in_Snapshot"><a href="#size_in_Snapshot" class="headerlink" title="size in Snapshot"></a><code>size</code> in Snapshot</h2><p>未解决。</p>
<h2 id="Readonly_Iterator"><a href="#Readonly_Iterator" class="headerlink" title="Readonly Iterator"></a>Readonly Iterator</h2><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>Concurrent Tries with Efficient Non-Blocking Snapshots, Aleksandar Prokopec, Nathan G. Bronson, Phil Bagwell, Martin Odersky</li>
<li>Non-blocking Binary Search Trees, Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel</li>
<li>A Practical Multi-Word Compare-and-Swap Operation, Timothy L. Harris, Keir Fraser, Ian A. Pratt</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Concurrent KDTree with Snapshots, implemented in Java. This article is about some details in implementation.]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="snapshot" scheme="http://chaomai.github.io/tags/snapshot/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RDCSS]]></title>
    <link href="http://chaomai.github.io/2015/10/23/2015-2015-10-23-rdcss/"/>
    <id>http://chaomai.github.io/2015/10/23/2015-2015-10-23-rdcss/</id>
    <published>2015-10-23T13:42:51.000Z</published>
    <updated>2015-11-30T07:51:58.816Z</updated>
    <content type="html"><![CDATA[<p>RDCSS是Harris提出的一种实现double compare single swap方法，它的语义（也就是DCAS）如下，</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/rdcss_semantic.png" alt=""></p>
<h1 id="The_CAS1_Approach"><a href="#The_CAS1_Approach" class="headerlink" title="The CAS1 Approach"></a>The CAS1 Approach</h1><p>下面使用CAS1（single word compare and swap）来实现RDCSS。</p>
<p>这是descriptor和两个data section的示意图，</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/rdcss_descriptor.png" alt=""></p>
<p>下面是RDCSS的伪代码，</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/rdcss_implementation.png" alt=""></p>
<ol>
<li><p><strong>C1：</strong>首先尝试把a2变为descriptor d，如果CAS1成功，那么r == d-&gt;o2。</p>
</li>
<li><p><strong>H1：</strong>这步主要是针对C1失败的。如果C1成功，r不是descriptor。如果C1失败，有两种原因（其实是一种，只是分开看），（1）a2的数据被其他thread改为其他的数据，（2）a2被其他thread改为descriptor，那就帮助其他thread完成。</p>
</li>
<li><p><strong>B1：</strong>如果是H1（2），那么帮助其他thread完成以后，retry。</p>
</li>
<li><p><strong><code>if(r == d-&gt;o2) Complete</code>：</strong>这步是针对C1成功的。如果C1成功，继续执行。<br><em>在<a href="http://cstheory.stackexchange.com/questions/7083/a-practical-multi-word-compare-and-swap-operation" target="_blank" rel="external">A practical multi-word compare-and-swap operation - cstheory</a>里，axel22大神问这步能不能在不改变RDCSS语义的情况下省略。回答是，如果省略**RDCSS的这个部分`if(… &amp;&amp; (</em>a1 == o1)) <em>a2=n2`就不会执行**。或者运气好的话，其他thread帮助当前thread完成。</em></p>
</li>
<li><p><strong><code>return r</code>：</strong>返回a2里老的value，包括执行成功的情况和H1（1）。</p>
</li>
</ol>
<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>C2的if进行比较以后，会不会有其他thread改变o1？</strong></p>
<p>这里是一直没有想明白的。在看了Ctrie的代码以后，发现在做snapshot的时候，里面的root，mainnode和这里的Data section，Control section是对应的。要是这里存在这个问题，那么Ctrie里也存在（会不会有其他thread改变root里mainnode的reference）。</p>
<p>从Ctrie的角度来看，只要有thread在执行<code>RDCSS_Complete</code>，那么root一定是<code>RDCSS_Descriptor</code>。而任何thread想要更改root里mainnode，就必须首先read root。所以mainnode不会在某个thread正执行<code>RDCSS_Complete</code>的时候被改变。<br>（在上一篇，Notes of Non-Blocking Snapshots Concurrent Tries的<strong>A detail in <code>RDCSS_Complete</code></strong>部分，有详细的解释。）</p>
<p>再回过头来看这里的RDCSS，这里的Data section会不会相当于就是一个guard，要更改Control section，就必须首先read Data section。这样，在某个thread执行<code>RDCSS_Complete</code>的时候，其他thread直接去改变o1就是不可能的。（没有在这篇论文里面找到相关的说明，这里只是自己的理解。）</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>A Practical Multi-Word Compare-and-Swap Operation, Timothy L. Harris, Keir Fraser, Ian A. Pratt</li>
<li><a href="http://cstheory.stackexchange.com/questions/7083/a-practical-multi-word-compare-and-swap-operation" target="_blank" rel="external">A practical multi-word compare-and-swap operationn - cstheory</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[RDCSS是Harris提出的一种实现double compare single swap方法，使用了single word compare and swap来实现。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="dcas" scheme="http://chaomai.github.io/tags/dcas/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes of Non-Blocking Snapshots Concurrent Tries]]></title>
    <link href="http://chaomai.github.io/2015/10/22/2015-2015-10-22-notes-of-non-blocking-snapshots-concurrent-tries/"/>
    <id>http://chaomai.github.io/2015/10/22/2015-2015-10-22-notes-of-non-blocking-snapshots-concurrent-tries/</id>
    <published>2015-10-22T14:15:12.000Z</published>
    <updated>2015-11-30T07:51:54.093Z</updated>
    <content type="html"><![CDATA[<h1 id="Hash_tries"><a href="#Hash_tries" class="headerlink" title="Hash tries"></a>Hash tries</h1><p>Hash tries (Hash array mapped tries) are trees composed of internal nodes and leaves. Leaves store key-value bindings.</p>
<h1 id="Race"><a href="#Race" class="headerlink" title="Race"></a>Race</h1><p><img src="http://7vilyb.com1.z0.glb.clouddn.com/ctrie_conflict.png" alt=""></p>
<p>T1要插入k5到C2，与此同时T2要插入k4到C1。T1成功的进行了CAS，但是T2进行的CAS操作是在老的C2上，最后导致k4丢失。</p>
<p>这里的race类似于Non-blocking Binary Search Trees的情况，两个线程各自进行操作，就线程自己来看，所做的操作是正确的，但是相互不知道有race。</p>
<p><em>这个结构能否使用Non-blocking Binary Search Trees的方法（mark和flag）？</em></p>
<h2 id="u89E3_u51B3"><a href="#u89E3_u51B3" class="headerlink" title="解决"></a>解决</h2><p>引入各种中间结点。。。</p>
<h1 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h1><p><code>size</code>、<code>iterator</code>和<code>clear</code>不能简单的以lock-free的方式来实现，因为需要某一时刻的全局信息。基于atomic snapshot，这些操作可以高效和正确的得到结果。</p>
<p>当一个snapshot被创建时，root I-node被复制，并被设置为新的generation。这个generation count可以由每个I-node保存。当某些update操作检测到它gen比root老，它就创建带有最新gen的那个I-node的copy，并根据需要update parent。snapshot创建后最终的效果就是，当首次访问（update）那个leaf的时候，从root到leaf，整个path都被update。</p>
<p>这里用到的snapshot方法，我觉得本质上还是copy on write。</p>
<h2 id="Race-1"><a href="#Race-1" class="headerlink" title="Race"></a>Race</h2><p>创建snapshot的线程、读取了老的root且正在遍历并update的线程之间（插入操作的linearization point可能会先于snapshot的创建）。</p>
<h2 id="GCAS__28generation-compare-and-swap_29"><a href="#GCAS__28generation-compare-and-swap_29" class="headerlink" title="GCAS (generation-compare-and-swap)"></a>GCAS (generation-compare-and-swap)</h2><p>直接用CAS在这里并不可行，因为有gen，就需要同时比较新老数据，还有I-node和root的gen。</p>
<p>GCAS类似CAS，不同的地方是加入了I-node和root结点gen的比较。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCAS</span>(</span>in, old, n)</span><br><span class="line">	r = <span class="type">READ</span>(in.main)</span><br><span class="line">	<span class="keyword">if</span> r = old &amp;&amp; in.gen = <span class="type">READ</span>(root).gen &#123;</span><br><span class="line">		<span class="type">WRITE</span>(in.main. n)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>具体的操作是先不管gen的情况，把old Main node挂到new Main node的prev上，接着把new Main node挂到I-node，最后处理I-node下Main node的情况。</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/ctrie_gcas.png" alt=""></p>
<p><em>现在的问题是怎么update从root到leaf的path？</em></p>
<p>当遍历时遇到一个I-node，如果gen &lt; startgen，那么就创建它的C-node和这个C-node下面所有I-node的copy，这个C-node下面其他类型的node（S-node）不copy。这样就update了从root到leaf的path。</p>
<h2 id="RDCSS"><a href="#RDCSS" class="headerlink" title="RDCSS"></a>RDCSS</h2><p><em>问题又来了，其他I-node可以被创建copy，但是第一个I-node，即root，它并没有在C-node下面，如何创建新gen的root？</em></p>
<p>直接创建新gen root的copy，然后cas挂上去，这个方法并不好完成。因为只有当root和old I-node一致，且old I-node的main和old main一致（因为原文代码165行的地方，需要old main来构建新的I-node）时才行。</p>
<p>这里使用的RDCSS源自Harris提出的方法，类似GCAS。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RDCSS</span>(</span>ov, ovmain, nv)</span><br><span class="line">	r = <span class="type">READ</span>(root)</span><br><span class="line">	<span class="keyword">if</span> r = ov &amp;&amp; <span class="type">GCAS_READ</span>(ov.main) = ovmain &#123;</span><br><span class="line">		<span class="type">WRITE</span>(root, nv)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>要注意的是：如果两个线程，一个GCAS对root I-node进行操作，另一个RDCSS对Ctrie的root成员进行操作，那么回导致死锁（<strong>为什么？与RDCSS中</strong>（<em>C2的if进行比较以后，会不会有其他thread改变o1？</em>）<strong>这个问题有关？</strong>)。</p>
<p>因此引入了ABORTABLE_READ。</p>
<h3 id="A_detail_in_RDCSS_Complete"><a href="#A_detail_in_RDCSS_Complete" class="headerlink" title="A detail in RDCSS_Complete"></a>A detail in <code>RDCSS_Complete</code></h3><p>在阅读源码的时候，想到这么一个问题，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">val</span> <span class="title">oldmain</span> =</span> ov.gcasRead(<span class="keyword">this</span>)</span><br><span class="line"> <span class="keyword">if</span> (oldmain eq exp) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="type">CAS_ROOT</span>(desc, nv)) &#123;</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>My previous doubt lies in line 711. The <code>oldmain</code> is compared with <code>expectedmain</code>. If they are reference to same main node, then do <code>CAS_ROOT</code>.<br>Suppose thread A is executing <code>RDCSS_Complete</code> and just finished line 710. Thread B is inserting a key value pair at the mainnode of root. What if thread B changes the <code>MainNode</code> reference in the root into a new mainnode before thread A execute <code>CAS_ROOT</code>?</p>
<p>The doubt is unnecessary. Since thread A is executing <code>RDCSS_Complete</code>, the root must be <code>RDCSS_Descriptor</code>. If Thread B want to insert at the <code>MainNode</code> of root, it will read root first, find it’s <code>RDCSS_Descriptor</code> and call <code>RDCSS_Complete</code> to help thread A first. So Thread B can’t change the <code>MainNode</code> reference in the root directly.</p>
</blockquote>
<p>（与Aleksandar Prokopec邮件的内容，就是问题和自己的理解，这里只是做个整理，不翻译了，其实是懒。。。）</p>
<h2 id="Snashot"><a href="#Snashot" class="headerlink" title="Snashot"></a>Snashot</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot</span>(</span>)</span><br><span class="line">	r = <span class="type">RDCSS_READ</span>()</span><br><span class="line">	expmain = <span class="type">GCAS_READ</span>(r)</span><br><span class="line">	<span class="keyword">if</span> <span class="type">RDCSS</span>(r, expmain, <span class="keyword">new</span> <span class="type">INode</span>(expmain, <span class="keyword">new</span> <span class="type">Gen</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Ctrie</span> &#123;</span><br><span class="line">			root = <span class="keyword">new</span> <span class="type">INode</span>(expmain, <span class="keyword">new</span> <span class="type">Gen</span>)</span><br><span class="line">			readonly = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> snapshot()</span><br></pre></td></tr></table></figure>
<p><code>snapshot()</code>以后，实际上是产生了两个新的root I-node，其中一个替换Ctrie自己的root，另一个用于构成返回Ctrie，这个返回的Ctrie就是所需的snapshot。</p>
<p>从上面伪代码来看，可能会产生怀疑的是，<code>snapshot()</code>刚刚完成时，两个root I-node都是reference到同一个C-node。<em>如果某个线程更改了root下的C-node，那snapshot中root下的C-node也被改，snapshot还有什么意思？</em></p>
<p>snapshot的中的东西不会被更改，具体的原因如下，注意看版本号，</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/ctrie_snapshot.png" alt=""></p>
<p>换句话说，就是当没有update或access时，Ctrie和snapshot共享结点；但是如果Ctrie发生update或access，从root到访问位置的path就被copy和update了，snapshot里的不变。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot</span>(</span>)</span><br><span class="line">	r = <span class="type">RDCSS_READ</span>()</span><br><span class="line">	expmain = <span class="type">GCAS_READ</span>(r)</span><br><span class="line">	<span class="keyword">if</span> <span class="type">RDCSS</span>(r, expmain, <span class="keyword">new</span> <span class="type">INode</span>(expmain, <span class="keyword">new</span> <span class="type">Gen</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Ctrie</span> &#123;</span><br><span class="line">			root = r</span><br><span class="line">			readonly = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> snapshot()</span><br></pre></td></tr></table></figure>
<p>由于当计算snapshot的size或进行iterate时，snapshot是不变的，因此update涉及到的node是不必要的开销，因此使用旧的root，且把readonly设为true来构造snapshot。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>Concurrent Tries with Efficient Non-Blocking Snapshots, Aleksandar Prokopec, Nathan G. Bronson, Phil Bagwell, Martin Odersky</li>
<li>Non-blocking Binary Search Trees, Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel</li>
<li>A Practical Multi-Word Compare-and-Swap Operation, Timothy L. Harris, Keir Fraser, Ian A. Pratt</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Hash trie的并发会存在操作丢失的情况，类似Non-blocking Binary Search Trees里的情况，这里引入了中间结点来解决。同时文章还提出了一种snapshot的方法，这种方法对于tree很有用。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="snapshot" scheme="http://chaomai.github.io/tags/snapshot/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Miscellaneous Material About Concurrency]]></title>
    <link href="http://chaomai.github.io/2015/10/12/2015-2015-10-12-miscellaneous-material-about-concurrency/"/>
    <id>http://chaomai.github.io/2015/10/12/2015-2015-10-12-miscellaneous-material-about-concurrency/</id>
    <published>2015-10-12T13:43:54.000Z</published>
    <updated>2015-11-30T07:51:50.103Z</updated>
    <content type="html"><![CDATA[<h1 id="Cuckoo_hashing"><a href="#Cuckoo_hashing" class="headerlink" title="Cuckoo hashing"></a>Cuckoo hashing</h1><p>Cuckoo hashing是Rasmus Pagh, Flemming Friche Rodler在2001年提出的，在hash table中用于解决hash collision的一种方法，是一种开放寻址法的hash table。</p>
<p>Cuckoo hashing维护了两个hash table，$T_1$和$T_2$，使用两个hash function，$h_1$和$h_2$。每个key存储在$T_1$的$h_1(x)$或者$T_2$的$h_2(x)$，但不会同时存储在两个地方。</p>
<p>由于使用了两个hash table，Cuckoo hashing保证了在最坏情况下，lookup和delete也能有$O(1)$的时间，insert的期望时间是$O(1)$。</p>
<p>原始的cuckoo hashing并不支持并发读写，同时对于每个inset和lookup需要多个内存引用。Bin Fan, David G. Andersen, Michael Kaminsky在2013年提出了Concurrent Cuckoo hashing，用optimistic version，使得cuckoo hashing在保证原有空间高效性的情况下，支持多个reader和一个writer的并发访问；同时使用了针对每个key的short summary，提高了hash table操作中cache的局部性；还优化了insert操作，提高了吞吐率。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>Rasmus Pagh, Flemming Friche Rodler. Cuckoo Hashing[J]. Algorithms, 2001, 51(2).</li>
<li>Bin Fan, David G. Andersen, Michael Kaminsky. MemC3: Compact and Concurrent MemCache with Dumber Caching and Smarter Hashing[C]. Networked Systems Design and Implementation, 2013: 371-384.</li>
<li>Xiaozhou Li, David G. Andersen, Michael Kaminsky, Michael J. Freedman. Algorithmic improvements for fast concurrent Cuckoo hashing[C]. Proceedings of the Ninth European Conference on Computer Systems, 2014, 27.</li>
</ol>
<h1 id="Hopscotch_hashing"><a href="#Hopscotch_hashing" class="headerlink" title="Hopscotch hashing"></a>Hopscotch hashing</h1><p>Hopscotch hashing是Maurice Herlihy, Nir Shavit, Moran Tzafrir在2008年提出的，在hash table中用于解决hash collision的一种方法，是一种开放寻址法的hash table，结合了linear探测、链式hash和cuckoo hash的优点。</p>
<p>它使用了一个hash function，$h$和hopscotch方法。hash table的每个项都包含一个hop-information，一个$H$-bit的一个bitmap（$H$是常数，通常是一个word），被hash到table里的每个item，x总会在$h(x)$或者下$H-1$个位置被找到。</p>
<p>它的insert，remove和contains的期望时间都是常数时间。</p>
<p>Hopscotch hashing在设计之初就考虑到了并发，使用了lock和time stamp的方式来保证了并发安全性。</p>
<h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>Maurice Herlihy, Nir Shavit, Moran Tzafrir. Hopscotch Hashing[C]. Proceedings of the 22nd international symposium on Distributed Computing, 2008: 350-364.</li>
</ol>
<h1 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h1><p>spinlock是一种同步机制，它会导致线程进入忙等待，不断检查锁是否可用，并尝试获取锁。</p>
<p>它避免了操作系统进行调度时的开销。</p>
<p>由于spinlock是忙等待，因此在多处理器上使用才有意义。spinlock在锁可能耽搁一小段时间的情况下，很高效。因为这个原因，操作系统的内核中经常使用spinlock。</p>
<h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>Maurice Herlihy, Nir Shavit. The Art of Multiprocessor Programming Revised Reprint [M]. Elsevier, 2012.</li>
</ol>
<h1 id="rwlock"><a href="#rwlock" class="headerlink" title="rwlock"></a>rwlock</h1><p>Readers-writer lock是一种同步原语。在访问共享对象时，对于仅有reader的情况，是完全不需要同步的，但如果有writer，就需要同步。当一个wirter范围共享数据的时候，其他所有的writer和reader都会被阻塞，直到这个writer结束访问。</p>
<p>在共享数据更新很少，读取很多的情况下，Readers-writer lock会拥有很高的效率。</p>
<h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>Maurice Herlihy, Nir Shavit. The Art of Multiprocessor Programming Revised Reprint [M]. Elsevier, 2012.</li>
</ol>
<h1 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h1><p>RCU是一种同步机制，在Linux内核中有广泛的用途，Linux内核2.5.43版本就开始使用RCU，截至2014年，已经使用了超过9000个RCU API。它允许reader和writer并发的访问共享数据，支持一个writer和多个reader之间的并发。通过维护多个版本的数据，RCU保证了reader读取到的数据的一致性，还保证在reader完成读取前，被访问的数据不会被释放。</p>
<p>RCU有3个基本机制，用于insert的Publish-Subscribe机制、用于delete的Wait For Pre-Existing RCU Readers to Complete机制和允许reader容忍并发insert和delete的Maintain Multiple Versions of Recently Updated Objects机制。</p>
<h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>Paul E. McKenney, John D. Slingwine. Read-Copy Update: Using Execution History to Solve Concurrency Problems[C]. Parallel and Distributed Computing and Systems, 1998: 509–518.</li>
<li>Paul E. McKenney, Jonathan Walpole. Introducing technology into the Linux kernel: a case study[C]. Special Interest Group on Operating Systems, 2008, 42(5): 4–17.</li>
</ol>
<h1 id="CPU_with_HTM_from_Intel_and_IBM"><a href="#CPU_with_HTM_from_Intel_and_IBM" class="headerlink" title="CPU with HTM from Intel and IBM"></a>CPU with HTM from Intel and IBM</h1><h2 id="Intel"><a href="#Intel" class="headerlink" title="Intel"></a>Intel</h2><p>Transactional Synchronization Extensions（TSX）是x86架构指令集的扩展，这个扩展加入了Hardware Transactional Memory（HTM）的支持。</p>
<p>在2013年6月，Intel推出了基于Haswell微架构的处理器。Haswell处理器成为了主流处理器中首次引入Transactional Memory的处理器，在这一系列的处理器中，型号低于45xx，R系列和K系列的不支持TSX。</p>
<h2 id="IBM"><a href="#IBM" class="headerlink" title="IBM"></a>IBM</h2><h3 id="Power8"><a href="#Power8" class="headerlink" title="Power8"></a>Power8</h3><p>IBM在2013年8月的Hot Chips会议上推出了Power8。Power8是基于Power架构的超标量体系结构对称多处理器家族。Power8加入了Hardware Transactional Memory的支持。</p>
<h3 id="Blue_Gene"><a href="#Blue_Gene" class="headerlink" title="Blue Gene"></a>Blue Gene</h3><p>Blue Gene是IBM的一个项目，目标是设计计算速度能够达到PFLOPS级别的，同时低能耗的超级计算机。这个项目产生了3代的超级计算机，Blue Gene/L，Blue Gene/P和Blue Gene/Q。其中Blue Gene/Q支持Transactional Memory。</p>
]]></content>
    <summary type="html">
    <![CDATA[简单记录了一些关于并发的资料（hash table，spinlock，rwlock和CPU对HTM的支持）。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes of Non-Blocking Binary Search Trees]]></title>
    <link href="http://chaomai.github.io/2015/10/04/2015-2015-10-04-notes-of-non-blocking-binary-search-trees/"/>
    <id>http://chaomai.github.io/2015/10/04/2015-2015-10-04-notes-of-non-blocking-binary-search-trees/</id>
    <published>2015-10-04T09:21:49.000Z</published>
    <updated>2015-11-20T15:34:04.936Z</updated>
    <content type="html"><![CDATA[<h1 id="specification"><a href="#specification" class="headerlink" title="specification"></a>specification</h1><ul>
<li>no duplicate key</li>
<li>deleting non-existent key leads to return false</li>
<li><p>leaf-oriented BST</p>
<blockquote>
<ul>
<li>all keys currently in the dictionary are <strong>stored in the leaves of the tree.</strong></li>
<li>Internal nodes of the tree are used to direct a Find operation along the path to the correct leaf.</li>
<li>The keys stored in internal nodes may or may<br>not be in the dictionary.</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="features"><a href="#features" class="headerlink" title="features"></a>features</h1><ul>
<li>non-blocking</li>
<li><p>linearizable</p>
<blockquote>
<p>for every execution, one can assign a linearization point to each completed operation and some of the uncompleted operations <strong>so that the linearization point of each operation occurs after the operation starts and before it ends</strong>, and the results of these operations are the same <em>as if they had been performed sequentially, in the order of their linearization points.</em></p>
</blockquote>
</li>
</ul>
<h1 id="basic_idea"><a href="#basic_idea" class="headerlink" title="basic idea"></a>basic idea</h1><p>类似Harris’ Linked List里面的做法，这里是mark the parent of the leaf before<br>splicing that parent out of the tree。一旦被标记，那么其指向子结点的指针将不能被改变。</p>
<h1 id="problems"><a href="#problems" class="headerlink" title="problems"></a>problems</h1><p><img src="http://7vilyb.com1.z0.glb.clouddn.com/non-block-bst_problems.png" alt=""></p>
<p>上图中，两个线程分别delete C和E，两个concurrent operation同时看到了BST以后，接下来的操作是，<em>基于各自看到的的BST来进行的</em>，它们彼此并不知道对方进行了什么操作，最后导致E并没有被deleted，其中一个操作丢失了。</p>
<p>解决这个需要对parent的child pointer进行mark，但是要mark的pointer是存在两个不同的word（left and right child pointer）里面的，不能够用一个cas来同时mark。</p>
<h1 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h1><p>using a separate state <strong>ﬁeld of the node</strong> to mark or flag，而不是mark那个pointer。</p>
<ul>
<li>mark: node marked is unchangeable。</li>
<li>flag: indicate that an update is trying to change a child pointer of the node.</li>
</ul>
<p>mark和flag类似于加锁。</p>
<h2 id="insert_u548Cdelete"><a href="#insert_u548Cdelete" class="headerlink" title="insert和delete"></a>insert和delete</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p><img src="http://7vilyb.com1.z0.glb.clouddn.com/non-block-bst_insert.png" alt=""></p>
<p>Insert (C):</p>
<ol>
<li>ﬂag node D’s parent, node B,</li>
<li>change the appropriate child pointer of node B,</li>
<li>unﬂag node B.</li>
</ol>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><img src="http://7vilyb.com1.z0.glb.clouddn.com/non-block-bst_delete.png" alt=""></p>
<p>Delete (C):</p>
<ol>
<li>ﬂag C’s grandparent, node B,</li>
<li>mark C’s parent, node D,</li>
<li>change the appropriate child pointer of B,</li>
<li>unﬂag node B.</li>
</ol>
<p>insert在完成第一步以后，在insert进行后续操作时，其他线程将不能够block insert。delete类似的，在完成第一二步以后也是。</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/non-block-bst_delete2.png" alt=""></p>
<p>但是delete在完成第一步以后，第二步mark有可能失败，比如insert把将要删除的node换为新的三个node。in which case the ﬂag is no longer on the node whose child pointer must be changed to accomplish the deletion.</p>
<p>如果mark失败，delete会remove flag，重新开始。</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/non-block-bst_state.PNG" alt=""></p>
<h1 id="some_details_in_implementation"><a href="#some_details_in_implementation" class="headerlink" title="some details in implementation"></a>some details in implementation</h1><h2 id="helping_mechanism"><a href="#helping_mechanism" class="headerlink" title="helping mechanism"></a>helping mechanism</h2><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>类似Barnes的方法，将线程拥有lock换成操作拥有lock（marked or flagged）。一个操作在处理tree的同时，还保存了它在holding lock的时候要进行的操作，其他线程遇到lock，就帮助它完成，使得lock最终release。</p>
<p>为了避免helping mechanism带来的性能下降（多个线程会尝试进行同一个操作），这里用了保守的策略： a process P helps another process’s operation <strong>only if the other operation is preventing P’s own progress</strong>.</p>
<h3 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h3><p>线程之间是无法自动感知对方的存在的，也就是说实现helping mechanism，需要a data structure that is shared between threads holds the operating information。</p>
<h2 id="dummy_keys"><a href="#dummy_keys" class="headerlink" title="dummy keys"></a>dummy keys</h2><p>在delete时，需要flag grandparent和mark parent，如果BST的key少于4个，必然就会有一个leaf没有grandparent，那么在delete就需要考虑很多例外的情况（insert类似）。</p>
<p>为了避免这些特殊情况，下面引入两个特殊值$\infty_1$和$\infty_2$，使得BST在没有key的时候，也存在3个node。这两个dummy keys是不允许删除的。</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/non-block-bst_dummy_keys.png" alt=""></p>
<h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol>
<li><strong>Excellent tutorial</strong> about helping mechanism!!!</li>
<li>在树上面进行并发操作的时候，这篇论文中描述的问题其实大都是存在的，因此论文中的方法可以考虑用到其他树型结构上面。</li>
</ol>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ol>
<li>Non-blocking Binary Search Trees, Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[使用了mark标记结点的方式，解决了single word cas无法同时操作multi-word的问题，同时使用外部树减少了操作影响到的结点的数目，还有就是Excellent tutorial about helping mechanism!]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes of Read-Log-Update a Lightweight Synchronization Mechanism for Concurrent Programming]]></title>
    <link href="http://chaomai.github.io/2015/09/26/2015-2015-09-26-notes-of-rlu/"/>
    <id>http://chaomai.github.io/2015/09/26/2015-2015-09-26-notes-of-rlu/</id>
    <published>2015-09-26T05:34:55.000Z</published>
    <updated>2015-11-30T07:51:34.996Z</updated>
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>RCU, this barrier-based mechanism, allows for simple epoch-based reclamation of the old copies, and the mechanism as a whole eliminates many of the atomic read-modify-write instructions, memory barriers, and cache misses that are so expensive on modern multicore systems.</p>
<h2 id="About_RLU"><a href="#About_RLU" class="headerlink" title="About RLU"></a>About RLU</h2><ul>
<li>Novel extension of RCU framework that support read-only traverals concurrently with multiple updates.</li>
<li>In a semi-automated way.</li>
<li>Removes from the programmer the burder of handcrafting the concurrent copy management using only single pointer manipulations.</li>
<li>Can be API-compatible with RCU.</li>
</ul>
<h2 id="About_Implementation_of_RLU"><a href="#About_Implementation_of_RLU" class="headerlink" title="About Implementation of RLU"></a>About Implementation of RLU</h2><ul>
<li>Clock-based logging mechanism.</li>
<li>Object-level write-log per thread.</li>
</ul>
<h1 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h1><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For all operations:</span></span><br><span class="line"></span><br><span class="line">   +--------------+</span><br><span class="line">   |all operations|</span><br><span class="line">   +------+-------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">+---------v-----------+</span><br><span class="line">|read the global clock|</span><br><span class="line">+---------+-----------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">       +--v--+</span><br><span class="line">       |start|</span><br><span class="line">       +-----+</span><br><span class="line"></span><br><span class="line"><span class="comment">// For writer:</span></span><br><span class="line">                              +------+</span><br><span class="line">              +--+            |writer|</span><br><span class="line">              |               +---+--+</span><br><span class="line">              |                   |</span><br><span class="line">              |                   |</span><br><span class="line">              |     +-------------v-------------------------------+</span><br><span class="line">              |     | copy the object into a its own              |</span><br><span class="line">modification&lt;-+     |thread wirte-<span class="built_in">log</span> and lock the original object|</span><br><span class="line">              |     +-------------+-------------------------------+</span><br><span class="line">              |                   |</span><br><span class="line">              |                   |</span><br><span class="line">              |      +------------v-------------+</span><br><span class="line">              |      |manipulate the object copy|</span><br><span class="line">              +---+  +--------------+-----------+</span><br><span class="line">                                    |</span><br><span class="line">                                    |</span><br><span class="line">              +---+    +------------v------------------------------+</span><br><span class="line">              |        |increments the write clock and global clock|</span><br><span class="line">              |        +------------+------------------------------+</span><br><span class="line">              |                     |</span><br><span class="line">              |                     |</span><br><span class="line">              |      +--------------v----------------+</span><br><span class="line">              |      |splits operations into two sets|</span><br><span class="line">              |      +--------------+----------------+</span><br><span class="line">              |                     |</span><br><span class="line">      commit&lt;-+                     |</span><br><span class="line">              |     +---------------v-----------------+</span><br><span class="line">              |     |wait <span class="keyword">for</span> old operations to finish|</span><br><span class="line">              |     +---------------+-----------------+</span><br><span class="line">              |                     |</span><br><span class="line">              |                     |</span><br><span class="line">              |     +---------------v--------------------+</span><br><span class="line">              |     |   write back the <span class="keyword">new</span> objects       |</span><br><span class="line">              |     |from the writer-<span class="built_in">log</span> into the memory,|</span><br><span class="line">              |     |  overwriting the old objects,      |</span><br><span class="line">              |     |      release the locks             |</span><br><span class="line">              +---+ +------------------------------------+</span><br></pre></td></tr></table></figure>
<p>The writer’s modifications are:</p>
<ul>
<li>hidden from concurrent reads,</li>
<li>avoid conflicts with concurrent writes.</li>
</ul>
<p>In the following figure, <strong>the order of updating new value</strong>, 23, at write-clock and global-clock is important. Because all new object copies of the write-log become visible at once to all concurrent RLU protected section <strong>after the increment of global clock</strong>.</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/rlu_readers%20and%20writer.png" alt=""></p>
<p>Many of the lock mentioned is not really calling <code>pthread_mutex_lock()</code> but just performing a update at a specific filed in data.</p>
<h2 id="Synchronizing_Write_Operations"><a href="#Synchronizing_Write_Operations" class="headerlink" title="Synchronizing Write Operations"></a>Synchronizing Write Operations</h2><p>Two approaches:</p>
<ul>
<li>Execute writers serially.</li>
<li>Fine-grained locks.</li>
</ul>
<h3 id="Execute_Writers_Serially"><a href="#Execute_Writers_Serially" class="headerlink" title="Execute Writers Serially"></a>Execute Writers Serially</h3><p>Using a global lock for each writer is simplicity of the code and the concurrency that does exist between read-only and write operations.</p>
<p>But the drawback is a lack of scalability.</p>
<h3 id="Fine-grained_Locks"><a href="#Fine-grained_Locks" class="headerlink" title="Fine-grained Locks"></a>Fine-grained Locks</h3><p>Each object that a writer modifies is logged and locked (as shown in the former figure) by the RLU mechanism.</p>
<h2 id="Fine-grained_Locking_Using_RLU"><a href="#Fine-grained_Locking_Using_RLU" class="headerlink" title="Fine-grained Locking Using RLU"></a>Fine-grained Locking Using RLU</h2><p>RLU locks can be used as a fine-grained locking mechanism.</p>
<p>For standard lock, it is necessary to execute post-lock customized verifications to ensure that the state of the object is still the same as it was before locking. This action is unnecessary for RLU locks.</p>
<h2 id="Data_Structures"><a href="#Data_Structures" class="headerlink" title="Data Structures"></a>Data Structures</h2><p>Global:</p>
<ul>
<li>a global clock</li>
<li>a global array of threads</li>
</ul>
<p>Thread:</p>
<ul>
<li>two write-logs: new object copies<ul>
<li>header:<ul>
<li>a thread indentifier</li>
<li>a pointer: point to the actual object</li>
<li>the object size</li>
<li>a special pointer value that indicates this is a copy (constant)</li>
</ul>
</li>
</ul>
</li>
<li>a run counter: the thread is active or not</li>
<li>a local clock: stealing mechanism</li>
<li>write clock for each thread: stealing mechanism<ul>
<li>write clock of a thread is initially $\infty$ and write clock is updated first (than global clock), so stealing from a thread is only possible when is updates the write clock during the commit</li>
</ul>
</li>
</ul>
<p>Object header:</p>
<ul>
<li>a pointer: points to the copy of this object in a write-log</li>
</ul>
<p><strong>Note:</strong> The actually code is the way of much more complex than previously mentioned. But these code are also nice course of programming in C.</p>
<h1 id="RLU_Deferring"><a href="#RLU_Deferring" class="headerlink" title="RLU Deferring"></a>RLU Deferring</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------+</span><br><span class="line">|writer saves the current write-<span class="built_in">log</span>|</span><br><span class="line">|and generates <span class="keyword">new</span> <span class="built_in">log</span> <span class="keyword">for</span> the next|</span><br><span class="line">|writer                            |</span><br><span class="line">+---------+------------------------+</span><br><span class="line">          |</span><br><span class="line">          | <span class="keyword">if</span> a writer tries to lock an object</span><br><span class="line">          | that is already locked</span><br><span class="line">          |</span><br><span class="line">+---------v---------------------------+</span><br><span class="line">|writer sends a <span class="string">"sync request"</span> to     |</span><br><span class="line">|the conflicting thread to force it to|</span><br><span class="line">|release it locks                     |</span><br><span class="line">|                                     |</span><br><span class="line">|(global-clock++ -&gt; rlu sync -&gt;       |</span><br><span class="line">| write back -&gt; unlock                |</span><br><span class="line">+-------------------------------------+</span><br></pre></td></tr></table></figure>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming, Alexander Matveev, Nir Shavit, Pascal Felber, Patrick Marlier</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[今年SOSP的文章，提出了Read-Log-Update，使用了Clock-based logging mechanism和Object-level write-log per thread，解决了RCU不能有多个writer等缺陷。其中的RLU Deferring减少了synchronize调用的次数，提高了cache hit。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RCU]]></title>
    <link href="http://chaomai.github.io/2015/09/25/2015-2015-09-25-rcu/"/>
    <id>http://chaomai.github.io/2015/09/25/2015-2015-09-25-rcu/</id>
    <published>2015-09-25T11:00:58.000Z</published>
    <updated>2015-09-26T05:47:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Brief_Introduction"><a href="#Brief_Introduction" class="headerlink" title="Brief Introduction"></a>Brief Introduction</h1><ol>
<li><p>a <strong>synchronization mechanism</strong>.</p>
</li>
<li><p>allowing read to occur concurrently with updates.</p>
</li>
<li><p>supports concurrency between a <strong>single updater and multiple readers</strong>.</p>
</li>
<li><p>ensures that reads are coherent by maintaining multiple versions of objects and ensuring that they are not freed up until all pre-existing read-side critical sections complete.</p>
</li>
<li><p>defines and uses efficient and scalable mechanisms for publishing and reading new versions of an object, and also for deferring the collection of old versions.</p>
</li>
<li><p>read-side primitives have zero overhead in non-preemptable kernels.</p>
</li>
</ol>
<h1 id="Fundamental_Mechanisms"><a href="#Fundamental_Mechanisms" class="headerlink" title="Fundamental Mechanisms"></a>Fundamental Mechanisms</h1><ol>
<li>Publish-Subscribe Mechanism (for insertion)</li>
<li>Wait For Pre-Existing RCU Readers to Complete (for deletion)</li>
<li>Maintain Multiple Versions of Recently Updated Objects (allow readers to tolerate concurrent insertions and deletions)</li>
</ol>
<h2 id="Publish-Subscribe_Mechanism__28insertion_29"><a href="#Publish-Subscribe_Mechanism__28insertion_29" class="headerlink" title="Publish-Subscribe Mechanism (insertion)"></a>Publish-Subscribe Mechanism (insertion)</h2><p>RCU uses what can be thought of as a publish-subscribe mechanism to provide <em>the ability to safely scan data, even though that data is being modified concurrently.</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="keyword">struct</span> foo &#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> foo *gp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line"></span><br><span class="line">p = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">p-&gt;a = <span class="number">1</span>;</span><br><span class="line">p-&gt;b = <span class="number">2</span>;</span><br><span class="line">p-&gt;c = <span class="number">3</span>;</span><br><span class="line">gp = p;</span><br></pre></td></tr></table></figure>
<h3 id="Problem_1_-_rcu_assign_pointer_28_29"><a href="#Problem_1_-_rcu_assign_pointer_28_29" class="headerlink" title="Problem 1 - rcu_assign_pointer()"></a>Problem 1 - <code>rcu_assign_pointer()</code></h3><p>The <strong>memory reordering</strong> in updater may cause that concurrent readers could see the uninitialized values (<code>gp</code>). And this requires to use <strong>memory barriers (hard)</strong> to keep things ordered.</p>
<p>The primitive, <code>rcu_assign_pointer()</code>, encapsulates these memory barriers.</p>
<p>The <code>rcu_assign_pointer()</code> would <strong>publish</strong> the new structure, forcing both the compiler and the CPU to execute the assignment to <code>gp</code> after the assignments to the fields referenced by <code>p</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gp = p;</span></span><br><span class="line">rcu_assign_pointer(gp, p);</span><br></pre></td></tr></table></figure>
<h3 id="Problem_2_-_rcu_dereference_28_29"><a href="#Problem_2_-_rcu_dereference_28_29" class="headerlink" title="Problem 2 - rcu_dereference()"></a>Problem 2 - <code>rcu_dereference()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line">p = gp;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not only the updater but also the reader requires enforce ordering because of the <strong>value-speculation compiler optimizations</strong> (the compiler guess the value p, access its filed, then fetch the actual value of p and check the guess) in the context of <strong>profile-driven optimization</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock();</span><br><span class="line">p = rcu_dereference(gp);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br></pre></td></tr></table></figure>
<p>The <code>rcu_dereference()</code> primitive can thus be thought of as <strong>subscribing</strong> to a given value of the specified pointer, guaranteeing that subsequent dereference operations <em>will see any initialization that occurred before the corresponding publish (<code>rcu_assign_pointer()</code>) operation</em>.</p>
<p>The <code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code> calls are absolutely required: they define the extent of the <strong>RCU read-side critical section</strong>. In non-<code>CONFIG_PREEMPT</code> kernels, they generate absolutely no code.</p>
<h3 id="Special_RCU_Variants"><a href="#Special_RCU_Variants" class="headerlink" title="Special RCU Variants"></a>Special RCU Variants</h3><p>Special RCU variants of Linux’s list-manipulation API contains <code>rcu_assign_pointer()</code> and <code>rcu_dereference()</code> primitives.</p>
<p>Doubly linked list in Linux:</p>
<ul>
<li>the circular <code>struct list_head</code></li>
<li>the linear <code>struct hlist_head</code>/<code>struct hlist_node</code> pair</li>
</ul>
<h3 id="RCU_Publish_and_Subscribe_Primitives"><a href="#RCU_Publish_and_Subscribe_Primitives" class="headerlink" title="RCU Publish and Subscribe Primitives"></a>RCU Publish and Subscribe Primitives</h3><table>
<thead>
<tr>
<th>Category</th>
<th>Publish</th>
<th>Retract</th>
<th>Subscribe</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pointers</td>
<td><code>rcu_assign_pointer()</code></td>
<td><code>rcu_assign_pointer(..., NULL)</code></td>
<td><code>rcu_dereference()</code></td>
</tr>
<tr>
<td>Lists</td>
<td><code>list_add_rcu()</code> <code>list_add_tail_rcu()</code> <code>list_replace_rcu()</code></td>
<td><code>list_del_rcu()</code></td>
<td><code>list_for_each_entry_rcu()</code></td>
</tr>
<tr>
<td>Hlists</td>
<td><code>hlist_add_after_rcu()</code> <code>hlist_add_before_rcu()</code> <code>hlist_add_head_rcu()</code> <code>hlist_replace_rcu()</code></td>
<td><code>hlist_del_rcu()</code></td>
<td><code>hlist_for_each_entry_rcu()</code></td>
</tr>
</tbody>
</table>
<p>The <code>list_replace_rcu()</code>, <code>list_del_rcu()</code>, <code>hlist_replace_rcu()</code>, and <code>hlist_del_rcu()</code> introduce a new problem. When is it safe to free up the data element that was replaced or removed?</p>
<h2 id="Wait_For_Pre-Existing_RCU_Readers_to_Complete__28deletion_29"><a href="#Wait_For_Pre-Existing_RCU_Readers_to_Complete__28deletion_29" class="headerlink" title="Wait For Pre-Existing RCU Readers to Complete (deletion)"></a>Wait For Pre-Existing RCU Readers to Complete (deletion)</h2><p>RCU is a way of waiting for lots of (for example, 20,000) different things to finish without having to explicitly track each and every one of them.</p>
<h3 id="About_Waiting"><a href="#About_Waiting" class="headerlink" title="About Waiting"></a>About Waiting</h3><p><img src="http://7vilyb.com1.z0.glb.clouddn.com/rcu_waiting.png" alt=""></p>
<p>The things waited on RCU read-side critical sections, which can be <strong>nested, and may contain pretty much any code, as long as that code does not explicitly block or sleep </strong>(<strong>SRCU</strong> is a special case).</p>
<p>When readers are not inside a read-side critical section, they are in a <strong>quiescent state</strong>.</p>
<p>A time period during which all such pre-existing readers complete is called a <strong>grace period</strong>. (or a period of time during which every<br>thread goes through at least one quiescent state is called a<br>grace period.)</p>
<p>If the section begins after the beginning of a given grace period, the execution of that section will extend beyond the end of that grace period. Because after the beginning of a given grace period, *new readers won’t hold a reference to old data.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> foo &#123;</span><br><span class="line">  <span class="keyword">struct</span> list_head <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">LIST_HEAD(head);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line"></span><br><span class="line">p = search(head, key);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">/* Take appropriate action, unlock, and return. */</span></span><br><span class="line">&#125;</span><br><span class="line">q = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following 4 lines gives RCU its name:</span></span><br><span class="line"><span class="comment">// 1. while permitting concurrent reads,</span></span><br><span class="line"><span class="comment">// 2. *q = *p copies,</span></span><br><span class="line"><span class="comment">// 3. q-&gt;b = 2, q-&gt;c = 3, list_replace_rcu(&amp;p-&gt;list, &amp;q-&gt;list) do an update.</span></span><br><span class="line"></span><br><span class="line">*q = *p;</span><br><span class="line">q-&gt;b = <span class="number">2</span>;</span><br><span class="line">q-&gt;c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// three main steps of the basic form of algorithms that use RCU to wait for readers</span></span><br><span class="line"><span class="comment">// 1. make a change</span></span><br><span class="line">list_replace_rcu(&amp;p-&gt;<span class="built_in">list</span>, &amp;q-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="comment">// 2. wait for all pre-existing RCU read-side critical sections to completely finish</span></span><br><span class="line"><span class="comment">// the key observation here is that subsequent RCU read-side critical sections have no way to gain a reference to the newly removed element.</span></span><br><span class="line">synchronize_rcu();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. clean up</span></span><br><span class="line">kfree(p);</span><br></pre></td></tr></table></figure>
<h3 id="synchronize_rcu_28_29"><a href="#synchronize_rcu_28_29" class="headerlink" title="synchronize_rcu()"></a><code>synchronize_rcu()</code></h3><h4 id="The_Trick"><a href="#The_Trick" class="headerlink" title="The Trick"></a>The Trick</h4><p>The trick is that RCU read-side critical sections is <strong>not permitted to block or sleep</strong>.</p>
<p>If a given CPU executes a context switch, <strong>the completion</strong> of any prior RCU read-side critical sections is guaranteed.</p>
<p>I think there must be an mechanism that the given CPU can <em>detect the existence of all RCU read-side critical sections and complete them</em> before the context switch.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simplified synchronize_rcu()</span></span><br><span class="line">for_each_online_cpu(cpu)</span><br><span class="line">    run_on(cpu);</span><br></pre></td></tr></table></figure>
<p><code>for_each_online_cpu(cpu)</code> loop through all CPU:<br><code>run_on()</code> switches the current thread to the specified CPU –&gt; forces<br>a context switch on that CPU –&gt; guarantee the completion</p>
<p>Therefore, the completion of all prior RCU read-side critical sections are guaranteed.</p>
<p>This approach works for for non-<code>CONFIG_PREEMPT</code> and <code>CONFIG_PREEMPT</code> kernels.</p>
<h2 id="Maintain_Multiple_Versions_of_Recently_Updated_Objects"><a href="#Maintain_Multiple_Versions_of_Recently_Updated_Objects" class="headerlink" title="Maintain Multiple Versions of Recently Updated Objects"></a>Maintain Multiple Versions of Recently Updated Objects</h2><p>The multiple versions of recently updated objects allow synchronization-free readers.</p>
<p>While the reader remains in its RCU read-side critical section, the data referenced must remain intact. (The readers are not permitted to maintain references to element after exiting from their RCU read-side critical sections.)</p>
<p>The multiple versions mentioned here doesn’t mean the RCU uses a version number. <strong>Versions exist logically</strong>. Because readers do not synchronize directly with updaters, readers might run concurrently with this entire update (insert, delete, or replacement) process. For example, some readers <em>might reference to a old element and see the old version of the list</em>, while other readers reference to a up-to-date element at same location.</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/rcu_insert.png" alt=""><br>(The red border means that readers might be holding references to them.)</p>
<p>After the <code>synchronize_rcu()</code> returns, <em>a grace period will have elapsed</em>, and so all reads that started before the <code>list_replace_rcu()</code> will have completed. No readers will hold the reference to the old element. From the readers’ point of view, there is a single version of list.</p>
<h1 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h1><h2 id="Single_Updater"><a href="#Single_Updater" class="headerlink" title="Single Updater"></a>Single Updater</h2><p>RCU permit concurrency between a single updater and multiple readers. <em>(I think its should caused by <code>synchronize_rcu()</code>. I am not pretty sure for now because of being unaware of detailed design and implementation of RCU.)</em></p>
<p>So RCU only allow the existence of two versions of the list. If we want to permit more than two version of the list, one way is using lock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note that this means that multiple concurrent deletions might be waiting in synchronize_rcu().</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;mylock);</span><br><span class="line">p = search(head, key);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  spin_unlock(&amp;mylock);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    list_del_rcu(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">    spin_unlock(&amp;mylock);</span><br><span class="line">    synchronize_rcu();</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If a semaphore protecting the update is held across the grace period, then there can be at most two versions.</p>
<h2 id="Subtle_Priority-inversion_Scenario"><a href="#Subtle_Priority-inversion_Scenario" class="headerlink" title="Subtle Priority-inversion Scenario"></a>Subtle Priority-inversion Scenario</h2><p>Such as, a high-priority process blocked waiting for an RCU grace period to elapse can be blocked by low-priority RCU readers in -rt kernels. This can be solved by using RCU priority boosting or <code>call_rcu()</code> instead of <code>synchronize_rcu()</code>.</p>
<h2 id="Access_Old_Data_and_Inconsistencies"><a href="#Access_Old_Data_and_Inconsistencies" class="headerlink" title="Access Old Data and Inconsistencies"></a>Access Old Data and Inconsistencies</h2><p>RCU readers might access stale data, and might even see inconsistencies.</p>
<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><ol>
<li>a Reader-Writer Lock Replacement</li>
<li>a Restricted Reference-Counting Mechanism</li>
<li>a Bulk Reference-Counting Mechanism</li>
<li>a Poor Man’s Garbage Collector</li>
<li>a Way of Providing Existence Guarantees</li>
<li>a Way of Waiting for Things to Finish</li>
</ol>
<h2 id="Reader-Writer_Lock_Replacement"><a href="#Reader-Writer_Lock_Replacement" class="headerlink" title="Reader-Writer Lock Replacement"></a>Reader-Writer Lock Replacement</h2><p>Perhaps the most common use of RCU within the Linux kernel is as a replacement for reader-writer locking in <strong>read-intensive situations</strong>. The key similarity between RCU and reader-writer locking is that <em>both have read-side critical sections that can execute in parallel</em>.</p>
<h2 id="Restricted_Reference-Counting_Mechanism"><a href="#Restricted_Reference-Counting_Mechanism" class="headerlink" title="Restricted Reference-Counting Mechanism"></a>Restricted Reference-Counting Mechanism</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock();  <span class="comment">/* acquire reference. */</span></span><br><span class="line">p = rcu_dereference(head);</span><br><span class="line"><span class="comment">/* do something with p. */</span></span><br><span class="line">rcu_read_unlock();  <span class="comment">/* release reference. */</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;mylock);</span><br><span class="line">p = head;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">spin_unlock(&amp;mylock);</span><br><span class="line">synchronize_rcu();  <span class="comment">/* Wait for all references to be released. */</span></span><br><span class="line">kfree(p);</span><br></pre></td></tr></table></figure>
<p>Well, it is pretty much like the replacement for reader-writer lock. The difference is the perspective of thinking about it.</p>
<p>Again, the duration of read-side critical section matters here. The performance advantages of RCU are most pronounced for short duration.</p>
<h2 id="Bulk_Reference-Counting_Mechanism"><a href="#Bulk_Reference-Counting_Mechanism" class="headerlink" title="Bulk Reference-Counting Mechanism"></a>Bulk Reference-Counting Mechanism</h2><p>A single global reference counter for a large variety of data structures causes bouncing the cache line containing the reference count, and can degrade performance.</p>
<h2 id="Garbage_Collector"><a href="#Garbage_Collector" class="headerlink" title="Garbage Collector"></a>Garbage Collector</h2><p>OK, when I read about this section in the original article, I’m sure that I am the poor man. But they (RCU and Garbage Collector) has some differences.</p>
<p> RCU requires that</p>
<ul>
<li>manually indicate when a given data structure is eligible to be collected.</li>
<li>manually mark the RCU read-side critical sections where references might legitimately be held.</li>
</ul>
<h2 id="Providing_Existence_Guarantees"><a href="#Providing_Existence_Guarantees" class="headerlink" title="Providing Existence Guarantees"></a>Providing Existence Guarantees</h2><p>Since RCU protects data within the read-side critial section, the data is guaranteed to remain in existence for the duration of the read-side critial section.</p>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="Kernel_Space"><a href="#Kernel_Space" class="headerlink" title="Kernel Space"></a>Kernel Space</h2><p>RCU was accepted into the Linux 2.5.43 kernel in 2002.</p>
<h2 id="User_Space"><a href="#User_Space" class="headerlink" title="User Space"></a>User Space</h2><p><a href="http://liburcu.org/" target="_blank" rel="external">User-space RCU</a> is widely applicable for general-purpose code but in general does not perform as well as the kernel implementation.</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="http://lwn.net/Articles/262464/" target="_blank" rel="external">What is RCU, Fundamentally?</a></li>
<li><a href="http://lwn.net/Articles/263130/" target="_blank" rel="external">What is RCU? Part 2: Usage</a></li>
<li><a href="http://lwn.net/Articles/264090/" target="_blank" rel="external">RCU part 3: the RCU API</a></li>
<li><a href="http://www2.rdrop.com/~paulmck/RCU/" target="_blank" rel="external">RCU</a></li>
<li><a href="http://codemacro.com/2015/04/19/rw_thread_gc/" target="_blank" rel="external">使用RCU技术实现读写线程无锁</a></li>
<li><a href="http://lwn.net/Articles/609904/" target="_blank" rel="external">The RCU API, 2014 Edition</a></li>
<li><a href="http://lwn.net/Articles/253651/" target="_blank" rel="external">The design of preemptible read-copy-update</a></li>
<li><a href="http://www2.rdrop.com/~paulmck/RCU/" target="_blank" rel="external">RCU by Paul McKenney</a></li>
<li><a href="http://liburcu.org/" target="_blank" rel="external">Userspace RCU</a></li>
<li><a href="https://lwn.net/Articles/573424/" target="_blank" rel="external">User-space RCU</a></li>
<li>Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming, Alexander Matveev, Nir Shavit, Pascal Felber, Patrick Marlier</li>
<li>User-Level Implementations of Read-Copy Update, Mathieu Desnoyers, Paul E. McKenney, Alan S. Stern, Michel R. Dagenais and Jonathan Walpole</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[RCU is a synchronization mechanism, which is widely used in the Linux kernel.]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Char *(*(**foo[][8])())[]...]]></title>
    <link href="http://chaomai.github.io/2015/09/17/2015-2015-09-17-char-foo-8/"/>
    <id>http://chaomai.github.io/2015/09/17/2015-2015-09-17-char-foo-8/</id>
    <published>2015-09-16T16:06:18.000Z</published>
    <updated>2015-09-16T16:09:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="declaration"><a href="#declaration" class="headerlink" title="declaration"></a>declaration</h1><p>one <strong>basic type</strong> + zero or more <strong>derived types</strong></p>
<h2 id="basic_type"><a href="#basic_type" class="headerlink" title="basic type"></a>basic type</h2><p><code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code>, <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>float</code>, <code>double</code>, <code>void</code>, <code>struct tag</code>, <code>union tag</code>, <code>enum tag</code>, <code>long long</code>, <code>unsigned long long</code>, <code>long double</code></p>
<h2 id="derived_types"><a href="#derived_types" class="headerlink" title="derived types"></a>derived types</h2><p><code>*</code>: pointer to …   - always on the left side<br><code>[]</code>: array of …   - always on the left side<br><code>()</code>: function returning …   - always on the left side</p>
<h1 id="operator_precedence"><a href="#operator_precedence" class="headerlink" title="operator precedence"></a>operator precedence</h1><p>The <code>[]</code> and <code>()</code> have higher precedence than <code>*</code>.</p>
<h2 id="the_rule_to_read_declaration"><a href="#the_rule_to_read_declaration" class="headerlink" title="the rule to read declaration"></a>the rule to read declaration</h2><p>There is a <a href="http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html" target="_blank" rel="external">“right-left” rule</a>. I think the rule is based on the precedence.</p>
<p><a href="http://stackoverflow.com/questions/859634/c-pointer-to-array-array-of-pointers-disambiguation" target="_blank" rel="external">C pointer to array/array of pointers disambiguation</a> also mentioned <em>“go right when you can, go left when you must”</em>.</p>
<h2 id="find_error_in_declaration"><a href="#find_error_in_declaration" class="headerlink" title="find error in declaration"></a>find error in declaration</h2><p>Since we can read complex declaration by applying the rule mentioned before, we also can find error in declaration with the knowledge of what is legal in C.</p>
<p>Some illegal declarations,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array of functions?</span></span><br><span class="line"><span class="comment">// error: 'a' declared as array of functions of type 'int ()'</span></span><br><span class="line"><span class="keyword">int</span> a[]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// a function returning function?</span></span><br><span class="line"><span class="comment">// error: function cannot return function type 'int ()'</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array of functions?</span></span><br><span class="line"><span class="comment">// a function returning array of int?</span></span><br><span class="line"><span class="comment">// error: function cannot return array type 'int []'</span></span><br><span class="line"><span class="comment">// error: 'c' declared as array of functions of type 'int ()'</span></span><br><span class="line"><span class="keyword">int</span> c[]()[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// array of functions?</span></span><br><span class="line"><span class="comment">// error: 'd' declared as array of functions of type 'int ()'</span></span><br><span class="line"><span class="keyword">int</span> (*d)[]();</span><br></pre></td></tr></table></figure>
<h1 id="char_*_28*_28**foo_5B_5D_5B8_5D_29_28_29_29_5B_5D"><a href="#char_*_28*_28**foo_5B_5D_5B8_5D_29_28_29_29_5B_5D" class="headerlink" title="char *(*(**foo[][8])())[]"></a><code>char *(*(**foo[][8])())[]</code></h1><p>foo is array of array of 8 pointer to pointer to function returning pointer to array of pointer to char.</p>
<h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol>
<li>The key is the <a href="http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html" target="_blank" rel="external">“right-left” rule</a>.</li>
<li>Be aware of what is legal in C.</li>
<li>数组指针，指针数组。。。Well, the Chinese description is really ambiguous.</li>
</ol>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ol>
<li><a href="http://unixwiz.net/techtips/reading-cdecl.html" target="_blank" rel="external">Reading C type declarations</a></li>
<li><a href="http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html" target="_blank" rel="external">The “right-left” rule</a></li>
<li><a href="http://stackoverflow.com/questions/859634/c-pointer-to-array-array-of-pointers-disambiguation" target="_blank" rel="external">C pointer to array/array of pointers disambiguation</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Understand complex declaration in C.]]>
    
    </summary>
    
      <category term="c" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes of to Lock, Swap, or Elide: On the Interplay of Hardware Transactional Memory and Lock Free Indexing]]></title>
    <link href="http://chaomai.github.io/2015/09/05/2015-2015-09-05-notes-of-to-lock-swap-or-elide-on-the-interplay-of-hardware-transactional-memory-and-lock-free-indexing/"/>
    <id>http://chaomai.github.io/2015/09/05/2015-2015-09-05-notes-of-to-lock-swap-or-elide-on-the-interplay-of-hardware-transactional-memory-and-lock-free-indexing/</id>
    <published>2015-09-05T04:27:15.000Z</published>
    <updated>2015-09-26T05:50:45.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u89E3_u51B3_u4E86_u8FD9_u4E48_u51E0_u4E2A_u95EE_u9898"><a href="#u89E3_u51B3_u4E86_u8FD9_u4E48_u51E0_u4E2A_u95EE_u9898" class="headerlink" title="解决了这么几个问题"></a>解决了这么几个问题</h1><ul>
<li><p>Does HTM obviate the need for crafty lock-free index designs?<br>No.</p>
</li>
<li><p>How does HTM differ from lock-free index designs?</p>
</li>
<li><p>Given that lock-free designs are still relevant, can HTM help simplify lock-free design techniques while maintaining good performance?<br>Yes.</p>
</li>
</ul>
<h1 id="HTM"><a href="#HTM" class="headerlink" title="HTM"></a>HTM</h1><h2 id="Transactional_memory"><a href="#Transactional_memory" class="headerlink" title="Transactional memory"></a>Transactional memory</h2><p>ease the burden (<em>a tedious and error prone task leading to deadlocks and race conditions</em>) by delegating conflict detection and resolution from the developer to the system.</p>
<h2 id="Hardware_Transactional_Memory"><a href="#Hardware_Transactional_Memory" class="headerlink" title="Hardware Transactional Memory"></a>Hardware Transactional Memory</h2><p>a best-effort model, optimistic concurrency.</p>
<h3 id="Based_on_existing_features_in_CPU"><a href="#Based_on_existing_features_in_CPU" class="headerlink" title="Based on existing features in CPU"></a>Based on existing features in CPU</h3><ul>
<li><p>caches<br>store transaction buffers and provide isolation.</p>
</li>
<li><p>cache coherence protocol<br>detect conflicting transactional accesses.</p>
</li>
</ul>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul>
<li><p>read and write set of a transaction must fit in cache in order for it to be executed<br>limitation of CPU.</p>
</li>
<li><p>transaction duration<br>hardware events will abort a transaction.</p>
</li>
<li><p>the work of conflict detection<br>it is usually done at the granularity of a cache line. This may lead to cases of false sharing where aborts occur due to threads accessing and modifying separate items on the same cache line.</p>
</li>
</ul>
<h3 id="Solutions_-_lock_elision"><a href="#Solutions_-_lock_elision" class="headerlink" title="Solutions - lock elision"></a>Solutions - lock elision</h3><p>因为HTM是best-effort的，由于上述constraints的存在，transaction需要fallback path。</p>
<p>最简单的一种，是transaction不成功的时候，就改用lock，这个技术叫做lock elision；它将一个lock保护的区域作为transaction来执行，仅当transaction 没有成功commit的时候，它才falls back为block on the lock。</p>
<p>lock elision将MT作为一个fast path，slow path就是lock (a simple coarse grain locks).</p>
<p>In lock elision, the lock word needs to be included in the read set of a transaction, so that the transaction aborts when another thread acquires the lock (thus causing a conflict). Hence, once a thread resorts to non-transactional execution by taking the lock, <strong>all other concurrently executing transactions will abort, stalling overall progress.</strong></p>
<h2 id="Intel_TSX"><a href="#Intel_TSX" class="headerlink" title="Intel TSX"></a>Intel TSX</h2><p>the support of transactional memory in Intel starts from Haswell.</p>
<p>According to Intel, there is no guarantee that a transaction<br>will eventually succeed even if it is infinitely retried.</p>
<ul>
<li><p>HLE<br>Hardware Lock Elision (HLE)</p>
</li>
<li><p>RTM<br>Restricted Transactional Memory (RTM)</p>
</li>
</ul>
<h2 id="cpp-btree_and_Bw-tree"><a href="#cpp-btree_and_Bw-tree" class="headerlink" title="cpp-btree and Bw-tree"></a>cpp-btree and Bw-tree</h2><p>cpp-btree</p>
<ul>
<li>does not contain the fine-grained locking techniques and concurrency protocols</li>
</ul>
<p>Bw-tree</p>
<ul>
<li><p>a mapping table that maps logical page identifiers (LPIDs) to virtual addresses</p>
</li>
<li><p>Lock-free updates</p>
<ul>
<li>delta record</li>
<li>pages consolidation (to get search-optimized page)</li>
</ul>
</li>
<li><p>Structure modifications</p>
<ul>
<li>breaks an SMO into a sequence of atomic steps</li>
</ul>
</li>
</ul>
<h1 id="A_study_of_fundamental_differences_between_HTM-based_and_lock-free_index_designs"><a href="#A_study_of_fundamental_differences_between_HTM-based_and_lock-free_index_designs" class="headerlink" title="A study of fundamental differences between HTM-based and lock-free index designs"></a>A study of fundamental differences between HTM-based and lock-free index designs</h1><h2 id="Experiment_1_-_Throughput"><a href="#Experiment_1_-_Throughput" class="headerlink" title="Experiment 1 - Throughput"></a>Experiment 1 - Throughput</h2><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>for read operation, HTM provides high throughput with little effort.</p>
<h2 id="Experiment_2_-_Effect_of_Key_and_Payload_Sizes"><a href="#Experiment_2_-_Effect_of_Key_and_Payload_Sizes" class="headerlink" title="Experiment 2 - Effect of Key and Payload Sizes"></a>Experiment 2 - Effect of Key and Payload Sizes</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>such a workload in experiment 1 <strong>do not hold in general</strong>.</p>
<ul>
<li><p>capacity limits <em>(for Haswell’s CPU)</em><br>L1 cache is 32KB. no transaction can write more than can fit in L1.</p>
</li>
<li><p>associativity <em>(for Haswell’s CPU)</em></p>
</li>
<li><p>hyper-threading <em>(for Haswell’s CPU)</em><br>L1 cache and other resources is shared among hardware threads.</p>
</li>
</ul>
<blockquote>
<p>many of the properties that determine the HTM abort rate for a given tree may not be known until runtime. A tree’s key size, payload size, total size, and address access patterns all affect performance.</p>
</blockquote>
<h3 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h3><p>even trees with relatively small keys and payloads cannot always parallelize. With Haswell’s HTM almost all transactions abort with payloads larger than a few kilobytes.</p>
<h2 id="Experiment_3_-_Highcontention_Performance"><a href="#Experiment_3_-_Highcontention_Performance" class="headerlink" title="Experiment 3 - Highcontention Performance"></a>Experiment 3 - Highcontention Performance</h2><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><ul>
<li><p>two other problematic ways</p>
<ul>
<li><p>speculation is not free</p>
</li>
<li><p>lemming effect<br>When a transaction falls back and acquires the lock, <strong>all other transactions in the critical section</strong> abort and cannot restart <strong>until the lock is released</strong>. The effect is that execution is <strong>fully serialized</strong> until the lock is released – even if the other transactions operate on non conflicting cache lines.</p>
<ul>
<li>mitigate the lemming effect<br>have transactions retry more than once<br><em>cost of retrying a contentious transaction &lt; serializing execution</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Results-2"><a href="#Results-2" class="headerlink" title="Results"></a>Results</h3><p><em>the workload skew: for the payload, the bigger the skew is, the latter it is updated at the end of a tree traversal operation, and the latter it is within the transaction.</em></p>
<p>The results show that as workload skew increases <strong>the performance of lock-elision drops sharply</strong>. At some point lock-elision performs even <strong>worse than spin-locks</strong>. Increasing the number of transactional attempts delays the performance cliff, and leads to a more graceful degradation of performance as skew increases.</p>
<h3 id="Optimal_Number_of_Transactional_Attempts"><a href="#Optimal_Number_of_Transactional_Attempts" class="headerlink" title="Optimal Number of Transactional Attempts"></a>Optimal Number of Transactional Attempts</h3><p>for a set of concurrent transactions, it may be possible that none of them commit: a situation worse than using a spinlock.</p>
<p>The optimal number of transactional attempts depends on workloads and varies highly. chooses the number of transactional attempts dynamically depending on the workload.</p>
<h2 id="Lock-coupling"><a href="#Lock-coupling" class="headerlink" title="Lock-coupling"></a>Lock-coupling</h2><p>lock-coupling is one of the most widely used approaches to achieve efficient fine-grained locking on B-Trees.</p>
<p>In lock-coupling a pair of locks are held as a worker traverses pages: one on a “source” page and another on a “target” page.</p>
<p><img src="http://7vilyb.com1.z0.glb.clouddn.com/stm_lock%20coupling.png" alt=""></p>
<p>Because of restrictive support of lock-coupling in Haswell’s HTM interface, it is not possible on Haswell’s CPU.</p>
<h1 id="A_study_of_fundamental_differences_between_HTM-based_and_lock-free_index_designs-1"><a href="#A_study_of_fundamental_differences_between_HTM-based_and_lock-free_index_designs-1" class="headerlink" title="A study of fundamental differences between HTM-based and lock-free index designs"></a>A study of fundamental differences between HTM-based and lock-free index designs</h1><p><img src="http://7vilyb.com1.z0.glb.clouddn.com/stm_compare.png" alt=""></p>
<h2 id="Experiment_1_-_Impact_of_concurrent_writers_on_readers"><a href="#Experiment_1_-_Impact_of_concurrent_writers_on_readers" class="headerlink" title="Experiment 1 - Impact of concurrent writers on readers"></a>Experiment 1 - Impact of concurrent writers on readers</h2><h3 id="Results-3"><a href="#Results-3" class="headerlink" title="Results"></a>Results</h3><p>for high contention workloads the reader throughput that the cpp-btree can sustain begins to drop.</p>
<h2 id="The_Overheads_of_LockFreedom"><a href="#The_Overheads_of_LockFreedom" class="headerlink" title="The Overheads of LockFreedom"></a>The Overheads of LockFreedom</h2><ul>
<li><p>a garbage-collection mechanism for memory safety</p>
<ul>
<li>epoch mechanism used in Bw-tree，类似引用计数。</li>
</ul>
</li>
<li><p>additional indirection for atomic updates<br><em>lockfreedom influences the in-memory layout of structures</em></p>
<ul>
<li>对于某些数据结构，如：Bw-tree，每次访问必须间接的通过一个额外的memory来进行，这就无形中增加了overheads。</li>
<li>额外的indirection同时还给内存分配带来压力。<ul>
<li>可能需要特别的或者lock-free的allocator。</li>
</ul>
</li>
</ul>
</li>
<li><p>cost of copy-on-write (when using paged copy-on-write semantics)</p>
<ul>
<li>the cost may be influenced by page size, access skew, the uniformity of payload sizes.</li>
</ul>
</li>
</ul>
<p>These costs are highly intertwined: tradeoffs for each influence the cost of the others</p>
<h1 id="A_study_of_how_HTM_can_help_lock-free_designs"><a href="#A_study_of_how_HTM_can_help_lock-free_designs" class="headerlink" title="A study of how HTM can help lock-free designs"></a>A study of how HTM can help lock-free designs</h1><p>it is very difficult to architect and build complex lock-free<br>data structures.</p>
<h2 id="MultiWord_CAS_using_HTM"><a href="#MultiWord_CAS_using_HTM" class="headerlink" title="MultiWord CAS using HTM"></a>MultiWord CAS using HTM</h2><ul>
<li>MW-CAS同时操作的word数受限于L1 cache的大小。过多的word，则无法用HTM来实现MW-CAS。Bw-tree可以。</li>
<li>MW-CAS是短时的transactions，也就是说不那么容易被interrupted。</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="https://lwn.net/Articles/534758/" target="_blank" rel="external">Lock elision in the GNU C library</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions" target="_blank" rel="external">Transactional Synchronization Extensions</a></li>
<li>CPU Cache and Memory Ordering, 何登成</li>
<li><a href="http://www.ecs.umass.edu/ece/koren/architecture/Cache/tutorial.html" target="_blank" rel="external">This is a basic Cache Tutorial</a></li>
<li>Computer Systems A Programmer’s Perspective, Randal E. Bryant, David R. O’Hallaron</li>
<li>To Lock, Swap, or Elide: On the Interplay of Hardware Transactional Memory and Lock Free Indexing, Darko Makreshanski, Justin Levandoski, Ryan Stutsman</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[主要研究了HTM and lock-free indexing的相互影响。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[慢跑总结]]></title>
    <link href="http://chaomai.github.io/2015/09/05/2015-2015-09-05-running-summary/"/>
    <id>http://chaomai.github.io/2015/09/05/2015-2015-09-05-running-summary/</id>
    <published>2015-09-05T03:21:11.000Z</published>
    <updated>2015-09-25T11:07:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h1><ul>
<li>摆臂方向不对，导致身体也左右转动，浪费能量</li>
<li>长时间跑以后，腰部不能保证挺直</li>
<li>推蹬时间点过早，导致身体腾空，浪费能量</li>
<li>呼吸有问题，导致腹部痛</li>
</ul>
<h1 id="u8DD1_u6B65_u6CE8_u610F"><a href="#u8DD1_u6B65_u6CE8_u610F" class="headerlink" title="跑步注意"></a>跑步注意</h1><ul>
<li><p>轻松直立微前倾</p>
</li>
<li><p>两眼注视前下方</p>
</li>
</ul>
<ol>
<li>10m左右；</li>
</ol>
<ul>
<li><p>前摆至胸线，后摆至腰际</p>
</li>
<li><p>膝前提腿下摆向后下方推蹬</p>
</li>
</ul>
<ol>
<li>身体重心过了支撑点，再推蹬，否则身体会腾空；</li>
<li>推蹬顺序：先大腿，后小腿，最后脚踝；</li>
<li>避免脚尖落地，长时间跑小腿以及脚踝的负荷会太大；</li>
</ol>
<ul>
<li><p>蹬踝前摆全脚掌落地</p>
</li>
<li><p>鼻为主口为辅自然顺畅为原则</p>
</li>
</ul>
<h1 id="u6838_u5FC3_u808C_u7FA4_u8BAD_u7EC3"><a href="#u6838_u5FC3_u808C_u7FA4_u8BAD_u7EC3" class="headerlink" title="核心肌群训练"></a>核心肌群训练</h1><ul>
<li>抬头挺胸缩腹夹臀</li>
</ul>
<h2 id="u8BAD_u7EC3_u65B9_u6CD5"><a href="#u8BAD_u7EC3_u65B9_u6CD5" class="headerlink" title="训练方法"></a>训练方法</h2><ul>
<li>Plank</li>
<li>Side Plank</li>
<li>Upward plank pose</li>
</ul>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.zhihu.com/question/20693323?rf=21469986" target="_blank" rel="external">正确的慢跑姿势是怎样的？</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_9bf935a90101l1id.html" target="_blank" rel="external">跑者入门01：跑步姿势与呼吸</a></li>
<li><a href="http://tw.running.biji.co/index.php?q=news&amp;act=info&amp;id=443" target="_blank" rel="external">[長跑觀念] 第1講—運動前後伸展</a></li>
<li><a href="http://post.smzdm.com/xilie/27/" target="_blank" rel="external">系列：跑步装备介绍</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[近期跑步的时候遇到的问题，以及一些注意事项的记录。]]>
    
    </summary>
    
      <category term="running" scheme="http://chaomai.github.io/tags/running/"/>
    
      <category term="life" scheme="http://chaomai.github.io/categories/life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Harris' Non-Blocking Linked-Lists]]></title>
    <link href="http://chaomai.github.io/2015/07/30/2015-2015-07-30-harris-non-blocking-linked-lists/"/>
    <id>http://chaomai.github.io/2015/07/30/2015-2015-07-30-harris-non-blocking-linked-lists/</id>
    <published>2015-07-30T15:30:59.000Z</published>
    <updated>2015-09-26T05:47:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="specification"><a href="#specification" class="headerlink" title="specification"></a>specification</h1><ul>
<li>ordered（ascending）</li>
<li>no duplicated key</li>
</ul>
<h1 id="features"><a href="#features" class="headerlink" title="features"></a>features</h1><ul>
<li>non-blocking</li>
<li>linearizable</li>
<li>compare-and-swap based</li>
</ul>
<h1 id="u4EC5_u4F7F_u7528_u4E00_u4E2Acas_u7684_u7F3A_u9677"><a href="#u4EC5_u4F7F_u7528_u4E00_u4E2Acas_u7684_u7F3A_u9677" class="headerlink" title="仅使用一个cas的缺陷"></a>仅使用一个cas的缺陷</h1><ul>
<li><p>insert<br>  <img src="http://7vilyb.com1.z0.glb.clouddn.com/harris_single_insert.png" alt=""></p>
</li>
<li><p>delete<br>  <img src="http://7vilyb.com1.z0.glb.clouddn.com/harris_single_delete.png" alt=""></p>
</li>
</ul>
<p>对于只有一个insert或者一个delete的情况，没有问题会出现。</p>
<ul>
<li>insert and delete<br>  <img src="http://7vilyb.com1.z0.glb.clouddn.com/harris_insert_and_delete.png" alt=""></li>
</ul>
<p>但是如果一个insert和一个delete同时进行，问题就会出现。删除30的时候，一个cas无法保证，也不能避免10和30之间的修改。</p>
<h1 id="u89E3_u51B3_u65B9_u6CD5_uFF1A_u7528_u4E24_u4E2Acas"><a href="#u89E3_u51B3_u65B9_u6CD5_uFF1A_u7528_u4E24_u4E2Acas" class="headerlink" title="解决方法：用两个cas"></a>解决方法：用两个cas</h1><h2 id="u57FA_u672C_u601D_u60F3"><a href="#u57FA_u672C_u601D_u60F3" class="headerlink" title="基本思想"></a>基本思想</h2><ul>
<li><p>stage 1<br>  <img src="http://7vilyb.com1.z0.glb.clouddn.com/harris_logically_delete.png" alt=""><br>  用一个cas mark将要被删除结点的next field（logically deleted）；</p>
</li>
<li><p>stage 2<br>  <img src="http://7vilyb.com1.z0.glb.clouddn.com/harris_physically_delete.png" alt=""><br>  另一个cas来进行删除结点（physically deleted）。</p>
</li>
</ul>
<p>stage 1结束以后，list的结构保持不变，mark以后的结点，避免了新节点insert到该结点的后面。</p>
<h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><h2 id="marked_and_unmarked"><a href="#marked_and_unmarked" class="headerlink" title="marked and unmarked"></a>marked and unmarked</h2><blockquote>
<p>A node is marked if and only if its next field is marked.</p>
</blockquote>
<p>这句话是关键：论文中的mark，实际上是mark了要被删除结点的next指针，而不是要被删除的结点本身。<br>我觉得从另一个视角来看，mark的效果是，不允许改变<strong>要被删除结点的后继结点</strong>。这点从避免前文提到的问题的角度来说，也应该是正确的理解。</p>
<p><code>get_marked_reference</code>和<code>get_unmarked_reference</code>是以copy的形式传入reference，mark或者unmark以后的并不是reference本身。</p>
<h2 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">  key_type key;</span><br><span class="line">  node *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">list</span> &#123;</span><br><span class="line">  node *head;</span><br><span class="line">  node *tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p>满足这么几个要求：</p>
<ul>
<li>left_node.key &lt; search_key &lt;= right_node.key</li>
<li>left_node and right_node are unmarked</li>
<li>right_node is immediate successor（直接后继） of left_node</li>
</ul>
<p>有这么几个步骤：</p>
<ul>
<li>找到left_node和right_node</li>
<li>检查是不是直接后继<ul>
<li>是，直接返回</li>
</ul>
</li>
<li>移除left_node and right_node之间的一个或多个marked结点</li>
</ul>
<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><ul>
<li>找到left_node和right_node</li>
<li>cas插入</li>
</ul>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>如前文解决方法中描述的，分两个阶段：</p>
<ul>
<li>stage 1:<ul>
<li>找到left_node和right_node</li>
<li>logically delete</li>
</ul>
</li>
<li>stage 2:<ul>
<li>physically delete<ul>
<li>cas删除</li>
<li>或者search中删除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul>
<li>找到left_node和right_node</li>
<li>right_node == search_key</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li>A Pragmatic Implementation of Non-Blocking Linked-lists, Timothy L. Harris.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Harris的这篇论文提出了一种新的non-blocking linked-list，不同于Valois使用auxiliary node，Harris在操作的时候进行了mark，解决了插入丢失的问题。论文中有详细的伪代码，清晰的描述了实现的细节。但要注意的是，实际实现必然涉及到内存回收，没有自动内存回收机制的语言会有点麻烦。]]>
    
    </summary>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="data structures" scheme="http://chaomai.github.io/categories/programming/data-structures/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ Concurrency in Action (5) - the C++ Memory Model and Operations on Atomic Types]]></title>
    <link href="http://chaomai.github.io/2015/07/18/2015-2015-07-18-cpp-concurrency-in-action-5/"/>
    <id>http://chaomai.github.io/2015/07/18/2015-2015-07-18-cpp-concurrency-in-action-5/</id>
    <published>2015-07-18T10:41:54.000Z</published>
    <updated>2015-07-18T12:46:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Memory_model_basics"><a href="#Memory_model_basics" class="headerlink" title="Memory model basics"></a>Memory model basics</h1><p>two aspects:</p>
<ul>
<li>the basic structural aspects;</li>
<li>the concurrency aspects.</li>
</ul>
<h2 id="Objects_and_memory_location"><a href="#Objects_and_memory_location" class="headerlink" title="Objects and memory location"></a>Objects and memory location</h2><p>C++程序中所有的数据都是由object组成，object是”a region of storage”。一个对象存储在一个或多个<strong>memory location</strong>。</p>
<p>每个memory location，</p>
<ul>
<li>要么是，一个标量的一个对象（或子对象）；</li>
<li>要么是，相邻bit fields的序列。（虽然相邻的bit fields是不同对象，它们仍然算作相同的memory location，除非用长度为0的bit fields隔开。）</li>
</ul>
<h2 id="Modification_orders"><a href="#Modification_orders" class="headerlink" title="Modification orders"></a>Modification orders</h2><p>C++程序中的每个对象都定义了一个modification order，它由程序中的所有线程对这个对象的write组成， starting with the object’s initialization。</p>
<p>在绝大多数情况下，这个order在每次运行的时候都是不同的，但对于一个给定的执行，所有的线程都必须agree on the order。如果不使用原子类型，你就必须提供有效的同步来使得这些线程都agree on the modification order of each variable。但是线程并没有必要agree on the relative order of separate objects。</p>
<h1 id="Atomic_Operations_and_types_in_C++"><a href="#Atomic_Operations_and_types_in_C++" class="headerlink" title="Atomic Operations and types in C++"></a>Atomic Operations and types in C++</h1><p>一个atomic operation是<strong>indivisible operation</strong>，要么完成，要么不完成。</p>
<h2 id="The_standard_atomic_types"><a href="#The_standard_atomic_types" class="headerlink" title="The standard atomic types"></a>The standard atomic types</h2><p><code>is_lock_free()</code>：给定类型的操作是直接由atomic instructions完成，还是由编译器和库提供的内部锁完成。</p>
<p><code>std::atomic_flag</code>没有提供<code>is_lock_free()</code>成员函数。因为在这个类型上的操作required to be lock-free，一旦有了这个lock-free的类型，就能够以它为基础，进而实现所有其他的atomic类型。</p>
<p>在大多数平台上，所有内置类型的atomic变种都<strong>应该</strong>是lock-free的，但这并不是必须的。</p>
<p>要注意的是，由于历史的原因，在有的平台，atomic类型指的不一定是<code>std::atomic&lt;&gt;</code>的specialization（如：<code>atomic_bool</code>和<code>std::atomic&lt;bool&gt;</code>）。如果混用，就可能导致不兼容的情况出现。</p>
<p><strong>The alternative names for the standard atomic types and their corresponding <code>std::atomic&lt;&gt;</code> specializations.</strong></p>
<table>
<thead>
<tr>
<th>Atomic type</th>
<th>Corresponding specialization</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>atomic_bool</code></td>
<td><code>std::atomic&lt;bool&gt;</code></td>
</tr>
<tr>
<td><code>atomic_char</code></td>
<td><code>std::atomic&lt;char&gt;</code></td>
</tr>
<tr>
<td><code>atomic_schar</code></td>
<td><code>std::atomic&lt;signed char&gt;</code></td>
</tr>
<tr>
<td><code>atomic_uchar</code></td>
<td><code>std::atomic&lt;unsigned char&gt;</code></td>
</tr>
<tr>
<td><code>atomic_int</code></td>
<td><code>std::atomic&lt;int&gt;</code></td>
</tr>
<tr>
<td><code>atomic_uint</code></td>
<td><code>std::atomic&lt;unsigned&gt;</code></td>
</tr>
<tr>
<td><code>atomic_short</code></td>
<td><code>std::atomic&lt;short&gt;</code></td>
</tr>
<tr>
<td><code>atomic_ushort</code></td>
<td><code>std::atomic&lt;unsigned short&gt;</code></td>
</tr>
<tr>
<td><code>atomic_long</code></td>
<td><code>std::atomic&lt;long&gt;</code></td>
</tr>
<tr>
<td><code>atomic_ulong</code></td>
<td><code>std::atomic&lt;unsigned long&gt;</code></td>
</tr>
<tr>
<td><code>atomic_llong</code></td>
<td><code>std::atomic&lt;long long&gt;</code></td>
</tr>
<tr>
<td><code>atomic_ullong</code></td>
<td><code>std::atomic&lt;unsigned long long&gt;</code></td>
</tr>
<tr>
<td><code>atomic_char16_t</code></td>
<td><code>std::atomic&lt;char16_t&gt;</code></td>
</tr>
<tr>
<td><code>atomic_char32_t</code></td>
<td><code>std::atomic&lt;char32_t&gt;</code></td>
</tr>
<tr>
<td><code>atomic_wchar_t</code></td>
<td><code>std::atomic&lt;wchar_t&gt;</code></td>
</tr>
</tbody>
</table>
<p><strong>The standard atomic <code>typedefs</code> and their corresponding built-in <code>typedefs</code></strong></p>
<table>
<thead>
<tr>
<th>Atomic <code>typedef</code></th>
<th>Corresponding Standard Library <code>typedef</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>atomic_int_least8_t</code></td>
<td><code>int_least8_t</code></td>
</tr>
<tr>
<td><code>atomic_uint_least8_t</code></td>
<td><code>uint_least8_t</code></td>
</tr>
<tr>
<td><code>atomic_int_least16_t</code></td>
<td><code>int_least16_t</code></td>
</tr>
<tr>
<td><code>atomic_uint_least16_t</code></td>
<td><code>uint_least16_t</code></td>
</tr>
<tr>
<td><code>atomic_int_least32_t</code></td>
<td><code>int_least32_t</code></td>
</tr>
<tr>
<td><code>atomic_uint_least32_t</code></td>
<td><code>uint_least32_t</code></td>
</tr>
<tr>
<td><code>atomic_int_least64_t</code></td>
<td><code>int_least64_t</code></td>
</tr>
<tr>
<td><code>atomic_uint_least64_t</code></td>
<td><code>uint_least64_t</code></td>
</tr>
<tr>
<td><code>atomic_int_fast8_t</code></td>
<td><code>int_fast8_t</code></td>
</tr>
<tr>
<td><code>atomic_uint_fast8_t</code></td>
<td><code>uint_fast8_t</code></td>
</tr>
<tr>
<td><code>atomic_int_fast16_t</code></td>
<td><code>int_fast16_t</code></td>
</tr>
<tr>
<td><code>atomic_uint_fast16_t</code></td>
<td><code>uint_fast16_t</code></td>
</tr>
<tr>
<td><code>atomic_int_fast32_t</code></td>
<td><code>int_fast32_t</code></td>
</tr>
<tr>
<td><code>atomic_uint_fast32_t</code></td>
<td><code>uint_fast32_t</code></td>
</tr>
<tr>
<td><code>atomic_int_fast64_t</code></td>
<td><code>int_fast64_t</code></td>
</tr>
<tr>
<td><code>atomic_uint_fast64_t</code></td>
<td><code>uint_fast64_t</code></td>
</tr>
<tr>
<td><code>atomic_intptr_t</code></td>
<td><code>intptr_t</code></td>
</tr>
<tr>
<td><code>atomic_uintptr_t</code></td>
<td><code>uintptr_t</code></td>
</tr>
<tr>
<td><code>atomic_size_t</code></td>
<td><code>size_t</code></td>
</tr>
<tr>
<td><code>atomic_ptrdiff_t</code></td>
<td><code>ptrdiff_t</code></td>
</tr>
<tr>
<td><code>atomic_intmax_t</code></td>
<td><code>intmax_t</code></td>
</tr>
<tr>
<td><code>atomic_uintmax_t</code></td>
<td><code>uintmax_t</code></td>
</tr>
</tbody>
</table>
<p>要注意的是：</p>
<ol>
<li><p>标准的atomic类型<strong>不是copyable和assignable</strong>的；</p>
<blockquote>
<p>因为这些操作总是涉及到两个对象，必须从一个中read，然后write到另一个，这是两个单独的操作，合起来不可能是atomic。因此就不被允许。</p>
</blockquote>
</li>
<li><p>支持assignment from和implicit conversion to对应的内置类型；</p>
</li>
<li><p>赋值操作返回的并不是reference  to  the  object  it’s<br>assigned to，而是the value assigned。</p>
<blockquote>
<p>因为如果返回了reference  to atomic variable，那些使用这个变量的代码需要显示的<code>load()</code>，实际使用到值的可能是其他线程已经修改过的。</p>
</blockquote>
</li>
</ol>
<p><strong>Memory-ordering</strong></p>
<p>每个在atomic类型上的操作都有memory-ordering参数，来指定memory-ordering语义。不同的操作可传入不同的参数，操作分为三类：</p>
<ol>
<li>Store</li>
<li>Load</li>
<li>Read-modify-write</li>
</ol>
<p>默认是<code>memory_order_seq_cst</code>。</p>
<h2 id="Operations_on_std_3A_3Aatomic_flag"><a href="#Operations_on_std_3A_3Aatomic_flag" class="headerlink" title="Operations on std::atomic_flag"></a>Operations on <code>std::atomic_flag</code></h2><p>代表一个boolean flag，只能是两种状态：set或clear，并且总是starts clear。</p>
<p>必须用<code>ATOMIC_FLAG_INIT</code>来初始化，<code>std::atomic_flag guard = ATOMIC_FLAG_INIT</code>。这是唯一需要使用这样的特殊方式来初始化的类型，也是<strong>唯一一个</strong>保证lock-free的。</p>
<p>如果是<code>static</code>，那么在首次操作flag的时候初始化。</p>
<p>用于实现spinlock，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> spinlock_mutex &#123;</span><br><span class="line">    <span class="built_in">std</span>::atomic_flag flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    spinlock_mutex():</span><br><span class="line">        flag(ATOMIC_FLAG_INIT) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag.test_and_set(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag.clear(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Operations_on_std_3A_3Aatomic_26lt_3Bbool_26gt_3B"><a href="#Operations_on_std_3A_3Aatomic_26lt_3Bbool_26gt_3B" class="headerlink" title="Operations on std::atomic&lt;bool&gt;"></a>Operations on <code>std::atomic&lt;bool&gt;</code></h2><p>可用nonatomic bool来初始化，还可以向实例赋nonatomic bool值，<strong><code>std::atomic&lt;bool&gt;</code>可能不是lock-free的！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; b(<span class="literal">true</span>);</span><br><span class="line">b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>write：<code>store()</code>；</li>
<li>read-modify-write：<code>exchange()</code>；</li>
<li>nonmodifying query：<code>load()</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> x=b.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">b.store(<span class="literal">true</span>);</span><br><span class="line">x=b.exchange(<span class="literal">false</span>,<span class="built_in">std</span>::memory_order_acq_rel);</span><br></pre></td></tr></table></figure>
<p><strong>compare/exchange</strong></p>
<ul>
<li><code>compare_exchange_weak()</code></li>
<li><code>compare_exchange_strong()</code></li>
</ul>
<p>如果失败，expected value或被更新为original value，都接受两个memory-ordering参数。</p>
<p>有这么几个要注意的地方：</p>
<ol>
<li>一个failed compare/exchange是不会进行保存的，因此某些memory-ordering语义是不可用的（<code>memory_order_release</code>和<code>memory_order_acq_rel</code>）。</li>
<li>can’t supply stricter memory ordering for failure than for success。</li>
<li>如果不为failure提供memory-ordering参数，则<strong>在满足1的情况下</strong>，与success一致。</li>
<li>如果都不提供，则使用默认的<code>memory_order_seq_cst</code>。</li>
<li>它们是read-modify-write operation。</li>
</ol>
<p><em>蛋疼的作者啊，很多地方扯到memory-ordering语义，但是总是说“leave to section 5.3…”</em></p>
<h2 id="Operations_on_std_3A_3Aatomic_26lt_3BT*_26gt_3B"><a href="#Operations_on_std_3A_3Aatomic_26lt_3BT*_26gt_3B" class="headerlink" title="Operations on std::atomic&lt;T*&gt;"></a>Operations on <code>std::atomic&lt;T*&gt;</code></h2><p><code>std::atomic&lt;bool&gt;</code>有的成员函数，这个也有。</p>
<p><code>std::atomic&lt;T*&gt;</code>还提供了pointer arithmetic operations，由<code>fetch_add()</code>和<code>fetch_sub()</code>实现。</p>
<p><strong><code>fetch_add()</code>和<code>fetch_sub()</code></strong></p>
<ol>
<li>也叫做<em>exchange-and-add</em>，它们是atomic read-modify-write operation。</li>
<li><p>返回的是原始的值，而不是add或sub后的值。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo&#123;&#125;;</span><br><span class="line">Foo some_array[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Foo*&gt; p(some_array);</span><br><span class="line">Foo* x=p.fetch_add(<span class="number">2</span>);</span><br><span class="line">assert(x==some_array);</span><br><span class="line">assert(p.load()==&amp;some_array[<span class="number">2</span>]);</span><br><span class="line">x=(p-=<span class="number">1</span>);</span><br><span class="line">assert(x==&amp;some_array[<span class="number">1</span>]);</span><br><span class="line">assert(p.load()==&amp;some_array[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Operations_on_standard_atomic_integral_types"><a href="#Operations_on_standard_atomic_integral_types" class="headerlink" title="Operations on standard atomic integral types"></a>Operations on standard atomic integral types</h2><p>Only division, multiplication, and shift operators are missing。因为atomic integral types通常作为计数器或位域来使用，如果需要额外的操作，可以在loop中用<code>compare_exchange_weak()</code>来实现。</p>
<h2 id="The_std_3A_3Aatomic_26lt_3B_26gt_3B_primary_class_template"><a href="#The_std_3A_3Aatomic_26lt_3B_26gt_3B_primary_class_template" class="headerlink" title="The std::atomic&lt;&gt; primary class template"></a>The <code>std::atomic&lt;&gt;</code> primary class template</h2><p>要将user-defined type用于<code>std::atomic&lt;&gt;</code>，UDT必须满足：</p>
<ol>
<li><p>必须有trivial copy-assignment operator；</p>
<blockquote>
<ul>
<li>不能有任何的virtual函数或者virtual基类；</li>
<li>必须使用编译器生成的copy-assignment operator。</li>
</ul>
</blockquote>
</li>
<li><p>每个基类和非static数据成员必须有trivial copy-assignment operator；</p>
<blockquote>
<ul>
<li>这可以使得编译器将<code>memcpy()</code>或等价的操作用于assignment operation。</li>
</ul>
</blockquote>
</li>
<li><p>这个类型必须是bitwise equality comparable。</p>
<blockquote>
<ul>
<li>这里接着2，不仅要能够使用<code>memcpy()</code>来copy，还要能使用<code>memcmp()</code>来比较（以便compare/exchange能工作）。</li>
</ul>
</blockquote>
</li>
</ol>
<p><strong>为什么要满足？</strong></p>
<ol>
<li>If <strong>user-supplied</strong> copy-assignment or comparison operators were permitted, this would <strong>require passing a reference to the protected data</strong> as an argument <strong>to a user-supplied function</strong>, thus violating the guideline.</li>
<li>增大了编译器对<code>std::atomic&lt;UDT&gt;</code>直接使用atomic instruction的可能，因为编译器可以把UDT看作a set of raw bytes。</li>
</ol>
<p><strong><code>std::atomic&lt;float&gt; and std::atomic&lt;double&gt;</code>？</strong></p>
<p>因为表示的不同，即使相等<code>compare_exchange_strong()</code>也会fail。</p>
<h2 id="Free_functions_for_atomic_operations"><a href="#Free_functions_for_atomic_operations" class="headerlink" title="Free functions for atomic operations"></a>Free functions for atomic operations</h2><p>与原子类型的成员函数相对应，也有相应的非成员函数，大多数前面都会加上<code>atomic_</code>。</p>
<p>要注意的地方有：</p>
<ol>
<li>用含有<code>_explict</code>的版本来指定memory ordering；</li>
<li><p>所有free functions的第一个参数类型都是pointer to atomic objcet(为了C-compatible)；</p>
<blockquote>
<p>对于CAS，要么不指定failure memory ordering，要么两个都要指定。</p>
</blockquote>
</li>
<li><p>对于<code>std::atomic_flag</code>只能，</p>
<ul>
<li><code>std::atomic_flag_test_and_set()</code></li>
<li><code>std::atomic_flag_clear()</code></li>
<li><code>std::atomic_flag_test_and_set_explicit()</code></li>
<li><code>std::atomic_flag_clear_explicit()</code></li>
</ul>
</li>
<li><p><code>std::shared_ptr&lt;&gt;</code>算是特殊，它非atomic type，但支持load, store, exchange and compare/exchange。这些free functions第一个参数接受<code>std::shared_ptr&lt;&gt;*</code>。</p>
</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="http://stackoverflow.com/questions/24437396/stdatomic-flag-as-member-variable" target="_blank" rel="external">std::atomic_flag as member variable</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[The C++ memory model and operations on atomic types的笔记。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://chaomai.github.io/tags/c-11/"/>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes of CS100.1x Introduction to Big Data With Apache Spark (1)]]></title>
    <link href="http://chaomai.github.io/2015/06/26/2015-2015-06-26-notes-of-cs100-1x-introduction-to-big-data-with-apache-spark-1/"/>
    <id>http://chaomai.github.io/2015/06/26/2015-2015-06-26-notes-of-cs100-1x-introduction-to-big-data-with-apache-spark-1/</id>
    <published>2015-06-26T09:15:43.000Z</published>
    <updated>2015-09-25T11:07:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Lecture_3_3A_Big_Data_2C_Hardware_Trends_2C_and_Apache_Spark_and_Lecture_4_3A_Spark_Essentials"><a href="#Lecture_3_3A_Big_Data_2C_Hardware_Trends_2C_and_Apache_Spark_and_Lecture_4_3A_Spark_Essentials" class="headerlink" title="Lecture 3: Big Data, Hardware Trends, and Apache Spark and Lecture 4: Spark Essentials"></a>Lecture 3: Big Data, Hardware Trends, and Apache Spark and Lecture 4: Spark Essentials</h2><h3 id="The_Big_Data_Problem"><a href="#The_Big_Data_Problem" class="headerlink" title="The Big Data Problem"></a>The Big Data Problem</h3><ul>
<li>Growing data sources</li>
<li>Storage getting cheapper</li>
<li>But stalling CPU and storage bottlenecks</li>
</ul>
<h3 id="Hardware_for_Big_Data"><a href="#Hardware_for_Big_Data" class="headerlink" title="Hardware for Big Data"></a>Hardware for Big Data</h3><p>Problems with cheap hardware</p>
<ul>
<li>Failures</li>
<li>Network</li>
<li>Uneven performance</li>
</ul>
<h3 id="What_u2019s_Hard_About_Cluster_Computing"><a href="#What_u2019s_Hard_About_Cluster_Computing" class="headerlink" title="What’s Hard About Cluster Computing"></a>What’s Hard About Cluster Computing</h3><ul>
<li>Divide work across machines<ul>
<li>Must consider network, data locality</li>
<li>Moving data may be veay expensive</li>
</ul>
</li>
<li>Deal with failures</li>
</ul>
<h2 id="Spark_Essentials"><a href="#Spark_Essentials" class="headerlink" title="Spark Essentials"></a>Spark Essentials</h2><h3 id="PySpark"><a href="#PySpark" class="headerlink" title="PySpark"></a>PySpark</h3><p>A Spark program consists of two programs, a driver program<br>and a workers program.</p>
<ul>
<li>Drivers program: runs on the driver machine.</li>
<li>Worker programs: run on cluster nodes<br>or in local threads.</li>
</ul>
<p>RDDs are distributed across the workers.</p>
<h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><p>An RDD is immutable, so once it is created, it cannot be changed.</p>
<p>types of operations:</p>
<ul>
<li><p>transformations</p>
<ul>
<li>lazily evaluated.</li>
<li>A transformed RDD is executed only when an action runs on it.</li>
<li>can also persist, or cache RDDs in memory or on disk.<br>?</li>
</ul>
</li>
<li><p>actions</p>
<ul>
<li>cause Spark to execute the recipe to transform the source data.</li>
</ul>
</li>
</ul>
<h3 id="Spark_Programming_Model"><a href="#Spark_Programming_Model" class="headerlink" title="Spark Programming Model"></a>Spark Programming Model</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lines = sc.textFile(<span class="string">"..."</span>, <span class="number">4</span>)</span><br><span class="line">comments = lines.filter(isComment)</span><br><span class="line"><span class="keyword">print</span> lines.count(), comments.count()</span><br></pre></td></tr></table></figure>
<p><code>comments.count()</code> is going to cause Spark to re-compute lines. reread all of the data from that text file again, sum within the partition the number of lines, so the number of elements, and then combine those sums in the driver.</p>
<h3 id="Caching_RDDS"><a href="#Caching_RDDS" class="headerlink" title="Caching RDDS"></a>Caching RDDS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lines = sc.textFile(<span class="string">"..."</span>, <span class="number">4</span>)</span><br><span class="line">lines.cache()</span><br><span class="line">comments = lines.filter(isComment)</span><br><span class="line"><span class="keyword">print</span> lines.count(), comments.count()</span><br></pre></td></tr></table></figure>
<p>create the comments RDD directly, instead of reading from disk.</p>
<h3 id="Spark_Program_Lifecycle"><a href="#Spark_Program_Lifecycle" class="headerlink" title="Spark Program Lifecycle"></a>Spark Program Lifecycle</h3><ol>
<li>create RDDs from some external data source or parallelize a collection in your driver program.</li>
<li>lazily transform these RDDs into new RDDs.</li>
<li>cache some of those RDDs for future reuse.</li>
<li>perform actions to execute parallel computation and to produce results.</li>
</ol>
<h3 id="Spark_Broadcast_Variables"><a href="#Spark_Broadcast_Variables" class="headerlink" title="Spark Broadcast Variables"></a>Spark Broadcast Variables</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">broadcast_var = sc.broadcast([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">...</span><br><span class="line">broadcast_var.value</span><br></pre></td></tr></table></figure>
<p>Keep a read-only variable cached at a worker and will be reused every time we need to access it instead of constructing another closure.</p>
<h3 id="Spark_Accumulators"><a href="#Spark_Accumulators" class="headerlink" title="Spark Accumulators"></a>Spark Accumulators</h3><p>could only be added to by an associative operation. They’re used to very efficiently implement parallel counters and sums, and only the driver can read an accumulator’s values, not the tasks.</p>
<p>can be used in actions or transformations:</p>
<ul>
<li>actions: each tasks update to the accumulator is guaranteed by spark to <strong>only be applied once</strong>.</li>
<li>transformations: no guarantee.</li>
</ul>
<p>support the types:</p>
<ul>
<li>integers</li>
<li>double</li>
<li>long</li>
<li>float</li>
<li>custom types</li>
</ul>
<h2 id="About_pySpark"><a href="#About_pySpark" class="headerlink" title="About pySpark"></a>About pySpark</h2><h3 id="Spark_Context"><a href="#Spark_Context" class="headerlink" title="Spark Context"></a>Spark Context</h3><p>When running Spark, you start a new Spark application by creating a SparkContext. When the SparkContext is created, it asks the master for some cores to use to do work. The master sets these cores aside just for you; they <strong>won’t be used for other applications</strong>.</p>
<p>Driver programs access Spark through a SparkContext object, which represents <strong>a connection to a computing cluster</strong>. A Spark context object (sc) is the main entry point for Spark functionality. A Spark context can be used to create Resilient Distributed Datasets (RDDs) on a cluster.</p>
<p><img src="http://spark-mooc.github.io/web-assets/images/executors.png" alt=""></p>
<h3 id="Resilient_Distributed_Datasets__28RDDs_29"><a href="#Resilient_Distributed_Datasets__28RDDs_29" class="headerlink" title="Resilient Distributed Datasets (RDDs)"></a>Resilient Distributed Datasets (RDDs)</h3><p><img src="http://spark-mooc.github.io/web-assets/images/partitions.png" alt=""></p>
<h3 id="map_28_29"><a href="#map_28_29" class="headerlink" title="map()"></a><code>map()</code></h3><p>When you run <code>map()</code> on a dataset, a <strong>single stage of tasks</strong> is launched. A stage is <em>a group of tasks that all perform the same computation, but on different input data</em>. <strong>One task is launched for each partition</strong>. A task is <em>a unit of execution that runs on a single machine</em>. When we run <code>map(f)</code> within a partition, a new task applies f to all of the entries in a particular partition, and outputs a new partition.</p>
<p><img src="http://spark-mooc.github.io/web-assets/images/map.png" alt=""></p>
<p>When applying the <code>map()</code> transformation, each item in the parent RDD will map to one element in the new RDD.</p>
<h3 id="collect_28_29"><a href="#collect_28_29" class="headerlink" title="collect()"></a><code>collect()</code></h3><p>the data returned to the driver <strong>must fit into the driver’s available memory</strong>. If not, the driver will crash.</p>
<h3 id="first_28_29_and_take_28_29"><a href="#first_28_29_and_take_28_29" class="headerlink" title="first() and take()"></a><code>first()</code> and <code>take()</code></h3><p><code>first()</code> and <code>take()</code> actions, the elements that are returned depend on how the RDD is partitioned.</p>
<h3 id="takeOrdered_28_29"><a href="#takeOrdered_28_29" class="headerlink" title="takeOrdered()"></a><code>takeOrdered()</code></h3><p>The key advantage of using <code>takeOrdered()</code> instead of <code>first()</code> or <code>take()</code> is that <code>takeOrdered()</code> returns a <strong>deterministic result</strong>, while the other two actions may return different results, <em>depending on the number of partitions or execution environment</em>.</p>
<p><code>takeOrdered()</code> returns the list sorted in <strong>ascending order</strong>. The <code>top()</code> action is similar to <code>takeOrdered()</code> except that it returns the list in <strong>descending order</strong>.</p>
<h3 id="reduce_28_29"><a href="#reduce_28_29" class="headerlink" title="reduce()"></a><code>reduce()</code></h3><p>reduces the elements of a RDD to a single value by applying a function that takes two parameters and returns a single value.</p>
<p>The function should be <strong>commutative and associative（可交换和可结合）</strong>, as <code>reduce()</code> is applied at the partition level and then again to aggregate results from partitions.</p>
<h3 id="takeSample_28_29_and_countByValue_28_29"><a href="#takeSample_28_29_and_countByValue_28_29" class="headerlink" title="takeSample() and countByValue()"></a><code>takeSample()</code> and <code>countByValue()</code></h3><p>The <code>takeSample()</code> action returns an array with a random sample of elements from the dataset. It takes in a <code>withReplacement</code> argument, which specifies whether it is okay to randomly pick the same item multiple times from the parent RDD. It also takes an optional <code>seed</code> parameter that allows you to specify a seed value for the random number generator, so that reproducible results can be obtained.</p>
<p>The <code>countByValue()</code> action returns <strong>the count of each unique value</strong> in the RDD as a dictionary that maps values to counts.</p>
<h3 id="flatMap_28_29"><a href="#flatMap_28_29" class="headerlink" title="flatMap()"></a><code>flatMap()</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">simpleRDD = sc.parallelize([[[<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>],<span class="number">2</span>,<span class="number">3</span>], [[<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>],<span class="number">3</span>,<span class="number">4</span>], [[<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>],<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="keyword">print</span> simpleRDD.map(<span class="keyword">lambda</span> x:x).collect()</span><br><span class="line"><span class="keyword">print</span> simpleRDD.flatMap(<span class="keyword">lambda</span> x:x).collect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">[[[<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">2</span>, <span class="number">3</span>], [[<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">4</span>], [[<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">[[<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">2</span>, <span class="number">3</span>, [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">4</span>, [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<h3 id="groupByKey_28_29_and_reduceByKey_28_29"><a href="#groupByKey_28_29_and_reduceByKey_28_29" class="headerlink" title="groupByKey() and reduceByKey()"></a><code>groupByKey()</code> and <code>reduceByKey()</code></h3><p>Both of these transformations operate on <em>pair RDDs</em>. A pair RDD is an RDD where <em>each element is a pair tuple (key, value)</em>.</p>
<p><img src="http://spark-mooc.github.io/web-assets/images/reduce_by.png" alt=""></p>
<p><img src="http://spark-mooc.github.io/web-assets/images/group_by.png" alt=""></p>
<p><code>reduceByKey()</code> operates by applying the function first within each partition on a per-key basis and then across the partitions.</p>
<ul>
<li>the <code>reduceByKey()</code> transformation works much better for large distributed datasets. This is because Spark knows it can <em>combine output with a common key on each partition before shuffling</em> (redistributing) the data across nodes. Only use <code>groupByKey()</code> if the operation would not benefit from reducing the data before the shuffle occurs.</li>
<li>On the other hand, when using the <code>groupByKey()</code> transformation - all the key-value pairs are shuffled around, causing a lot of unnecessary data to being transferred over the network.</li>
</ul>
<h3 id="cache_28_29_and_unpersist_28_29"><a href="#cache_28_29_and_unpersist_28_29" class="headerlink" title="cache() and unpersist()"></a><code>cache()</code> and <code>unpersist()</code></h3><p>if you cache too many RDDs and Spark runs out of memory, it will delete the least recently used (LRU) RDD first. The RDD will be automatically recreated when accessed.</p>
<p>tell Spark to stop caching it in memory by using the RDD’s <code>unpersist()</code> method.</p>
]]></content>
    <summary type="html">
    <![CDATA[Notes of Lecture 3 Big Data, Hardware Trends, and Apache Spark.]]>
    
    </summary>
    
      <category term="edx" scheme="http://chaomai.github.io/tags/edx/"/>
    
      <category term="pyspark" scheme="http://chaomai.github.io/tags/pyspark/"/>
    
      <category term="spark" scheme="http://chaomai.github.io/tags/spark/"/>
    
      <category term="spark" scheme="http://chaomai.github.io/categories/spark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tmux]]></title>
    <link href="http://chaomai.github.io/2015/06/22/2015-2015-06-22-tmux/"/>
    <id>http://chaomai.github.io/2015/06/22/2015-2015-06-22-tmux/</id>
    <published>2015-06-22T12:36:57.000Z</published>
    <updated>2015-09-25T11:08:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><h3 id="Creating_Named_Sessions"><a href="#Creating_Named_Sessions" class="headerlink" title="Creating Named Sessions"></a>Creating Named Sessions</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new-session <span class="operator">-s</span> basic</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new <span class="operator">-s</span> basic</span><br></pre></td></tr></table></figure>
<h3 id="Detaching_Sessions"><a href="#Detaching_Sessions" class="headerlink" title="Detaching Sessions"></a>Detaching Sessions</h3><p><code>CTRL-b</code>, then <code>d</code></p>
<h3 id="Reattaching_to_Existing_Sessions"><a href="#Reattaching_to_Existing_Sessions" class="headerlink" title="Reattaching to Existing Sessions"></a>Reattaching to Existing Sessions</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new-session <span class="operator">-s</span> basic</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>If there is only session, then <code>tmux attach</code>.</li>
<li>If there are multiple sessions, then <code>tmux attach -t second_session</code>. BTY, you can also use this when you only have one session.</li>
</ol>
</blockquote>
<h3 id="Killing_Sessions"><a href="#Killing_Sessions" class="headerlink" title="Killing Sessions"></a>Killing Sessions</h3><ul>
<li>In sesssion, use <code>exit</code>.</li>
<li>Kill specific session when not in session,</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux <span class="built_in">kill</span>-session -t basic</span><br></pre></td></tr></table></figure>
<p>BTY, if there is no sessions, after typing <code>tmux ls</code>, you will get</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to connect to server: Connection refused</span><br></pre></td></tr></table></figure>
<h3 id="Creating_and_Naming_Windows"><a href="#Creating_and_Naming_Windows" class="headerlink" title="Creating and Naming Windows"></a>Creating and Naming Windows</h3><ul>
<li><p>In terminal</p>
<p>  <code>-n</code>: the name of new window.</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new <span class="operator">-s</span> windows -n shell</span><br></pre></td></tr></table></figure>
</li>
<li><p>In session</p>
<p>  <code>PREFIX c</code></p>
<p>  <code>PREFIX ,</code> will rename the new window.</p>
</li>
</ul>
<h3 id="Moving_Between_Windows"><a href="#Moving_Between_Windows" class="headerlink" title="Moving Between Windows"></a>Moving Between Windows</h3><ul>
<li><p>next and previous window</p>
<p>  <code>PREFIX n</code> and <code>PREFIX p</code></p>
</li>
<li><p>default id of window</p>
<p>  <code>PREFIX 0</code> to <code>PREFIX 9</code></p>
</li>
<li><p>find a window</p>
<p>  <code>PREFIX f</code></p>
</li>
<li><p>window list</p>
<p>  <code>PREFIX w</code></p>
</li>
</ul>
<h3 id="Close_a_Window"><a href="#Close_a_Window" class="headerlink" title="Close a Window"></a>Close a Window</h3><ul>
<li>type <code>exit</code> after command finish executed.</li>
<li><code>PREFIX &amp;</code></li>
</ul>
<p>If you want to quit a tmux session, you’ll have to close all windows.</p>
<h3 id="Panes"><a href="#Panes" class="headerlink" title="Panes"></a>Panes</h3><ul>
<li>vertically: <code>PREFIX %</code></li>
<li>horizontally: <code>PREFIX &quot;</code></li>
<li>switch between them:<ul>
<li>cycle through: <code>PREFIX o</code></li>
<li><code>PREFIX UP</code>, <code>PREFIX DOWN</code>, <code>PREFIX LEFT</code>, or <code>PREFIX RIGHT</code></li>
</ul>
</li>
</ul>
<h3 id="Pane_Layouts"><a href="#Pane_Layouts" class="headerlink" title="Pane Layouts"></a>Pane Layouts</h3><p>types:</p>
<ul>
<li>even-horizontal</li>
<li>even-vertical</li>
<li>main-horizontal</li>
<li>main-vertical</li>
<li>tiled</li>
</ul>
<p>cycle through these types by pressing <code>PREFIX SPACEBAR</code>.</p>
<h3 id="Closing_Panes"><a href="#Closing_Panes" class="headerlink" title="Closing Panes"></a>Closing Panes</h3><ul>
<li><code>exit</code></li>
<li><code>PREFIX X</code>. If there is only one pane in current window, it will close this window at the same time.</li>
</ul>
<h3 id="Command_Mode"><a href="#Command_Mode" class="headerlink" title="Command Mode"></a>Command Mode</h3><p>press <code>PREFIX :</code> to enter command mode.</p>
<ul>
<li>create new window with a name,</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new-window -n console</span><br></pre></td></tr></table></figure>
<ul>
<li>create new window with a name and a command,</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new-window -n processes <span class="string">"top"</span></span><br></pre></td></tr></table></figure>
<p><code>top</code> will execute immediately after new window created. What’s really cool is that <strong>this window close instantly when you press <code>q</code> to close top.</strong></p>
<h3 id="Quick_Reference"><a href="#Quick_Reference" class="headerlink" title="Quick Reference"></a>Quick Reference</h3><p><strong>创建会话</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tmux new-session</code></td>
<td>创建一个未命名的会话。可以简写为 <code>tmux new</code> 或者就一个简单的 <code>tmux</code></td>
</tr>
<tr>
<td><code>tmux new -s development</code></td>
<td>创建一个名为“development”的会话</td>
</tr>
<tr>
<td><code>tmux new -s development -n editor</code></td>
<td>创建一个名为“development”的会话并把该会话的第一个窗口命名为“editor”</td>
</tr>
<tr>
<td><code>tmux attach -t development</code></td>
<td>连接到一个名为“development”的会话</td>
</tr>
</tbody>
</table>
<p><strong>会话、窗口和面板的默认快捷键</strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PREFIX d</code></td>
<td>从一个会话中分离，让该会话在后台运行。</td>
</tr>
<tr>
<td><code>PREFIX :</code></td>
<td>进入命令模式</td>
</tr>
<tr>
<td><code>PREFIX c</code></td>
<td>在当前tmux会话创建一个新的窗口，是 new-window 命令的简写</td>
</tr>
<tr>
<td><code>PREFIX 0...9</code></td>
<td>根据窗口的编号选择窗口</td>
</tr>
<tr>
<td><code>PREFIX w</code></td>
<td>显示当前会话中所有窗口的可选择列表</td>
</tr>
<tr>
<td><code>PREFIX ,</code></td>
<td>显示一个提示符来重命名一个窗口</td>
</tr>
<tr>
<td><code>PREFIX &amp;</code></td>
<td>关闭当前窗口，带有确认提示</td>
</tr>
<tr>
<td><code>PREFIX %</code></td>
<td>把当前窗口垂直地一分为二，分割后的两个面板各占50%大小</td>
</tr>
<tr>
<td><code>PREFIX &quot;</code></td>
<td>把当前窗口水平地一分为二，分割后的两个面板各占50%大小</td>
</tr>
<tr>
<td><code>PREFIX o</code></td>
<td>在已打开的面板之间循环移动当前焦点</td>
</tr>
<tr>
<td><code>PREFIX q</code></td>
<td>短暂地显示每个面板的编号</td>
</tr>
<tr>
<td><code>PREFIX x</code></td>
<td>关闭当前面板，带有确认提示</td>
</tr>
<tr>
<td><code>PREFIX SPACE</code></td>
<td>循环地使用tmux的几个默认面板布局</td>
</tr>
</tbody>
</table>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li>[tmux-Productive-Mouse-Free-Development_zh(<a href="https://github.com/aqua7regia/tmux-Productive-Mouse-Free-Development_zh" target="_blank" rel="external">https://github.com/aqua7regia/tmux-Productive-Mouse-Free-Development_zh</a>)</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[tmux的简单操作。]]>
    
    </summary>
    
      <category term="linux" scheme="http://chaomai.github.io/tags/linux/"/>
    
      <category term="tmux" scheme="http://chaomai.github.io/tags/tmux/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Apt-Get Hold Version]]></title>
    <link href="http://chaomai.github.io/2015/06/16/2015-2015-06-16-apt-get-hold-version/"/>
    <id>http://chaomai.github.io/2015/06/16/2015-2015-06-16-apt-get-hold-version/</id>
    <published>2015-06-16T14:56:47.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<p>If you want some specific package not to be processed（keep the current version with the current status whatever that is）, you can hold it.</p>
<h2 id="hold"><a href="#hold" class="headerlink" title="hold"></a>hold</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"package_name hold"</span> | dpkg --set-selections</span><br></pre></td></tr></table></figure>
<h2 id="unhold"><a href="#unhold" class="headerlink" title="unhold"></a>unhold</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"package_name install"</span> | dpkg --set-selecions</span><br></pre></td></tr></table></figure>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="http://www.debian.org/doc/manuals/debian-faq/ch-pkg_basics.en.html" target="_blank" rel="external">The Debian GNU/Linux FAQ<br>Chapter 7 - Basics of the Debian package management system</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[在ubuntu上进行update的时候，有的时候会不想升级某些包，这时可以用dpkg来hold住包，不让它升级。]]>
    
    </summary>
    
      <category term="linux" scheme="http://chaomai.github.io/tags/linux/"/>
    
      <category term="ubuntu" scheme="http://chaomai.github.io/tags/ubuntu/"/>
    
      <category term="linux" scheme="http://chaomai.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[译 - Understand `Std::atomic::compare_exchange_weak()` in C++11]]></title>
    <link href="http://chaomai.github.io/2015/06/09/2015-2015-06-09-translation-understand-std-atomic-compare-exchange-weak-in-cpp11/"/>
    <id>http://chaomai.github.io/2015/06/09/2015-2015-06-09-translation-understand-std-atomic-compare-exchange-weak-in-cpp11/</id>
    <published>2015-06-08T16:00:49.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br><br>原文是stackoverflow上的<a href="http://stackoverflow.com/questions/25199838/understanding-stdatomiccompare-exchange-weak-in-c11" target="_blank" rel="external">一个关于<code>compare_exchange_weak()</code>问题和相应的答案</a>。<br><br></blockquote>

<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val, ..)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>compare_exchange_weak()</code>是C++11中提供的compare-exchange原语之一。之所以是<strong>weak</strong>，是因为即使在对象的值等于<code>expected</code>的情况下，也返回false。这是因为在某些平台上的<strong>spurious failure</strong>，这些平台使用了一系列的指令（而不是像在x86上一样，使用单条的指令）来实现CAS。在这种平台上，context switch, reloading of the same address (or cache line) by another thread等，将会导致这条原语失败。由于不是因为对象的值（不等于<code>expected</code>）导致的操作失败，因此是<code>spurious</code>。相反的，it’s kind of timing issues。</p>
<p>但是困扰我的是C++11标准（ISO/IEC 14882）里的，</p>
<blockquote>
<p>29.6.5 .. A consequence of spurious failure is that nearly all uses of weak compare-and-exchange will be in a loop.</p>
</blockquote>
<p>为什么in <strong>nearly all uses</strong>都必须在一个loop中？这是不是意味着因为有spurious failures，当它失败的时候，我们将会loop？如果这是原因，那么为什么我们还要那么麻烦的使用<code>compare_exchange_weak()</code>，并且自己写loop？我们可以直接使用<code>compare_exchange_strong()</code>，我认为这样可以让我们摆脱spurious failures。<code>compare_exchange_weak()</code>通常在什么情况下使用？</p>
<p>另一个相关的问题是，在Anthony的”C++ Concurrency In Action”一书中写到，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Because compare_exchange_weak() can fail spuriously, it must typically</span></span><br><span class="line"><span class="comment">//be used in a loop:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> expected=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="keyword">bool</span>&gt; b; <span class="comment">// set somewhere else</span></span><br><span class="line"><span class="keyword">while</span>(!b.compare_exchange_weak(expected,<span class="literal">true</span>) &amp;&amp; !expected);</span><br><span class="line"></span><br><span class="line"><span class="comment">//In this case, you keep looping as long as expected is still false,</span></span><br><span class="line"><span class="comment">//indicating that the compare_exchange_weak() call failed spuriously.</span></span><br></pre></td></tr></table></figure>
<p>为什么在loop的条件中有!expected？它是不是防止了所有线程可能会starve，并且在一段时间里make no progress？</p>
<p><strong>Edit：(最后一个问题)</strong></p>
<p>在那些没有单条硬件CAS指令的平台上，weak和strong版本都是使用LL/SC来实现的（像ARM，PowerPC等）。那么下面的两种loop之间是否有区别？如果有的话，为什么？（对我来说，我觉得它们应该有相似的性能）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use LL/SC (or CAS on x86) and ignore/loop on spurious failures</span></span><br><span class="line"><span class="keyword">while</span> (!compare_exchange_weak(..))</span><br><span class="line">&#123; .. &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use LL/SC (or CAS on x86) and ignore/loop on spurious failures</span></span><br><span class="line"><span class="keyword">while</span> (!compare_exchange_strong(..))</span><br><span class="line">&#123; .. &#125;</span><br></pre></td></tr></table></figure>
<p>你们都提到，在loop在可能会存在性能上的区别。这也在C++11（ISO/IEC 14882）标准中提到，</p>
<blockquote>
<p>When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</p>
</blockquote>
<p>但是根据上面的分析，两个版本的loop应该有相同或类似的性能。我遗漏了什么吗？</p>
<h2 id="Answer_1"><a href="#Answer_1" class="headerlink" title="Answer 1"></a>Answer 1</h2><h3 id="Why_doing_exchange_in_a_loop_3F"><a href="#Why_doing_exchange_in_a_loop_3F" class="headerlink" title="Why doing exchange in a loop?"></a>Why doing exchange in a loop?</h3><p>通常来说，你想要在进行下一步的工作前完成当前的工作，因此，你把<code>compare_exchange_weak</code>放入了一个loop，以便一直尝试exchange直到成功（也就是说，返回<code>true</code>）。</p>
<p>要注意的是，<code>compare_exchange_strong</code>也常常用在loop中。它不会因为spurious failure而失败，但会因为concurrent writes而失败。</p>
<h3 id="Why_to_use_weak_instead_of_strong_3F"><a href="#Why_to_use_weak_instead_of_strong_3F" class="headerlink" title="Why to use weak instead of strong?"></a>Why to use <code>weak</code> instead of <code>strong</code>?</h3><p>很简单：spurious failure并不会经常发生，因此这不会有大的性能损失。相反，tolerate这种failure允许在某些平台上有更高效的<code>weak</code>版本的实现（与<code>strong</code>相比较）。<code>strong</code>必须每次都检查spurious failure，并处理它，这是有代价的。</p>
<p>因此，<code>weak</code>在某些平台上比<code>strong</code>更快使得<code>weak</code>被使用。</p>
<h3 id="When_should_you_use_weak_and_when_strong_3F"><a href="#When_should_you_use_weak_and_when_strong_3F" class="headerlink" title="When should you use weak and when strong?"></a>When should you use <code>weak</code> and when <code>strong</code>?</h3><p>这个<a href="http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange" target="_blank" rel="external">参考文献</a>指明了什么时候用<code>weak</code>，什么时候用<code>strong</code>：</p>
<blockquote>
<p>When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.</p>
<p>当compare-and-exchange在loop中，weak版本在某些平台上会有更高的性能。当一个weak的compare-and-exchange需要一个loop，而strong的不需要，那么用strong的更合适。</p>
</blockquote>
<p>因此这个答案很容易记住：如果你使用loop仅仅是由于spurious failure，那么不要使用loop；用<code>strong</code>。如果你无法避免的要使用loop，那么就是用<code>weak</code>。</p>
<h3 id="Why_is__21expected_in_the_example_3F"><a href="#Why_is__21expected_in_the_example_3F" class="headerlink" title="Why is !expected in the example?"></a>Why is <code>!expected</code> in the example?</h3><p>这视实际情况和期望的语义而定，但是通常it is not needed for correctness。忽略它会产生一个非常相似的语义。仅仅在另一个线程可能会把值reset为<code>false</code>的情况下，这个语义才会有细微的差别（但是我没有找到一个比较meaningful的例子），Tony D的评论有更详细的解释。</p>
<p><strong>Tony D：</strong></p>
<p>“Why is !expected in the example? It is not needed for correctness. Omitting it would yield the same semantics.”</p>
<p>并非如此。假设第一个exchange由于b已经是<code>true</code>而失败，此时<code>expected</code>变为<code>true</code>。如果没有<code>&amp;&amp; !expected</code>的话，它只会再次loop，并且（傻傻的）将<code>true</code>与<code>true</code>交换。这可能会成功并且退出<code>while</code> loop。But could exhibit meaningfully different behavior if b had meanwhile changed back to false, in which case the loop would continue and may ultimately set b true yet again before breaking.</p>
<p>当其他线程写入<code>true</code>时，这是个简单快捷的方法：我们只需要终止，而不是再次尝试写入<code>true</code>。</p>
<h3 id="About_your_last_question"><a href="#About_your_last_question" class="headerlink" title="About your last question"></a>About your last question</h3><blockquote>
<p>但是根据上面的分析，两个版本的loop应该有相同或类似的性能。我遗漏了什么吗？</p>
</blockquote>
<p>在<a href="http://en.wikipedia.org/wiki/Load-link/store-conditional" target="_blank" rel="external">Wikipedia</a>：</p>
<blockquote>
<p>Real implementations of LL/SC do not always succeed if there are no concurrent updates to the memory location in question. Any exceptional events between the two operations, such as a context switch, another load-link, or even (on many platforms) another load or store operation, will cause the store-conditional to spuriously fail. Older implementations will fail if there are any updates broadcast over the memory bus.</p>
</blockquote>
<p>因此，LL/SC在发生context switch的时候将会fail spuriously。现在，<code>strong</code>版本的会使用它“自己的小loop”来检测spurious failure，并且通过重试来处理它。要注意的是，它自己的loop要比一个普通的CAS loop要复杂，因为它必须区分spurious failure（并处理它）和由于并发访问导致的失败（这会导致返回值为<code>false</code>）。<code>weak</code>版的并没有这样自己的loop。</p>
<p>既然你在两个例子中都显式的使用了loop，在<code>strong</code>版本中是完全没有必要使用loop的。结果是，在<code>strong</code>版本中，做了两次failure的检查；一次是<code>compare_exchange_strong</code>做的（由于它要区分spurious failure和并发访问，这要更复杂），另一是你自己的loop做的。这样代价高昂的检查时没有必要的，<code>weak</code>快的原因就在这里。</p>
<p>Also note that your argument (LL/SC) is just one possibility to implement this. There are more platforms that have even different instruction sets. In addition (and more importantly), note that std::atomic must support all operations for all possible data types, 因此即使你声明了一个一千万字节的结构体，你还是可以用compare_exchange来做这个。即使当CPU有CAS指令，你也不用能够CAS一千万字节，因此编译器会生成其他的指令（可能是acquire lock，然后进行non-atomic compare and swap，接着release lock）。现在，想想当swap一千万字节的时候会发生什么。因此尽管spurious error对于8 byte的exchanges可能是非常罕见的，在这种情况下，它可能更常见。</p>
<h2 id="Answer_2"><a href="#Answer_2" class="headerlink" title="Answer 2"></a>Answer 2</h2><p><strong>To be continued…</strong></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="http://stackoverflow.com/questions/25199838/understanding-stdatomiccompare-exchange-weak-in-c11" target="_blank" rel="external">Understanding std::atomic::compare_exchange_weak() in C++11</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[原文是stackoverflow上的一个关于compare_exchange_weak()问题和相应的答案，我做了简单的翻译和整理。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://chaomai.github.io/tags/c-11/"/>
    
      <category term="cas" scheme="http://chaomai.github.io/tags/cas/"/>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[转 - 如何实现一个Malloc]]></title>
    <link href="http://chaomai.github.io/2015/06/02/2015-2015-06-02-reproduce-a-malloc-tutorial/"/>
    <id>http://chaomai.github.io/2015/06/02/2015-2015-06-02-reproduce-a-malloc-tutorial/</id>
    <published>2015-06-02T15:10:10.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br><br><blockquote><p>这篇是转自<a href="ttp://blog.codinglabs.org" target="_blank" rel="external">CodingLabs</a>的文章，除了有原文的内容，我加入了自己的一些思考和理解。</p>
<footer><strong>张洋, CodingLabs</strong><cite><a href="http://blog.codinglabs.org/articles/a-malloc-tutorial.html" target="_blank" rel="external">如何实现一个Malloc</a></cite></footer></blockquote><br><br></blockquote>

<p>任何一个用过或学过C的人对malloc都不会陌生。大家都知道malloc可以分配一段连续的内存空间，并且在不再使用时可以通过free释放掉。但是，许多程序员对malloc背后的事情并不熟悉，许多人甚至把malloc当做操作系统所提供的系统调用或C的关键字。实际上，malloc只是C的标准库中提供的一个普通函数，而且实现malloc的<strong>基本</strong>思想并不复杂，任何一个对C和操作系统有些许了解的程序员都可以很容易理解。</p>
<p>这篇文章通过实现一个简单的malloc来描述malloc背后的机制。当然与现有C的标准库实现（例如glibc）相比，我们实现的malloc并不是特别高效，但是这个实现比目前真实的malloc实现要简单很多，因此易于理解。重要的是，这个实现和真实实现在基本原理上是一致的。</p>
<p>这篇文章将首先介绍一些所需的基本知识，如操作系统对进程的内存管理以及相关的系统调用，然后逐步实现一个简单的malloc。为了简单起见，这篇文章将只考虑x86_64体系结构，操作系统为Linux。</p>
<h1 id="u4EC0_u4E48_u662Fmalloc"><a href="#u4EC0_u4E48_u662Fmalloc" class="headerlink" title="什么是malloc"></a>什么是malloc</h1><p>在实现malloc之前，先要相对正式地对malloc做一个定义。</p>
<p>根据标准C库函数的定义，malloc具有如下原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(size_t size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p>
<ul>
<li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li>
<li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li>
<li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li>
<li>malloc应该尽快完成内存分配并返回（不能使用<a href="http://en.wikipedia.org/wiki/NP-hard" target="_blank" rel="external">NP-hard</a>的内存分配算法）</li>
<li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li>
</ul>
<p>对于malloc更多的说明可以在命令行中键入以下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man malloc</span><br></pre></td></tr></table></figure>
<h1 id="u9884_u5907_u77E5_u8BC6"><a href="#u9884_u5907_u77E5_u8BC6" class="headerlink" title="预备知识"></a>预备知识</h1><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p>
<h2 id="Linux_u5185_u5B58_u7BA1_u7406"><a href="#Linux_u5185_u5B58_u7BA1_u7406" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h2><h3 id="u865A_u62DF_u5185_u5B58_u5730_u5740_u4E0E_u7269_u7406_u5185_u5B58_u5730_u5740"><a href="#u865A_u62DF_u5185_u5B58_u5730_u5740_u4E0E_u7269_u7406_u5185_u5B58_u5730_u5740" class="headerlink" title="虚拟内存地址与物理内存地址"></a>虚拟内存地址与物理内存地址</h3><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片$2^N$字节的内存，其中$N$是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为$2^{64}$Byte。</p>
<p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p>
<p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank" rel="external">MMU</a>（Memory Management Unit）的硬件完成。</p>
<h3 id="u9875_u4E0E_u5730_u5740_u6784_u6210"><a href="#u9875_u4E0E_u5730_u5740_u6784_u6210" class="headerlink" title="页与地址构成"></a>页与地址构成</h3><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p>
<p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：</p>
<p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-01.png" alt="内存地址构成"></p>
<p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内偏移都是用低12位表示，而剩下的高地址表示页号。</p>
<p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="external">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="external">TLB</a>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。</p>
<p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-02.png" alt="内存地址翻译"></p>
<h3 id="u5185_u5B58_u9875_u4E0E_u78C1_u76D8_u9875"><a href="#u5185_u5B58_u9875_u4E0E_u78C1_u76D8_u9875" class="headerlink" title="内存页与磁盘页"></a>内存页与磁盘页</h3><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p>
<p>最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="external">图片来源页</a>）。</p>
<p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-03.png" alt="较为完整的地址翻译流程"></p>
<h2 id="Linux_u8FDB_u7A0B_u7EA7_u5185_u5B58_u7BA1_u7406"><a href="#Linux_u8FDB_u7A0B_u7EA7_u5185_u5B58_u7BA1_u7406" class="headerlink" title="Linux进程级内存管理"></a>Linux进程级内存管理</h2><h3 id="u5185_u5B58_u6392_u5E03"><a href="#u5185_u5B58_u6392_u5E03" class="headerlink" title="内存排布"></a>内存排布</h3><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p>
<p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p>
<p>根据<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="external">Linux内核相关文档</a>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p>
<p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-04.png" alt="Linux进程地址排布"></p>
<p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p>
<ul>
<li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li>
<li>Data：这里存放的是初始化过的全局变量</li>
<li>BSS：这里存放的是未初始化的全局变量</li>
<li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li>
<li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li>
<li>Stack：这是栈区域，自高地址向低地址增长</li>
</ul>
<p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p>
<h3 id="Heap_u5185_u5B58_u6A21_u578B"><a href="#Heap_u5185_u5B58_u6A21_u578B" class="headerlink" title="Heap内存模型"></a>Heap内存模型</h3><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p>
<p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：</p>
<p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-05.png" alt="Linux进程堆管理"></p>
<p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<h3 id="brk_u4E0Esbrk"><a href="#brk_u4E0Esbrk" class="headerlink" title="brk与sbrk"></a>brk与sbrk</h3><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(intptr_t increment)</span></span>;</span><br></pre></td></tr></table></figure>
<p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p>
<p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p>
<p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p>
<h3 id="u8D44_u6E90_u9650_u5236_u4E0Erlimit"><a href="#u8D44_u6E90_u9650_u5236_u4E0Erlimit" class="headerlink" title="资源限制与rlimit"></a>资源限制与rlimit</h3><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> rlimit *limit = (<span class="keyword">struct</span> rlimit *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> rlimit));</span><br><span class="line">    getrlimit(RLIMIT_AS, limit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"soft limit: %ld, hard limit: %ld\n"</span>, limit-&gt;rlim_cur, limit-&gt;rlim_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中rlimit是一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> rlimit &#123;</span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p>
<h1 id="u5B9E_u73B0malloc"><a href="#u5B9E_u73B0malloc" class="headerlink" title="实现malloc"></a>实现malloc</h1><h2 id="u73A9_u5177_u5B9E_u73B0"><a href="#u73A9_u5177_u5B9E_u73B0" class="headerlink" title="玩具实现"></a>玩具实现</h2><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个玩具malloc */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    p = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sbrk(size) == (<span class="keyword">void</span> *)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p>
<h2 id="u6B63_u5F0F_u5B9E_u73B0"><a href="#u6B63_u5F0F_u5B9E_u73B0" class="headerlink" title="正式实现"></a>正式实现</h2><p>下面严肃点讨论malloc的实现方案。</p>
<h3 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h3><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p>
<p>可以用如下结构体定义一个block：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_block *t_block;</span><br><span class="line"><span class="keyword">struct</span> s_block &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>注：</em><br><code>data</code>其实可以为<code>char data[]</code>。<br>详细的解释可以看[C语言结构体里的成员数组和指针]（<a href="http://coolshell.cn/articles/11377.html）中的关于零长度的数组。" target="_blank" rel="external">http://coolshell.cn/articles/11377.html）中的关于零长度的数组。</a></p>
</blockquote>
<p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：</p>
<p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-06.png" alt="Block结构"></p>
<h3 id="u5BFB_u627E_u5408_u9002_u7684block"><a href="#u5BFB_u627E_u5408_u9002_u7684block" class="headerlink" title="寻找合适的block"></a>寻找合适的block</h3><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p>
<ul>
<li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li>
<li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li>
</ul>
<p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First fit */</span></span><br><span class="line"><span class="function">t_block <span class="title">find_block</span><span class="params">(t_block *last, size_t size)</span> </span>&#123;</span><br><span class="line">    t_block b = first_block;</span><br><span class="line">    <span class="keyword">while</span>(b &amp;&amp; !(b-&gt;<span class="built_in">free</span> &amp;&amp; b-&gt;size &gt;= size)) &#123;</span><br><span class="line">        *last = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到就返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p>
<h3 id="u5F00_u8F9F_u65B0_u7684block"><a href="#u5F00_u8F9F_u65B0_u7684block" class="headerlink" title="开辟新的block"></a>开辟新的block</h3><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BLOCK_SIZE <span class="number">24</span> <span class="comment">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, size_t s)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sbrk(BLOCK_SIZE + s) == (<span class="keyword">void</span> *)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(last)</span><br><span class="line">        last-&gt;next = b;</span><br><span class="line">    b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5206_u88C2block"><a href="#u5206_u88C2block" class="headerlink" title="分裂block"></a>分裂block</h3><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：</p>
<p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-07.png" alt="分裂block"></p>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_block</span><span class="params">(t_block b, size_t s)</span> </span>&#123;</span><br><span class="line">    t_block <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span> = b-&gt;data + s;</span><br><span class="line">    <span class="keyword">new</span>-&gt;size = b-&gt;size - s - BLOCK_SIZE ;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="malloc_u7684_u5B9E_u73B0"><a href="#malloc_u7684_u5B9E_u73B0" class="headerlink" title="malloc的实现"></a>malloc的实现</h3><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p>
<p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> align8(<span class="keyword">size_t</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s &amp; <span class="number">0x7</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> ((s &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>注：</em></p>
<ol>
<li><p><code>0x7</code>？<br>如果数是8的倍数，那么它的二进制表示的最后3位都是0，其实可以看作<code>任意数*8</code>(<code>1000</code>)。</p>
</li>
<li><p><code>((s &gt;&gt; 3) + 1) &lt;&lt; 3</code>？<br>有了第1条，这里为什么是3位就很清楚了。之所以加1，是因为右移了以后，那3位丢了，s可能会变小；加1实际上是在第4位加。</p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BLOCK_SIZE <span class="number">24</span></span></span><br><span class="line"><span class="keyword">void</span> *first_block=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* other functions... */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(size_t size)</span> </span>&#123;</span><br><span class="line">    t_block b, last;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line">    <span class="comment">/* 对齐地址 */</span></span><br><span class="line">    s = align8(size);</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">        <span class="comment">/* 查找合适的block */</span></span><br><span class="line">        last = first_block;</span><br><span class="line">        b = find_block(&amp;last, s);</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="comment">/* 如果可以，则分裂 */</span></span><br><span class="line">            <span class="keyword">if</span> ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                split_block(b, s);</span><br><span class="line">            b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 没有合适的block，开辟一个新的 */</span></span><br><span class="line">            b = extend_heap(last, s);</span><br><span class="line">            <span class="keyword">if</span>(!b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = extend_heap(<span class="literal">NULL</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(!b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        first_block = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="calloc_u7684_u5B9E_u73B0"><a href="#calloc_u7684_u5B9E_u73B0" class="headerlink" title="calloc的实现"></a>calloc的实现</h3><p>有了malloc，实现calloc只要两步：</p>
<ol>
<li>malloc一段内存</li>
<li>将数据区内容置为0</li>
</ol>
<p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(size_t number, size_t size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">size_t</span> s8, i;</span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(number * size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>) &#123;</span><br><span class="line">        s8 = align8(number * size) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s8; i++)</span><br><span class="line">            <span class="keyword">new</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>注：</em></p>
<ol>
<li><p><code>align8(number * size) &gt;&gt; 3</code>？<br>每8字节一组置0。</p>
</li>
<li><p><code>将内存区域强制看做size_t类型</code>？<br>结合1，以及在x86_64的系统中，sizeof(size_t)是8字节。</p>
</li>
</ol>
</blockquote>
<h3 id="free_u7684_u5B9E_u73B0"><a href="#free_u7684_u5B9E_u73B0" class="headerlink" title="free的实现"></a>free的实现</h3><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p>
<ol>
<li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li>
<li>如何解决碎片问题</li>
</ol>
<p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p>
<ul>
<li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li>
<li>这个地址确实是之前通过我们自己的malloc分配的</li>
</ul>
<p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p>
<p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_block *t_block;</span><br><span class="line"><span class="keyword">struct</span> s_block &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们定义检查地址合法性的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;  </span><br><span class="line">    tmp = p;</span><br><span class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valid_addr</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &gt; first_block &amp;&amp; p &lt; sbrk(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == (get_block(p))-&gt;ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>注：</em></p>
<ol>
<li>为何不直接与<code>data</code>的地址作比较，而是另外加入了一个指针指向<code>data</code>？</li>
</ol>
</blockquote>
<p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p>
<p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> s_block *t_block;</span><br><span class="line"><span class="keyword">struct</span> s_block &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block prev; <span class="comment">/* 指向上个块的指针 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>合并方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">fusion</span><span class="params">(t_block b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span>) &#123;</span><br><span class="line">        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;</span><br><span class="line">        b-&gt;next = b-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next)</span><br><span class="line">            b-&gt;next-&gt;prev = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>注：</em></p>
<ol>
<li>仅有<code>prev</code>有何不可？感觉这里没有必要做成双向链表。<br><strong>Update</strong>：不行。如果不是双向链表，那么没有办法知道，当前的block是不是最后一个block（这个block可能很大），也就没有办法释放它。</li>
</ol>
</blockquote>
<p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        b-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;<span class="built_in">free</span>)</span><br><span class="line">            b = fusion(b-&gt;prev);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next)</span><br><span class="line">            fusion(b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;prev)</span><br><span class="line">                b-&gt;prev-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                first_block = <span class="literal">NULL</span>;</span><br><span class="line">            brk(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="realloc_u7684_u5B9E_u73B0"><a href="#realloc_u7684_u5B9E_u73B0" class="headerlink" title="realloc的实现"></a>realloc的实现</h3><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_block</span><span class="params">(t_block src, t_block dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *sdata, *ddata;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; (i * <span class="number">8</span>) &lt; src-&gt;size &amp;&amp; (i * <span class="number">8</span>) &lt; dst-&gt;size; i++)</span><br><span class="line">        ddata[i] = sdata[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p>
<ul>
<li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li>
<li>如果新的size变小了，考虑split</li>
<li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li>
</ul>
<p>下面是realloc的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *p, size_t size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line">    t_block b, <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">void</span> *newp;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="comment">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</span><br><span class="line">        s = align8(size);</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;size &gt;= s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                split_block(b,s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 看是否可进行合并 */</span></span><br><span class="line">            <span class="keyword">if</span>(b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span></span><br><span class="line">                    &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) &#123;</span><br><span class="line">                fusion(b);</span><br><span class="line">                <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                    split_block(b, s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 新malloc */</span></span><br><span class="line">                newp = <span class="built_in">malloc</span> (s);</span><br><span class="line">                <span class="keyword">if</span> (!newp)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">new</span> = get_block(newp);</span><br><span class="line">                copy_block(b, <span class="keyword">new</span>);</span><br><span class="line">                <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">return</span>(newp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u9057_u7559_u95EE_u9898_u548C_u4F18_u5316"><a href="#u9057_u7559_u95EE_u9898_u548C_u4F18_u5316" class="headerlink" title="遗留问题和优化"></a>遗留问题和优化</h2><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p>
<ul>
<li>同时兼容32位和64位系统</li>
<li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li>
<li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li>
<li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li>
</ul>
<p>还有很多可能的优化，这里不一一赘述。下面附上一些参考文献，有兴趣的同学可以更深入研究。</p>
<h1 id="u5176_u5B83_u53C2_u8003"><a href="#u5176_u5B83_u53C2_u8003" class="headerlink" title="其它参考"></a>其它参考</h1><ol>
<li>这篇文章大量参考了<a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf" target="_blank" rel="external">A malloc Tutorial</a>，其中一些图片和代码直接引用了文中的内容，这里特别指出</li>
<li><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="external">Computer Systems: A Programmer’s Perspective, 2/E</a>一书有许多值得参考的地方</li>
<li>关于Linux的虚拟内存模型，<a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="external">Anatomy of a Program in Memory</a>是很好的参考资料，另外作者还有一篇<a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/" target="_blank" rel="external">How the Kernel Manages Your Memory</a>对于Linux内核中虚拟内存管理的部分有很好的讲解</li>
<li>对于真实世界的malloc实现，可以参考<a href="http://repo.or.cz/w/glibc.git/blob/HEAD:/malloc/malloc.c" target="_blank" rel="external">glibc的实现</a></li>
<li>本文写作过程中大量参考了<a href="http://www.wikipedia.org/" target="_blank" rel="external">维基百科</a>，再次感谢这个伟大的网站，并且呼吁大家在手头允许的情况下可以适当捐助维基百科，帮助这个造福人类的系统运行下去</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇是转自CodingLabs的文章，除了有原文的内容，我加入了自己的一些思考和理解。]]>
    
    </summary>
    
      <category term="c" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="malloc" scheme="http://chaomai.github.io/tags/malloc/"/>
    
      <category term="operating system" scheme="http://chaomai.github.io/tags/operating-system/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ Concurrency in Action (4) - Synchronizing Concurrent Operations]]></title>
    <link href="http://chaomai.github.io/2015/05/31/2015-2015-05-31-cpp-concurrency-in-action-4/"/>
    <id>http://chaomai.github.io/2015/05/31/2015-2015-05-31-cpp-concurrency-in-action-4/</id>
    <published>2015-05-31T05:26:54.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="C++_Concurrency_in_Action_4"><a href="#C++_Concurrency_in_Action_4" class="headerlink" title="C++ Concurrency in Action 4"></a>C++ Concurrency in Action 4</h1><h2 id="Waiting_for_an_event_or_other_condition"><a href="#Waiting_for_an_event_or_other_condition" class="headerlink" title="Waiting for an event or other condition"></a>Waiting for an event or other condition</h2><ol>
<li><p>一直检查某个flag（被mutex保护）</p>
<p> 消耗资源，被锁住的flag实际上并不能被其他线程访问。消耗资源导致了被等待的线程运行时得到的资源更少，使得等待时间更长。</p>
</li>
<li><p>condition variable</p>
<p> wait and notify</p>
</li>
<li><p><code>std::this_thread::sleep_for()</code></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_flag</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(m);</span><br><span class="line">    <span class="keyword">while</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lk.unlock();</span><br><span class="line">		<span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line">        lk.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> sleep前unlock，以便其他线程有机会获得lock。但是难以掌握sleep的时长。</p>
</li>
</ol>
<h3 id="Waiting_for_a_condition_with_condition_variables"><a href="#Waiting_for_a_condition_with_condition_variables" class="headerlink" title="Waiting for a condition with condition variables"></a>Waiting for a condition with condition variables</h3><ul>
<li><code>std::condition_variable</code>：和mutex一起用，为了提供合适的同步。</li>
<li><code>std::condition_variable_any</code></li>
</ul>
<p>mutex_like即可，但是通用是要付出占用空间、性能或所需资源上的代价的。除非需要额外的灵活度，否则i用前者。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;</span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(more_data_to_prepare()) &#123;</span><br><span class="line">        data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        data_queue.push(data);</span><br><span class="line">        data_cond.notify_one(); <span class="comment">//notify waiting thread</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">	    data_cond.wait(</span><br><span class="line">            lk, []&#123; <span class="keyword">return</span> !data_queue.empty(); &#125;);</span><br><span class="line">        data_chunk data=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();  <span class="comment">//不要在处理的时候（可能耗时）持有</span></span><br><span class="line">        process(data);</span><br><span class="line">        <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>wait()</code>，<code>mut</code>，predicate有什么关系？</p>
<p> thread wakes(notified by <code>notify_one()</code>) -&gt; lock mutex -&gt; check predicate；</p>
<blockquote>
<p>predicate false -&gt; unlock mutex -&gt; thread blocked or waiting；<br>predicate true -&gt; still leave mutex locked -&gt; return from <code>wait()</code>；</p>
</blockquote>
</li>
<li><p>为什么在<code>data_processing_thread()</code>要使用<code>std::unique_lock</code>？</p>
<p> 反过来考虑为什么不是<code>std::lock_guard</code>和<code>std::mutex</code>。</p>
<p> <code>std::lock_guard</code>直到销毁才会unlock，但是线程wait的时候，就隐式的进行了unlock。</p>
<p> <code>std::mutex</code>，<a href="http://stackoverflow.com/questions/13099660/c11-why-does-stdcondition-variable-use-stdunique-lock" target="_blank" rel="external">这里</a>从API设计的角度上解释了为什么不是。</p>
</li>
</ol>
<p>在调用<code>wait()</code>期间，predicate会在mutex locked的条件下，被检查任意多次。当且仅当predicate true， <code>wait()</code>立即返回。</p>
<p><strong>spurious wake</strong></p>
<p>当等待线程重新获取锁并检查条件时，如果它不直接响应另一个线程的notification（例如：你的predicate和共享的变量无关，另一个线程notify的时候，predicate就不会直接respond），这就是spurious wake。是有side effect的。</p>
<p><strong><code>notify_one()</code>和<code>notify_all()</code></strong></p>
<ul>
<li>当有多个线程wait同一个event的时候，<code>notify_one()</code>并不能保证哪个线程会被通知。</li>
<li>当有多个线程wait同一个event，并且所有线程都需要respond的时候，<code>notify_all()</code>会导致这些线程都去check predicate。</li>
</ul>
<h2 id="Waiting_for_one-off_events_with_futures"><a href="#Waiting_for_one-off_events_with_futures" class="headerlink" title="Waiting for one-off events with futures"></a>Waiting for one-off events with futures</h2><p><code>std::future</code>：provides a mechanism to access the result of asynchronous operations。</p>
<p>由<code>std::unique_ptr</code>和<code>std::shared_ptr</code>建立：</p>
<ol>
<li><p>unique futures：<code>std::future&lt;&gt;</code></p>
<ul>
<li>moveable only</li>
<li>其实例是唯一关联到与它关联事件的实例。</li>
<li>ownership可以在实例间transfer，但是有一个实例可以引用到特定异步操作的结果。</li>
</ul>
</li>
<li><p>shared futures：<code>std::shared_future&lt;&gt;</code></p>
<ul>
<li>copyable</li>
<li>其多个实例可以指向同一个事件。在这个情况下，所有的实例都会同时ready，都可以访问与事件关联的数据。</li>
<li>可以有多个实例引用到关联状态。</li>
</ul>
</li>
</ol>
<p>如果无关联的数据，用<code>std::future&lt;void&gt;</code>或<code>std::shared_future&lt;void&gt;</code>。</p>
<h3 id="Returning_values_from_background_tasks"><a href="#Returning_values_from_background_tasks" class="headerlink" title="Returning values from background tasks"></a>Returning values from background tasks</h3><p>可以用<code>std::async()</code>开始一个<strong>异步任务</strong>。<code>std::async()</code>返回一个<code>std::future</code>对象，这个对象最终将持有函数的返回值，用<code>std::future</code>的<code>get()</code>获得（线程会block到future ready）。</p>
<p>对<code>std::async()</code>提供参数类似于<code>std::thread</code>和<code>std::call_once</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> X &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">bar</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="keyword">auto</span> f1=<span class="built_in">std</span>::async(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">auto</span> f2=<span class="built_in">std</span>::async(&amp;X::bar,x,<span class="string">"goodbye"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Y &#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Y y;</span><br><span class="line"><span class="keyword">auto</span> f3=<span class="built_in">std</span>::async(Y(),<span class="number">3.141</span>);</span><br><span class="line"><span class="keyword">auto</span> f4=<span class="built_in">std</span>::async(<span class="built_in">std</span>::ref(y),<span class="number">2.718</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp;)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::async(baz,<span class="built_in">std</span>::ref(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f5=<span class="built_in">std</span>::async(move_only()); <span class="comment">//对于右值，std::move会被隐式的调用</span></span><br></pre></td></tr></table></figure>
<p><code>std::async()</code>的运行由实现决定（自己试了发现libstdc++6用的是<code>std::launch::deferred</code>），但也可以由参数（<code>std::launch</code>类型）指定。</p>
<ul>
<li><code>std::launch::deferred</code>：函数调用推迟到在future上调用<code>wait()</code>或<code>get()</code>。</li>
<li><code>std::launch::async</code>：函数在它自己的线程上运行。</li>
<li><code>std::launch::deferred | std::launch::async</code>：默认，视实现而定。</li>
</ul>
<p>如果函数调用推迟了，那么它可能再也不会实际执行。</p>
<p>通过修改参数并运行下面这段代码，来体会它们的区别，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">timer t; <span class="comment">//可以自己简单的实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; the_answer = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, []() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999999</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"futuring..."</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999999</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; the_answer.get() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现使用<code>std::launch::deferred</code>的时间，几乎是<code>std::launch::async</code>的两倍，这里就能很形象的感受<strong>defer</strong>。</p>
<h3 id="Associating_a_task_with_a_future"><a href="#Associating_a_task_with_a_future" class="headerlink" title="Associating a task with a future"></a>Associating a task with a future</h3><p><code>std::packaged_task&lt;&gt;</code>把一个函数或callable对象绑定到一个future，当<code>std::packaged_task&lt;&gt;</code>被调用的时候，它进而调用关联的函数或callable对象使得future ready，返回值作为关联数据储存。</p>
<p><code>std::packaged_task</code>不是copyable，但是moveable。</p>
<p><code>std::packaged_task</code>的模板参数是函数签名。构造实例时，传入的callable对象要能接受指定的参数，并且返回值类型可以转换到所指定的返回类型。也就是说不必100% match，但是至少也要保证可以隐式转换。</p>
<blockquote>
<ul>
<li>函数签名的返回值类型指定了从<code>get_future()</code>返回的<code>std::future</code>的类型。</li>
<li>函数签名的参数列表指定了，封装的任务的函数调用的签名。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> b) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999999</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; task(f);</span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; res = task.get_future();</span><br><span class="line"><span class="comment">//res.wait();  //waiting endlessly</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; res.get() &lt;&lt; std::endl;  //waiting endlessly</span></span><br><span class="line">task(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res.get() &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>上例中，在<code>task()</code>调用前，绑定的函数是没有执行的，因此这里无论是对future进行wait或是get，都是无限的等下去。</li>
<li>调用<code>task()</code>时，任务其实是在当前的线程中执行的，不会新建一个线程执行。</li>
</ul>
<h3 id="Making__28std_3A_3A_29promises"><a href="#Making__28std_3A_3A_29promises" class="headerlink" title="Making (std::)promises"></a>Making (std::)promises</h3><p><code>std::promise&lt;T&gt;</code>提供了一种设置值的方式，这个值可以稍后被关联的<code>std::future&lt;T&gt;</code>对象读取。等待线程会在future上block，提供数据的线程可以用promise的<code>set_value()</code>来设置值，使得future ready。如果没有设置值就销毁<code>std::promise</code>，那么exception将会被存储。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> b) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999999</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">p.set_value(f(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">auto</span> fu = p.get_future();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fu.get() &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<h3 id="Saving_an_exception_for_the_future"><a href="#Saving_an_exception_for_the_future" class="headerlink" title="Saving an exception for the future"></a>Saving an exception for the future</h3><ol>
<li><p><code>std::async</code></p>
<p> 就像直接调用函数一样，</p>
<blockquote>
<p>函数抛出exception -&gt; exception被存储在future中，替代所存储的值 -&gt; future ready -&gt; <code>get()</code>会再次抛出exception<br>但是<code>get()</code>抛出的exception是原始的对象或copy，标准没有规定。</p>
</blockquote>
</li>
<li><p><code>std::packaged_task</code></p>
<ul>
<li><p>类似<code>std::async</code>，</p>
<blockquote>
<p>调用task -&gt; 函数抛出exception -&gt; exception被存储在future中，替代所存储的值 -&gt; future ready -&gt; <code>get()</code>会再次抛出exception</p>
</blockquote>
</li>
<li><p>直接destory <code>std::packaged_task</code></p>
<blockquote>
<p>如果future没有ready -&gt; destructor存储<code>std::future_error</code> exception在关联的状态中。<br>error code = <code>std::future_errc::broken_promise</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>std::promise</code></p>
<ul>
<li><p>类似前两者，但是需要显式的函数调用。如果要存储的不是值，是exception，就要调用<code>set_exception()</code>。</p>
</li>
<li><p>通常在try/catch中使用，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">std</span>::promise&lt;<span class="keyword">double</span>&gt; some_promise;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    some_promise.set_value(calculate_value());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(...) &#123;</span><br><span class="line">    some_promise.set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">some_promise.set_exception(<span class="built_in">std</span>::copy_exception(<span class="built_in">std</span>::logic_error(<span class="string">"foo"</span>)));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上例使用了<code>std::current_exception()</code>来获取已引发的异常。还可以    用<code>std::copy_exception()</code>创建新的exception，在exception已知的情况下，这样更简洁。</p>
</blockquote>
</li>
<li><p>直接destroy <code>std::promise</code></p>
<blockquote>
<p>如果future没有ready -&gt; destructor存储<code>std::future_error</code> exception在关联的状态中。<br>error code = <code>std::future_errc::broken_promise</code></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><strong>关于destory <code>std::packaged_task</code>和<code>std::promise</code></strong></p>
<ul>
<li><code>std::packaged_task</code>是<code>std::promise</code>更高层次的抽象，所以直接destroy以后，它们的行为是很相似的。</li>
<li>创建了future，你就promise to provide一个值或exception，如果你摧毁了他们的来源，你就break了promise。如果destructor不存储<code>std::future_error</code> exception，等待future的线程就会一直等下去。</li>
</ul>
<h3 id="Waiting_from_multiple_threads"><a href="#Waiting_from_multiple_threads" class="headerlink" title="Waiting from multiple threads"></a>Waiting from multiple threads</h3><p>在多个线程中访问<code>std::future</code>会有data race和undefined behavior。</p>
<p>原因：</p>
<blockquote>
<p>by design. It models unique ownership of the asynchronous result。因此并发的访问的没意义的，<code>get()</code>只能被调用一次。</p>
</blockquote>
<ol>
<li><p><code>std::shared_future</code></p>
<p> 就算有<code>std::shared_future</code>，特定对象的成员函数还是不同步的，要使用lock来避免data race，或者在每个线程创建并访问自己的copy。</p>
<p> <img src="http://7vilyb.com1.z0.glb.clouddn.com/ccpashared_future.jpg" alt=""></p>
</li>
<li><p>构造<code>std::shared_future</code></p>
<p> 引用异步状态的<code>std::shared_future</code>实例是由引用了这些状态的<code>std::future</code>实例构造的。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f(p.get_future());</span><br><span class="line"><span class="comment">// f refers to asynchronous state of p</span></span><br><span class="line"><span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; sf(<span class="built_in">std</span>::move(f));</span><br><span class="line"><span class="comment">// 现在f是invalid</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; sf(p.get_future());</span><br><span class="line"><span class="keyword">auto</span> sf = p.get_future().share();  <span class="comment">// transfer ownership directly</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Waiting_with_a_time_limit"><a href="#Waiting_with_a_time_limit" class="headerlink" title="Waiting with a time limit"></a>Waiting with a time limit</h2><p>two sorts of timeouts:</p>
<ul>
<li>duration-based timeout</li>
<li>absolute timeout</li>
</ul>
<h3 id="Clocks"><a href="#Clocks" class="headerlink" title="Clocks"></a>Clocks</h3><ol>
<li><p><code>system_clock</code></p>
<p> Wall clock time from the system-wide real-time clock.</p>
<p> <code>std::chrono::system_clock::now()</code>返回系统当前时间，类型是<code>std::chrono::system_clock::time_point</code>。</p>
<p> 提供了与<code>time_t</code>类型相互转化的函数。</p>
</li>
<li><p><code>steady_clock</code></p>
<ul>
<li>Values of <code>time_point</code> never decrease as physical time advances;</li>
<li><p>Values of <code>time_point</code> advance at a steady rate relative to real time.</p>
<p>That is, the clock may not be adjusted.</p>
<p><code>is_steady</code>可以检测是否是。</p>
</li>
</ul>
</li>
<li><p><code>high_resolution_clock</code></p>
<p> Clocks with the shortest tick period. <code>high_resolution_clock</code> may be a synonym for <code>system_clock</code> or <code>steady_clock</code>.</p>
</li>
</ol>
<p><strong>the tick period of clock</strong></p>
<p>可由clock的<code>period</code>成员得到。例如：每秒25次 tick，则是<code>std::ratio&lt;1, 25&gt;</code>。</p>
<p>并不能够保证，$在一次运行中观察到的tick period=那个clock指定的period$。</p>
<h3 id="Durations"><a href="#Durations" class="headerlink" title="Durations"></a>Durations</h3><p><code>std::chrono::duration&lt;&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span><br><span class="line">  <span class="keyword">struct</span> duration</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">typedef</span> _Rep			rep; <span class="comment">// the type of representation</span></span><br><span class="line"><span class="keyword">typedef</span> _Period 		period;  <span class="comment">// 指定duration的每个unit代表多长时间</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>标准库预定义了很多种durations：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, nano&gt; 	    nanoseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, micro&gt; 	    microseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, milli&gt; 	    milliseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>&gt; 		    seconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, ratio&lt; <span class="number">60</span>&gt;&gt;   minutes;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, ratio&lt;<span class="number">3600</span>&gt;&gt;  hours;</span><br></pre></td></tr></table></figure>
<p>它们都使用足够大的整数类型。当然也可以使用预定义的ratio或自己定义的来定义新的duration。</p>
<p>当不会发生截断的时候，durations之间的转换是隐式的。显示的转换可用<code>duration_cast</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::chrono::seconds s=</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(ms);</span><br><span class="line"><span class="comment">//截断，而非四舍五入，s=54</span></span><br></pre></td></tr></table></figure>
<p>durations可以与一个常数（<code>_Rep</code>类型的）进行加减乘除。</p>
<p>在一个duration中，要知道units的数目，可以调用<code>count()</code>。</p>
<p><strong>基于duration的wait</strong></p>
<p>之前提到的所有的blocking call都是block一个不确定长度的时间。</p>
<p>当你将duration用于wait，wait会返回一个状态，来标识是超时，还是其他情况。</p>
<ul>
<li><code>std::future_status::timeout</code>：the wait times out</li>
<li><code>std::future_status::ready</code>：the future is ready</li>
<li><code>std::future_status::deferred</code>：the future is deferred</li>
</ul>
<p>基于duration的wait的时间是通过一个内部的steady clock来衡量的，但是因为调度，或者精度的原因，实际等待的时间可能会略长。</p>
<h3 id="Time_points"><a href="#Time_points" class="headerlink" title="Time points"></a>Time points</h3><p><code>std::chrono::time_points&lt;&gt;</code>：存储了从clock的epoch开始的时长（某个duration的倍数）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Clock, <span class="keyword">typename</span> _Dur&gt;</span><br><span class="line">  <span class="keyword">struct</span> time_point</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">typedef</span> _Clock		clock; <span class="comment">// clock的类型</span></span><br><span class="line"><span class="keyword">typedef</span> _Dur		duration;  <span class="comment">// 度量从epoch开始的时间</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>对于一个time point，<code>time_since_epoch()</code>返回了从clock的epoch，到那个time point的时长。</p>
<ul>
<li>可以将duration与time point相加减，得到新的time point。</li>
<li>可以将两个share same clock的time point相减，得到duration。</li>
</ul>
<p><strong>基于time point的wait</strong></p>
<p>在condition variable中，如果不想向<code>wait()</code>传入一个predicate，那么最好是使用<code>wait_until()</code>，这样循环的总长度（看4.1.1）有限的。</p>
<h3 id="Functions_that_accept_timeouts"><a href="#Functions_that_accept_timeouts" class="headerlink" title="Functions that accept timeouts"></a>Functions that accept timeouts</h3><table>
<thead>
<tr>
<th>Class/Namespace</th>
<th>Functions</th>
<th>Return values</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::this_thread</code> namespace</td>
<td><code>sleep_for(duration)</code>, <code>sleep_until(time_point)</code></td>
<td>N/A</td>
</tr>
<tr>
<td><code>std::condition_variable</code> or <code>std::condition_variable_any</code></td>
<td><code>wait_for(lock, duration)</code>, <code>wait_until(lock, time_point)</code></td>
<td><code>std::cv_status::timeout</code> or <code>std::cv_status::no_timeout</code></td>
</tr>
<tr>
<td></td>
<td><code>wait_for(lock, duration, predicate)</code>, <code>wait_until(lock, time_point, predicate)</code></td>
<td>bool—the return value of the predicate when awakened</td>
</tr>
<tr>
<td><code>std::timed_mutex</code> or <code>std::recursive_ timed_mutex</code></td>
<td><code>try_lock_for(duration)</code>, <code>try_lock_until(time_point)</code></td>
<td>bool—true if the lock was acquired, false otherwise</td>
</tr>
<tr>
<td><code>std::unique_ lock&lt;TimedLockable&gt;</code></td>
<td><code>unique_lock(lockable, duration)</code>, <code>unique_lock(lockable, time_point)</code></td>
<td>N/A—<code>owns_lock()</code> on the newly constructed object; returns true if the lock was acquired, false otherwise</td>
</tr>
<tr>
<td></td>
<td><code>try_lock_for(duration)</code>, <code>try_lock_until(time_point)</code></td>
<td>bool—true if the lock was acquired, false otherwise</td>
</tr>
<tr>
<td><code>std::future&lt;ValueType&gt;</code> or <code>std::shared_ future&lt;ValueType&gt;</code></td>
<td><code>wait_for(duration)</code>, <code>wait_until (time_point)</code></td>
<td><code>std::future_status::timeout</code> if the wait timed out, <code>std::future_ status::ready</code> if the future is ready, or <code>std::future_status::deferred</code> if the future holds a deferred function that hasn’t yet started</td>
</tr>
</tbody>
</table>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="http://stackoverflow.com/questions/13263277/difference-between-stdsystem-clock-and-stdsteady-clock" target="_blank" rel="external">Difference between std::system_clock and std::steady_clock?</a></li>
<li>C++ Concurrency in Action</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Synchronizing concurrent operations的笔记。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://chaomai.github.io/tags/c-11/"/>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ Concurrency in Action (3) - Sharing Data Between Threads]]></title>
    <link href="http://chaomai.github.io/2015/05/30/2015-2015-05-30-cpp-concurrency-in-action-3/"/>
    <id>http://chaomai.github.io/2015/05/30/2015-2015-05-30-cpp-concurrency-in-action-3/</id>
    <published>2015-05-30T14:37:23.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="C++_Concurrency_in_Action_3"><a href="#C++_Concurrency_in_Action_3" class="headerlink" title="C++ Concurrency in Action 3"></a>C++ Concurrency in Action 3</h1><h2 id="Problems_with_sharing_data_between_threads"><a href="#Problems_with_sharing_data_between_threads" class="headerlink" title="Problems with sharing data between threads"></a>Problems with sharing data between threads</h2><p>在同一进程中，线程间的数据共享，不仅仅是便捷，还可能造成问题。</p>
<p>线程间共享数据的问题，全都可以归结到修改数据的顺序。</p>
<ul>
<li>如果所有数据都是只读的，那么不会有任何问题。</li>
<li>如果一个或多个线程修改它们之间共享的数据，现在的问题可能就会出现。</li>
</ul>
<p><strong>Invariant</strong>（不变条件）：关于某个特定的数据结构，始终为真的与君。</p>
<p>但是在多个线程修改共享数据时，invariant会被broken。</p>
<h3 id="Race_conditions"><a href="#Race_conditions" class="headerlink" title="Race conditions"></a>Race conditions</h3><p>并发中最常见的导致问题的原因。出现在两个或多个线程的执行结果依赖于相对的执行顺序。在某些情况下，race condition是无害的，但是如果race condition使得broken invariant，这将会导致问题。C++标准定义了一种特别的race condition - data race（由于并发的修改同一个对象），data race将会导致undefined behavior。</p>
<p>problematic race condition常常出现在完成一个操作需要修改两处或多处不同的数据。在一个线程正在修改数据，另一个可能在未修改完的时候就访问数据。</p>
<p>由于race condition是timing sensitive的，因此在debug的时候，debugger会影响程序的timing，问题就不会再现。</p>
<h3 id="Avoiding_problematic_race_conditions"><a href="#Avoiding_problematic_race_conditions" class="headerlink" title="Avoiding problematic race conditions"></a>Avoiding problematic race conditions</h3><ul>
<li>用某种保护机制来包装数据结构。</li>
</ul>
<blockquote>
<p>只有实际进行修改的线程才能看到invariants are broken的中间状态。</p>
</blockquote>
<ul>
<li>修改数据结构和invariants的设计，使得修改在一系列隐形的changes下完成，每个change可以保证invariants。</li>
</ul>
<blockquote>
<p>这一般指的就是lock-free。</p>
</blockquote>
<ul>
<li>将对数据结构的update作为transaction。</li>
</ul>
<blockquote>
<p>这就是software transactional memory（STM）。</p>
</blockquote>
<h2 id="Protecting_shared_data_with_mutexes"><a href="#Protecting_shared_data_with_mutexes" class="headerlink" title="Protecting shared data with mutexes"></a>Protecting shared data with mutexes</h2><p>mutex（mutual exclusion）：synchronization primitive。线程库保证一旦某个线程已经lock了某个mutex，其他所有尝试lock同一个mutex的线程，都必须等到那个成功lock这个mutex的线程unlock它。</p>
<p>这可以保证每个线程看到的都是self-consistent view的共享数据，避免broken invariant。</p>
<p>但mutex<strong>不是</strong>silver bullet！</p>
<h3 id="Using_mutexes_in_C++"><a href="#Using_mutexes_in_C++" class="headerlink" title="Using mutexes in C++"></a>Using mutexes in C++</h3><p>通过构造<code>std::mutex</code>的实例来创建一个mutex。</p>
<p>不推荐直接调用<code>std::mutex</code>的成员函数，尤其是<code>unlock()</code>。因为你必须在每段代码执行的尾部，包括异常中，都要记得unlock。<code>std::lock_guard</code>以<strong>RAII</strong>的方式来对mutex提供支持，在构造的时候lock，析构的时候unlock。</p>
<p>用类来封装。</p>
<h3 id="Structuring_code_for_protecting_shared_data"><a href="#Structuring_code_for_protecting_shared_data" class="headerlink" title="Structuring code for protecting shared data"></a>Structuring code for protecting shared data</h3><p>如果类的成员函数返回了指向受保护数据的指针或引用，那岂不就是开了后门？</p>
<p>那么是不是禁止返回指向受保护数据的指针或引用就ok了？</p>
<p>还有一个没有考虑到的就是，不要向那些不在你控制下的被调用函数，传入指向受保护数据的指针或引用。</p>
<blockquote>
<p>Don’t  pass  pointers  and  references  to  protected  data  outside  the  scope  of  the  lock,  whether  by returning them from a function, storing them in externally visible memory, or passing them as arguments to user-supplied functions.</p>
</blockquote>
<h3 id="Spotting_race_conditions_inherent_in_interfaces"><a href="#Spotting_race_conditions_inherent_in_interfaces" class="headerlink" title="Spotting race conditions inherent in interfaces"></a>Spotting race conditions inherent in interfaces</h3><p>考虑一个双向链表，如果要使得一个删除操作是线程安全的，那么要必须保证避免并发的访问三个结点（要删除的和两边的）。但这并不足以避免race condition，到目前为止，只能采用避免并发的访问整个list。</p>
<p>看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">stack</span>&amp;&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就算让<code>top()</code>返回copy，而不是reference，这个接口还是有race conditions。这并不是基于mutex的实现独有的问题，基于lock-free的实现也会有，这是接口设计的问题。</p>
<p>上例中，<code>empty()</code>和<code>top()</code>是不可靠的，因为在调用<code>empty()</code>或<code>size()</code>的线程使用它们返回的值之前，stack可能已经被其他线程改变了（可能已经empty），这时再去<code>top()</code>，stack已经不是调用<code>empty()</code>或<code>size()</code>时候的stack了。而在stack内使用mutex仅仅只能保证同一时刻，只有一个线程运行stack的成员函数，而这并不能解决这样的问题。</p>
<p>还有一个类似的问题是，<code>top()</code>和<code>pop()</code>之间，stack也有可能被修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">if</span>(!s.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> value=s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    do_something(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或许你觉得可以合并<code>top()</code>和<code>pop()</code>，但是<code>std::stack</code>这样分开设计不是没有理由的，简单来说，如果分开了，在return的时候，系统资源不足，copy构造函数失败，造成已经pop了，但是元素丢失（因为没有return成功）。</p>
<p>但是，比较头疼的是，要消除race condition就是要避免这样的分开设计（lock的粒度太小，mutex不能保护整个操作），进而避免上例中，不同线程的interleave。</p>
<p><strong>解法1：PASS IN A REFERENCE</strong></p>
<p>缺陷：</p>
<ul>
<li>不实用，构造一个实例需要额外的时间或资源。</li>
<li>不总是可用，构造函数所需要的参数不是时时可以获得的。</li>
<li>需要类型可赋值，但是赋值不总是可用的，尤其是自定义的类型。</li>
</ul>
<p><strong>解法2：REQUIRE A NO-THROW COPY CONSTRUCTOR OR MOVE CONSTRUCTOR</strong></p>
<p>There’s only an exception safety problem with a value-returning pop() if the return by value can throw an exception.</p>
<p>缺陷：</p>
<ul>
<li>限制只让那些有不抛出异常的构造函数或move构造函数的的类型使用stack，虽然可行，但是不通用。</li>
</ul>
<p><strong>解法3：RETURN A POINTER TO THE POPPED ITEM</strong></p>
<p>优势：</p>
<ul>
<li>pointer可以被自由的copy，而不抛出异常。</li>
</ul>
<p>缺陷：</p>
<ul>
<li>普通的方式需要管理分配给对象的内存，内存管理的开销可能还大于return by value。</li>
</ul>
<p>如果要使用，<code>std::shared_ptr</code>值得考虑，可以避免很多<code>new</code>和<code>delete</code>。</p>
<p><strong>解法 4：PROVIDE BOTH OPTION 1 AND EITHER OPTION 2 OR 3</strong></p>
<p>万金油，糅合1，2或1，3，要用什么，给用户自己选择。</p>
<p><strong>EXAMPLE DEFINITION OF A THREAD-SAFE STACK</strong></p>
<ul>
<li>在接口中没有race condition，并糅合了1、3；</li>
<li>不可赋值，可copy（假设元素可copy）；</li>
<li>stack为空时，<code>pop()</code>抛出异常，但是stack仍然可以工作；</li>
<li>简化的操作，使得数据得到了更好的控制，可以保证在每个操作中，mutex都是locked；</li>
<li>对<code>std::stack</code>进行了包装；</li>
<li>可以加入copy的支持，只要copy的时候lock mutex即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> empty_stack: <span class="built_in">std</span>::exception &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    threadsafe_stack()&#123;&#125;</span><br><span class="line">    threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp; other) &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(other.m);</span><br><span class="line">        data=other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">        data.push(new_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; pop() &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack();  </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="function"><span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data.top()</span>))</span>;</span><br><span class="line">        data.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">        value=data.top();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">        <span class="keyword">return</span> data.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>为什么m是mutable？</strong></p>
<p><code>empty()</code>后跟const，说明<code>empty()</code>不能修改类的成员，除非成员被设置为mutable。</p>
<p><strong>Granularity</strong></p>
<p>细粒度（fine-grained）锁会导致保护不完全，锁的粒度太大会导致并发失去意义。</p>
<p>有时细粒度锁意味着需要多个mutex，而这可能会导致deadlock。</p>
<h3 id="Deadlock_uFF1Athe_problem_and_a_solution"><a href="#Deadlock_uFF1Athe_problem_and_a_solution" class="headerlink" title="Deadlock：the problem and a solution"></a>Deadlock：the problem and a solution</h3><p>如果有两个mutex，那么总是以同样的顺序lock mutex就不会死锁 了。但是有时以同样的顺序lock mutex并不能满足需求。</p>
<p><code>std::lock</code>：可以一次性锁住两个或多个mutex，而不会deadlock。但是如果分别获得lock，它并不能保证不死锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> some_big_object;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="keyword">class</span> X &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(some_big_object <span class="keyword">const</span>&amp; sd):some_detail(sd)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">std</span>::lock(lhs.m,rhs.m);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock_a(lhs.m,<span class="built_in">std</span>::adopt_lock);</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock_b(rhs.m,<span class="built_in">std</span>::adopt_lock);  </span><br><span class="line">        swap(lhs.some_detail,rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上例中有这么几个要注意的地方：</p>
<p><strong>为什么要检查是否是不同的实例？</strong></p>
<p><code>std::lock</code>做了这么一个事情：</p>
<blockquote>
<p>Locks the given Lockable objects lock1, lock2, …, lockn using a deadlock avoidance algorithm to avoid deadlock. The objects are locked by an unspecified series of calls to lock, try_lock, unlock. If a call to lock or unlock results in an exception, unlock is called for any locked objects before rethrowing.</p>
</blockquote>
<p>换句话说，作为参数的几个mutex都会被an unspecified series of calls to lock, try_lock, unlock一遍。</p>
<p>要注意的是，必须是<a href="http://en.cppreference.com/w/cpp/concept/Lockable" target="_blank" rel="external">Lockable objects</a>。</p>
<p>对于已经在外部lock的lockables，deadlock是无法保证不发生的。</p>
<p>如果某个mutex是locked，deadlock是不能够保证会避免的。</p>
<p><strong><code>std::adopt_lock</code>是什么鬼？</strong></p>
<p>constexpr（常量表达式），tag type used to specify locking strategy 。其中std::adopt_lock：assume the calling thread already has ownership of the mutex。也就是说告诉<code>std::lock_guard</code>，给你的mutex已经锁上了，你就不要再lock一次了。</p>
<p>下面是<code>std::lock_guard</code>的构造函数的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; __m)</span> : _<span class="title">M_device</span><span class="params">(__m)</span></span><br><span class="line"></span>&#123; _M_device.lock(); &#125;</span><br><span class="line"></span><br><span class="line">lock_guard(mutex_type&amp; __m, <span class="keyword">adopt_lock_t</span>) : _M_device(__m)</span><br><span class="line">&#123; &#125; <span class="comment">// calling thread owns mutex</span></span><br></pre></td></tr></table></figure>
<p>可以很明确的看出使用了<code>adopt_lock_t</code>后，<code>std::lock_guard</code>并没有去lock。</p>
<p><strong>会不会抛出异常？什么地方会？抛出会怎样？</strong></p>
<p>比较可能会，如果抛出，函数就退出了，不会进行swap；<br><code>std::lock</code>可能会（确切的说是，<code>std::lock</code>内部<code>lock lhs.m</code>或<code>rhs.m</code>的时候可能会，接着异常会传出<code>std::lock</code>），如果抛出，函数就退出了，不会进行swap；<br>构造<code>lock_guard</code>不会，标准规定的。</p>
<p><code>std::lock</code>不万能，如果分别获得lock，它并不能保证不deadlock。</p>
<h3 id="Further_guidelines_for_avoiding_deadlock"><a href="#Further_guidelines_for_avoiding_deadlock" class="headerlink" title="Further guidelines for avoiding deadlock"></a>Further guidelines for avoiding deadlock</h3><p>deadlock不仅仅出现在有lock的时候，也不局限于两个线程。</p>
<p>避免deadlock的方法可以归结为：不要等待一个可能等待你的线程。</p>
<p>下面的准则能检查并消除，有其他线程等待你的可能性。</p>
<p><strong>AVOID NESTED LOCKS</strong></p>
<p>如果需要多个lock，用<code>std::lock</code>。</p>
<p><strong>AVOID CALLING USER-SUPPLIED CODE WHILE HOLDING A LOCK</strong></p>
<p>用户提供的代码可能会请求另一个lock，进而违反上一个准则。</p>
<p><strong>ACQUIRE LOCKS IN A FIXED ORDER</strong></p>
<p>如果要获取两个或更多的lock，并且不能使用<code>std::lock</code>一次性获取，次优的方案是在每个线程中以同样的顺序获取。the key is to define the order in a way that’s consistent between threads.</p>
<p><strong>USE A LOCK HIERARCHY</strong></p>
<p>lock hierarchy提供了一种方法，可以在运行时检查是否遵循lock oerding。如果一段代码已经获得了低层的lock，那么它不允许获得高层的lock。本质上就是为了保证获取lock的顺序。但是这种lock的机制，要求chain中每个mutex的hierarchy value都比前一个低，可能在某些情况下并不实用。</p>
<p>下面是一个hierarchical mutex的例子，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> hierarchical_mutex &#123;</span><br><span class="line">  <span class="built_in">std</span>::mutex internal_mutex;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hierarchy_value;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> previous_hierarchy_value;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (this_thread_hierarchy_value &lt;= hierarchy_value) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"mutex hierarchy violated"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    previous_hierarchy_value = this_thread_hierarchy_value;</span><br><span class="line">    this_thread_hierarchy_value = hierarchy_value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span> :</span><br><span class="line">      <span class="title">hierarchy_value</span><span class="params">(value)</span>,</span><br><span class="line">      <span class="title">previous_hierarchy_value</span><span class="params">(<span class="number">0</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation();</span><br><span class="line">    internal_mutex.lock();</span><br><span class="line">    update_hierarchy_value();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    this_thread_hierarchy_value = previous_hierarchy_value;</span><br><span class="line">    internal_mutex.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation();</span><br><span class="line">    <span class="keyword">if</span> (!internal_mutex.try_lock())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    update_hierarchy_value();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> hierarchical_mutex::this_thread_hierarchy_value(ULONG_MAX);</span><br></pre></td></tr></table></figure>
<p>有这么几个要注意的地方：</p>
<p><strong><code>thread_local</code></strong></p>
<p>这个是这段代码的关键。<code>thread_local</code>变量允许你在每个线程中都有一个独立的实例。在namespace的变量、类的static data member和局部变量都可以被声明为<code>thread_local</code>，并且拥有thread storage duration。</p>
<p>{ %blockquote% }<br>When thread_local is applied to a variable of block scope, the storage-class-specifier static is implied if it does not appear explicitly.<br>{ %endblockquote% }</p>
<p>因此上例中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;</span><br></pre></td></tr></table></figure>
<p>又因为，C++规定const静态类成员可以直接初始化，其他非const的静态类成员需要在类声明以外初始化，所以有最后的初始化。</p>
<p><strong>一个线程有多个mutex的情况下，<code>thread_local</code>变量是共享的？</strong></p>
<p>是的，因为它属于类，而不是某个对象。</p>
<p><strong>三个value会不会在多个线程并发时，出现interleaving修改？</strong></p>
<p>不会，修改是在internal mutex的lock和unlock之间。</p>
<p>hierarchy mutex本质上说的还是lock的order，其目的就是为了避免多个线程中出现wait cycle，hierarchy mutex是把这种order强制化了。</p>
<h3 id="Flexible_locking_with_std_3A_3Aunique_lock"><a href="#Flexible_locking_with_std_3A_3Aunique_lock" class="headerlink" title="Flexible locking with std::unique_lock"></a>Flexible locking with std::unique_lock</h3><p><code>std::unique_lock</code>提供了比<code>std::lock_guard</code>更多的灵活度（构造函数的可传入：<code>std::defer_lock</code>、<code>std::try_to_lock</code>和<code>std::adopt_lock</code>），并且不总是拥有mutex的ownership（locked）。但这两者是有代价的，<code>std::unique_lock</code>要占用更多的空间，并且稍微慢一点点，这个可以用源码看出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">    unique_lock(mutex_type&amp; __m, <span class="keyword">defer_lock_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    : _M_device(&amp;__m), _M_owns(<span class="literal">false</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    unique_lock(mutex_type&amp; __m, <span class="keyword">try_to_lock_t</span>)</span><br><span class="line">    : _M_device(&amp;__m), _M_owns(_M_device-&gt;try_lock())</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    unique_lock(mutex_type&amp; __m, <span class="keyword">adopt_lock_t</span>)</span><br><span class="line">    : _M_device(&amp;__m), _M_owns(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// <span class="label">XXX calling thread owns mutex</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    mutex_type* _M_device;</span><br><span class="line">    <span class="keyword">bool</span> _M_owns; <span class="comment">// <span class="label">XXX use atomic_bool</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p><code>std::unique_lock</code>需要flag，<code>_M_owns</code>来存储mutex的ownership，在unlock、析构等时候，需要根据flag来判断是否要forward to<code>_M_device</code>的成员函数来做实际的工作。flag可以通过<code>std::unique_lock</code>的<code>owns_lock()</code>来获得。</p>
<p><code>std::unique_lock</code>还允许在实例销毁前释放lock，这样就可以在明确知道不再需要lock的时候，进行release，而不必等到销毁时，避免了其他线程额外的等待。</p>
<p>一般来说推荐使用<code>std::lock_gurad</code>，但是如果需要额外的灵活度，那就用<code>std::unique_lock</code>，例如：</p>
<ul>
<li>延迟锁</li>
<li>Transfer ownership of lock</li>
</ul>
<h3 id="Transferring_mutex_ownership_between_scopes"><a href="#Transferring_mutex_ownership_between_scopes" class="headerlink" title="Transferring mutex ownership between scopes"></a>Transferring mutex ownership between scopes</h3><p>Because <code>std::unique_lock</code> instances don’t have to own their associated mutexes, the ownership of a mutex can be transferred between instances by moving the instances around.</p>
<p><code>std::unique_lock</code>是movable，但不是copyable的。</p>
<p>其中一个应用是返回一个lock，来transfer ownership给调用函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; get_lock() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(some_mutex);</span><br><span class="line">    prepare_data();</span><br><span class="line">    <span class="keyword">return</span> lk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(get_lock());</span><br><span class="line">    do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Locking_at_an_appropriate_granularity"><a href="#Locking_at_an_appropriate_granularity" class="headerlink" title="Locking at an appropriate granularity"></a>Locking at an appropriate granularity</h3><p>lock的粒度是用来描述被一个锁保护的数据的数量。</p>
<p>如果可能，只有在真正访问共享数据的时候才lock a mutex。</p>
<p>一般来说，不要在拥有锁的时候做耗时的工作，尤其是等待其他的lock（就算知道不会deadlock），或者文件I/O（除非真的是需要保护文件的访问）。</p>
<p><code>std::unique_lock</code>很适合用于这样的情况，因为你可以在不需要访问共享数据的时候<code>unlock()</code>，需要的时候<code>再lcok()</code>。</p>
<p><strong>关于lock的粒度和拥有锁的时长</strong></p>
<ol>
<li>如果只有一个mutex来保护整个数据结构，那么不仅仅很可能会出现更多的竞争，而且减少了lock被held的时间。</li>
<li>对于同一个mutex，如果获得lock以后进行的操作越多，那么lock就会被held越长。</li>
</ol>
<p>找到一个合适的粒度，不仅仅要看锁住的数据的数量，还要看lock被获得的时长和获得lock的时候做了什么操作。In general, a lock should be held for only the minimum possible time needed to perform the required operations.</p>
<p>还有一个问题就是，由于改变了lock的方式，可能会导致代码语义上的改变，有时这样的改变会导致错误。</p>
<h2 id="Alternative_facilities_for_protecting_shared_data"><a href="#Alternative_facilities_for_protecting_shared_data" class="headerlink" title="Alternative facilities for protecting shared data"></a>Alternative facilities for protecting shared data</h2><p>在特殊情况下，有一些比mutex更合适的方式来保护共享数据。</p>
<h3 id="Protecting_shared_data_during_initialization"><a href="#Protecting_shared_data_during_initialization" class="headerlink" title="Protecting shared data during initialization"></a>Protecting shared data during initialization</h3><p>有时候可能共享数据在创建以后就是只读的，因此只需要在创建的时候进行保护。但是如果使用mutex，仅仅在初始化的时候保护，这是不必要的，并且还会带来不必要的性能损失。</p>
<p><strong>Double-Checked Locking</strong></p>
<p>最早接触<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="external">DCL</a>是在设计模式里，单例模式提到过。这个看似高效的方法之所以被骂，就是因为CPU乱序执行可能会导致线程访问没有初始化的对象。</p>
<p>在这里也是类似的，也会带来问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undefined_behaviour_with_double_checked_locking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resource_ptr) &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(resource_mutex);</span><br><span class="line">        <span class="keyword">if</span>(!resource_ptr) &#123;</span><br><span class="line">            resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种类型的race condition叫做data race，是undefined behavior。</p>
<p><strong>lazy initialization with <code>std::once_flag</code>和<code>std::call_once</code></strong></p>
<p><code>std::call_once</code>通常比显式使用mutex会有更低的开销，尤其是当初始化已经完成的时候。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="built_in">std</span>::once_flag resource_flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(resource_flag,init_resource);</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当初始化函数是带有函数调用操作符的类的实例的时候，<code>std::call_once</code>也支持像<code>std::thread</code>和<code>std::bind()</code>的用法。</p>
<p>要注意的是，如果类的成员含有不能copy或move的，那么要为它们定义特殊成员函数。</p>
<p><strong>static</strong></p>
<p>C++11中，规范了在多线程的情况下初始化static变量。初始化被定义为只发生在一个线程上，直到初始化完成其他线程才能继续。</p>
<p>这可以作为<code>std::call_once</code>的替代。</p>
<h3 id="Protecting_rarely_updated_data_structures"><a href="#Protecting_rarely_updated_data_structures" class="headerlink" title="Protecting rarely updated data structures"></a>Protecting rarely updated data structures</h3><p>用mutex来保护较少更新的数据结构不合适，当没有进行更新的时候，它消除了并发读的可能。</p>
<p><strong>reader-writer mutex</strong></p>
<p>允许：</p>
<ol>
<li>互斥的写或共享；</li>
<li>并发的的读。</li>
</ol>
<p>C++标准库没有提供这种锁，这里使用的是boost库。这种锁不是万能的，它的性能依赖于处理器的数量和读写线程相对的工作负载。</p>
<p><strong><code>boot::shared_mutex</code></strong></p>
<p>由boost提供。</p>
<h3 id="Recursive_locking"><a href="#Recursive_locking" class="headerlink" title="Recursive locking"></a>Recursive locking</h3><p>可以在同一个线程中从同一个<code>std::recursive_lock</code>的实例获得多次lock。在其他线程获得lock前，当前线程<code>lock()</code>了多少次，就必须<code>unlock()</code>多少次。</p>
<p>但是并不建议使用<code>std::recursive_lock</code>，当持有lock的时候，invariant很可能是broke的。继续lock，意味着要在invariant broken的情况下做操作。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="http://stackoverflow.com/questions/18047413/is-this-an-exception-safe-implementation-of-swapmultithread" target="_blank" rel="external">Is this an exception safe implementation of swap(multithread)?</a></li>
<li><a href="http://stackoverflow.com/questions/22794382/are-c11-thread-local-variables-automatically-static" target="_blank" rel="external">Are C++11 thread_local variables automatically static?</a></li>
<li><a href="http://en.cppreference.com/w/cpp/concept/Lockable" target="_blank" rel="external">C++ concepts: Lockable</a></li>
<li><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization" target="_blank" rel="external">双重检查锁定与延迟初始化</a></li>
<li>C++ Concurrency in Action</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Sharing data between threads的笔记。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://chaomai.github.io/tags/c-11/"/>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[转 - 字符集和字符编码]]></title>
    <link href="http://chaomai.github.io/2015/05/27/2015-2015-05-27-reproduce-character-encoding/"/>
    <id>http://chaomai.github.io/2015/05/27/2015-2015-05-27-reproduce-character-encoding/</id>
    <published>2015-05-27T14:20:14.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><br><br>原文：<a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="external">十分钟搞清字符集和字符编码</a><br><br></blockquote>

<h2 id="u5B57_u7B26_u96C6"><a href="#u5B57_u7B26_u96C6" class="headerlink" title="字符集"></a>字符集</h2><p>字符集就规定了某个文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。</p>
<h2 id="u5B57_u7B26_u7F16_u7801"><a href="#u5B57_u7B26_u7F16_u7801" class="headerlink" title="字符编码"></a>字符编码</h2><p>字符集只是一个规则集合的名字，对应到真实生活中，字符集就是对某种语言的称呼。</p>
<p>对于一个字符集来说要正确编码转码一个字符需要三个关键元素：字库表（character repertoire）、编码字符集（coded character set）、字符编码（character encoding form）</p>
<h3 id="u5B57_u5E93_u8868"><a href="#u5B57_u5E93_u8868" class="headerlink" title="字库表"></a>字库表</h3><p>一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。</p>
<h3 id="u7F16_u7801_u5B57_u7B26_u96C6"><a href="#u7F16_u7801_u5B57_u7B26_u96C6" class="headerlink" title="编码字符集"></a>编码字符集</h3><p>用一个编码值<strong>code point</strong>来表示一个字符在字库中的位置。</p>
<h3 id="u5B57_u7B26_u7F16_u7801-1"><a href="#u5B57_u7B26_u7F16_u7801-1" class="headerlink" title="字符编码"></a>字符编码</h3><p>将编码字符集和实际存储数值之间的转换关系。</p>
<p>一般来说都会直接将code point的值作为编码后的值直接存储。例如在ASCII中<code>A</code>在表中排第65位，而编码后<code>A</code>的数值是<code>0100 0001</code>也即十进制的65的二进制转换结果。</p>
<ul>
<li>为什么还要多此一举通过字符编码把序号转换成另外一种存储格式？</li>
</ul>
<p>统一字库表的目的是为了能够涵盖世界上所有的字符，但实际使用过程中会发现真正用的上的字符相对整个字库表来说比例非常低。而如果把每个字符都用字库表中的序号来存储的话，每个字符就需要3个字节（这里以Unicode字库为例），这样对于原本用仅占一个字符的ASCII编码的英语地区国家显然是一个额外成本（存储体积是原来的三倍）。于是就出现了UTF-8这样的变长编码。在UTF-8编码中原本只需要一个字节的ASCII字符，仍然只占一个字节。而像中文及日语这样的复杂字符就需要2个到3个字节来存储。</p>
<h2 id="UTF-8_u548CUnicode_u7684_u5173_u7CFB"><a href="#UTF-8_u548CUnicode_u7684_u5173_u7CFB" class="headerlink" title="UTF-8和Unicode的关系"></a>UTF-8和Unicode的关系</h2><p>Unicode就是上文中提到的编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。</p>
<p>Unicode标准几乎涵盖了各个国家语言可能出现的符号和文字，并将为他们编号。详见：Unicode on Wikipedia。Unicode的编号从<code>0000</code>开始一直到<code>10FFFF</code>共分为16个Plane，每个Plane中有65536个字符。而UTF-8则只实现了第一个Plane，可见UTF-8虽然是一个当今接受度最广的字符集编码，但是它并没有涵盖整个Unicode的字库，这也造成了它在某些场景下对于特殊字符的处理困难。</p>
<h2 id="UTF-8_u7F16_u7801_u7B80_u4ECB"><a href="#UTF-8_u7F16_u7801_u7B80_u4ECB" class="headerlink" title="UTF-8编码简介"></a>UTF-8编码简介</h2><h3 id="UTF-8_u7684_u7269_u7406_u5B58_u50A8_u548CUnicode_u5E8F_u53F7_u7684_u8F6C_u6362_u5173_u7CFB"><a href="#UTF-8_u7684_u7269_u7406_u5B58_u50A8_u548CUnicode_u5E8F_u53F7_u7684_u8F6C_u6362_u5173_u7CFB" class="headerlink" title="UTF-8的物理存储和Unicode序号的转换关系"></a>UTF-8的物理存储和Unicode序号的转换关系</h3><p>UTF-8编码为变长编码。最小编码单位（<code>code unit</code>）为一个字节。一个字节的前1-3个bit为描述性部分，后面为实际序号部分。</p>
<ul>
<li>如果一个字节的第一位为0，那么代表当前字符为单字节字符，占用一个字节的空间。0之后的所有部分（7个bit）代表在Unicode中的序号。</li>
</ul>
<table>
<thead>
<tr>
<th>Byte 1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xxx xxxx</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>实际字符</th>
<th>在Unicode字库序号的十六进制</th>
<th>在Unicode字库序号的二进制</th>
<th>UTF-8编码后的二进制</th>
<th>UTF-8编码后的十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>0024</td>
<td>010 0100</td>
<td>0<strong>010 0100</strong></td>
<td>24</td>
</tr>
</tbody>
</table>
<ul>
<li>如果一个字节以110开头，那么代表当前字符为双字节字符，占用2个字节的空间。110之后的所有部分（5个bit）加上后一个字节的除10外的部分（6个bit）代表在Unicode中的序号。且第二个字节以10开头。</li>
</ul>
<table>
<thead>
<tr>
<th>Byte 1</th>
<th>Byte 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xxx xxxx</td>
<td>10xx xxxx</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>实际字符</th>
<th>在Unicode字库序号的十六进制</th>
<th>在Unicode字库序号的二进制</th>
<th>UTF-8编码后的二进制</th>
<th>UTF-8编码后的十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>¢</td>
<td>00A2</td>
<td>000 1010 0010</td>
<td>110<strong>0 0010</strong> 10<strong>10 0010</strong></td>
<td>C2 A2</td>
</tr>
</tbody>
</table>
<ul>
<li>如果一个字节以1110开头，那么代表当前字符为三字节字符，占用2个字节的空间。1110之后的所有部分（5个bit）加上后两个字节的除10外的部分（12个bit）代表在Unicode中的序号。且第二、第三个字节以10开头。</li>
</ul>
<table>
<thead>
<tr>
<th>Byte 1</th>
<th>Byte 2</th>
<th>Byte 3</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xxx xxxx</td>
<td>10xx xxxx</td>
<td>10xx xxxx</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>实际字符</th>
<th>在Unicode字库序号的十六进制</th>
<th>在Unicode字库序号的二进制</th>
<th>UTF-8编码后的二进制</th>
<th>UTF-8编码后的十六进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>€</td>
<td>20AC</td>
<td>0010 0000 1010 1100</td>
<td>1110 <strong>0010</strong> 10<strong>00 0010</strong> 10<strong>10 1100</strong></td>
<td>E2 82 AC</td>
</tr>
</tbody>
</table>
<ul>
<li><p>如果一个字节以10开头，那么代表当前字节为多字节字符的第二个字节。10之后的所有部分（6个bit）和之前的部分一同组成在Unicode中的序号。</p>
</li>
<li><p>3个字节的UTF-8十六进制编码一定是以<code>E</code>开头的。</p>
</li>
<li>2个字节的UTF-8十六进制编码一定是以<code>C</code>或<code>D</code>开头的。</li>
<li>1个字节的UTF-8十六进制编码一定是以比<code>8</code>小的数字开头的。</li>
</ul>
<h2 id="u4E71_u7801"><a href="#u4E71_u7801" class="headerlink" title="乱码"></a>乱码</h2><p>编码和解码时用了不同或者不兼容的字符集。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="http://cenalulu.github.io/linux/character-encoding/" target="_blank" rel="external">十分钟搞清字符集和字符编码</a></li>
<li><a href="http://cenalulu.github.io/python/python-encoding/" target="_blank" rel="external">关于Python的默认字符集</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode和UTF-8</a></li>
<li><a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="external">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></li>
<li><a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="external">字体编辑用中日韩汉字Unicode编码表</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[原文是十分钟搞清字符集和字符编码，这里我简化了一些说明，稍微修改了原文的例子。]]>
    
    </summary>
    
      <category term="encoding" scheme="http://chaomai.github.io/tags/encoding/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pattern Matching相关算法小结]]></title>
    <link href="http://chaomai.github.io/2015/05/25/2015-2015-05-25-summary-of-pattern-matching/"/>
    <id>http://chaomai.github.io/2015/05/25/2015-2015-05-25-summary-of-pattern-matching/</id>
    <published>2015-05-25T03:33:43.000Z</published>
    <updated>2016-01-18T08:10:37.724Z</updated>
    <content type="html"><![CDATA[<h1 id="Pattern_matching"><a href="#Pattern_matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h1><p>Pattern matching的算法有很多，这里做一个简单的总结。</p>
<p>问题：给定一个字符串<code>txt[0...n-1]</code>和另一个字符串<code>pat[0...m-1]</code>，假设n &gt; m，实现一个函数<code>search(char pat[], char txt[])</code>，完成在<code>txt</code>中找到所有<code>pat</code>出现的位置。</p>
<p>例子：</p>
<ul>
<li>Input:</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">txt[] = <span class="value"><span class="string">"THIS IS A TEST TEXT"</span></span></span></span><br><span class="line"><span class="setting">pat[] = <span class="value"><span class="string">"TEST"</span></span></span></span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern found <span class="keyword">at</span> index <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Input:</li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">txt[] = <span class="value"><span class="string">"AABAACAADAABAAABAA"</span></span></span></span><br><span class="line"><span class="setting">pat[] = <span class="value"><span class="string">"AABA"</span></span></span></span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern found at index <span class="operator">0</span><br><span class="line">Pattern <span class="keyword">found</span> <span class="keyword">at</span> <span class="keyword">index</span> <span class="number">9</span></span><br><span class="line">Pattern <span class="keyword">found</span> <span class="keyword">at</span> <span class="keyword">index</span> <span class="number">13</span></span></span><br></pre></td></tr></table></figure>
<h1 id="Naive_Pattern_Searching"><a href="#Naive_Pattern_Searching" class="headerlink" title="Naive Pattern Searching"></a>Naive Pattern Searching</h1><p>也叫Bruce Force。</p>
<p>方法很简单，对于<code>txt</code>中的每个index i，检查<code>pat</code>的每个字符是否匹配。如果有匹配不上的字符，或者匹配成功，都move到下一个index。</p>
<p>最坏时间复杂度，$O(mn)$。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-1-naive-pattern-searching/" target="_blank" rel="external">Naive Pattern Searching</a></li>
</ul>
<h1 id="A_Better_Naive_Pattern_Searching"><a href="#A_Better_Naive_Pattern_Searching" class="headerlink" title="A Better Naive Pattern Searching"></a>A Better Naive Pattern Searching</h1><p>这个方法需要有一个前提条件：<code>pat</code>里所有字符都不相同。</p>
<p>在这个前提下，如果在匹配了j个字符之后出现了mismatch，那么<code>pat</code>就不是后移一个位置，而是后移j个位置。当然如果是首字符就不匹配，那么仍然是后移一个位置。</p>
<h2 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://www.geeksforgeeks.org/pattern-searching-set-4-a-naive-string-matching-algo-question/" target="_blank" rel="external">A Naive Pattern Searching Question</a></li>
</ul>
<h1 id="KMP_Algorithm"><a href="#KMP_Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h1><p>Naive Pattern Searching在这样的情况下，效率是很低的：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">txt[] = <span class="value"><span class="string">"AAAAAAAAAAAAAAAAAB"</span></span></span></span><br><span class="line"><span class="setting">pat[] = <span class="value"><span class="string">"AAAAB"</span></span></span></span><br></pre></td></tr></table></figure>
<p>因为<code>pat</code>每次在比较到不同的字符B的时候，仅仅向后移动一位，搜索位置又要退回，重新比较已经比较过的字符。</p>
<p>同时这也是Naive Pattern Searching的改进方法无法处理的，因为里面出现了重复的字符。如果再回去看Naive Pattern Searching的改进方法，其实本质上就是为了避免搜索位置的退回。</p>
<p>KMP可以利用已经比较过的字符这一信息来避免搜索位置退回。至于怎么利用，就是部分匹配表。</p>
<p>部分匹配表是KMP的关键，生成的方式是对pat的每个前缀，计算该前缀的前缀和后缀的最长的共有元素的长度。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pat                 A B C D A B D</span><br><span class="line">partial match value <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>有了部分匹配表，在发现不同的字符的时候，就不直接把<code>pat</code>后移一位，而是根据下面的公式，</p>
<p>$$<br>移动位数 = 已匹配的字符数 - 对应的部分匹配值<br>$$</p>
<p>这里对应的部分匹配值指的是，在<code>pat</code>中，最后已匹配字符对应的部分匹配值。</p>
<p>如果是首字符就不匹配，那么仍然是后移一个位置。</p>
<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，<code>&quot;ABCDAB&quot;</code>之中有两个<code>&quot;AB&quot;</code>，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个<code>&quot;AB&quot;</code>向后移动4位（$字符串长度-部分匹配值$），就可以来到第二个<code>&quot;AB&quot;</code>的位置。</p>
<p>最坏时间复杂度，$O(n)$。</p>
<p>看完KMP，可以发现Naive Pattern Searching的改进方法实际上是KMP的特例，由于pat中所有字符都不相同，因此部分匹配表中所有的对应的部分匹配值都是0，</p>
<p>$$<br>移动位数 = 已匹配的字符数<br>$$</p>
<h2 id="References-2"><a href="#References-2" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="external">KMP Algorithm</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="external">字符串匹配的KMP算法</a></li>
</ul>
<h1 id="Rabin-Karp_Algorithm"><a href="#Rabin-Karp_Algorithm" class="headerlink" title="Rabin-Karp Algorithm"></a>Rabin-Karp Algorithm</h1><p>Bruce Force在<code>txt</code>上每次把<code>pat</code>后移一位，每次移动之后，检查<code>pat</code>的每个字符是否匹配。Rabin-Karp也是类似的，每次把pat后移一位，不同的是Rabin-Karp比较的是<code>pat</code>的hash值和当前对应的<code>txt</code>子串的hash值。如果hash值相等，然后再去逐个检查子串的字符。</p>
<p>最直接的方法莫过于计算<code>h(pat)</code>和<code>txt</code>中所有子串的hash，然后一一比较。但光是计算<code>txt</code>中所有子串的hash就需要O(mn)的时间，这样一来，相比起Naive Pattern Searching，这个方法就毫无优势了。</p>
<p>如何计算hash值是Rabin-Karp的关键，最好是能够利用当前<code>txt</code>子串的hash值，计算后移一位以后的，以减少计算的开销。Rabin-Karp使用的hash叫做Rolling hash，基本实现是刚刚的方法实际上重复计算了很多重叠的部分，而Rolling hash就要利用当前子串的hash值，来计算后移一个位置之后子串的hash值。</p>
<p>Intro to Algorithms的Lecture Note举了一个很形象的例子来说明Rolling hash。</p>
<p>在最坏情况下，每次移动后hash值都相等（因为子串相同或hash冲突），因此移动后都要逐个检查子串的字符。</p>
<p>最坏时间复杂度，$O(mn)$。</p>
<h2 id="References-3"><a href="#References-3" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://en.wikipedia.org/wiki/Rolling_hash" target="_blank" rel="external">Rolling hash</a></li>
<li><a href="http://courses.csail.mit.edu/6.006/spring11/rec/rec06.pdf" target="_blank" rel="external">Rolling Hash (Rabin-Karp Algorithm)</a></li>
<li><a href="http://stellar.mit.edu/S/course/6/fa13/6.006/courseMaterial/topics/topic6/lectureNotes/L09-Hashing-II/L09-Hashing-II.pdf" target="_blank" rel="external">Hashing-II</a></li>
<li><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-3-rabin-karp-algorithm/" target="_blank" rel="external">Rabin-Karp Algorithm</a></li>
</ul>
<h1 id="Finite_Automata"><a href="#Finite_Automata" class="headerlink" title="Finite Automata"></a>Finite Automata</h1><p>基于有限状态机实现pattern searching，就是用pattern来构建一个状态表，构建完成以后就可以根据txt的每个字符，来在有限状态机的各个状态之间转移，如果到达终态，那就是匹配到了。</p>
<p>这个算法的关键就是基于pattern构建状态表。</p>
<h2 id="References-4"><a href="#References-4" class="headerlink" title="References"></a>References</h2><p><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-5-finite-automata/" target="_blank" rel="external">http://www.geeksforgeeks.org/searching-for-patterns-set-5-finite-automata/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Pattern matching的算法有很多，这里做一个简单的总结。]]>
    
    </summary>
    
      <category term="pattern matching" scheme="http://chaomai.github.io/tags/pattern-matching/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
      <category term="algorithms" scheme="http://chaomai.github.io/categories/programming/algorithms/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[译 - Locks, Mutexes, and Semaphores: Types of Synchronization Objects]]></title>
    <link href="http://chaomai.github.io/2015/05/23/2015-2015-05-23-translation-locks-mutexes-and-semaphores-types-of-synchronization-objects/"/>
    <id>http://chaomai.github.io/2015/05/23/2015-2015-05-23-translation-locks-mutexes-and-semaphores-types-of-synchronization-objects/</id>
    <published>2015-05-23T14:12:13.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h1><p>lock是一个抽象的概念。一个基本的前提就是一个lock保护着某种共享资源的访问。如果你own一个lock，那么你就能访问被保护的共享资源。如果你没有own lock，那么你就不能够访问这个共享资源。</p>
<p>为了own一个lock，你首先需要某种lockable对象。然后你从那个对象获得lock。这个操作精确的术语可能会有很多。例如，如果你有一个lockable对象XYZ，你可以：</p>
<ul>
<li>acquire the lock on XYZ,</li>
<li>take the lock on XYZ,</li>
<li>lock XYZ,</li>
<li>take ownership of XYZ,</li>
<li>or some similar term specific to the type of XYZ</li>
</ul>
<p>lock的概念也意味着某种exclusion：有时，你可能不能获得ownership of a lock，接着将要执行的操作将会fail、或block。就前者而言，操作将会返回某些错误码或异常，以指明take ownership的操作尝试失败。而后者，只有当这个操作take ownership，它才会返回，而这需要系统里的其他线程完成一些工作才能使得这个发生。</p>
<p>exclusion最常见的形式是一个简单的计数：lockable对象有最大数目的owners。如果达到了这个数目，那么接下来任何尝试获取a lock on it都不会成功。因此，这需要我们有某种机制（当我们完成操作的时候，放弃ownership）。这通常叫做unlocking，但是同样的术语可能不同。例如，你可以：</p>
<ul>
<li>release the lock on XYZ,</li>
<li>drop the lock on XYZ,</li>
<li>unlock XYZ,</li>
<li>relinquish ownership of XYZ,</li>
<li>or some similar term specific to the type of XYZ</li>
</ul>
<p>当你以合适的方式relinquish ownership，如果所需的条件都满足了，那么一个被block的尝试获得锁的操作现在将会继续。</p>
<p>例如一个lockable对象只允许有3个owners，那么第4个尝试获得lock的操作将block。当3个中的某个owner 释放了lock，那么第4个尝试获得lock的操作将会成功。</p>
<h1 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h1><p>“own” a lock的意思视lockable对象确切的类型而定。某些lockable对象会对ownership有非常严格的定义：this specific thread owns the lock, through the use of that specific object, within this particular scope.</p>
<p>在其他情况下，这个定义会更不稳定，ownership of the lock会更抽象。在这些情况下，ownership can be relinquished by a different thread or object than the thread or object that acquired the lock.</p>
<p>注：其实就想看这篇文章里说Ownership的部分，后面的就不翻译了:)</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>原文：<a href="https://www.justsoftwaresolutions.co.uk/threading/locks-mutexes-semaphores.html" target="_blank" rel="external">Locks, Mutexes, and Semaphores: Types of Synchronization Objects</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[C++ Concurrency in Action作者的文章，介绍了一些关于并发的基础概念：锁、互斥量和信号量。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://chaomai.github.io/tags/c-11/"/>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="translation" scheme="http://chaomai.github.io/tags/translation/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ Concurrency in Action (2) - Managing Threads]]></title>
    <link href="http://chaomai.github.io/2015/05/18/2015-2015-05-18-cpp-concurrency-in-action-2/"/>
    <id>http://chaomai.github.io/2015/05/18/2015-2015-05-18-cpp-concurrency-in-action-2/</id>
    <published>2015-05-18T11:35:23.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Managing_threads"><a href="#Managing_threads" class="headerlink" title="Managing threads"></a>Managing threads</h1><p><code>std::thread</code>：线程管理的相关类和函数。</p>
<p>对于那些不是那么简单的任务，库提供了可以让你从基本的代码来构建你需要的东西的灵活性。</p>
<h2 id="Basic_thread_management"><a href="#Basic_thread_management" class="headerlink" title="Basic thread management"></a>Basic thread management</h2><p>每个C++程序都至少有一个线程，这个线程是由C++运行时启动的：运行<code>main()</code>的那个线程。</p>
<h3 id="Launching_a_thread"><a href="#Launching_a_thread" class="headerlink" title="Launching a thread"></a>Launching a thread</h3><p>启动一个线程需要构造<code>std::thread</code>对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>; <span class="comment">//此时新线程已经启动</span></span><br></pre></td></tr></table></figure>
<p>在C++标准库中，<code>std::thread</code>可以适用于任何callable类型。如果是一个带有函数调用操作符的类的实例，那么对象会被copy到新线程的存储空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> background_task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        do_something();</span><br><span class="line">        do_something_else();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task f;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但要注意的是，如果传入的是一个临时对象，而不是已经命名的对象，那么这样的语法就和函数调用没有区别，编译器也不会把它看作是callable对象。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">(background_task()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这里声明了一个my_thread函数，接受一个参数，参数是一个函数指针（这个函数不接受任何参数，返回的是background_task对象），返回一个<code>std::thread</code>对象。</p>
<p>避免这样问题的方法：</p>
<ol>
<li>命名函数对象</li>
<li>使用额外的括号</li>
<li>使用新的统一的初始化语法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">((background_task()</span>))</span>;    <span class="comment">//prevent interpretation as a function</span></span><br><span class="line"><span class="built_in">std</span>::thread my_thread&#123;background_task()&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="lambda_u8868_u8FBE_u5F0F"><a href="#lambda_u8868_u8FBE_u5F0F" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">([](</span><br><span class="line">    do_something()</span></span>;</span><br><span class="line">    do_something_else();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在线程启动以后，需要决定是等待线程结束，还是任其运行。这个决定只需要在线程destroy之前完成即可，因为有可能在你join或detach前，线程就运行完成了。</p>
<p>如果不想等待线程结束，那么必须保证线程所访问的数据，直到该线程结束时都是合法的。下面就是一个反例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> func</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; i;</span><br><span class="line">    func(<span class="keyword">int</span>&amp; i_):i(i_)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            do_something(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    my_thread.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，因为调用了<code>detach()</code>，所以<code>oops()</code>结束时，新线程仍然有可能还在运行。如果仍然在运行，那么<code>do_something(i)</code>将会访问一个已经destroyed的变量。</p>
<p>一种常用的方式是，使得thread function self-contained，并且是copy数据到线程，（这里指的应该是function object），而不是共享数据（指针或引用）。除非可以保证线程在函数结束前运行完，否则不要创建一个可以访问所在函数局部变量的线程。当然，也可以join。</p>
<h3 id="Waiting_for_a_thread_to_complete"><a href="#Waiting_for_a_thread_to_complete" class="headerlink" title="Waiting for a thread to complete"></a>Waiting for a thread to complete</h3><p>对与线程相关联的<code>std::thread</code>对象调用<code>join()</code>。</p>
<p>在上例中，可以换成<code>join()</code>。但是换了以后就失去了多线程的意义，因为原始线程除了wait，什么都没法做。</p>
<p><code>join()</code>是一种简单粗暴的方法。如果需要细粒度的控制wait，那么就需要其他的机制。</p>
<p>调用<code>join()</code>还会清除与线程相关的任何storage，因此<code>std::thread</code>对象不再和任何已结束的线程关联，换句话说就是，对于给定线程，<code>join()</code>只能调用一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func my_func;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>
<p>这里加断点可以验证，t在join前，thread id的值不为0，join后变为0。</p>
<h3 id="Waiting_in_exceptinal_circumstances"><a href="#Waiting_in_exceptinal_circumstances" class="headerlink" title="Waiting in exceptinal circumstances"></a>Waiting in exceptinal circumstances</h3><p><code>detach()</code>可以在线程开始后马上调用，但是<code>join()</code>意味着wait。如果想要在wait前做些其他事情，那么就必须考虑<code>join()</code>放置的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> func;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        do_something_in_current_thread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        t.join();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码保证了在异常或者无异常的情况下，都能够<code>join()</code>。无论是什么原因导致要<code>join()</code>，都必须保证在所有exit可能的情况里，都有<code>join()</code>，而上面的代码太复杂，容易出错。</p>
<h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> thread_guard</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread&amp; t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(<span class="built_in">std</span>::thread&amp; t_)</span>:</span><br><span class="line">        <span class="title">t</span><span class="params">(t_)</span></span><br><span class="line">    </span>&#123;&#125;</span><br><span class="line">    ~thread_guard()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.joinable())</span><br><span class="line">        &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread_guard(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> func;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但f exit时，局部对象的销毁顺序是与构造顺序相反的。因此无论是什么情况导致f exit，只要t是joinable的，就可以保证join。</p>
<p>之所以要disable copy和assign，是因为如果enalbe，那么对象的生命周期可能会超过thread应该join的作用域。</p>
<h3 id="Runing_threads_in_the_background"><a href="#Runing_threads_in_the_background" class="headerlink" title="Runing threads in the background"></a>Runing threads in the background</h3><p>在一个<code>std::thread</code>对象上调用<code>detach()</code>。</p>
<p>一旦调用<code>detach()</code>，就再也无法wait for that thread（不能获得reference到that thread的<code>std::thread</code>对象，也不能<code>join()</code>）。</p>
<p>被<code>detach()</code>的线程（也被叫做demon thread）会在后台运行，拥有权和控制权会交给C++ Runtime library，它能保证当线程结束时，相关的资源会被回收。这样的线程可能会是long-running的线程，执行监视、清理和优化的工作。</p>
<p>为了从一个<code>std::thread</code>对象上<code>detach()</code>线程，必须要有线程来detach。调用<code>detach()</code>的要求和<code>join()</code>一样，joinable的<code>std::thread</code>对象才可以detach()。</p>
<h2 id="Passing_arguments_to_a_thread_function"><a href="#Passing_arguments_to_a_thread_function" class="headerlink" title="Passing arguments to a thread function"></a>Passing arguments to a thread function</h2><p>可以用前面的方法，用一个带有data成员的函数对象，但更简便的是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,”hello”)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在上例中，要注意的是，std::string是以char const*的形式传入的，只有在新线程的context中才会被转为<code>std::string</code>。</p>
<p>在默认情况下，参数是被copy的。我猜这样设计的原因也是出于之前提到过的原因，如果线程point to或reference to的local variable所在的scope结束，local variable就会被销毁，那么线程将会访问一个已经destroyed的变量。除非使用额外的<code>join()</code>，但这无疑增加了用户编码的复杂度。</p>
<h3 id="Just_want_reference"><a href="#Just_want_reference" class="headerlink" title="Just want reference"></a>Just want reference</h3><p>如果我就是要修改原始数据，怎么办？对于pointer，这个倒是好说，直接传pointer即可，地址会被copy，但是reference就不一样了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    widget_data data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(update_data_for_widget,w,data)</span></span>;</span><br><span class="line">    display_status();</span><br><span class="line">    t.join();</span><br><span class="line">    process_widget_data(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，虽然<code>update_data_for_widget()</code>期望的是第二个参数传入引用，但是<code>std::thread</code>并不知道。<code>update_data_for_widget()</code>被调用时，data实际上是reference to线程内部的copy过来的data，而不是原始的data。线程结束时，这些对data的操作都会随着线程内部copy的销毁而丢失，<code>process_widget_data()</code>接受的还是没有修改的data。</p>
<p>但是我在clang++-3.6，libstdc++的环境下编译的时候，以上代码是无法通过编译的，错误如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: no type named 'type' in 'std::result_of&lt;void (*(int, double))(int, double &amp;)&gt;'</span><br><span class="line">      typedef typename result_of&lt;_Callable(_Args...)&gt;::type result_type;</span><br></pre></td></tr></table></figure>
<p>加入std::ref后编译通过，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(update_data_for_widget,w,<span class="built_in">std</span>::ref(data)</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="std_3A_3Athread_and_std_3A_3Abind"><a href="#std_3A_3Athread_and_std_3A_3Abind" class="headerlink" title="std::thread and std::bind"></a><code>std::thread</code> and <code>std::bind</code></h3><p><code>std::thread</code>的构造函数和<code>std::bind</code>的操作有相同的机制，可以这样构造<code>std::thread</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> X</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_lengthy_work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work,&amp;my_x)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果成员函数有参数，那么可以作为构造函数的第三个参数，以此类推。</p>
<h3 id="objects_cannot_be_copied"><a href="#objects_cannot_be_copied" class="headerlink" title="objects cannot be copied"></a>objects cannot be copied</h3><p>有的对象不能够被copy，比如<code>std::unique_ptr</code>对象。这时需要用<code>std::move()</code>来transfer ownership到另一个<code>std::unique_ptr</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_big_object</span><span class="params">(<span class="built_in">std</span>::unique_ptr&lt;big_object&gt;)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::unique_ptr&lt;big_object&gt; p(<span class="keyword">new</span> big_object);</span><br><span class="line">p-&gt;prepare_data(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(process_big_object,<span class="built_in">std</span>::move(p)</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Transferring_ownership_of_a_thread"><a href="#Transferring_ownership_of_a_thread" class="headerlink" title="Transferring ownership of a thread"></a>Transferring ownership of a thread</h2><p>虽然<code>std::thread</code>不像<code>std::unique_ptr</code>动态的拥有一个对象，但是<code>std::thread</code>的确是拥有资源：每个<code>std::thread</code>实例负责管理一个线程的执行。由于<code>std::thread</code>对象不是copyable，而是moveable，因此对象的ownership可以在对象间transfer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(some_function)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::thread t2=<span class="built_in">std</span>::move(t1);    <span class="comment">//t1不再与运行some_function()的线程关联</span></span><br><span class="line">t1=<span class="built_in">std</span>::thread(some_other_function);    <span class="comment">//如果是临时对象，move自动并且隐式的发生</span></span><br><span class="line"><span class="built_in">std</span>::thread t3；    <span class="comment">//默认构造，没有和任何执行线程关联</span></span><br><span class="line">t3=<span class="built_in">std</span>::move(t2);</span><br><span class="line">t1=<span class="built_in">std</span>::move(t3);</span><br></pre></td></tr></table></figure>
<p>在上例中的最后一个move，t1原本是和运行<code>some_other_function()</code>的线程关联的，但是运行着<code>some_function()</code>的线程的ownership被transfer给了t1，这将导致程序终止。<br>因为在线程运行结束并销毁前，要么<code>join()</code>，要么<code>detach()</code>，但是绝对不能够简单的通过向管理它的<code>std::thread</code>对象赋值(move)而丢掉它。“野线程”不允许存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">f</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::thread(some_function);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">g</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(some_other_function,<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，实际上是在transfer ownership。</p>
<p>在这里，<code>std::move</code>的另一个作用可以简化<code>thread_gurad</code>。在原来的<code>thread_gurad</code>中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_gurad(<span class="built_in">std</span>::thread(do_work, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>这样是不允许的，因为<code>thread_gurad</code>构造函数接受的参数是引用，因此传入的必须是左值，而unnamed <code>std::thread</code> object并不是左值对象。</p>
<p>使用<code>std::move</code>后，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> scoped_thread &#123;</span><br><span class="line">  <span class="built_in">std</span>::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(<span class="built_in">std</span>::thread t_)</span> :</span><br><span class="line">      <span class="title">t</span><span class="params">(<span class="built_in">std</span>::move(t_)</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t.joinable()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"No thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~scoped_thread() &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scoped_thread(scoped_thread <span class="keyword">const</span> &amp;p) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  scoped_thread &amp;<span class="keyword">operator</span>=(scoped_thread <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">scoped_thread(<span class="built_in">std</span>::thread(do_work, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>上述操作就可以了。这样做还避免了<code>thread_gurad</code>对象的生命周期可能超过它引用的线程所在的scope，并且transfer以后，没有其他关联的<code>std::thread</code>对象可以join或detach。</p>
<h2 id="Choosing_the_number_of_threads_at_runtime"><a href="#Choosing_the_number_of_threads_at_runtime" class="headerlink" title="Choosing the number of threads at runtime"></a>Choosing the number of threads at runtime</h2><p><code>std::thread::hardware_concurrency()</code>，这个函数返回可以真正并行执行的线程数目。但这只是个hint，换句话说，就算可以并发多个线程，如果没有可用的信息，它可能会返回0。</p>
<p>C++ Concurrency in Action书中，在并行累加例子的后面有并行算法要求的共性的总结：</p>
<ul>
<li>at least forward iterators</li>
<li>single-pass input iterators</li>
<li>T must be default constructiable</li>
</ul>
<p>到目前位置，由于不能够直接从线程中返回值，因此必须传入reference。</p>
<h2 id="Identifying_threads"><a href="#Identifying_threads" class="headerlink" title="Identifying threads"></a>Identifying threads</h2><p>线程识别符是<code>std::thread::id</code>类型的，获得方式有：</p>
<ul>
<li>通过成员函数<code>get_id()</code>，从关联该线程的<code>std::thread</code>对象获得（如果对象没有关联任何线程，则会返回默认构造函数生成的<code>std::thread::id</code>对象，表示not any thread）</li>
<li>对于当前线程，使用<code>std::thread::get_id()</code></li>
</ul>
<p><code>std::thread::id</code>对象可以被copy，并且该类型提供了完整的比较操作（全序的）。如果一致，那么他们代表同一线程，或者<em>not any thread</em>。该类型对象还可以作为key用于关联容器、排序，同时标准库还提供了<code>std::hash&lt;std::thread::id&gt;</code>，因此还能用于无序关联容器。</p>
<p><code>std::thread::id</code>对象常用于检查线程是否需要做某些操作。</p>
]]></content>
    <summary type="html">
    <![CDATA[Managing threads的笔记。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://chaomai.github.io/tags/c-11/"/>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ Concurrency in Action (1) - Hello, World of Concurrency in C++!]]></title>
    <link href="http://chaomai.github.io/2015/05/17/2015-2015-05-17-cpp-concurrency-in-action-1/"/>
    <id>http://chaomai.github.io/2015/05/17/2015-2015-05-17-cpp-concurrency-in-action-1/</id>
    <published>2015-05-17T11:35:23.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5173_u4E8E_u6B64_u7CFB_u5217_u6587_u7AE0"><a href="#u5173_u4E8E_u6B64_u7CFB_u5217_u6587_u7AE0" class="headerlink" title="关于此系列文章"></a>关于此系列文章</h1><p>最近在看这本书，这个系列文章是我在看书过程中的笔记，记录了一些我觉得关键的地方和自己的思考。如果能帮助到你，I will be very happy :).</p>
<h1 id="u5173_u4E8EC++_Concurrency_in_Action"><a href="#u5173_u4E8EC++_Concurrency_in_Action" class="headerlink" title="关于C++ Concurrency in Action"></a>关于C++ Concurrency in Action</h1><blockquote><p>本书是一本基于C++11新标准的并发和多线程编程深度指南。从std::thread、std::mutex、std::future和std::async等基础类的使用，到内存模型和原子操作、基于锁和无锁数据结构的构建，再扩展到并行算法、线程管理，最后还介绍了多线程代码的测试工作。本书的附录部分还对C++11新语言特性中与多线程相关的项目进行了简要的介绍，并提供了C++11线程库的完整参考。</p>
<footer><strong>并发编程网</strong><cite><a href="http://ifeve.com/c-plus-plus-concurrency-in-action/" target="_blank" rel="external">《C++ Concurrency in Action》中文版</a></cite></footer></blockquote>
<p>2014年初要出的中文版，只是到现在还没有，看英文吧。</p>
<h1 id="Hello_2C_world_of_concurrency_in_C++"><a href="#Hello_2C_world_of_concurrency_in_C++" class="headerlink" title="Hello, world of concurrency in C++"></a>Hello, world of concurrency in C++</h1><p>在C++中实现多线程，可以写出行为有保证的可移植的代码。</p>
<h3 id="Appraoches_to_concurrency"><a href="#Appraoches_to_concurrency" class="headerlink" title="Appraoches to concurrency"></a>Appraoches to concurrency</h3><h4 id="u591A_u8FDB_u7A0B"><a href="#u591A_u8FDB_u7A0B" class="headerlink" title="多进程"></a>多进程</h4><p>消息传递由进程间通信实现，但是，</p>
<ul>
<li>由于操作系统的有很多保护机制来避免一个进程难以修改另一个的数据，因此实现通讯的方式复杂或者慢；</li>
<li>有固有的开销，启动进程需要时间（系统需要分配资源等）。</li>
</ul>
<h4 id="u591A_u7EBF_u7A0B"><a href="#u591A_u7EBF_u7A0B" class="headerlink" title="多线程"></a>多线程</h4><p>操作系统要做的更少，灵活的共享内存是有代价的。</p>
<ul>
<li>内存一致性</li>
</ul>
<h2 id="Why_use_concurrency"><a href="#Why_use_concurrency" class="headerlink" title="Why use concurrency"></a>Why use concurrency</h2><ul>
<li>separation of concerns</li>
<li>performance</li>
</ul>
<h3 id="Ways_to_use_concurrency"><a href="#Ways_to_use_concurrency" class="headerlink" title="Ways to use concurrency"></a>Ways to use concurrency</h3><ul>
<li>task parallelism, data parallelism；</li>
<li>使用现有的并行计算能力来解决更大的问题；</li>
<li>（两种方式有着不同的关注点：一个是利用并行来缩短任务的时间；另一个是在任务处理时间一定的情况下，并行的运行多个任务来加大处理量。）</li>
</ul>
<h3 id="When_not_to_use_concurrency"><a href="#When_not_to_use_concurrency" class="headerlink" title="When not to use concurrency"></a>When not to use concurrency</h3><ul>
<li>实现并发的cost&gt;收益；</li>
<li>线程的启动需要时间来给os分配相关的内核资源和栈空间，如果线程完成的时间很短，那可能启动的时间就占据了运行时间的大部分；</li>
<li>由于系统的资源有限，线程是一种有限的资源,线程越多，os必须进行更多的context switching。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Hello, world of concurrency in C++!的笔记。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://chaomai.github.io/tags/c-11/"/>
    
      <category term="concurrency" scheme="http://chaomai.github.io/tags/concurrency/"/>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Clang++中C++11 Thread的支持]]></title>
    <link href="http://chaomai.github.io/2015/05/15/2015-2015-05-15-compile-c-11-thread-with-clang/"/>
    <id>http://chaomai.github.io/2015/05/15/2015-2015-05-15-compile-c-11-thread-with-clang/</id>
    <published>2015-05-15T11:35:23.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h1><p>在Ubuntu中使用Clang++，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++-<span class="number">3.7</span> -std=c++<span class="number">11</span> test.cpp</span><br></pre></td></tr></table></figure>
<p>编译C++11编写的多线程代码时，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">  t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现如下问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/<span class="built_in">test</span>-<span class="number">9606</span>ba.o: In <span class="keyword">function</span> `std::thread::thread&lt;void (&amp;)()&gt;(void (&amp;)())<span class="string">':</span><br><span class="line">test.cpp:(.text[_ZNSt6threadC2IRFvvEJEEEOT_DpOT0_]+0x21): undefined reference to `pthread_create'</span></span><br><span class="line">clang: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code <span class="number">1</span> (use -v to see invocation)</span><br></pre></td></tr></table></figure>
<h1 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h1><ol>
<li><p>在Linux中，Standard C++ library的默认实现是libstdc++。虽然安装了clang，但是编译时使用的仍然是GNU的libstdc++。</p>
</li>
<li><p>执行clang++ -v以后，可以知道使用的线程模型是posix。</p>
</li>
</ol>
<h1 id="u89E3_u51B3"><a href="#u89E3_u51B3" class="headerlink" title="解决"></a>解决</h1><p>既然底层使用了posix来实现C++11的线程，那么编译的时候必然要有-pthread</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++-<span class="number">3.7</span> -std=c++<span class="number">11</span> -pthread test.cpp</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[在Linux下编译C++11的多线程代码时，提示pthread_create为定义。最后发现clang++在Linux在使用的是posix来实现C++11的线程，编译的时候需要加上-pthread。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="c++11" scheme="http://chaomai.github.io/tags/c-11/"/>
    
      <category term="clang" scheme="http://chaomai.github.io/tags/clang/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译时，-Pthread and -Lpthread的区别]]></title>
    <link href="http://chaomai.github.io/2015/05/14/2015-2015-05-14-difference-between-pthread-and-lpthread/"/>
    <id>http://chaomai.github.io/2015/05/14/2015-2015-05-14-difference-between-pthread-and-lpthread/</id>
    <published>2015-05-14T11:31:30.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<p>-pthread告诉编译器，要链接到pthread库，同时配置线程的编译。</p>
<p>下面的例子就显示了在使用-pthread时，定义了不同的宏。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -pthread -E <span class="operator">-d</span>M test.c &gt; dm.pthread.txt</span><br><span class="line">$ gcc          -E <span class="operator">-d</span>M test.c &gt; dm.nopthread.txt</span><br><span class="line">$ diff dm.pthread.txt dm.nopthread.txt</span><br><span class="line"><span class="number">152</span>d151</span><br><span class="line">&lt; <span class="comment">#define _REENTRANT 1</span></span><br><span class="line"><span class="number">208</span>d206</span><br><span class="line">&lt; <span class="comment">#define __USE_REENTRANT 1</span></span><br></pre></td></tr></table></figure>
<p>-lpthread只会告诉编译器，要链接到pthread库，但是这些宏不会被定义。</p>
<p>编译时，应该使用-pthread。</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol>
<li><a href="http://stackoverflow.com/questions/23250863/difference-between-pthread-and-lpthread-while-compiling" target="_blank" rel="external">difference-between-pthread-and-lpthread-while-compiling</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[gcc编译多线程代码时，参数不同导致结果的不同。]]>
    
    </summary>
    
      <category term="pthread" scheme="http://chaomai.github.io/tags/pthread/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读加缪《局外人》]]></title>
    <link href="http://chaomai.github.io/2015/03/21/2015-2015-03-21-the-stranger/"/>
    <id>http://chaomai.github.io/2015/03/21/2015-2015-03-21-the-stranger/</id>
    <published>2015-03-21T15:08:50.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<p>存在主义，这是在读这本书前，我从书评里扫到的第一个，也是印象最深的词。隐约觉得《局外人》会表达某种深奥的、晦涩的东西。接着我便怀着竭尽自己所能去理解的心态开始了阅读。</p>
<p>“今天，妈妈死了。也许是在昨天，我搞不清。”简短的四句话便铺垫了书中默尔索冷漠的态度。默尔索是一个冷淡孤僻、不懂得人情世故、交友不慎、无追求不上进的人。在他看来，身边发生的一切，他都表现得和他没什么关系、很随意的样子，无论是亲情、爱情、友情，亦或是事业。我好几次都被他不正常的冷静逗笑。结尾默尔索因为杀了人，被判处死刑。审判的时候，大家议论的更多的是他母亲去世的那天，他的表现，而不是杀人这个事情本身。最后默尔索拒绝上述、忏悔，静静的等待死亡。</p>
<ul>
<li>从小说叙述的事情来看，默尔索的死，其实是因为拒绝了循规蹈矩、大家都过着的、正常人的生活，他挑战了整个社会。作为一个异类，社会不允许这样的人继续存在。</li>
</ul>
<blockquote><p>“莫尔索的死，不是因为杀了人，而是挑战了整个社会的伪善矫情，挑战了谎言堆砌的现代文明，戳穿了皇帝的新衣。这个什么都不爱什么都不在乎的人，在这一点上是激情澎湃的。总是这样，小说中的人物代替我们说出真相，代替我们勇敢。”</p>
<footer><strong>不吭声</strong><cite><a href="http://book.douban.com/review/1396585/" target="_blank" rel="external">读加缪杂记</a></cite></footer></blockquote>
<ul>
<li>在看了wiki上关于存在主义的词条以后，对存在主义的定义了解了，但是很难说出小说中含有的存在主义的东西。</li>
</ul>
<blockquote><p>“存在主义，是一个哲学的非理性主义思潮，它认为人存在的意义是无法经由理性思考而得到答案的，以强调个人、独立自主和主观经验。”</p>
<p>““存在先于本质”（法语：l’existence précède l’essence）。他的意思是说，除了人的生存之外没有天经地义的道德或灵魂。道德和灵魂都是人在生存中创造出来的。人没有义务遵守某个道德标准或宗教信仰，却有选择的自由。要评价一个人，要评价他的所作所为，而不是评价他是个什么人物，因为一个人是由他的行动来定义的。”</p>
<footer><strong>存在主义</strong><cite><a href="http://zh.wikipedia.org/zh-cn/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89" target="_blank" rel="external">Wiki</a></cite></footer></blockquote>
<p>在小说的末尾，默尔索觉得神甫连自己是否活着都没法把握，但是他对自己很有把握，对他所有的一切都有把握。接着，默尔索又说了，注定只有一种命运选择了他，那么其他人的生活和命运对他又有什么重要？</p>
]]></content>
    <summary type="html">
    <![CDATA[读了加谬的《局外人》，这个算是，不是读后感的读后感吧。]]>
    
    </summary>
    
      <category term="reading" scheme="http://chaomai.github.io/tags/reading/"/>
    
      <category term="thought" scheme="http://chaomai.github.io/categories/thought/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从汇编的角度分析C++引用]]></title>
    <link href="http://chaomai.github.io/2015/03/10/2015-2015-03-10-analysis-reference-in-cpp-from-the-perspective-of-assembly/"/>
    <id>http://chaomai.github.io/2015/03/10/2015-2015-03-10-analysis-reference-in-cpp-from-the-perspective-of-assembly/</id>
    <published>2015-03-10T09:35:29.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5F15_u7528"><a href="#u5F15_u7528" class="headerlink" title="引用"></a>引用</h1><p>C++中，引用为对象起了另外一个名字，引用类型refers to另外一种类型。定义引用时，把引用和初始值绑定在一起，而不是将初始值拷贝给引用。定义了引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。但是引用本身不是一个对象。</p>
<p>说到这里，其实会发现引用和指针有点像，但实际上它们是不同的。首先引用在绑定到对象以后，就不能再绑定到另外一个对象；其次，引用本身不是一个对象，但是指针是一个对象。</p>
<h1 id="u6C47_u7F16_u7684_u89D2_u5EA6"><a href="#u6C47_u7F16_u7684_u89D2_u5EA6" class="headerlink" title="汇编的角度"></a>汇编的角度</h1><p>更深入到底层，可以汇编的角度来看引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ra = a;</span><br><span class="line">ra++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> *pa = &amp;b;</span><br><span class="line">pa++;</span><br><span class="line">(*pa)++;</span><br></pre></td></tr></table></figure>
<p>以上代码的反汇编如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span><span class="comment">;</span></span><br><span class="line">012E33F8  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [a],<span class="number">3</span></span><br><span class="line"><span class="keyword">int</span> &amp;ra = a<span class="comment">;</span></span><br><span class="line">012E33FF  <span class="keyword">lea</span>         <span class="literal">eax</span>,[a]</span><br><span class="line">012E3402  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [ra],<span class="literal">eax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span><span class="comment">;</span></span><br><span class="line">012E3405  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [b],<span class="number">4</span></span><br><span class="line"><span class="keyword">int</span> *pa = &amp;b<span class="comment">;</span></span><br><span class="line">012E340C  <span class="keyword">lea</span>         <span class="literal">eax</span>,[b]</span><br><span class="line">012E340F  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [pa],<span class="literal">eax</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ra++<span class="comment">;</span></span><br><span class="line">013F4475  <span class="keyword">mov</span>         <span class="literal">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [ra]</span><br><span class="line">013F4478  <span class="keyword">mov</span>         <span class="literal">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">eax</span>]</span><br><span class="line">013F447A  <span class="keyword">add</span>         <span class="literal">ecx</span>,<span class="number">1</span></span><br><span class="line">013F447D  <span class="keyword">mov</span>         <span class="literal">edx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [ra]</span><br><span class="line">013F4480  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">edx</span>],<span class="literal">ecx</span>  </span><br><span class="line"></span><br><span class="line">pa++<span class="comment">;</span></span><br><span class="line">013F448F  <span class="keyword">mov</span>         <span class="literal">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [pa]</span><br><span class="line">013F4492  <span class="keyword">add</span>         <span class="literal">eax</span>,<span class="number">4</span></span><br><span class="line">013F4495  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [pa],<span class="literal">eax</span></span><br><span class="line">(*pa)++<span class="comment">;</span></span><br><span class="line">013F4498  <span class="keyword">mov</span>         <span class="literal">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [pa]</span><br><span class="line">013F449B  <span class="keyword">mov</span>         <span class="literal">ecx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">eax</span>]</span><br><span class="line">013F449D  <span class="keyword">add</span>         <span class="literal">ecx</span>,<span class="number">1</span></span><br><span class="line">013F44A0  <span class="keyword">mov</span>         <span class="literal">edx</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [pa]</span><br><span class="line">013F44A3  <span class="keyword">mov</span>         <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">edx</span>],<span class="literal">ecx</span></span><br></pre></td></tr></table></figure>
<p>可以看到，首先把3放入地址为[a]的内存，然后把a的地址放入eax，最后把eax的值放入地址为[ra]的内存。实际上，就是把a的地址放入了ra里。而b和pa也同样是这样步骤。</p>
<p>然后再来看++操作的部分，在汇编的角度，引用和指针在内存中都是地址，在对指针指向的变量进行++时，需要手动的来进行解引用；但对于引用，解引用这个操作是编译器帮你完成了，只需要直接++即可。</p>
<p>从汇编的角度来看，引用是通过指针来实现的。</p>
<h1 id="u5B9E_u73B0_u5F15_u7528_u7C7B_u578B_u4E0E_u88AB_u5F15_u7528_u5BF9_u8C61_u5206_u79BB_3F"><a href="#u5B9E_u73B0_u5F15_u7528_u7C7B_u578B_u4E0E_u88AB_u5F15_u7528_u5BF9_u8C61_u5206_u79BB_3F" class="headerlink" title="实现引用类型与被引用对象分离?"></a>实现引用类型与被引用对象分离?</h1><p>C++中规定了引用在绑定到对象以后，就不能再绑定到另外一个对象，既然了解了C++中引用的底层的实现，能否通过底层的方法来绕过这个限制？答案是可以的。</p>
<p>先来看这么几行代码，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;  </span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;  </span><br><span class="line"><span class="keyword">int</span> &amp;ra = a;</span><br></pre></td></tr></table></figure>
<p>对ra进行的所有操作都是在与之绑定的变量a上进行的，因此直接操作ra来修改绑定是无法实现的。由于定义以上几个变量时，它们应该是处于相邻的内存空间中，因此可以通过ra相邻的内存，来更改ra，进而分离ra与被引用对象a。</p>
<p>这是在执行以上3条语句之后的内存情况，</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x0078F750  <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> 6c f7 78 00  ????<span class="keyword">l</span>?x.</span><br><span class="line">0x0078F758  <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span>  ????????</span><br><span class="line">0x0078F760  04 00 00 00 <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span>  ....????</span><br><span class="line">0x0078F768  <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> 03 00 00 00  ????....</span><br><span class="line">0x0078F770  <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> <span class="keyword">cc</span> 96 d1 e4 4e  ???????<span class="keyword">N</span></span><br><span class="line">0x0078F778  c8 f7 78 00 69 69 18 00  ??x.ii..</span><br></pre></td></tr></table></figure>
<p>其中EBP=其中EBP=0x007EFA7C，可以看到EBP之前的12byte的位置才是第一个变量，再往前12byte是第二个变量，继续往前12byte是引用。因此b的地址减3就是存储引用的内存，修改这个地方即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(&amp;b - <span class="number">3</span>) = (<span class="keyword">int</span>)&amp;b;</span><br><span class="line">ra++;</span><br></pre></td></tr></table></figure>
<p>继续执行下面代码以后，b被增加成5。</p>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><ol>
<li>C++ Primer 第5版</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[C++中，引用为对象起了另外一个名字，引用类型refers to另外一种类型。引用和指针是不同的，可以汇编的角度来看引用。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++中typedef的使用意图，以及类型安全]]></title>
    <link href="http://chaomai.github.io/2015/02/06/2015-2015-02-06-type-safe-typedef-in-cpp/"/>
    <id>http://chaomai.github.io/2015/02/06/2015-2015-02-06-type-safe-typedef-in-cpp/</id>
    <published>2015-02-06T15:06:00.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5173_u4E8Etypedef"><a href="#u5173_u4E8Etypedef" class="headerlink" title="关于typedef"></a>关于<code>typedef</code></h1><p>传统的<code>typedef</code>机制允许对已存在的type提供synonym或者alias，我们把这种的传统的<code>typedef</code>（包括c++11中的alias声明）描述为“透明类型机制”：这种声明引入了新的类型名称，但不是新的类型。被定义为新引入的alias的类型与被定义为原来类型的变量，完全一样，不会有一丁点行为上的差别。</p>
<h1 id="u95EE_u9898"><a href="#u95EE_u9898" class="headerlink" title="问题"></a>问题</h1><p>但是这种特性在某些场景下会有缺陷。</p>
<h2 id="u95EE_u98981"><a href="#u95EE_u98981" class="headerlink" title="问题1"></a>问题1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> score = <span class="keyword">unsigned</span>;</span><br><span class="line"><span class="function">score <span class="title">penalize</span><span class="params">(score n)</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">5u</span> ? n - <span class="number">5u</span> : score &#123; <span class="number">0u</span> &#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> serial_number = <span class="keyword">unsigned</span>;</span><br><span class="line"><span class="function">serial_number <span class="title">next_id</span><span class="params">(serial_number n)</span> </span>&#123; <span class="keyword">return</span> n + <span class="number">1u</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>使用新的alias可以很明显的了解以上代码的意图，但实际上这样的使用意图在错误使用alias的情况下，是无法保证的，或者说是不可实行的(unenforceable)。</p>
<p><code>unsigned</code>, <code>next_id</code>和<code>serial_number</code>是可以互换的。<code>penalize()</code>所penalize的不一定是<code>score</code>，也可以是<code>serial_number</code>。这样虽然编译器不会报错，但是代码没有意义。编码的时候如果错误的使用了alias，还会导致难以track的问题。</p>
<h2 id="u95EE_u98982"><a href="#u95EE_u98982" class="headerlink" title="问题2"></a>问题2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> sound_id;</span><br><span class="line"><span class="function">sound_id <span class="title">create_sound</span><span class="params">(...)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title">destroy_sound</span><span class="params">(sound_id id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> sprite_id;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_sprite</span><span class="params">(sprite_id)</span></span>;</span><br><span class="line"></span><br><span class="line">sound_id fx = create_sound(...);</span><br><span class="line">destroy_sprite(fx);  <span class="comment">// An honest mistake!</span></span><br></pre></td></tr></table></figure>
<p>这里的问题也是类似问题1。或许你可以认为自己能够小心的编码，来保证alias的正确使用，但是这种欺骗自己的想法，并不能100%的保证问题不会发生。If they can happen, they will happen!</p>
<h2 id="u95EE_u98983"><a href="#u95EE_u98983" class="headerlink" title="问题3"></a>问题3</h2><p>这个问题也是类似，但不仅仅会有误用的风险，同时还导致了类型系统的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> X, Y, Z; <span class="comment">// Cartesian 3D coordinate types</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Rho, Theta, Phi; <span class="comment">// spherical 3D coordinate types</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PhysicsVector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PhysicsVector(X, Y, Z);</span><br><span class="line">    PhysicsVector(Rho, Theta, Phi);</span><br><span class="line">    · · ·</span><br><span class="line">&#125;; <span class="comment">// PhysicsVector</span></span><br></pre></td></tr></table></figure>
<p>在上述例子中，<code>typedef</code>的大量使用实际上破坏了类型系统（问题域中的类型和构造函数中的类型）。笛卡尔坐标系的三个坐标值和球坐标系中的，虽然都是<code>double</code>，但明显意义是不一样的。尽管误用编译器不会报错，但是程序是有bug的。</p>
<p>另一个问题是，两个构造函数实际上就是一个，它接受三个<code>double</code>类型的参数。但这里的意图是，分别为两种坐标系建立构造函数。</p>
<h1 id="u89E3_u51B3"><a href="#u89E3_u51B3" class="headerlink" title="解决"></a>解决</h1><h2 id="opaque_type_28clang++_3-5-1_2C_g++4-8-2_u548CVS2013_u90FD_u4E0D_u652F_u6301_29"><a href="#opaque_type_28clang++_3-5-1_2C_g++4-8-2_u548CVS2013_u90FD_u4E0D_u652F_u6301_29" class="headerlink" title="opaque type(clang++ 3.5.1, g++4.8.2和VS2013都不支持)"></a>opaque type(clang++ 3.5.1, g++4.8.2和VS2013都不支持)</h2><p>引入opaque（不透明的） typedef，在发生误用时，由编译器来检查。</p>
<p>opaque typedef定义了一种新的类型，这种新的类型与它的underlying type不同，并且与它的underlying type是可区分的，同时还保证了与它的underlying type的layout compatibility。</p>
<h2 id="Type_tags"><a href="#Type_tags" class="headerlink" title="Type tags"></a>Type tags</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Tag, <span class="keyword">class</span> impl, impl default_value&gt;</span><br><span class="line"><span class="keyword">class</span> ID</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ID <span class="title">invalid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ID(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defaults to ID::invalid()</span></span><br><span class="line">    ID() : m_val(default_value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicit constructor:</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ID</span><span class="params">(impl val)</span> : <span class="title">m_val</span><span class="params">(val)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicit conversion to get back the impl:</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">impl</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_val; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(ID a, ID b) &#123; <span class="keyword">return</span> a.m_val == b.m_val; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(ID a, ID b) &#123; <span class="keyword">return</span> a.m_val != b.m_val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    impl m_val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个方法相当与简单的包装了一下。参数Tag其实并没有在模板里面使用，它的使用方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sound_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">typedef</span> ID&lt;sound_tag, <span class="keyword">int</span>, -<span class="number">1</span>&gt; sound_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> sprite_tag&#123;&#125;;</span><br><span class="line"><span class="keyword">typedef</span> ID&lt;sprite_tag, <span class="keyword">int</span>, -<span class="number">1</span>&gt; sprite_id;</span><br></pre></td></tr></table></figure>
<p>tag保证了<code>sound_id</code>和<code>sprite_id</code>是不同的type，换句话说，只要函数声明了不同了type，它们就不会被误用。</p>
<h2 id="BOOST_STRONG_TYPEDEF"><a href="#BOOST_STRONG_TYPEDEF" class="headerlink" title="BOOST_STRONG_TYPEDEF"></a><code>BOOST_STRONG_TYPEDEF</code></h2><p>如果使用boost库，那么boost提供了<code>BOOST_STRONG_TYPEDEF</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BOOST_STRONG_TYPEDEF(<span class="keyword">int</span>, a);</span><br><span class="line">BOOST_STRONG_TYPEDEF(T, D);</span><br></pre></td></tr></table></figure>
<p>这个宏为类型<code>T</code>创建了新的类型名<code>D</code>。</p>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="http://www.ilikebigbits.com/blog/2014/5/6/type-safe-identifiers-in-c" target="_blank" rel="external">Type safe handles in C++</a></p>
</li>
<li><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3741.pdf" target="_blank" rel="external">Toward Opaque Typedefs for C++1Y, v2</a></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[传统的`typedef`机制允许对已存在的type提供synonym或者alias，被定义为新引入的alias的类型与被定义为原来类型的变量，完全一样，不会有一丁点行为上的差别，但是这种特性在某些场景下会有缺陷。]]>
    
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[入手KBC Poker 2]]></title>
    <link href="http://chaomai.github.io/2014/12/11/2014-2014-12-11-kbc-poker-2-briefly-reivew/"/>
    <id>http://chaomai.github.io/2014/12/11/2014-2014-12-11-kbc-poker-2-briefly-reivew/</id>
    <published>2014-12-11T15:20:42.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="KBC_Poker_2"><a href="#KBC_Poker_2" class="headerlink" title="KBC Poker 2"></a>KBC Poker 2</h1><p>用倦Thindpad T420自带的键盘，也想尝试一下机械键盘的手感如何，就入手了一个机械键盘，KBC Poker 2。</p>
<p>入手Poker 2的原因不仅仅是Filco Minila Air和HHKB的价格有点高，还有一点吸引我的原因就是Poker 2支持全键位硬件可编程。</p>
<p>Poker 2已经是第二代了，相比起第一代，带来了许多的改进，网上的总结有这么几点：</p>
<blockquote><ul>
<li>保留了经典的US配列</li>
<li>增加了数控钢板，使得茶轴、青轴和红轴的手感大大增强，黑轴基本不变</li>
<li>内置7级亮度调节的DIY灯控支持，插上LED就会亮</li>
<li>全新加厚PBT键帽，带来目前最为细腻的PBT触感</li>
<li>增加了实用和进阶的附件六颗RGB加厚PBT套装和钢丝拔键器</li>
<li>换代的卫星轴进一步提升了手感，彻底让卫星轴翻身做主人</li>
<li>仍然保持一代的价格，加量完全不加价，499元</li>
<li>USB任意6键无冲</li>
<li>自带延时编程的全键位硬件可编程</li>
</ul>
</blockquote>
<p>键盘从淘宝上购买，只是中通快递，等得我整个人都不好了。。。</p>
<p>除了键盘外，还随带附送的配件：分离式可拆卸的USB数据线，一个钢丝拔键器，一套RGB的PBT材质键帽。换下原来的键帽，把六个RGB键帽装上以后，就是这样了。</p>
<img src="http://7vilyb.com1.z0.glb.clouddn.com/kbcpoker2openboxIMG_20150211_192835.jpg">
<p>因为是60%尺寸的设计，省去了方向键和其他的一些功能键，改用Fn的组合键和Pn的编程键实现相应的功能，因此键盘更加玲珑小巧、方便携带。在文章的后面会给出自己修改键位的办法。</p>
<img src="http://7vilyb.com1.z0.glb.clouddn.com/kbcpoker2openboxIMG_20150211_192808.jpg">
<p>键帽由于是PBT材质的，而且还是加厚的键帽，手感很不错，空格键上的”Enjoy your feeling”正是说明了这一点。</p>
<p>但是细节处的做工就不是那么精细了，键帽边缘有少许的毛刺。但我不是强迫症，平时使用根本看不见，So it doesn’t matter.</p>
<p>这次入手的Poker 2是茶轴的，网上茶轴的介绍如下：</p>
<blockquote><p>全面兼顾：茶轴</p>
<p>茶轴的手感比较均衡，也可说是较为中庸，带有段落感，触发键程为2.0mm。另外，其压力克数比较小，只有60g，敲击显得非常轻松，能兼顾打字和游戏使用。</p>
<p>敲击茶轴的感觉如同小范围内的极速轻金属碰撞，很神秘的那么一下，结合了青轴和黑轴的特点，或者看成它是最没有特点的一种特殊轴，这也是手感最类似于传统键盘的机械键盘，压力在黑轴和青轴中间。</p>
<p>它的段落感，你按下一个键后段落感可以给你确认感，同时压力不太大，适合那种瞬间飚快捷键的快手。</p>
</blockquote>
<p>由于没有使用过其他机械键盘，我只能和T420的键盘做对比。使用下来的感觉是，和T420的键盘相比，不需要多大的力量就可以触发，按下去的时候有段落感，触发段落感的力量也不大。用了Poker 2以后，感觉就是“回不去了。。。”。</p>
<img src="http://7vilyb.com1.z0.glb.clouddn.com/kbcpoker2openboxIMG_20150211_193448.jpg">
<p>USB数据线的接口，看着像micro USB的，但其实不是，有点像以前老式的好记星的接口。</p>
<img src="http://7vilyb.com1.z0.glb.clouddn.com/kbcpoker2openboxIMG_20150211_193043.jpg">
<p>背面有四个橡胶脚垫，不支持角度的调节，不过键盘正面的有弧度的设计，比较符合人体工程学，因此还是很舒适的。</p>
<img src="http://7vilyb.com1.z0.glb.clouddn.com/kbcpoker2openboxIMG_20150211_193117.jpg">
<p>这里就是DIP开关。最早见到这个DIP开关是在HHKB上，Poker 2的DIP开关与HHKB的还是有所区别的。记得当初关注HHKB并不是因为机械键盘的缘故，而是Caps和Control键可以互换，加上当时在Ubuntu下开发，所以一直眼馋HHKB，只是价格的原因，一直没入手。</p>
<img src="http://7vilyb.com1.z0.glb.clouddn.com/kbcpoker2openboxIMG_20150211_193231.jpg">
<h2 id="Poker_2_u603B_u7ED3"><a href="#Poker_2_u603B_u7ED3" class="headerlink" title="Poker 2总结"></a>Poker 2总结</h2><p>Poker 2使用了小尺寸的设计，精简了多余的按键，加上分离式可拆卸的USB，大大提升了便携性。总体来说，做工中规中矩，PBT加厚键帽，内置钢板，但不足的是小细节的地方，比如键帽的边缘。</p>
<h1 id="u952E_u4F4D_u4FEE_u6539"><a href="#u952E_u4F4D_u4FEE_u6539" class="headerlink" title="键位修改"></a>键位修改</h1><p>首先，用键盘编程在V键上，把Win键编程为：Pn+V。因为后面需要用开关把做Win改为左Fn，还有就是目前是在Windows下工作，Win键不可少，所以这里要提前设置Win的替代键位。</p>
<p>接下来，用键盘编程在L上，把Win+L键编程为：Pn+L；在，键上，把Win+Space编程为：Pn+，。其实这里不是必须的，我只是为了方便。</p>
<p>然后就是设置键盘后面的几个开关，背面的4个DIP开关的功能分别是：</p>
<ul>
<li>开关1：Caps与左Win切换</li>
<li>开关2：右Ctrl与`~切换</li>
<li>开关3：左Win与Fn切换</li>
<li>开关4：键盘写保护，键位编程</li>
</ul>
<p>将开关1和3都拨到ON的位置，效果：Caps变成了Fn，左Win变成了Caps。</p>
<p>到这里键位修改就完成了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="KBC_Poker_2"><a href="#KBC_Poker_2" class="headerlink" title="KBC Poker 2"></a>KBC Poker 2</h1><p>用倦Thindpad T420自带的键盘，也想尝试一下机械键盘的手感]]>
    </summary>
    
      <category term="keyboard" scheme="http://chaomai.github.io/tags/keyboard/"/>
    
      <category term="hardware" scheme="http://chaomai.github.io/categories/hardware/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ 初始化]]></title>
    <link href="http://chaomai.github.io/2014/02/17/2014-2014-02-17-cpp-initialization/"/>
    <id>http://chaomai.github.io/2014/02/17/2014-2014-02-17-cpp-initialization/</id>
    <published>2014-02-17T12:56:12.000Z</published>
    <updated>2016-02-15T17:38:45.475Z</updated>
    <content type="html"><![CDATA[<h1 id="u5217_u8868_u521D_u59CB_u5316_uFF08list_initialization_uFF09"><a href="#u5217_u8868_u521D_u59CB_u5316_uFF08list_initialization_uFF09" class="headerlink" title="列表初始化（list initialization）"></a>列表初始化（list initialization）</h1><p>注：对于内置类型的变量，如果使用列表初始化且初始化存在丢失信息的风险，则编译器将报错。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> i&#123;d&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u9ED8_u8BA4_u521D_u59CB_u5316_uFF08default_initialization_uFF09"><a href="#u9ED8_u8BA4_u521D_u59CB_u5316_uFF08default_initialization_uFF09" class="headerlink" title="默认初始化（default initialization）"></a>默认初始化（default initialization）</h1><p>如果定义变量时没有指定初值，则变量被默认初始化，具体值由变量类型决定。对象被默认初始化时自动执行默认构造函数。</p>
<h2 id="u4F55_u65F6_u53D1_u751F"><a href="#u4F55_u65F6_u53D1_u751F" class="headerlink" title="何时发生"></a>何时发生</h2><ul>
<li><p>当在块作用域中不使用任何初始值定义一个非静态变量或者数组时；</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">double</span> b[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个类本身含有类类型的成员且使用合成的默认构造函数时；</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  A a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当类类型的成员没有在构造函数初始值列表中显示地初始化时。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  A(<span class="keyword">int</span> a) : a_(a) &#123;&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="u503C_u521D_u59CB_u5316"><a href="#u503C_u521D_u59CB_u5316" class="headerlink" title="值初始化"></a>值初始化</h1><p>对于内置类型，则元素初始值自动设为0；如果是类类型，则由类来默认初始化。</p>
<h2 id="u4F55_u65F6_u53D1_u751F-1"><a href="#u4F55_u65F6_u53D1_u751F-1" class="headerlink" title="何时发生"></a>何时发生</h2><ul>
<li><p>在数组初始化时，提供的初始值的数量少于数组的大小；</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// a[] = &#123;1, 2, 3, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不使用初始值定义一个局部静态变量时；</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> s; <span class="comment">// s值为0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>T()</code>来显示地请求值初始化时;</p>
</li>
<li>使用列表初始化来初始化聚合类，列表中元素数量少于类的成员数量时，后续成员被值初始化。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Aggre &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Aggre aggre = &#123;<span class="number">1</span>&#125; <span class="comment">// d和c都是0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li><a href="https://www.zhihu.com/question/36735960" target="_blank" rel="external">C++值初始化，默认初始化，以及其他初始化类型的区别</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5217_u8868_u521D_u59CB_u5316_uFF08list_initialization_uFF09"><a href="#u5217_u8868_u521D_u59CB_u5316_uFF08list_initialization_uFF09]]>
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++IO库]]></title>
    <link href="http://chaomai.github.io/2014/02/16/2014-2014-02-16-cpp-io-library/"/>
    <id>http://chaomai.github.io/2014/02/16/2014-2014-02-16-cpp-io-library/</id>
    <published>2014-02-16T14:10:25.000Z</published>
    <updated>2016-02-15T17:38:25.285Z</updated>
    <content type="html"><![CDATA[<h1 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a><code>iostream</code></h1><h2 id="u6761_u4EF6_u72B6_u6001"><a href="#u6761_u4EF6_u72B6_u6001" class="headerlink" title="条件状态"></a>条件状态</h2><p><code>strm::iostate</code>是<strong>机器相关</strong>的位类型，用来标识流错误状态，有4个值，<code>strm::badbit</code>，<code>strm::failbit</code>，<code>strm::eofbit</code>和<code>strm::goodbit</code>。可用<code>ios::bad()</code>，<code>ios::fail()</code>，<code>ios::eof()</code>和<code>ios::good()</code>来得知各个flag是否置位；用<code>ios::rdstate()</code>来获取流的当前状态。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">badbit: <span class="number">0001</span></span><br><span class="line">failbit: <span class="number">0100</span></span><br><span class="line">eofbit: <span class="number">0010</span></span><br><span class="line">goodbit: <span class="number">0000</span></span><br></pre></td></tr></table></figure>
<p>不同的错误会导致不同的flag被置位，</p>
<ul>
<li>eof -&gt; eofbit，failbit</li>
<li>fail -&gt; failbit</li>
<li>bad -&gt; badbit，且fail()返回true</li>
</ul>
<p>用<code>ios::clear()</code>和<code>ios::setstate()</code>可以对flag进行置位，两者区别在于，<code>ios::clear()</code>会先将原先的所有flag先复位，而后者不会，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ios::setstate (iostate state) &#123;</span><br><span class="line">  clear(rdstate() | state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u8F93_u51FA_u7F13_u51B2"><a href="#u8F93_u51FA_u7F13_u51B2" class="headerlink" title="输出缓冲"></a>输出缓冲</h2><p>每个输出流都管理一个缓冲区。</p>
<h3 id="u7F13_u51B2_u5237_u65B0"><a href="#u7F13_u51B2_u5237_u65B0" class="headerlink" title="缓冲刷新"></a>缓冲刷新</h3><p>即数据真正写到输出设备或文件，会有以下原因，</p>
<ul>
<li>程序正常结束，main函数return；</li>
<li>缓冲区满，需要刷新才能写入后续数据；</li>
<li>使用操纵符；<ul>
<li><code>endl</code>：换行并刷新缓冲区；</li>
<li><code>flush</code>：刷新缓冲区，不附加任何额外字符；</li>
<li><code>ends</code>：附加一个空字符，刷新缓冲区。</li>
</ul>
</li>
<li><code>unitbuf</code>和<code>nounitbuf</code>；<br>  使用<code>unitbuf</code>后，接下来的每次写操作都进行一次flush；使用<code>nounitbuf</code>返回正常的缓冲方式。</li>
<li>关联输入流和输出流。<br>  关联一个输入流到输出流时，从输入流读取数据，会先刷新关联的输出流，<code>cin</code>和<code>cout</code>是被关联的。使用<code>tie</code>进行关联。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tie的两个重载版本</span></span><br><span class="line"><span class="comment">// 两个版本都返回已经tied ostream，如果没有，则返回nullptr</span></span><br><span class="line">ostream* os = <span class="built_in">cin</span>.tie();</span><br><span class="line">(*os) &lt;&lt; <span class="string">"tie version 1"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ostream* old_os = <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">ostream* null_os = <span class="built_in">cin</span>.tie();</span><br><span class="line">(*old_os) &lt;&lt; <span class="string">"tie version 2"</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; (old_os == &amp;<span class="built_in">cout</span>) &lt;&lt; <span class="string">"\n"</span> &lt;&lt; (null_os == <span class="literal">nullptr</span>) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="comment">// 此时上面的两个true并不会输出</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h1 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a><code>fstream</code></h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op1=&#62;operation: iostream&#10;op2=&#62;operation: fstream&#10;&#10;op2(right)-&#62;op1</span><br></pre></td></tr></table></figure>
<p>继承自<code>iostream</code>，</p>
<ul>
<li>接受一个<code>iostream</code>类型引用或指针参数的函数，可用一个对应的<code>fstream</code>类型来调用；</li>
<li>支持<code>iostream</code>的所有操作。</li>
</ul>
<p><code>fstream</code>也有自己特有的行为和操作，</p>
<ul>
<li><code>fstream::fstream(s)</code>：创建对象并打开文件<code>s</code>；</li>
<li><code>fstream::open()</code>：打开文件，并与<code>fstream</code>对象关联；</li>
<li><code>fstream::close()</code>：关闭与<code>fstream</code>对象关联的文件；</li>
<li><code>fstream::is_open()</code>：与<code>fstream</code>对象关联的文件是否成功打开，且未关闭；</li>
<li>对于已打开的<code>fstream</code>对象，再次<code>open()</code>会失败；</li>
<li><p><code>open()</code>失败-&gt;failbit；</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (ifs) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当<code>fstream</code>对象被销毁，<code>close()</code>会被自动调用。</p>
</li>
</ul>
<h2 id="u6587_u4EF6_u6A21_u5F0F"><a href="#u6587_u4EF6_u6A21_u5F0F" class="headerlink" title="文件模式"></a>文件模式</h2><p>对于<code>ofstream</code>，</p>
<ul>
<li>未指定打开模式时，以<code>out</code>打开；</li>
<li>通常<code>out</code>意味着同时使用<code>trunc</code>；</li>
<li><code>app</code>不能与<code>trunc</code>同时设置；</li>
<li><code>app</code>和<code>ate</code>；<ul>
<li><code>app</code>，所有的输出操作都在文件末尾，不能seek around；</li>
<li><code>ate</code>，初始位置在文件末尾，可以seed around。</li>
</ul>
</li>
</ul>
<h1 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a><code>sstream</code></h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op1=&#62;operation: iostream&#10;op2=&#62;operation: sstream&#10;&#10;op2(right)-&#62;op1</span><br></pre></td></tr></table></figure>
<p>类似<code>fstream</code>，<code>sstream</code>也包含特有的操作，</p>
<ul>
<li><code>sstream::sstream(s)</code>：创建对象，并保存<code>s</code>的copy；</li>
<li><code>sstream::str()</code>：返回保存的string的copy；</li>
<li><code>sstream::str(s)</code>：copy<code>s</code>到对象中。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a><code>iostream</code></h1><h2 id="u6761_u4EF6_u72B6_u6001"><a ]]>
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++Primer - 第1章 开始]]></title>
    <link href="http://chaomai.github.io/2014/02/06/2014-2014-02-06-cpp-primer-ch1/"/>
    <id>http://chaomai.github.io/2014/02/06/2014-2014-02-06-cpp-primer-ch1/</id>
    <published>2014-02-06T15:06:00.000Z</published>
    <updated>2015-07-14T14:28:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u7F13_u51B2_u533A_uFF08bufer_uFF09"><a href="#u7F13_u51B2_u533A_uFF08bufer_uFF09" class="headerlink" title="缓冲区（bufer）"></a>缓冲区（bufer）</h1><p>一个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的。我们可以显式地刷新输出缓冲，以便强制将缓冲区中的数据写入输出设备。默认情况下，读cin会刷新cout；程序非正常终止时也会刷新cout。</p>
<h1 id="cerr"><a href="#cerr" class="headerlink" title="cerr"></a>cerr</h1><p>一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到cerr的数据是不缓冲的。cerr通常用于输出错误信息或其他不属于程序正常逻辑的输出内容。</p>
<h1 id="u7C7B_uFF08class_uFF09"><a href="#u7C7B_uFF08class_uFF09" class="headerlink" title="类（class）"></a>类（class）</h1><p>一种定义自己的数据结构及其相关操作的机制。</p>
<h1 id="u7C7B_u7C7B_u578B_uFF08class_type_uFF09"><a href="#u7C7B_u7C7B_u578B_uFF08class_type_uFF09" class="headerlink" title="类类型（class type）"></a>类类型（class type）</h1><p>类定义的类型。类名即为类型名。</p>
<h1 id="clog"><a href="#clog" class="headerlink" title="clog"></a>clog</h1><p>一个ostream对象，关联到标准错误。默认情况下，写到clog的数据是被缓冲的。clog通常用于报告称程序的执行信息，存入一个日志文件中。</p>
<p>未初始化的变量（uninitialized variable）</p>
<p>未赋予初值的变量。类类型的变量如果未指定初值，则按类定义指定的方式进行初始化。定义在函数内部的内置类型变量默认是不初始化的，除非有显式的初始化语句。</p>
<h1 id="u53D8_u91CF_uFF08variable_uFF09"><a href="#u53D8_u91CF_uFF08variable_uFF09" class="headerlink" title="变量（variable）"></a>变量（variable）</h1><p>具名对象。</p>
<h1 id="28_29_u8FD0_u7B97_u7B26_uFF08_28_29opeartor_uFF09"><a href="#28_29_u8FD0_u7B97_u7B26_uFF08_28_29opeartor_uFF09" class="headerlink" title="()运算符（()opeartor）"></a>()运算符（()opeartor）</h1><p>调用运算符。跟随在函数名字之后的一对括号“()”，起到调用函数的效果，传递给函数的实参放置在括号内。</p>
<h1 id="u8FD0_u7B97_u7B26_uFF08-operator_uFF09"><a href="#u8FD0_u7B97_u7B26_uFF08-operator_uFF09" class="headerlink" title=".运算符（.operator）"></a>.运算符（.operator）</h1><p>点运算符。左侧运算符必须是一个类类型对象，右侧运算对象必须是此对象的一个成员的名字。运算结果即为该对象的这个成员。</p>
<h1 id="3A_3A_u8FD0_u7B97_u7B26_uFF08_3A_3Aoperator_uFF09"><a href="#3A_3A_u8FD0_u7B97_u7B26_uFF08_3A_3Aoperator_uFF09" class="headerlink" title="::运算符（::operator）"></a>::运算符（::operator）</h1><p>作用域运算符。其用处之一是访问命名空间中的名字。</p>
<h1 id="26lt_3B_26lt_3B_u548C_26gt_3B_26gt_3B_u8FD0_u7B97_u7B26_uFF08_26lt_3B_26gt_3Boperator_uFF09"><a href="#26lt_3B_26lt_3B_u548C_26gt_3B_26gt_3B_u8FD0_u7B97_u7B26_uFF08_26lt_3B_26gt_3Boperator_uFF09" class="headerlink" title="&lt;&lt;和&gt;&gt;运算符（&lt;&gt;operator）"></a>&lt;&lt;和&gt;&gt;运算符（&lt;<operator,>&gt;operator）</operator,></h1><p>输出和输入运算符。它们的计算结果均是其左侧的运算对象。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7F13_u51B2_u533A_uFF08bufer_uFF09"><a href="#u7F13_u51B2_u533A_uFF08bufer_uFF09" class="headerlink" title="缓冲区（bufer）"></a>缓冲区（bufe]]>
    </summary>
    
      <category term="c++" scheme="http://chaomai.github.io/tags/c/"/>
    
      <category term="programming" scheme="http://chaomai.github.io/categories/programming/"/>
    
  </entry>
  
</feed>
