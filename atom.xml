<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chaomai&#39;s blog</title>
  
  
  <link href="https://chaomai.github.io/atom.xml" rel="self"/>
  
  <link href="https://chaomai.github.io/"/>
  <updated>2021-06-27T14:57:29.289Z</updated>
  <id>https://chaomai.github.io/</id>
  
  <author>
    <name>Chao Mai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Thread</title>
    <link href="https://chaomai.github.io/2021/2021-05-21-thread/"/>
    <id>https://chaomai.github.io/2021/2021-05-21-thread/</id>
    <published>2021-05-20T16:27:00.000Z</published>
    <updated>2021-06-27T14:57:29.289Z</updated>
    
    <content type="html"><![CDATA[<p><a id="orge6dba39"></a></p><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><p><a id="org651ceca"></a></p><h2 id="Thread-Model"><a href="#Thread-Model" class="headerlink" title="Thread Model"></a>Thread Model</h2><ol><li>LinuxThreads<ul><li>  Default thread implementation since Linux kernel 2.0</li><li>  Obsolete</li></ul></li><li>Next Generation POSIX Thread （NGPT）<ul><li>  IBM developed version of POSIX thread library</li><li>  Abandoned</li></ul></li><li>Native POSIX Thread Library（NPTL）<ul><li>  Developed by RedHat</li><li>  Better performance and scalability than LinuxThreads</li><li>  Since Linux Kernel 2.6, glibc 2.3.5</li></ul></li></ol><p><a id="orgf062b6e"></a></p><h2 id="Memory-Layout"><a href="#Memory-Layout" class="headerlink" title="Memory Layout"></a>Memory Layout</h2><ul><li>  Heap：被所有线程共享。</li><li>  Stack：每个线程都有自己独立的 stack。</li></ul><p><a id="orgb5aaed5"></a></p><h3 id="Thread-Stack"><a href="#Thread-Stack" class="headerlink" title="Thread Stack"></a>Thread Stack</h3><p><img data-src="/images/2021/05/20210526_230935Snipaste_2021-05-26_23-09-07.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">low  ┌──────────┐</span><br><span class="line">     │...       │ ─┐                  ─┐</span><br><span class="line">     ├──────────┤  │                   │</span><br><span class="line">     │list      │  │                   │</span><br><span class="line">     ├──────────┤  ├─►pthread struct   │</span><br><span class="line">     │tid       │  │                   │</span><br><span class="line">     ├──────────┤  │                   │</span><br><span class="line">     │...       │ ─┘                   │</span><br><span class="line">     ├──────────┤                      ├─►thread 1</span><br><span class="line">     │          │                      │</span><br><span class="line">     │stack     │                      │</span><br><span class="line">     │          │                     ─┘</span><br><span class="line">     ├──────────┤</span><br><span class="line">     │          │ ───►stack guard(4k)</span><br><span class="line">     ├──────────┤</span><br><span class="line">     │...       │ ─┐</span><br><span class="line">     ├──────────┤  │</span><br><span class="line">     │list      │  │</span><br><span class="line">     ├──────────┤  │</span><br><span class="line">     │tid       │  │</span><br><span class="line">     ├──────────┤  │</span><br><span class="line">     │...       │  │</span><br><span class="line">     ├──────────┤  ├─►thread 2</span><br><span class="line">     │          │  │</span><br><span class="line">     │stack     │  │</span><br><span class="line">     │          │ ─┘</span><br><span class="line">high └──────────┘</span><br></pre></td></tr></table></figure><p><a id="org6351cb5"></a></p><h3 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h3><ol><li><p>Implementation</p><p> 线程栈分配逻辑如下（基于 glibc 2.29.9000），</p><ol><li><p><code>__pthread_create_2_1</code> 创建 thread 时，调用 <code>ALLOCATE_STACK</code> 宏创建 Thread stack。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_create_2_1 (<span class="keyword">pthread_t</span> *newthread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span><br><span class="line">                      <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> err = ALLOCATE_STACK (iattr, &amp;pd);</span><br><span class="line">  <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ALLOCATE_STACK</code> 宏调用 <code>allcate_stack</code> 来执行具体的创建逻辑。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">allocate_stack (<span class="keyword">const</span> struct pthread_attr *attr, struct pthread **pdp,</span><br><span class="line">                ALLOCATE_STACK_PARMS)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 从 cache 中查找空闲的栈内存</span></span><br><span class="line">  pd = get_cached_stack (&amp;size, &amp;mem);</span><br><span class="line">  <span class="comment">// 没有空闲的则 mmap 创建</span></span><br><span class="line">  <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      mem = __mmap (<span class="literal">NULL</span>, size, (guardsize == <span class="number">0</span>) ? prot : PROT_NONE,</span><br><span class="line">                    MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">/* Allocate the DTV for this thread.  */</span></span><br><span class="line">      _dl_allocate_tls (TLS_TPADJ (pd));</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">/* Prepare to modify global data.  */</span></span><br><span class="line">      lll_lock (stack_cache_lock, LLL_PRIVATE);</span><br><span class="line">      <span class="comment">/* And add to the list of stacks in use.  */</span></span><br><span class="line">      <span class="comment">// 将 stack 内存挂到 stack_used list 中</span></span><br><span class="line">      stack_list_add (&amp;pd-&gt;<span class="built_in">list</span>, &amp;stack_used);</span><br><span class="line">      lll_unlock (stack_cache_lock, LLL_PRIVATE);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 更新全局栈内存指针</span></span><br><span class="line">  *<span class="built_in">stack</span> = pd-&gt;stackblock;</span><br><span class="line">  *stacksize = stacktop - *<span class="built_in">stack</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><a id="org6d6ae77"></a></p><h1 id="Thread-Local-Storage"><a href="#Thread-Local-Storage" class="headerlink" title="Thread-Local Storage"></a>Thread-Local Storage</h1><p>Thread-local storage（TLS）提供了一种机制，使得每个 thread 都拥有一份变量的实例，对 TLS 中变量进行的修改仅对当前 thread 可见。</p><p><a id="org4131fc9"></a></p><h2 id="Common-Implementation"><a href="#Common-Implementation" class="headerlink" title="Common Implementation"></a>Common Implementation</h2><ol><li> pthread：thread-specific data （TSD）</li><li>ELF（Executable and Linkable Format） TLS<ul><li>  gcc： <code>__thread</code></li><li>  c11： <code>_Thread_local</code></li><li>  c++11： <code>thread_local</code></li></ul></li></ol><p><a id="org2a0f8a1"></a></p><h2 id="Example-Usages"><a href="#Example-Usages" class="headerlink" title="Example Usages"></a>Example Usages</h2><ol><li><p>adext <code>ThreadData</code> 主要用于存储 iconf ctx，确保每个 thread 使用自己的 ctx 来 merge cgi 下发的实验配置。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __thread ThreadData* s_td = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadData</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ThreadData();</span><br><span class="line">        ~ThreadData();</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">set_request_info</span><span class="params">(<span class="keyword">int</span> bucketid,bs::RankFrontendResp *admergeResult)</span></span>;</span><br><span class="line">    </span><br><span class="line">        ::<span class="function">iconf::Context* <span class="title">get_context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _ctx;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        ::iconf::Context* _ctx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>jemalloc 使用 TLS 来保存每个线程特有的数据，避免锁竞争。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>malloc_tsd_data(a_attr, a_name, a_type, a_initializer)\</span></span><br><span class="line">a_attr __thread a_type JEMALLOC_TLS_MODEL\</span><br><span class="line">    a_name##tsd_tls = a_initializer;\</span><br><span class="line">a_attr <span class="keyword">pthread_key_t</span>a_name##tsd_tsd;\</span><br><span class="line">a_attr <span class="keyword">bool</span>a_name##tsd_booted = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>POSIX <code>errno</code></p><blockquote><p>errno is thread-local; setting it in one thread does not affect its value in any other thread.</p></blockquote></li></ol><p><a id="orgcbc4191"></a></p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p><a id="org5c2cc58"></a></p><h2 id="pthread：thread-specific-data-（TSD）"><a href="#pthread：thread-specific-data-（TSD）" class="headerlink" title="pthread：thread-specific data （TSD）"></a>pthread：thread-specific data （TSD）</h2><p><a id="orgda2c1a7"></a></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> tsd_key;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_memory</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(arg);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">run</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *d = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(arg);</span><br><span class="line">    <span class="keyword">void</span> *p = pthread_getspecific(tsd_key);</span><br><span class="line">    assert(p == <span class="literal">nullptr</span>);</span><br><span class="line">    p = <span class="keyword">new</span> <span class="keyword">int</span>(*d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pa = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line">    *pa += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = pthread_setspecific(tsd_key, p);</span><br><span class="line">    assert(err == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid = pthread_self();</span><br><span class="line">    p = pthread_getspecific(tsd_key);</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">&quot; in thread &quot;</span> &lt;&lt; tid &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = pthread_key_create(&amp;tsd_key, free_memory);</span><br><span class="line">    assert(err == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid[<span class="number">0</span>], <span class="literal">nullptr</span>, run, &amp;data[<span class="number">0</span>]);</span><br><span class="line">    pthread_create(&amp;tid[<span class="number">1</span>], <span class="literal">nullptr</span>, run, &amp;data[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid[<span class="number">0</span>], <span class="literal">nullptr</span>);</span><br><span class="line">    pthread_join(tid[<span class="number">1</span>], <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_key_delete(tsd_key);</span><br><span class="line">    assert(err == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 25 in thread 139672264689408</span></span><br><span class="line"><span class="comment">// 15 in thread 139672273082112</span></span><br></pre></td></tr></table></figure><p><a id="org64eec1c"></a></p><h3 id="Memory-Layout-1"><a href="#Memory-Layout-1" class="headerlink" title="Memory Layout"></a>Memory Layout</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> low ┌─────────────────┐</span><br><span class="line">     │header           │ ───►tcbhead_t struct ─┐</span><br><span class="line">     ├─────────────────┤                       │</span><br><span class="line">     │list             │                       │                     ─┐</span><br><span class="line">     ├─────────────────┤                       │                      │</span><br><span class="line">     │tid              │                       │                      │</span><br><span class="line">     ├─────────────────┤                       ├─►pthread struct      │</span><br><span class="line">     │specific_1stblock│                       │                      │</span><br><span class="line">     ├─────────────────┤                       │                      │</span><br><span class="line">     │specific         │                       │                      │</span><br><span class="line">     ├─────────────────┤                       │                      ├─►thread 1</span><br><span class="line">     │...              │                      ─┘                      │</span><br><span class="line">     ├─────────────────┤                                              │</span><br><span class="line">     │                 │                                              │</span><br><span class="line">     │stack            │                                              │</span><br><span class="line">     │                 │                                             ─┘</span><br><span class="line">     ├─────────────────┤</span><br><span class="line">     │                 │ ───►stack guard(4k)</span><br><span class="line">     ├─────────────────┤</span><br><span class="line">     │header           │ ─┐</span><br><span class="line">     ├─────────────────┤  │</span><br><span class="line">     │list             │  │</span><br><span class="line">     ├─────────────────┤  │</span><br><span class="line">     │tid              │  │</span><br><span class="line">     ├─────────────────┤  │</span><br><span class="line">     │...              │  │</span><br><span class="line">     ├─────────────────┤  ├─►thread 2</span><br><span class="line">     │                 │  │</span><br><span class="line">     │stack            │  │</span><br><span class="line">     │                 │ ─┘</span><br><span class="line">high └─────────────────┘</span><br></pre></td></tr></table></figure><p><a id="orgb0c1f4d"></a></p><h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><ol><li> 全局分配唯一 key</li><li> 各个 thread 存储自己的 key-value map</li></ol><p>以下分析基于 glibc 2.29.9000。</p><ol><li><p>如何访问 Thread Stack</p><p> TSD 是存储在各个线程的内存中，要访问 TSD，就需要一种方法来访问线程栈。</p><p> glibc 通过调用 <code>clone</code> 实现创建线程。如果提供了 <code>CLONE_SETTLS</code> ，那么会将 <code>tls</code> 存入 fs 寄存器。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *<span class="built_in">stack</span>, <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="comment">/* pid_t *parent_tid, void *tls, pid_t *child_tid */</span> )</span></span>;</span><br></pre></td></tr></table></figure><p> 在调用 <code>clone</code> 时， <code>tls</code> 是 <code>struct pthread</code> 的地址。从而可以通过 fs 寄存器来访问到线程栈。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TLS_DEFINE_INIT_TP (tp, pd);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (ARCH_CLONE (&amp;start_thread, STACK_VARIABLES_ARGS,</span><br><span class="line">                                  clone_flags, pd, &amp;pd-&gt;tid, tp, &amp;pd-&gt;tid)</span><br><span class="line">                      == <span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p> glibc，以及各种 TLS 实现中对线程栈的访问都是利用 fs 实现的。</p><p> fs 寄存器可以通过如下方式获得：</p><ol><li><p><code>arch_prctl</code></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch_prctl(ARCH_GET_FS, &amp;pthread_addr);</span><br></pre></td></tr></table></figure></li><li><p>asm %fs</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_SELF \</span></span><br><span class="line">  (&#123; struct pthread *__self;                                                      \</span><br><span class="line">     <span class="keyword">asm</span> (<span class="string">&quot;mov %%fs:%c1,%0&quot;</span> : <span class="string">&quot;=r&quot;</span> (__self)                                      \</span><br><span class="line">          : <span class="string">&quot;i&quot;</span> (offsetof (struct pthread, header.self)));                       \</span><br><span class="line">     __self;&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">self</span>;</span></span><br><span class="line">self = THREAD_SELF;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Create</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_KEYS_MAX        1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">pthread_key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread-local data handling.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_key_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Sequence numbers.  Even numbers indicated vacant entries.  Note</span></span><br><span class="line"><span class="comment">     that zero is even.  We use uintptr_t to not require padding on</span></span><br><span class="line"><span class="comment">     32- and 64-bit machines.  On 64-bit machines it helps to avoid</span></span><br><span class="line"><span class="comment">     wrapping, too.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> seq;</span><br><span class="line">  <span class="comment">/* Destructor for the data.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*destr) (<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_key_struct</span> __<span class="title">pthread_keys</span>[<span class="title">PTHREAD_KEYS_MAX</span>]</span></span><br></pre></td></tr></table></figure><p> 在主线程中调用 <code>pthread_key_create</code> 完成 key 的创建。glibc 定义了全局数组 <code>__pthread_keys</code> 来管理 key，每个进程最多创建 1024 个 key。</p><p> 数组中每个元素的：</p><ol><li><p> <code>seq</code> 用于判断 key 是否被使用，为奇数则被使用</p></li><li><p><code>destr</code> 用于存储释放资源的函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_UNUSED(p) (((p) &amp; 1) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_key_create (<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (*destr) (<span class="keyword">void</span> *))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Find a slot in __pthread_keys which is unused.  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> cnt = <span class="number">0</span>; cnt &lt; PTHREAD_KEYS_MAX; ++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">          <span class="comment">/* Remember the destructor.  */</span></span><br><span class="line">          __pthread_keys[cnt].destr = destr;</span><br><span class="line">          <span class="comment">/* Return the key to the caller.  */</span></span><br><span class="line">          *key = cnt;</span><br><span class="line">          <span class="comment">/* The call succeeded.  */</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Set</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_KEY_2NDLEVEL_SIZE       32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_KEY_1STLEVEL_SIZE \</span></span><br><span class="line">  ((PTHREAD_KEYS_MAX + PTHREAD_KEY_2NDLEVEL_SIZE - <span class="number">1</span>) \</span><br><span class="line">   / PTHREAD_KEY_2NDLEVEL_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_key_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Sequence number.  We use uintptr_t to not require padding on</span></span><br><span class="line"><span class="comment">     32- and 64-bit machines.  On 64-bit machines it helps to avoid</span></span><br><span class="line"><span class="comment">     wrapping, too.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> seq;</span><br><span class="line">  <span class="comment">/* Data pointer.  */</span></span><br><span class="line">  <span class="keyword">void</span> *data;</span><br><span class="line">&#125; specific_1stblock[PTHREAD_KEY_2NDLEVEL_SIZE];</span><br><span class="line"><span class="comment">/* Two-level array for the thread-specific data.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_key_data</span> *<span class="title">specific</span>[<span class="title">PTHREAD_KEY_1STLEVEL_SIZE</span>];</span></span><br></pre></td></tr></table></figure><p> 各个线程将 key-value 存储到线程栈中，</p><ol><li><p> 如果 key &lt; 32，到存储到 <code>specific_1stblock</code></p></li><li><p>如果 32 &lt;= key &lt; 1024，存储到二维数组 <code>specific</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_setspecific (<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">self</span>;</span></span><br><span class="line">  self = THREAD_SELF;</span><br><span class="line">  <span class="comment">/* Special case access to the first 2nd-level block.  This is the</span></span><br><span class="line"><span class="comment">     usual case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (key &lt; PTHREAD_KEY_2NDLEVEL_SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      level2 = &amp;self-&gt;specific_1stblock[key];</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;</span><br><span class="line">      idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">/* This is the second level array.  Allocate it if necessary.  */</span></span><br><span class="line">      level2 = THREAD_GETMEM_NC (self, specific, idx1st);</span><br><span class="line">      <span class="keyword">if</span> (level2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 分配 specific 二维数组</span></span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/* Pointer to the right array element.  */</span></span><br><span class="line">      level2 = &amp;level2[idx2nd];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* Store the data and the sequence number so that we can recognize</span></span><br><span class="line"><span class="comment">     stale data.  */</span></span><br><span class="line">  level2-&gt;seq = seq;</span><br><span class="line">  level2-&gt;data = (<span class="keyword">void</span> *) value;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Get</p><p> 根据 key 的取值范围，决定访问 <code>specific_1stblock</code> ，还是 <code>specific</code> 。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__pthread_getspecific (<span class="keyword">pthread_key_t</span> key)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (key &lt; PTHREAD_KEY_2NDLEVEL_SIZE))</span><br><span class="line">    data = &amp;THREAD_SELF-&gt;specific_1stblock[key];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> idx1st = key / PTHREAD_KEY_2NDLEVEL_SIZE;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> idx2nd = key % PTHREAD_KEY_2NDLEVEL_SIZE;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      data = &amp;level2[idx2nd];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *result = data-&gt;data;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Delete</p><p> <code>pthread_key_delete</code> 会把 seq++，置为偶数，表示 key 为被使用，并不会真正的调用 <code>destr</code> 来进行资源的释放。</p><p> 当线程执行完毕时， <code>__nptl_deallocate_tsd</code> 调用每个 key 的 <code>destr</code> 执行清理。</p></li></ol><p><a id="orgc89cd55"></a></p><h2 id="ELF-TLS"><a href="#ELF-TLS" class="headerlink" title="ELF TLS"></a>ELF TLS</h2><p>pthread TSD 全局分配 key，需要调用 glibc API 在运行时完成 TSD 的构造和使用，比较复杂，影响效率。因此就有了 ELF TLS。</p><p>ELF TLS 是编译器（gcc/clang）的扩展特性，其实现需要如下方面的支持：</p><ol><li> ELF 文件需要区分普通静态全局变量和 TLS 变量</li><li> 程序启动时，动态链接器需要初始化 TLS 变量的段</li><li> 线程运行时，需要为 TLS 分配专门的内存区域，以及动态计算 TLS 的地址</li></ol><p><a id="org5d56054"></a></p><h3 id="ELF-TLS-Section"><a href="#ELF-TLS-Section" class="headerlink" title="ELF TLS Section"></a>ELF TLS Section</h3><p>普通 <code>static</code> 全局变量，根据是否初始化分别存储在 <code>.data</code> （已初始化）和 <code>.bss</code> （未初始化，初始化为 0），类似的 TLS 变量存储在 <code>.tdata</code> 和 <code>.tbss</code> 段。</p><p>由于 TLS 是各个线程私有的数据，因此线程是不能直接访问 <code>.tdata</code> 和 <code>.tbss</code> 段的。</p><p><a id="orgd6638a0"></a></p><h3 id="运行时分配-TLS"><a href="#运行时分配-TLS" class="headerlink" title="运行时分配 TLS"></a>运行时分配 TLS</h3><ol><li><p>Memory Layout</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> low ┌──────┬──────────┐</span><br><span class="line">     │      │...       │ ─┐                     ─┐</span><br><span class="line">     │      ├──────────┤  │                      │</span><br><span class="line">     │header│dtv       │  │                      │</span><br><span class="line">     │      ├──────────┤  │                      │</span><br><span class="line">     │      │...       │  │                      │</span><br><span class="line">     ├──────┴──────────┤  ├─►pthread <span class="class"><span class="keyword">struct</span>      │</span></span><br><span class="line"><span class="class">     │<span class="title">list</span>             │  │                      │</span></span><br><span class="line"><span class="class">     ├─────────────────┤  │                      │</span></span><br><span class="line"><span class="class">     │<span class="title">tid</span>              │  │                      │</span></span><br><span class="line"><span class="class">     ├─────────────────┤  │                      ├─►<span class="title">thread</span> 1</span></span><br><span class="line"><span class="class">     │...              │  │                      │</span></span><br><span class="line"><span class="class">     ├─────────────────┤  │                      │</span></span><br><span class="line"><span class="class">     │...              │ ─┘                      │</span></span><br><span class="line"><span class="class">     ├─────────────────┤                         │</span></span><br><span class="line"><span class="class">     │                 │                         │</span></span><br><span class="line"><span class="class">     │<span class="title">stack</span>            │                         │</span></span><br><span class="line"><span class="class">     │                 │                        ─┘</span></span><br><span class="line"><span class="class">     ├─────────────────┤</span></span><br><span class="line"><span class="class">     │                 │ ───►<span class="title">stack</span> <span class="title">guard</span>(4<span class="title">k</span>)</span></span><br><span class="line"><span class="class">     ├─────────────────┤</span></span><br><span class="line"><span class="class">     │<span class="title">header</span>           │ ─┐</span></span><br><span class="line"><span class="class">     ├─────────────────┤  │</span></span><br><span class="line"><span class="class">     │<span class="title">list</span>             │  │</span></span><br><span class="line"><span class="class">     ├─────────────────┤  │</span></span><br><span class="line"><span class="class">     │<span class="title">tid</span>              │  │</span></span><br><span class="line"><span class="class">     ├─────────────────┤  │</span></span><br><span class="line"><span class="class">     │...              │  │</span></span><br><span class="line"><span class="class">     ├─────────────────┤  ├─►<span class="title">thread</span> 2</span></span><br><span class="line"><span class="class">     │                 │  │</span></span><br><span class="line"><span class="class">     │<span class="title">stack</span>            │  │</span></span><br><span class="line"><span class="class">     │                 │ ─┘</span></span><br><span class="line"><span class="class"><span class="title">high</span> └─────────────────┘</span></span><br></pre></td></tr></table></figure><p> TLS 的内存布局用两种，对于 x86-64 是如下布局，</p><p> <img data-src="/images/2021/05/Snipaste_2021-05-27_23-24-12.png" alt="img"></p><p> tp（thread pointer，也是前面提到的 fs 寄存器的值） 指向 TCB，也就是 pthread struct，TCB 包含了一个 dtv（dynamic thread vector）指针，指向线程的 dtv 数组。</p><p> dtv 存储了 TLS block 地址，通过 module ID 和 TLS 变量的偏移量来实现 TLS 变量的寻址。对于 exec，module ID 是 1；动态库（ <code>dlopen</code> ）的 module ID 直到加载的时候才会分配。</p><p> 根据 TLS 变量在何处被定义，其存储分为，</p><ol><li> 来自 exec、以及 shared object： <code>main</code> 函数之前加载的 TLS 变量存储在 TCB 前面的 TLS block。dtv[1] 指向这个 TLS block。</li><li> <code>dlopen</code> 加载的 shared object：TLS 变量在 TLS Blocks for Dynamically-Loaded Modules。</li></ol></li><li><p>Allocate</p><p> 程序启动时，动态链接器将 exec、shared object 映射到进程地址空间，并进行相关初始化，</p><ol><li> 可能会对这两个段进行重定位，并把重定位后的段保存为 TLS 初始化镜像，之后便不再改动</li><li> 调用 <code>_dl_determine_tlsoffset</code> 获得每个 module 中 TLS 变量的 offset（在编译的时候决定），offset 表示变量在 TLS block 中的偏移量</li><li> 调用 <code>_dl_allocate_tls_storage</code> 分配 TLS 和 dtv 的内存</li><li> 调用 <code>_dl_allocate_tls_init</code> 完成 TLS 和 dtv 的初始化</li></ol></li><li><p>Implementation</p><ol><li><p>前面提到线程启动时， <code>ALLOCATE_STACK</code> 宏调用 <code>allcate_stack</code> 来执行创建线程栈的逻辑，其中调用 <code>_dl_allocate_tls</code> 是进行 TLS 和 dtv 的分配以及初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">allocate_stack (<span class="keyword">const</span> struct pthread_attr *attr, struct pthread **pdp,</span><br><span class="line">                ALLOCATE_STACK_PARMS)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/* Allocate the DTV for this thread.  */</span></span><br><span class="line">  _dl_allocate_tls (TLS_TPADJ (pd));</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_dl_allocate_tls_init</code> 将每个 module 的 TLS 初始化镜像复制到 TLS block。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">_dl_allocate_tls_init (<span class="keyword">void</span> *result)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.val = TLS_DTV_UNALLOCATED;</span><br><span class="line">          dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.to_free = <span class="literal">NULL</span>;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          dest = (<span class="keyword">char</span> *) result - <span class="built_in">map</span>-&gt;l_tls_offset;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Set up the DTV entry.  The simplified __tls_get_addr that</span></span><br><span class="line"><span class="comment">             some platforms use in static programs requires it.  */</span></span><br><span class="line">          dtv[<span class="built_in">map</span>-&gt;l_tls_modid].pointer.val = dest;</span><br><span class="line">          <span class="comment">/* Copy the initialization image and clear the BSS part.  */</span></span><br><span class="line">          <span class="built_in">memset</span> (__mempcpy (dest, <span class="built_in">map</span>-&gt;l_tls_initimage,</span><br><span class="line">                             <span class="built_in">map</span>-&gt;l_tls_initimage_size), <span class="string">&#x27;\0&#x27;</span>,</span><br><span class="line">                  <span class="built_in">map</span>-&gt;l_tls_blocksize - <span class="built_in">map</span>-&gt;l_tls_initimage_size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><a id="orga18a701"></a></p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __thread var_1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __thread var_2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> pthread_addr = <span class="number">0</span>;</span><br><span class="line">    arch_prctl(ARCH_GET_FS, &amp;pthread_addr);</span><br><span class="line"></span><br><span class="line">    var_1 = <span class="number">1</span>;</span><br><span class="line">    var_2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;&amp;pthread = %p, &amp;var_1 = %p, off_var_1 = %d,  &amp;var_2 = %p, off_var_2 = &quot;</span></span><br><span class="line">        <span class="string">&quot;%d\n&quot;</span>,</span><br><span class="line">        pthread_addr, &amp;var_1, (<span class="keyword">long</span>)&amp;var_1 - pthread_addr, &amp;var_2,</span><br><span class="line">        (<span class="keyword">long</span>)&amp;var_2 - pthread_addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tids[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;tids[i], <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_join(tids[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;pthread = 0x7ff58904d700, &amp;var_1 = 0x7ff58904d6f8, off_var_1 = -8,  &amp;var_2 = 0x7ff58904d6fc, off_var_2 = -4</span></span><br><span class="line"><span class="comment">// &amp;pthread = 0x7ff58804b700, &amp;var_1 = 0x7ff58804b6f8, off_var_1 = -8,  &amp;var_2 = 0x7ff58804b6fc, off_var_2 = -4</span></span><br><span class="line"><span class="comment">// &amp;pthread = 0x7ff58884c700, &amp;var_1 = 0x7ff58884c6f8, off_var_1 = -8,  &amp;var_2 = 0x7ff58884c6fc, off_var_2 = -4</span></span><br></pre></td></tr></table></figure><p><a id="orgafae4bb"></a></p><h3 id="TLS-Access-Models"><a href="#TLS-Access-Models" class="headerlink" title="TLS Access Models"></a>TLS Access Models</h3><p>根据 TLS 变量定义的位置，以及访问的位置不同，有以下 4 中使用 TLS 变量的模型。具体采用哪种模式由编译器和链接器共同决定。</p><ol><li><p>General Dynamic</p><p> 最通用的访问模型，任何地方定义的 TLS 变量，在任何地方访问，都可以使用这个方式。其他模型都是加上各种限制条件以后的优化。</p><p> 可以用这个公式来表示 <code>dtv[ti_module].pointer + ti_offset</code> 。实际可以使用 <code>__tls_get_addr</code> 来获取 TLS 变量地址。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__tls_get_addr (GET_ADDR_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv = THREAD_DTV ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (dtv[<span class="number">0</span>].counter != GL(dl_tls_generation)))</span><br><span class="line">    <span class="keyword">return</span> update_get_addr (GET_ADDR_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p = dtv[GET_ADDR_MODULE].pointer.val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == TLS_DTV_UNALLOCATED))</span><br><span class="line">    <span class="keyword">return</span> tls_get_addr_tail (GET_ADDR_PARAM, dtv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">char</span> *) p + GET_ADDR_OFFSET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Local Dynamic</p><p> Local Dynamic 是对 General Dynamic 的优化。如果 TLS 变量在同一个模块被定义和使用，则可以使用这个模型。</p><p> TLS 变量的 offset 在编译时可以确定，因此可以减少 <code>__tls_get_addr</code> 的调用。</p></li><li><p>Initial Exec</p><p> 如果可以 TLS 变量在程序启动时就已分配好，则采用此模型。</p></li><li><p>Local Exec</p><p> 对 Local Dynamic 的优化，如果 TLS 变量在 exec 中定义，在 exec 中访问，则使用这个模型。</p><p> 通过 fs 寄存器 + 偏移量访问。这种是最简单，也是最高效的方式，和访问局部变量没有区别。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  var_1 = <span class="number">1</span>;</span><br><span class="line"><span class="number">401194</span>:       <span class="number">64</span> c7 <span class="number">04</span> <span class="number">25</span> fc ff ff    movl   $<span class="number">0x1</span>,%fs:<span class="number">0xfffffffffffffffc</span></span><br><span class="line"><span class="number">40119b</span>:       ff <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">4011</span>a0:       <span class="number">64</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">0</span>c <span class="number">25</span> <span class="number">00</span> <span class="number">00</span>    mov    %fs:<span class="number">0x0</span>,%rcx</span><br><span class="line"><span class="number">4011</span>a7:       <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">4011</span>a9:       <span class="number">48</span> <span class="number">8</span>d <span class="number">91</span> fc ff ff ff    lea    <span class="number">-0x4</span>(%rcx),%rdx</span><br><span class="line">  var_2 = <span class="number">2</span>;</span><br><span class="line"><span class="number">4011b</span>0:       <span class="number">64</span> c7 <span class="number">04</span> <span class="number">25</span> f8 ff ff    movl   $<span class="number">0x2</span>,%fs:<span class="number">0xfffffffffffffff8</span></span><br><span class="line"><span class="number">4011b</span>7:       ff <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">4011b</span>c:       <span class="number">48</span> <span class="number">8</span>d <span class="number">89</span> f8 ff ff ff    lea    <span class="number">-0x8</span>(%rcx),%rcx</span><br></pre></td></tr></table></figure></li></ol><p><a id="org1527264"></a></p><h3 id="gcc：-thread"><a href="#gcc：-thread" class="headerlink" title="gcc： __thread"></a>gcc： <code>__thread</code></h3><p>pass</p><p><a id="org566bd8c"></a></p><h3 id="c11：-Thread-local"><a href="#c11：-Thread-local" class="headerlink" title="c11： _Thread_local"></a>c11： <code>_Thread_local</code></h3><p>同 gcc <code>__thread</code></p><p><a id="orga9137dc"></a></p><h3 id="c-11：-thread-local"><a href="#c-11：-thread-local" class="headerlink" title="c++11： thread_local"></a>c++11： <code>thread_local</code></h3><p>相对于 <code>__thread</code> ， <code>thread_local</code> 可以在首次使用时自动初始化，线程结束时自动析构。</p><p><a id="org77e5e2e"></a></p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol><li>pthread：thread-specific data （TSD）<ul><li>  全局分配 key</li><li>  线程栈中的 pthread struct 存储自己线程的 key-value</li><li>  每个进程的 TSD 个数有限， <code>PTHREAD_KEYS_MAX</code> 个</li><li>  需要调用 glibc API 完成 TSD 的构造和使用，逻辑复杂</li></ul></li><li>ELF TLS<ul><li>  效率比 TSD 高</li><li>  使用方便</li></ul></li></ol><p><a id="orgbfce451"></a></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a id="org079540d"></a></p><h2 id="Thread-1"><a href="#Thread-1" class="headerlink" title="Thread"></a>Thread</h2><ol><li> <a href="https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4">Understanding the Memory Layout of Linux Executables</a></li><li> <a href="https://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps">Understanding Linux /proc/id/maps</a></li><li> <a href="https://zhuanlan.zhihu.com/p/32542921">Glibc 线程资源分配与释放&#x2013;&#x2014;线程栈</a></li><li> <a href="https://durant35.github.io/2017/10/29/VM_Stacks/">虚拟内存[02] Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</a></li><li> <a href="https://aandds.com/blog/threads.html">Threads</a></li><li> <a href="https://code.woboq.org/userspace/glibc/nptl/">source code of userspace/glibc/nptl/</a></li></ol><p><a id="org9b6efcd"></a></p><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><ol><li> <a href="https://gcc.gnu.org/onlinedocs/gcc/Thread-Local.html">gcc Thread-Local Storage</a></li><li> <a href="https://www.akkadia.org/drepper/tls.pdf">ELF Handling For Thread-Local Storage</a></li><li> <a href="https://chao-tic.github.io/blog/2018/12/25/tls">A Deep dive into (implicit) Thread Local Storage</a></li><li> <a href="https://maskray.me/blog/2021-02-14-all-about-thread-local-storage">All about thread-local storage</a></li><li> <a href="https://fasterthanli.me/series/making-our-own-executable-packer/part-13">Thread-local storage</a></li><li> <a href="https://stackoverflow.com/questions/32245103/how-does-the-gcc-thread-work">stackoverflow How does the gcc `_<sub>thread</sub>` work?</a></li><li> <a href="https://spockwangs.github.io/blog/2017/12/01/thread-local-storage/">线程私有存储</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a id=&quot;orge6dba39&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Thread&quot;&gt;&lt;a href=&quot;#Thread&quot; class=&quot;headerlink&quot; title=&quot;Thread&quot;&gt;&lt;/a&gt;Thread&lt;/h1&gt;&lt;p&gt;&lt;a id=&quot;org651ceca&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="linux" scheme="https://chaomai.github.io/categories/linux/"/>
    
    
    <category term="thread" scheme="https://chaomai.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>用 org mode 管理生活和工作</title>
    <link href="https://chaomai.github.io/2021/2021-03-13-organized-life/"/>
    <id>https://chaomai.github.io/2021/2021-03-13-organized-life/</id>
    <published>2021-03-13T14:40:00.000Z</published>
    <updated>2021-06-27T14:57:29.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>notion 是个方便高效的工具，用起来很顺手，但是最近频繁的 Notion Incident 邮件报警看得我着实心烦，很担心哪天要用的时候服务挂了干着急。所以决定寻找 notion 的替代。</p><p><img data-src="/images/2021/03/Snipaste_2021-03-13_22-03-37.png" alt="img"></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>对我来说，一个高效的任务管理系统需要有一下功能：</p><ol><li> 任务管理：管理 deadline、与他人共同工作的项目。</li><li> 材料记录和收集：记录想法、临时的一些思路、可以灵活的添加链接、图片等。</li><li> 保存和分享：持久化保存数据、不限于工具限制，便于导出分享。</li><li> 定期 review：达成一个长期的目标需要定期 review 短期的 task，保证方向合理和根据达成情况适当调整目标。</li><li> 易用：学习和维护成本低，用工具管理 task，而不是被工具牵制。</li></ol><h1 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h1><p>基于前面描述的功能点，很多工具就被否定了，</p><ol><li> 各种 todo 管理 app，以及附带番茄钟计时器的 app，例如：<a href="https://pomotodo.com/intl/en/">Pomotodo</a>，<a href="https://www.wunderlist.com/">Wunderlist</a>。 过于简单。</li><li> 专门的任务管理 app，例如：<a href="https://www.omnigroup.com/omnifocus/">omnifocus</a>。 不便于添加各种资料。</li><li> notion：不便于导出，服务频繁出问题。</li></ol><p>最终我选择了 emacs 的 org mode。因为我有 emacs 的使用经历，上手 org-mode 较为容易；其次是会简单的写和改 elisp 代码，配置起来难度不大。</p><ol><li> 简单但是比 markdown 强大的多的纯文本记录格式。</li><li> task 支持状态、标签和时间，能方便的移动 task，便于调整 task 和 review。</li><li> agenda view 过滤和查看 task。</li><li> 通过 pandoc 实现丰富的导出功能，就算哪天不用 org mode，也不影响查阅内容。</li><li> 添加图片确实不方便，但通过 org-download 也基本能实现拖拽添加。</li><li> 能<strong>华丽呼哨</strong>的定制，<del>感觉这个才是从 notion 换到 emacs 的动力</del>。</li></ol><p><img data-src="/images/2021/03/Snipaste_2021-03-13_21-36-25.png" alt="img"></p><h1 id="我的-org-mode-workflow"><a href="#我的-org-mode-workflow" class="headerlink" title="我的 org-mode workflow"></a>我的 org-mode workflow</h1><h2 id="task-状态"><a href="#task-状态" class="headerlink" title="task 状态"></a>task 状态</h2><p>参考别人的用法后，规划了如下几个 task 状态，含义如下：</p><ul><li>  TODO：收集到 inbox 中，但是还没有决定是否要做</li><li>  NEXT：review TODO 的 task 以后，规划要做</li><li>  PROG：正在进行</li><li>  DONE：完成</li><li>  HOLD：由于某些原因 task 暂停了</li><li>  CANCELLED：取消不做了</li></ul><p>状态的变更规则如下：</p><ol><li> TODO -&gt; NEXT -&gt; PROG -&gt; DONE</li><li> PROG -&gt; HOLD</li><li> PROG -&gt; CANCELLED</li></ol><p>除了上述状态，如果有的 task 有开始或截止时间，那么还可以加上 SCHEDULED 或者 DEADLINE。</p><h2 id="daily-highlight"><a href="#daily-highlight" class="headerlink" title="daily highlight"></a>daily highlight</h2><p>经过长久的实践，发现不管怎么规划 task，一旦事情堆的太多，看着整页的 NEXT 就会不想做。为此每天开始都先定一下当天<strong>必须</strong>要完成的事情，叫做 daily highlight，不限于工作的任务，休息日的时候也可以是看一本书之类的。daily highlight 不要过多，2～3 件即可。<del>上班的时候集中精力做完 daily highlight 以后就可以愉快的摸鱼了</del>。</p><p>目前使用 org mode 的时间还不长，上述的 workflow 可能还会随着时间不断更新。</p><h1 id="导入-notion-文件"><a href="#导入-notion-文件" class="headerlink" title="导入 notion 文件"></a>导入 notion 文件</h1><p>从 notion 导出的格式为 markdown，可以使用 pandoc 转为 org 格式。</p><pre><code>pandoc -f markdown -t org markdown_file.md | sed -E &quot;/^[[:space:]]+:/ d&quot;</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li> <a href="http://www.cachestocaches.com/2020/3/my-organized-life/">A Guide to My Organizational Workflow: How to Streamline Your Life</a></li><li> <a href="https://whhone.com/posts/org-mode-task-management/">An Org-Mode Workflow for Task Management</a></li><li> <a href="https://blog.jethro.dev/posts/org_mode_workflow_preview/">Org-mode Workflow: A Preview</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;notion 是个方便高效的工具，用起来很顺手，但是最近频繁的 Notion Incident 邮件报警看得我着实心烦，很担心哪天要用的时候</summary>
      
    
    
    
    <category term="emacs" scheme="https://chaomai.github.io/categories/emacs/"/>
    
    
    <category term="gdt" scheme="https://chaomai.github.io/tags/gdt/"/>
    
    <category term="org-mode" scheme="https://chaomai.github.io/tags/org-mode/"/>
    
  </entry>
  
  <entry>
    <title>A New Start</title>
    <link href="https://chaomai.github.io/2020/2020-03-08-a-new-start/"/>
    <id>https://chaomai.github.io/2020/2020-03-08-a-new-start/</id>
    <published>2020-04-08T14:36:02.000Z</published>
    <updated>2021-06-27T14:57:29.287Z</updated>
    
    <content type="html"><![CDATA[<p>有段时间没有更新了。最近因为一些原因，换了工作。</p><p>之前的工作内容偏dmp，离线处理，业务相关的东西一直关注的比较少。现在转向线上广告引擎，与业务结合比较紧密，有点不习惯，需要改变一下思考的方式了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有段时间没有更新了。最近因为一些原因，换了工作。&lt;/p&gt;
&lt;p&gt;之前的工作内容偏dmp，离线处理，业务相关的东西一直关注的比较少。现在转向线上广告引擎，与业务结合比较紧密，有点不习惯，需要改变一下思考的方式了。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="life" scheme="https://chaomai.github.io/categories/life/"/>
    
    
    <category term="work" scheme="https://chaomai.github.io/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>redis quicklist</title>
    <link href="https://chaomai.github.io/2019/2019-12-08-redis-quicklist/"/>
    <id>https://chaomai.github.io/2019/2019-12-08-redis-quicklist/</id>
    <published>2019-12-07T16:00:00.000Z</published>
    <updated>2021-06-27T14:57:29.286Z</updated>
    
    <content type="html"><![CDATA[<p>quicklist是由ziplist构成的双向链表。ziplist需要可能对内存进行复制，在长度较长的时候，性能不佳。quicklist存储多个小ziplist，对除<code>head</code>和<code>tail</code>外的节点还进行了压缩，保证了push和pop性能的同时，又减少了内存的占用。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="keyword">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><p><code>quicklistLZF</code>：存储压缩后的ziplist</p><p><code>quicklist</code>：</p><ul><li><code>fill</code>：存放<code>list-max-ziplist-size</code>参数<ul><li><code>fill</code>取正值时，表示entry个数</li><li>取负值时，表示大小</li></ul></li><li><code>compress</code>：存放<code>list-compress-depth</code>参数</li></ul><h1 id="push"><a href="#push" class="headerlink" title="push"></a>push</h1><p>push时，先检查本次push是否会超过限制大小，<code>quicklist-&gt;fill</code>，依次按照用户定义大小、默认个数（<code>SIZE_SAFETY_LIMIT</code>）、用户定义个数检查。</p><ul><li>如果没有超过，那么在<code>head</code>的ziplist头部添加entry。</li><li>如果超过，那么创建新的ziplist，并在<code>quicklist-&gt;head</code>前插入新node。最后压缩原来的<code>quicklist-&gt;head</code>节点。</li></ul><p><code>quicklistPushTail</code>也是类似的，但是在ziplist的尾部添加entry，且插入后是压缩原来的<code>quicklist-&gt;tail</code>节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;quicklist是由ziplist构成的双向链表。ziplist需要可能对内存进行复制，在长度较长的时候，性能不佳。quicklist存储多个小ziplist，对除&lt;code&gt;head&lt;/code&gt;和&lt;code&gt;tail&lt;/code&gt;外的节点还进行了压缩，保证了push和</summary>
      
    
    
    
    <category term="redis" scheme="https://chaomai.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://chaomai.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis ziplist</title>
    <link href="https://chaomai.github.io/2019/2019-12-06-redis-ziplist/"/>
    <id>https://chaomai.github.io/2019/2019-12-06-redis-ziplist/</id>
    <published>2019-12-05T16:00:00.000Z</published>
    <updated>2021-06-27T14:57:29.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h1><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>ziplist是一个压缩的双向链表，由一个特殊编码的连续内存块构成。如果没有特殊指定，所有字段都是以小端序来存储的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ziplist：</span><br><span class="line">&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</span><br><span class="line"></span><br><span class="line">entry：</span><br><span class="line">&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</span><br></pre></td></tr></table></figure><p>ziplist：</p><ul><li><code>uint32_t zlbytes</code>：ziplist占据的内存大小，包括<code>zlbytes</code>字段。</li><li><code>uint32_t zltail</code>：最后一个entry（非zlend）的offset，记录了尾节点距离起始地址的字节数，相当于尾指针的作用。</li><li><code>uint16_t zllen</code>：entry的数目，如果元素数目大于<code>2^16-2</code>，那么值为<code>2^16-1</code>，只有通过遍历才能得知，有多少个元素。zlen不计入entry数目。</li><li><code>uint8_t zlend</code>：特殊的entry，ziplist的结尾标记，值为<code>0xFF</code>。</li></ul><p>每个entry大小是不固定的：</p><ul><li><p><code>prevlen</code>：前一个entry的长度，用于从后往前遍历时计算prev entry的起始地址。长度小于254字节和大于等于254字节分别使用两种存储方式。</p><table><thead><tr><th>value</th><th>prevlen</th><th>size</th></tr></thead><tbody><tr><td>&lt; 254</td><td><code>0xbb</code></td><td>1字节</td></tr><tr><td>&gt;=254</td><td><code>0xFE xx xx xx xx</code></td><td>5字节</td></tr></tbody></table><p>  当长度大于等于254时，<code>0xFE</code>代表<code>prevlen</code>值的类型，后面的4个字节才是长度。</p><p>  这样存储方式刚好可以与<code>zlend</code>的<code>0xFF</code>区分开来，没有一个entry的开头会是<code>0xFF</code>。</p></li><li><p><code>encoding</code>：记录了<code>entry-data</code>数据类型和长度。</p><p>  前两个bit代表存储的是字节数组，还是整型。</p><table><thead><tr><th>encoding</th><th>size</th><th>值的类型</th></tr></thead><tbody><tr><td><code>00pppppp</code></td><td>1 byte</td><td>长度&lt;=63的字节数组</td></tr><tr><td>`01pppppp</td><td>qqqqqqqq`</td><td>2 bytes（14 bits使用大端序存储）</td></tr><tr><td>`10000000</td><td>qqqqqqqq</td><td>rrrrrrrr</td></tr><tr><td><code>11000000</code></td><td>1 byte</td><td>int16_t</td></tr><tr><td><code>11010000</code></td><td>1 byte</td><td>int32_t</td></tr><tr><td><code>11100000</code></td><td>1 byte</td><td>int64_t</td></tr><tr><td><code>11110000</code></td><td>1 byte</td><td>24 bit signed integer</td></tr><tr><td><code>11111110</code></td><td>1 byte</td><td>8 bit signed integer</td></tr><tr><td><code>1111xxxx</code></td><td>1 byte</td><td>没有<code>content</code>属性，4个bit存储[0, 12]的值</td></tr><tr><td><code>11111111</code></td><td>1 byte</td><td>zlend</td></tr></tbody></table></li><li><p><code>entry-data</code>：节点的值，字节数组或整形。</p></li></ul><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>ziplist使用了很多宏来实现，主要是进行类型转换和指针运算以便访问相关的字段。</p><p>插入分三个情况，<br><img data-src="/images/2019/15757879857637.jpg" alt="-w629"></p><p>需要分别准备新entry的<code>prevlen</code>，<code>encoding</code>，分配空间。</p><ol><li><p><code>prevlen</code><br> 先看插入位置是否在<code>zlen</code>之前，</p><ul><li><p>如果不在，<code>p</code>处的<code>prevlen</code>就是新entry的<code>prevlen</code>。</p></li><li><p>如果在，此时无法直接得知<code>prevlen</code>，需要看<code>zlend</code>前是否还有元素。若没有，则<code>zipRawEntryLength(ptail)</code>计算<code>tail</code>元素的长度。</p><p><code>p</code>不是<code>zlend</code>的时候，新entry的len会作为<code>p</code>处entry的<code>prevlen</code>，需要确保<code>p</code>处<code>prevlen</code>空间足够。</p><p><img data-src="/images/2019/15757965712995.jpg" alt="-w736"></p></li></ul></li><li><p><code>encoding</code><br> 对于<code>encoding</code>，先会尝试编码为整型<code>zipTryEncoding(s,slen,&amp;value,&amp;encoding)</code>，</p><ul><li>如果可以编码为整型，那么<code>zipIntSize(encoding)</code>得到entry-data的大小。</li><li>如果无法合法的编码为整型，那么根据<code>slen</code>编码为字节数组<code>zipStoreEntryEncoding(NULL,encoding,slen)</code>，entry-data的大小为<code>slen</code>。</li></ul></li><li><p>分配空间，<br> 计算出各字段所需的空间后，<code>memmove()</code>来完成空间的调整。要注意对源地址的处理，<code>p-nextdiff</code>。</p><ul><li><p>如果<code>nextdiff == 0</code>，说明<code>p</code>处entry的<code>prevlen</code>，可以保存新entry的大小。</p></li><li><p>如果<code>nextdiff == 4</code>，那么说明空间不够，此时<code>p</code>处entry的<code>prevlen</code>原大小为1 byte，从<code>p</code>往前数4 bytes，加起来的5 bytes作为新<code>prevlen</code>的存储，因此从<code>p - 4</code>处开始<code>memmove()</code>。</p><p>  <img data-src="/images/2019/15757965415426.jpg" alt="-w614"></p></li><li><p>如果<code>nextdiff == -4</code>，说明空间多出4 bytes，从<code>p + 4</code>的位置开始<code>memmove()</code>。</p></li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value</span></span><br><span class="line"><span class="comment">                                    that is easy to see if for some reason</span></span><br><span class="line"><span class="comment">                                    we use it uninitialized. */</span></span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * entry开头的1 byte是不是0xFF</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果插入位置是在zlend处，需要判断zlend前是否有entry，</span></span><br><span class="line"><span class="comment">     * 如果没有，那么新prevlen为0，</span></span><br><span class="line"><span class="comment">     * 如果有，那么需要计算zl+zltail处entry的大小，将其设置为新entry的prevlen</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if the entry can be encoded */</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is set to the appropriate integer encoding */</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is untouched, however zipStoreEntryEncoding will use the</span></span><br><span class="line"><span class="comment">         * string length to figure out how to encode it. */</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We need space for both the length of the previous entry and</span></span><br><span class="line"><span class="comment">     * the length of the payload. */</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the insert position is not equal to the tail, we need to</span></span><br><span class="line"><span class="comment">     * make sure that the next entry can hold this entry&#x27;s length in</span></span><br><span class="line"><span class="comment">     * its prevlen field. */</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Encode this entry&#x27;s raw length in the next entry. */</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update offset for tail */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">         * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */</span></span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This element will be the new tail. */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the entry */</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>插入或删除时，可能导致后面entry存储的<code>prevlen</code>发生变化。理论上，扩张和缩小都会有，但redis有意忽略了缩小的情况，避免连续的插入导致频繁的扩容和缩小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">    <span class="comment">/* This would result in shrinking, which we want to avoid.</span></span><br><span class="line"><span class="comment">     * So, set &quot;rawlen&quot; in the available bytes. */</span></span><br><span class="line">    zipStorePrevEntryLengthLarge(p+rawlen,rawlen);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    zipStorePrevEntryLength(p+rawlen,rawlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stop here, as the raw length of &quot;next&quot; has not changed. */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ziplist&quot;&gt;&lt;a href=&quot;#ziplist&quot; class=&quot;headerlink&quot; title=&quot;ziplist&quot;&gt;&lt;/a&gt;ziplist&lt;/h1&gt;&lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结</summary>
      
    
    
    
    <category term="redis" scheme="https://chaomai.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://chaomai.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis intset</title>
    <link href="https://chaomai.github.io/2019/2019-12-05-redis-intset/"/>
    <id>https://chaomai.github.io/2019/2019-12-05-redis-intset/</id>
    <published>2019-12-04T16:00:00.000Z</published>
    <updated>2021-06-27T14:57:29.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>intset存储了有序的整数集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p><code>encoding</code>决定如何解析<code>contents</code>，取值为，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure><h1 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h1><p>不同于其他结构，intset在存储的时候考虑了字节序的问题，redis会使用小端序来存储intset的所有字段。目的是intset能够兼容不同字节序的cpu。</p><p>sds也有多字节的字段，为什么sds不做这个转换？</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>由于<code>contents[]</code>是有序的，因此直接使用二分查找。</p><p>在执行二分查找前，先进行了特殊情况的判断，避免进行多余的搜索，</p><ul><li>如果数组长度为0，则直接返回。</li><li>如果<code>value</code>大于末尾元素，或小于首部元素，也直接返回，并set插入位置<code>pos</code>。</li></ul><p>二分查找中使用了<code>mid = ((unsigned int)min + (unsigned int)max) &gt;&gt; 1</code>来计算mid，会不会存在溢出的问题？毕竟intset的<code>length</code>的类型是<code>uint32_t</code>，理论可以保存$2^{32}$个元素。redis仅使用intset存储少量的元素，如果元素过多，会使用其他方式存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>插入分两种情况，</p><ul><li>可直接插入</li><li>新元素的类型比集合存储的类型长，需要升级</li></ul><h2 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h2><p>对于直接插入，先使用<code>intsetSearch()</code>找到待插入位置<code>pos</code>，然后移动<code>pos</code>后的所有元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>移动元素分两个步骤完成，</p><ul><li><p>在<code>intsetResize()</code>中调用<code>zrealloc()</code>先分配<code>is-&gt;length+1</code>的空间，这里可能会有一次内存拷贝。</p></li><li><p>然后在<code>intsetMoveTail()</code>使用<code>memmove()</code>移动内存，这里一定会有一次内存拷贝。<code>memmove()</code>保证了在原位置和目标位置的情况下，能够安全的进行拷贝。</p><p>计算源地址和目的地址时，需要先将<code>contents</code>转换为内容实际对应的类型，然后再做指针的计算。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = intrev32ifbe(is-&gt;length)-from;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="keyword">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="keyword">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="需要升级编码"><a href="#需要升级编码" class="headerlink" title="需要升级编码"></a>需要升级编码</h2><p>对于插入类型大于集合现有类型的情况，那么待插入的元素一定是在数组头部（负数的时候）或者尾部。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断新的编码类型并分配内存以后，从后往前遍历，逐个升级编码。这里需要处理prepend和append的情况。区别就是对于prepend，遍历时，新的元素的位置是当前位置+1，<code>_intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc))</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev64ifbe(((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="降级编码"><a href="#降级编码" class="headerlink" title="降级编码"></a>降级编码</h2><p>除了遍历，无法确定是否存在超出范围的元素，intset不支持降级。</p><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete integer from intset */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> len = intrev32ifbe(is-&gt;length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We know we can delete */</span></span><br><span class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Overwrite value with tail and update length */</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; (len<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</span><br><span class="line">        is = intsetResize(is,len<span class="number">-1</span>);</span><br><span class="line">        is-&gt;length = intrev32ifbe(len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h1&gt;&lt;p&gt;intset存储了有序的整数集合。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    <category term="redis" scheme="https://chaomai.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://chaomai.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis skiplist</title>
    <link href="https://chaomai.github.io/2019/2019-12-04-redis-skiplist/"/>
    <id>https://chaomai.github.io/2019/2019-12-04-redis-skiplist/</id>
    <published>2019-12-03T16:00:00.000Z</published>
    <updated>2021-06-27T14:57:29.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h1><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>skiplist提供了平均$O(log n)$的查找、插入和删除。<code>zskiplistNode</code>中使用柔性数组设计，每个节点存储了sds，<code>level</code>数组存储了各层指向其他节点的指针，最大层数为<code>ZSKIPLIST_MAXLEVEL = 64</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>先找到待插入的位置，查找的时候从顶层开始，在当前层尽可能的往前移动，每层都满足<code>[header, update[i]]：(&lt; score) or (== score and &lt; ele))</code>。最终的插入位置在<code>update[i]</code>之后。</p><p>要提的一点是redis的skiplist还维护了，</p><ul><li><p><code>span</code>，记录了两个节点间的距离。</p><ul><li><p>寻找插入位置时，需要在每层都累加节点的<code>span</code>。</p></li><li><p>插入时，</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>forward</code>，记录了节点的prev指针。</p><p>  在插入时，如果<code>新节点的random level &gt; zsl-&gt;level</code>，则需要将<code>update</code>中多出来的<code>level</code>设置为header。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the element is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, reinserting the same element should never happen since the</span></span><br><span class="line"><span class="comment">     * caller of zslInsert() should test in the hash table if the element is</span></span><br><span class="line"><span class="comment">     * already inside or not. */</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>和以插入相同的方式查找待删除节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele, zskiplistNode **node)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            zslFreeNode(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *node = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除时需要维护<code>span</code>和<code>forward</code>，</p><ul><li><p>如果当前层<code>update[i]-&gt;level[i].forward == x</code>，</p><ul><li><p><code>span</code>：</p><p>  累加上<code>x</code>的，并减1。</p></li><li><p><code>forward</code>：</p><p>  在每层指向待删除节点的下一个节点，<code>update[i]-&gt;level[i].forward = x-&gt;level[i].forward</code>。</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html">Redis内部数据结构详解(6)——skiplist</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;skiplist&quot;&gt;&lt;a href=&quot;#skiplist&quot; class=&quot;headerlink&quot; title=&quot;skiplist&quot;&gt;&lt;/a&gt;skiplist&lt;/h1&gt;&lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="redis" scheme="https://chaomai.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://chaomai.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis dict</title>
    <link href="https://chaomai.github.io/2019/2019-12-03-redis-dict/"/>
    <id>https://chaomai.github.io/2019/2019-12-03-redis-dict/</id>
    <published>2019-12-02T16:00:00.000Z</published>
    <updated>2021-06-27T14:57:29.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>dict使用链地址法解决冲突，<code>size</code>为$2^n$，<code>sizemask = size - 1</code>，用于计算key所属的bucket上，避免了mod，还便于处理scan时发生rehash的情况。每个dict有两个dictht，多个出来的一个用于rehash。</p><p>使用了类似list中的方式来保存key和value，并提供了<code>hashFunction</code>，<code>keyDup</code>等函数操作key和value。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>添加元素的过程，</p><ol><li><p><code>dictAdd()</code></p></li><li><p><code>dictAddRaw()</code></p><ul><li><p>如果需要rehash，<code>_dictRehashStep()</code>。</p></li><li><p><code>_dictKeyIndex()</code>查找entry。</p></li><li><p>如果找不到，创建新的entry，并插入链表的头部（这里假设了最近创建的会被更频繁的使用）。当rehash时，选择新的hash table，<code>d-&gt;ht[1]</code>进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">ht-&gt;table[index] = entry;</span><br><span class="line">ht-&gt;used++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">dictSetKey(d, entry, key);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>_dictKeyIndex()</code></p><ul><li><p>检查是否需要扩张hash table（扩张或为<code>d-&gt;ht[0]</code>进行初始化），<code>_dictExpandIfNeeded()</code>。</p></li><li><p>使用<code>hash &amp; d-&gt;ht[table].sizemask</code>计算所属bucket。</p></li><li><p>查找entry。在rehash的时候，会在两个hash table中进行查找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">    idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">    <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">    he = d-&gt;ht[table].table[idx];</span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="扩张hash-table"><a href="#扩张hash-table" class="headerlink" title="扩张hash table"></a>扩张hash table</h1><p>每次add都会调用<code>_dictExpandIfNeeded()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果<code>d-&gt;ht[0]</code>为空，那么<code>dictExpand()</code>中为<code>d-&gt;ht[0]</code>初始化，初始大小为4。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d-&gt;ht[<span class="number">0</span>] = n;</span><br></pre></td></tr></table></figure></li><li><p>如果load factor达到了1，还需要看dict当前是否可以resize，如果不可以，那么会提高load factor到5（有子进程时，为了避免COW内存复制），然后才会在<code>dictExpand()</code>中分配新的hash table。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">d-&gt;rehashidx = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><p><code>dictExpand()</code>中，如果分配了新的hash table，那么会set <code>d-&gt;rehashidx = 0;</code>，标识开始rehash。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand or create the hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hash table */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rehashing to the same table size is not useful. */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it&#x27;s not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除key"><a href="#删除key" class="headerlink" title="删除key"></a>删除key</h1><p>删除分为两种，</p><ul><li><p><code>dictDelete()</code>：会把key，value和entry都真正的进行删除。最终是调用<code>dictGenericDelete()</code>进行删除。</p></li><li><p><code>dictUnlink()</code>：只会把entry从链表中移除，并返回entry。最终是调用<code>dictGenericDelete()</code>进行删除。<br>  这个函数主要用于，想把entry从hash table中移除，但同时又想使用这个entry的情况。如果没有这个函数，则需要进行两次查找。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entry = dictFind(...);</span><br><span class="line"><span class="comment">// Do something with entry</span></span><br><span class="line">dictDelete(dictionary,entry);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> dictEntry *<span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span> &amp;&amp; d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                    zfree(he);</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h1><p>为了避免集中的rehash操作对性能的影响，redis使用的是渐进式rehash。<code>dict.rehashidx</code>初始化为-1，在rehash时，<code>[0, rehashidnex)</code>代表老的hash table已经迁移的bucket。</p><p>rehash会两种情况下发生，</p><ol><li><p>每次查询或更新操作时，都会调用<code>dictRehash()</code>执行一步rehash，一般来说这个函数只会移动一个bucket，也有可能一个都不移动，因为rehash时，每次检查至多10个bucket。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">dictRehash(d,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果server比较空闲，上述rehash的过程就会很慢，dict将会占用两个hash table较长的时间。在初始化redis时，<code>serverCron()</code>会作为计时器的回调函数定时执行。</p><p> 如果启用了<code>server.activerehashing</code>，执行过程中，会分配1ms的时间来执行<code>dictRehash()</code>。</p><ul><li><code>serverCron()</code></li><li><code>databasesCron()</code></li><li><code>incrementallyRehash()</code></li><li><code>dictRehashMilliseconds(server.db[dbid].dict,1)</code>，1ms</li><li><code>dictRehash(d,100)</code></li></ul></li></ol><p><code>int dictRehash(dict *d, int n)</code>中，最多移动100个bucket，在移动每个bucket时，至多会检查<code>n*10</code>个bucket，因为有的bucket可能是空的，因此需要多看几个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h1><p>scan可以用于遍历dict中的元素，初始提供一个<code>cursor = 0</code>，每次迭代返回一个新的<code>cursor</code>，当<code>cursor</code>再次为0的时候，遍历结束。</p><p>遍历每个bucket时，调用<code>fn</code>对每个元素<code>de</code>进行处理，这个处理可能是，复制<code>de</code>到其他地方，例如：<code>void scanCallback(void *privdata, const dictEntry *de)</code>。</p><p>scan需要考虑是否正在rehash的情况，</p><ol><li><p>scan过程中，dict没有变化</p><p> 由于hash table的大小总是$2^n$，因此每个bucket的index总是<code>key &amp; 2^n - 1</code>后的一个值，即<code>idx = hash &amp; d-&gt;ht[table].sizemask</code>。</p><p> 每次调用<code>scan</code>时，处理完毕一个bucket中的元素后，<code>v |= ~m0</code>保留cursor的低n个bit（在遍历结束前，<code>v == v | ~m0</code>），并加1。如果遍历结束，那么cursor值为<code>2^n - 1</code>，加1，并<code>v |= ~m0</code>后，<code>v</code>为0。则停止调用<code>dictScan</code>。</p><p> 这里还看不出<code>reverse cursor</code>的特殊作用。无论高位加1并<code>rev()</code>，还是低位加1，都可以完成上述过程。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Emit entries at cursor */</span></span><br><span class="line"><span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">de = t0-&gt;table[v &amp; m0];</span><br><span class="line"><span class="keyword">while</span> (de) &#123;</span><br><span class="line">    next = de-&gt;next;</span><br><span class="line">    fn(privdata, de);</span><br><span class="line">    de = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></span><br><span class="line"><span class="comment"> * operates on the masked bits */</span></span><br><span class="line">v |= ~m0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">v = rev(v);</span><br><span class="line">v++;</span><br><span class="line">v = rev(v);</span><br></pre></td></tr></table></figure></li><li><p>如果正在rehash<br> 如果正在rehash，scan是通过高位掩码的方式来完成扫描的。</p><p> 先来看bucket的计算方式，<code>idx = hash &amp; d-&gt;ht[table].sizemask</code>。如果发生rehash，假设小表a大小为<code>2^n</code>，大表b为<code>2^m</code>。某个key，在两个表中的bucket分别为<code>hash &amp; d-&gt;ht[a].sizemask</code>，<code>hash &amp; d-&gt;ht[b].sizemask</code>。hash是一致的，这就意味着，两个bucket的低n位也是一致的。这是rehash时能保证元素一定会被扫描到的关键。</p><p> scan时，t0（小表）索引为<code>v &amp; m0</code>的bucket，然后扫描t1中索引低<code>n</code>为<code>v &amp; m0</code>的bucket。由于大表中低<code>n</code>为<code>v &amp; m0</code>的bucket是多个，因此需要在高<code>m - n</code>位不断递增。由于需要在高位不断递增，因此需要先<code>rev()</code>，然后再加1。</p><p> 总结来说，rehash时的扫描过程，其实就是通过一个函数，将一个bucket值<code>xxxxx</code>，映射到集合<code>aa...axxxxx</code>的过程。</p><p> scan大表时的停止条件就是高<code>m - n</code>位都被扫描一遍，<code>v &amp; (m0 ^ m1)</code>。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></span><br><span class="line"><span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123;</span><br><span class="line">    t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">    t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m0 = t0-&gt;sizemask;</span><br><span class="line">m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Emit entries at cursor */</span></span><br><span class="line"><span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">de = t0-&gt;table[v &amp; m0];</span><br><span class="line"><span class="keyword">while</span> (de) &#123;</span><br><span class="line">    next = de-&gt;next;</span><br><span class="line">    fn(privdata, de);</span><br><span class="line">    de = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment"> * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">    <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);</span><br><span class="line">    de = t1-&gt;table[v &amp; m1];</span><br><span class="line">    <span class="keyword">while</span> (de) &#123;</span><br><span class="line">        next = de-&gt;next;</span><br><span class="line">        fn(privdata, de);</span><br><span class="line">        de = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Increment the reverse cursor not covered by the smaller mask.*/</span></span><br><span class="line">    v |= ~m1;</span><br><span class="line">    v = rev(v);</span><br><span class="line">    v++;</span><br><span class="line">    v = rev(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h1&gt;&lt;p&gt;dict使用链地址法解决冲突，&lt;code&gt;size&lt;/code&gt;为$2^n$，&lt;code&gt;sizemask = size - 1&lt;/code</summary>
      
    
    
    
    <category term="redis" scheme="https://chaomai.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://chaomai.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis list</title>
    <link href="https://chaomai.github.io/2019/2019-12-02-redis-list/"/>
    <id>https://chaomai.github.io/2019/2019-12-02-redis-list/</id>
    <published>2019-12-01T16:00:00.000Z</published>
    <updated>2021-06-27T14:57:29.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>reids的list采用的是双向链表的实现，未使用dummy node。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>双端</li><li>无环</li><li>有头尾指针</li><li>有长度计数器</li><li>多态（使用<code>void*</code>来保存节点值，并提供<code>free</code>，<code>dup</code>，<code>match</code>来处理节点）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h1&gt;&lt;p&gt;reids的list采用的是双向链表的实现，未使用dummy node。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="redis" scheme="https://chaomai.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://chaomai.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis sds</title>
    <link href="https://chaomai.github.io/2019/2019-11-26-redis-sds/"/>
    <id>https://chaomai.github.io/2019/2019-11-26-redis-sds/</id>
    <published>2019-11-25T16:00:00.000Z</published>
    <updated>2021-06-27T14:57:29.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>sds主要由<code>len</code>，<code>alloc</code>和<code>buf</code>构成。其中<code>buf</code>是柔性数组，分配sds的时候，这个结构体会作为header。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有packed，那么sizeof(sdshdr32) =</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为sds分配空间，<code>initlen</code>是字符串的长度，1是末尾的’\0’。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="sdsnewlen、sdslen，sdsavail"><a href="#sdsnewlen、sdslen，sdsavail" class="headerlink" title="sdsnewlen、sdslen，sdsavail"></a>sdsnewlen、sdslen，sdsavail</h1><p><code>sdsnewlen</code>返回的是<code>char buf[]</code>首元素的地址，这个值作为<code>sds</code>指针的值。这是sds中巧妙的地方。但是如何获取header地址，以及访问成员？毕竟相关字段是在柔性数组的前面。</p><ul><li><p><code>sds - 1</code>就是<code>flag</code>，由<code>flag</code>可以得知header类型，也就知道header的长度，减去header的长度得到header的地址，访问<code>len</code>成员即可得知<code>buf</code>长度。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br></pre></td></tr></table></figure></li><li><p><code>sdshdr5</code>是一个特别的类型，长度和类型都隐藏在了<code>flag</code>里面。<code>SDS_TYPE_5</code>存储的是长度小于<code>1 &lt;&lt; 5</code>的字符数组，也就是可以用5 bit来表示。这样加上3 bit的类型，合起来刚好8 bit，就是一个<code>flag</code>。</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br></pre></td></tr></table></figure><p>  因此<code>flag</code>的3 lsb作为类型，5 msb作为长度。但<code>sdshdr5</code>无法记录空闲的空间，因此无法扩容。</p></li></ul><h1 id="sdsgrowzero"><a href="#sdsgrowzero" class="headerlink" title="sdsgrowzero"></a>sdsgrowzero</h1><ul><li>新长度小于1MB，则buf大小翻倍</li><li>新长度大于等于1MB，则buf加1MB</li></ul><h1 id="sdstrim"><a href="#sdstrim" class="headerlink" title="sdstrim"></a>sdstrim</h1><p>trim后并未释放buf的空间。</p><p>提供了<code>sdsRemoveFreeSpace</code>函数，可以完成在尾部没有空闲的空间。</p><h1 id="sds与c字符串的区别"><a href="#sds与c字符串的区别" class="headerlink" title="sds与c字符串的区别"></a>sds与c字符串的区别</h1><ul><li>参数时间获取字符串长度</li><li>记录长度，避免buffer overflow</li><li>空间预分配、惰性释放，减少重分配次数</li><li>二进制安全</li><li>兼容部分c字符串函数</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>sds的定义使用了pack，内存没有对齐的情况下，会影响cpu访问内存的性能，这个是如何解决的？</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="https://youjiali1995.github.io/redis/learn-redis/">Redis源码阅读计划</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261663&idx=1&sn=949aec03a6edf0b2281d5d83147ba367&chksm=84479186b33018903b9a3664d4de17ab83b62760e456ffcf32e9319d03964892fac6d0a7c208&scene=21#wechat_redirect">Redis源码从哪里读起？</a></li><li><a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b336601f265da598e13f917">Redis 深度历险：核心原理与应用实践</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h1&gt;&lt;p&gt;sds主要由&lt;code&gt;len&lt;/code&gt;，&lt;code&gt;alloc&lt;/code&gt;和&lt;code&gt;buf&lt;/code&gt;构成。其中&lt;code&gt;b</summary>
      
    
    
    
    <category term="redis" scheme="https://chaomai.github.io/categories/redis/"/>
    
    
    <category term="redis" scheme="https://chaomai.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>go踩坑合集</title>
    <link href="https://chaomai.github.io/2019/2019-09-20-golang-traps-and-pitfalls/"/>
    <id>https://chaomai.github.io/2019/2019-09-20-golang-traps-and-pitfalls/</id>
    <published>2019-09-20T09:07:39.000Z</published>
    <updated>2021-06-27T14:57:29.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RWMutex-RLock重入导致死锁"><a href="#RWMutex-RLock重入导致死锁" class="headerlink" title="RWMutex RLock重入导致死锁"></a>RWMutex RLock重入导致死锁</h1><p>RWMutex，即读写锁，可以被多个的reader或一个writer获取使用。</p><h2 id="死锁例子"><a href="#死锁例子" class="headerlink" title="死锁例子"></a>死锁例子</h2><p>在使用RWMutex的时候，同一个reader是不应该连续调用<code>Rlock</code>多次的，这样做不但没有意义，还有可能导致死锁，具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> l = sync.RWMutex&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">l.RLock()</span><br><span class="line"><span class="keyword">defer</span> l.RUnlock()</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">runtime.Gosched()</span><br><span class="line"></span><br><span class="line">l.RLock()</span><br><span class="line"><span class="keyword">defer</span> l.RUnlock()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-c</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.Unlock()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-RWMutex分析"><a href="#sync-RWMutex分析" class="headerlink" title="sync.RWMutex分析"></a>sync.RWMutex分析</h2><p>下面<a href="https://github.com/golang/go/blob/master/src/sync/rwmutex.go">RWMutex的实现</a>，我们来看这段代码的具体执行。为了方便理解，把<code>if race.Enabled &#123;...&#125;</code>的相关代码都去除了。</p><ol><li><p><strong>goroutine 1</strong>：<code>l.RLock()</code></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 执行<code>l.RLock()</code>后，goroutine 1获得写锁。</p><ul><li>状态：获得读锁</li><li>readerCount = 1，readerWait = 0</li></ul></li><li><p><strong>goroutine 2</strong>：<code>l.Lock()</code></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// First, resolve competition with other writers.</span></span><br><span class="line">rw.w.Lock()</span><br><span class="line"><span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"><span class="comment">// Wait for active readers.</span></span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 由于goroutine 1已获得写锁，此时goroutine 2等待。</p><ul><li>状态：等待reader释放读锁</li><li>readerCount = 1 - rwmutexMaxReaders，readerWait = 1</li></ul></li><li><p><strong>goroutine 1</strong>：<code>l.RLock()</code></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// A writer is pending, wait for it.</span></span><br><span class="line">runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> goroutine 1发现readerCount为负，认为有writer获得了写锁，接着也进入了等待状态。</p><ul><li>状态：等待</li><li>readerCount = 2 - rwmutexMaxReaders，readerWait = 1</li></ul></li></ol><p>最后goroutine 1和goroutine 2都进入了等待状态。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>readerCount的作用？<br> 持有读锁的reader数。置为负时，代表了writer正在或者已经获得了读锁，此时其他reader不能再获得写锁。</p></li><li><p>readerWait的作用，以及在<code>Lock()</code>中，为何需要同时判断<code>r != 0</code>和<code>atomic.AddInt32(&amp;rw.readerWait, r) != 0</code>？<br> 置readerCount为负的时候，获得了写锁，但尚未RULock的reader数。writer需要等待这些reader执行结束。</p><ul><li><p>若<code>r == 0</code>，则无正在持有读锁的reader，可以直接完成读锁的加锁。</p></li><li><p>若<code>r != 0</code>，writer需要等待获得了写锁，但尚未RULock的reader执行结束。如何判断是否需要等待呢，即readerWait不为0的时候。同时reader决定是否能唤醒writer，也需要等到readerWait为0的时候。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">rw.w.Lock()</span><br><span class="line">r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line"><span class="comment">// 此刻起，其他reader不再能够获得读锁。</span></span><br><span class="line"><span class="comment">// 此时，尚未释放写锁的reader数为readerWait个，等待他们结束才能完成读锁的加锁。</span></span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="sync-WaitGroup使用的问题"><a href="#sync-WaitGroup使用的问题" class="headerlink" title="sync.WaitGroup使用的问题"></a>sync.WaitGroup使用的问题</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在实现一个需求的时候，需要等待一定数目的go协程执行完毕，但这个数目事先并不好确定。想到了可以用sync.WaitGroup来完成，在使用时候发现，<code>Wait()</code>没有生效，并未等待协程结束，代码大致如下，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ch:</span><br><span class="line">fmt.Println(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后程序不会有任何的输出就退出了。</p><h2 id="sync-WaitGroup源码分析"><a href="#sync-WaitGroup源码分析" class="headerlink" title="sync.WaitGroup源码分析"></a>sync.WaitGroup源码分析</h2><blockquote><p>Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for.</p></blockquote><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ch:</span><br><span class="line">fmt.Println(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://stackoverflow.com/questions/18805416/waiting-on-an-indeterminate-number-of-goroutines">Waiting on an indeterminate number of goroutines</a></li></ol><h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ctx context.Context, wg *sync.WaitGroup, retCh <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line"><span class="comment">// process</span></span><br><span class="line"><span class="comment">// send process result back</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">retCh &lt;- <span class="number">1</span></span><br><span class="line">retCh &lt;- <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">retCh &lt;- <span class="number">1</span></span><br><span class="line">retCh &lt;- <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loop</span><span class="params">(ctx context.Context, wg *sync.WaitGroup, retCh <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> process(ctx, wg, retCh)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> ret := &lt;-retCh:</span><br><span class="line">fmt.Println(ret)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">retCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> loop(ctx, wg, retCh)</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">cancel()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RWMutex-RLock重入导致死锁&quot;&gt;&lt;a href=&quot;#RWMutex-RLock重入导致死锁&quot; class=&quot;headerlink&quot; title=&quot;RWMutex RLock重入导致死锁&quot;&gt;&lt;/a&gt;RWMutex RLock重入导致死锁&lt;/h1&gt;&lt;p&gt;RW</summary>
      
    
    
    
    <category term="golang" scheme="https://chaomai.github.io/categories/golang/"/>
    
    
    <category term="golang" scheme="https://chaomai.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>python multiprocessing.Queue模块源码阅读</title>
    <link href="https://chaomai.github.io/2019/2019-09-10-python-multiprocessing-queue/"/>
    <id>https://chaomai.github.io/2019/2019-09-10-python-multiprocessing-queue/</id>
    <published>2019-09-10T04:35:20.000Z</published>
    <updated>2021-06-27T14:57:29.282Z</updated>
    
    <content type="html"><![CDATA[<p>之前有记录过python <a href="/2018/2018-07-04-python-multiprocessing-communication">Queue</a>的使用，以及<a href="/2019/2019-09-09-python-multiprocessing-process">multiprocessing.Process模块</a>。现在看看<code>multiprocessing.Queue</code>的具体工作方式（本文基于Python 3.7.4）。</p><p><code>multiprocessing.Queue</code>定义在queues.py中，除此之外还定义了<code>SimpleQueue</code>和<code>JoinableQueue</code>，是FIFO队列。</p><p>类似<code>multiprocessing.Process</code>，首先导入了<code>context</code>，判断当前系统类型，并相应地使用对应的实现。使用的<code>multiprocessing.Queue()</code>的时候，实际上是调用了<code>context</code>中的<code>Queue()</code>方法，设置了<code>ctx</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Queue</span>(<span class="params">self, maxsize=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Returns a queue object&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">from</span> .queues <span class="keyword">import</span> Queue</span><br><span class="line">    <span class="keyword">return</span> Queue(maxsize, ctx=self.get_context())</span><br></pre></td></tr></table></figure><h1 id="SimpleQueue"><a href="#SimpleQueue" class="headerlink" title="SimpleQueue"></a>SimpleQueue</h1><p><code>SimpleQueue</code>很简单，其实就是一个带锁的pipe，</p><ul><li>主进程和子进程分别使用各自的lock，实现写入pipe和读取pipe是并发安全的<br>  之所以<code>put()</code>和<code>get()</code>可以使用不同的lock，是因为pipe两端的读写已经是并发安全的了。</li><li>用<code>multiprocessing.Pipe</code>来实现消息传递，支持多读多写</li></ul><blockquote><p>关于<code>os.pipe</code>和<code>multiprocessing.Pipe</code></p><ul><li><code>os.pipe</code>：在Linux上底层访问的是传统的POSIX pipes，单向，使用encode/decode序列化</li><li><code>multiprocessing.Pipe</code>：使用<code>multiprocessing.Connection</code>实现，在Linux上使用POSIX sockets完成数据发送，双向，使用pickle/unpickle序列化</li></ul></blockquote><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p><code>Queue</code>可以看做在<code>SimpleQueue</code>的基础上，增加了生产者端的发送buffer、支持设置队列大小，以及<code>get()</code>和<code>put()</code>的无阻塞调用。</p><p><img data-src="/images/2019/python%20queues.jpg" alt="python queues"></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>__init__()</code>初始化了这么几个比较重要的变量，</p><ul><li><code>_maxsize</code>：队列最大size</li><li><code>_reader</code>，<code>_writer</code>：<code>multiprocessing.Connection</code>实例，负责数据的收发</li><li><code>_rlock</code>：<code>multiprocessing.Lock</code>，进程间共享，保证<code>_reader.recv_bytes()</code>并发安全</li><li><code>_wlock</code>：<code>multiprocessing.Lock</code>，进程间共享，保证<code>_writer.send_bytes()</code>并发安全</li><li><code>_sem</code>：队列长度信号量，计数器初始化为<code>_maxsize</code></li><li><code>_notempty</code>：条件变量，同步生产者放入<code>_buffer</code>和<code>_buffer</code>中数据的发送</li><li><code>_buffer</code>：每个进程有自己独立的buffer，线程安全，size其实是由<code>_sem</code>来控制</li><li><code>_thread</code>：生产者数据发送线程</li></ul><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>首先<code>_sem.acquire()</code>，计数器-1，如果不为零，说明队列还可以写入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self._sem.acquire(block, timeout):</span><br><span class="line">    <span class="keyword">raise</span> Full</span><br></pre></td></tr></table></figure><p>然后获得<code>_notempty</code>的锁，如果发送线程未创建，则创建。追加元素至buffer后，<code>_notempty.notify()</code>通知发送线程。生产者中数据的发送由单独的线程完成，主线程只负责将数据放入buffer。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> self._notempty: <span class="comment"># acquire保护_notempty和_thread的修改</span></span><br><span class="line">    <span class="keyword">if</span> self._thread <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._start_thread()</span><br><span class="line">    self._buffer.append(obj)</span><br><span class="line">    self._notempty.notify()</span><br></pre></td></tr></table></figure><h2 id="feed线程"><a href="#feed线程" class="headerlink" title="feed线程"></a>feed线程</h2><p><code>_start_thread()</code>创建thread对象后，设置<code>daemon</code>属性为<code>True</code>，目的是随主线程的退出而退出，不必手动添加停止的逻辑。接着就启动线程。</p><p>具体发送时，不断等待buffer中有元素；如果buffer中有元素，<code>popleft()</code>并发送，直到发送完。</p><p>为何<code>_notempty</code>的锁在<code>popleft()</code>就释放了？</p><ol><li>buffer是<code>collections.deque</code>，本身就是并发安全的</li><li><code>_notempty</code>锁的目的其实是为了保护<code>_notempty</code>的修改，和<code>put()</code>中的目的类似，但并不是为了保护buffer<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        nacquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> buffer:</span><br><span class="line">                nwait()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            nrelease()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                obj = bpopleft()</span><br><span class="line">                <span class="keyword">if</span> obj <span class="keyword">is</span> sentinel:</span><br><span class="line">                    debug(<span class="string">&#x27;feeder thread got sentinel -- exiting&#x27;</span>)</span><br><span class="line">                    close()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># serialize the data before acquiring the lock</span></span><br><span class="line">                obj = _ForkingPickler.dumps(obj)</span><br><span class="line">                <span class="keyword">if</span> wacquire <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    send_bytes(obj)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    wacquire()</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        send_bytes(obj)</span><br><span class="line">                    <span class="keyword">finally</span>:</span><br><span class="line">                        wrelease()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># ......</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p><strong>对于<code>block=True</code>的情况</strong><br>类似<code>SimpleQueue</code>，一直等待<code>_reader.recv_bytes()</code>，直到收到数据。在<code>_reader.recv_bytes()</code>以后，<code>_sem.release()</code>，计数器+1，表示从队列消耗了一个元素。此时如果有进程调用<code>_sem.acquire()</code>并在等待，那么<code>_sem.release()</code>会唤醒其中一个等待的进程。</p><p><strong>对于<code>block=False</code>的情况</strong><br>由于不能阻塞，因此不能一直等待<code>_reader.recv_bytes()</code>。</p><ol><li>如果在<code>timeout</code>内<code>_rlock</code>都没有获得锁，则返回<code>Empty</code></li><li><code>_reader.poll()</code>（底层还是使用<code>select</code>来实现的）判断是否在<code>timeout</code>内<code>_reader</code>可读，如果不可读，则返回<code>Empty</code></li><li>最后<code>_reader.recv_bytes()</code>，并<code>_sem.release()</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, block=<span class="literal">True</span>, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> block <span class="keyword">and</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">with</span> self._rlock:</span><br><span class="line">            res = self._recv_bytes()</span><br><span class="line">        self._sem.release()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> block:</span><br><span class="line">            deadline = time.monotonic() + timeout</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._rlock.acquire(block, timeout):</span><br><span class="line">            <span class="keyword">raise</span> Empty</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> block:</span><br><span class="line">                timeout = deadline - time.monotonic()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self._poll(timeout): <span class="comment"># 此时的timeout已经减去了等待_rlock.acquire的时间</span></span><br><span class="line">                    <span class="keyword">raise</span> Empty</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self._poll():</span><br><span class="line">                <span class="keyword">raise</span> Empty</span><br><span class="line">            res = self._recv_bytes()</span><br><span class="line">            self._sem.release()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._rlock.release()</span><br><span class="line">    <span class="comment"># unserialize the data after having released the lock</span></span><br><span class="line">    <span class="keyword">return</span> _ForkingPickler.loads(res)</span><br></pre></td></tr></table></figure><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化和反序列化使用的是pickle来实现，那么如何判断消息的边界？<code>Connection</code>中定义了一个规则，在<code>header</code>存放长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_send_bytes</span>(<span class="params">self, buf</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(buf)</span><br><span class="line">    <span class="comment"># For wire compatibility with 3.2 and lower</span></span><br><span class="line">    header = struct.pack(<span class="string">&quot;!i&quot;</span>, n)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">16384</span>:</span><br><span class="line">        <span class="comment"># The payload is large so Nagle&#x27;s algorithm won&#x27;t be triggered</span></span><br><span class="line">        <span class="comment"># and we&#x27;d better avoid the cost of concatenation.</span></span><br><span class="line">        self._send(header)</span><br><span class="line">        self._send(buf)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Issue #20540: concatenate before sending, to avoid delays due</span></span><br><span class="line">        <span class="comment"># to Nagle&#x27;s algorithm on a TCP socket.</span></span><br><span class="line">        <span class="comment"># Also note we want to avoid sending a 0-length buffer separately,</span></span><br><span class="line">        <span class="comment"># to avoid &quot;broken pipe&quot; errors if the other end closed the pipe.</span></span><br><span class="line">        self._send(header + buf)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recv_bytes</span>(<span class="params">self, maxsize=<span class="literal">None</span></span>):</span></span><br><span class="line">    buf = self._recv(<span class="number">4</span>)</span><br><span class="line">    size, = struct.unpack(<span class="string">&quot;!i&quot;</span>, buf.getvalue())</span><br><span class="line">    <span class="keyword">if</span> maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> size &gt; maxsize:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> self._recv(size)</span><br></pre></td></tr></table></figure><h2 id="close和join-thread"><a href="#close和join-thread" class="headerlink" title="close和join_thread"></a>close和join_thread</h2><p>由于生产者启动了一个线程来负责发送，元素首先append到buffer，然后发送。在进程结束时，如何确保元素发送完毕的问题？</p><p>在启动feed线程的时候，创建了两个<code>Finalize</code>对象，<code>_finalize_close</code>和<code>_finalize_join</code>，前者的优先级较高，并set了<code>_close</code>和<code>_jointhread</code>。当进程退出的时候，会自动地先后调用这两个函数（基于<code>atexit</code>实现），</p><ol><li><code>_finalize_close</code>：会append元素<code>_sentinel = object()</code>到buffer，feed线程如果看到<code>_sentinel</code>，会调用<code>close()</code>并停止服务</li><li><code>_finalize_join</code>：join feed线程</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self._joincancelled:</span><br><span class="line">    self._jointhread = Finalize(</span><br><span class="line">        self._thread, Queue._finalize_join,</span><br><span class="line">        [weakref.ref(self._thread)],</span><br><span class="line">        exitpriority=-<span class="number">5</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send sentinel to the thread queue object when garbage collected</span></span><br><span class="line">self._close = Finalize(</span><br><span class="line">    self, Queue._finalize_close,</span><br><span class="line">    [self._buffer, self._notempty],</span><br><span class="line">    exitpriority=<span class="number">10</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>模块同样也提供了<code>close()</code>和<code>join_thread()</code>方法，调用的其实就是<code>_close</code>和<code>_jointhread</code>。如果先手动调用，然后<code>aexit</code>调用，那不会回有问题？首次调用后，都会从<code>util</code>模块的<code>_finalizer_registry</code>中移除，因此不会存在重复调用<code>_finalize_close</code>和<code>_finalize_join</code>的问题。</p><h2 id="deadlock"><a href="#deadlock" class="headerlink" title="deadlock"></a>deadlock</h2><p>这几个stackoverflow（<a href="https://stackoverflow.com/questions/31665328/python-3-multiprocessing-queue-deadlock-when-calling-join-before-the-queue-is-em">1</a>，<a href="https://stackoverflow.com/questions/31708646/process-join-and-queue-dont-work-with-large-numbers">2</a>，<a href="https://stackoverflow.com/questions/26738648/script-using-multiprocessing-module-does-not-terminate">3</a>）的问题很类似，在官方的文档中也有提及（<a href="https://docs.python.org/2.7/library/multiprocessing.html#pipes-and-queues">python 2</a>，<a href="https://docs.python.org/3/library/multiprocessing.html#all-start-methods">python 3</a>），总结下来就是，<em>join一个调用put的进程，且这个进程尚未把buffer中所有的元素写入pipe时</em>，可能会导致死锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">q</span>):</span></span><br><span class="line">    q.put(<span class="string">&#x27;1&#x27;</span>*<span class="number">10000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(os.getpid())</span><br><span class="line">    q = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">    p = multiprocessing.Process(target=work, args=(q,))</span><br><span class="line"></span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    print(q.get())</span><br></pre></td></tr></table></figure><p>原因是，<code>Queue</code>使用了os的pipe来进行数据的传输，而pipe的大小是有限的。如果数据过大，<code>_writer.send_bytes()</code>在写入数据到pipe的时候会阻塞。如果此时join这个子进程，那进程本身已经卡住了，join永远等不到进程结束。</p><h1 id="JoinableQueue"><a href="#JoinableQueue" class="headerlink" title="JoinableQueue"></a>JoinableQueue</h1><p><code>JoinableQueue</code>基于<code>Queue</code>实现，覆盖了<code>put()</code>，并新增了，</p><ul><li><code>task_done()</code>：表示先前放入队列中的元素被取走了，由消费者调用</li><li><code>join()</code>：阻塞直到队列中所有元素都被取走</li></ul><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p><code>__init__()</code>调用了<code>Queue</code>的初始化函数，并额外初始化了，</p><ul><li><code>_unfinished_tasks</code>：信号量，表示队列中当前未取走的元素</li><li><code>_cond</code>：条件变量，同步<code>join()</code>和<code>task_done()</code></li></ul><h2 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h2><p>和<code>Queue</code>的<code>put()</code>基本一致。多出来的一点是，每次<code>put()</code>都会对<code>_unfinished_tasks</code>的计数器+1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, obj, block=<span class="literal">True</span>, timeout=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">with</span> self._notempty, self._cond:</span><br><span class="line">        <span class="keyword">if</span> self._thread <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._start_thread()</span><br><span class="line">        self._buffer.append(obj)</span><br><span class="line">        self._unfinished_tasks.release()</span><br><span class="line">        self._notempty.notify()</span><br></pre></td></tr></table></figure><h2 id="task-done和join"><a href="#task-done和join" class="headerlink" title="task_done和join"></a>task_done和join</h2><p><code>task_done()</code>对<code>_unfinished_tasks</code>的计数器进行-1，如果计数器为0，则通知等待在<code>join()</code>的进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_done</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self._cond:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._unfinished_tasks.acquire(<span class="literal">False</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;task_done() called too many times&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self._unfinished_tasks._semlock._is_zero():</span><br><span class="line">            self._cond.notify_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">with</span> self._cond:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._unfinished_tasks._semlock._is_zero():</span><br><span class="line">            self._cond.wait()</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://stackoverflow.com/questions/15720120/python-os-pipe-vs-multiprocessing-pipe">Python os.pipe vs multiprocessing.Pipe</a></li><li><a href="https://laike9m.com/blog/daemon-is-not-daemon-but-what-is-it,97/">Daemon is not daemon, but what is it?</a></li><li><a href="https://blog.dreamfever.me/2019/04/21/python-zhong-de-multiprocess-queue/">Python 中的 multiprocess.Queue</a></li><li><a href="https://stackoverflow.com/questions/31665328/python-3-multiprocessing-queue-deadlock-when-calling-join-before-the-queue-is-em">Python 3 Multiprocessing queue deadlock when calling join before the queue is empty</a></li><li><a href="https://stackoverflow.com/questions/31708646/process-join-and-queue-dont-work-with-large-numbers">Process.join() and queue don’t work with large numbers</a></li><li><a href="https://stackoverflow.com/questions/26738648/script-using-multiprocessing-module-does-not-terminate">Script using multiprocessing module does not terminate</a></li><li><a href="https://docs.python.org/3/library/multiprocessing.html#all-start-methods">https://docs.python.org/3/library/multiprocessing.html#all-start-methods</a></li><li><a href="https://stackoverflow.com/questions/42350933/joining-multiprocessing-queue-takes-a-long-time">Joining multiprocessing queue takes a long time</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前有记录过python &lt;a href=&quot;/2018/2018-07-04-python-multiprocessing-communication&quot;&gt;Queue&lt;/a&gt;的使用，以及&lt;a href=&quot;/2019/2019-09-09-python-multiprocess</summary>
      
    
    
    
    <category term="python" scheme="https://chaomai.github.io/categories/python/"/>
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>python multiprocessing.Process模块源码阅读</title>
    <link href="https://chaomai.github.io/2019/2019-09-09-python-multiprocessing-process/"/>
    <id>https://chaomai.github.io/2019/2019-09-09-python-multiprocessing-process/</id>
    <published>2019-09-09T07:16:20.000Z</published>
    <updated>2021-06-27T14:57:29.282Z</updated>
    
    <content type="html"><![CDATA[<p>之前有记录过<a href="/2018/2018-07-04-python-multiprocessing-communication">python进程间通信</a>的几个方式，现在来看看这个模块的具体的是怎样工作的（本文基于Python 3.7.4）。</p><p><code>multiprocessing.Process</code>典型的使用方式为，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;hello&#x27;</span>, name)</span><br><span class="line"></span><br><span class="line">p = multiprocessing.Process(target=f, args=(<span class="string">&#x27;world&#x27;</span>,))</span><br><span class="line">p.start()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure><p>以这段代码为例，看看进程的执行过程。</p><p><img data-src="/images/2019/python%20process.jpg" alt="python process"></p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p><code>import multiprocessing</code>，导入multiprocessing的时候，做了一些初始化的工作。</p><ol><li>multiprocessing的包导入了<code>context</code>，这个模块主要是判断当前系统类型，并相应地使用对应的实现。在<code>sys.platform != &#39;win32&#39;</code>的系统上，例如：mac和linux，默认使用<code>fork</code>来创建子进程。</li><li><code>context</code>模块中，<ul><li>导入了<code>process</code></li><li>定义了<code>Process</code>类，这个类继承自<code>process.BaseProcess</code>，覆盖了<code>process.BaseProcess</code>的<code>_Popen</code>方法，目的是根据系统类型，在初始化的时候根据系统类型，选择相应的<code>Popen</code>实现</li></ul></li><li><code>process</code>模块中，<ul><li>导入了<code>util</code>，注册了<code>_exit_function</code>，被注册的函数会在解释器正常终止时执行（子进程主动调用，主进程自动调用）</li><li>此时在父进程里，初始化了几个<code>process</code>模块的全局变量，<ul><li><code>_current_process</code>：代表当前进程</li><li><code>_process_counter</code>：进程数计数器</li><li><code>_children</code>：子进程的集合</li></ul></li></ul></li></ol><h2 id="创建Process实例"><a href="#创建Process实例" class="headerlink" title="创建Process实例"></a>创建<code>Process</code>实例</h2><p><code>p = multiprocessing.Process(target=f, args=(&#39;world&#39;,))</code>，实际上是调用<code>process.BaseProcess</code>的<code>__init__()</code>方法进行初始化，并使用了<code>process</code>模块的全局变量初始化实例变量，以及获取当前进程的pid，</p><ul><li><code>count = next(_process_counter)</code></li><li><code>self._identity = _current_process._identity + (count,)</code></li><li><code>self._config = _current_process._config.copy()</code></li><li><code>self._parent_pid = os.getpid()</code></li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p><code>p.start()</code>创建子进程，首先做了几个检查，</p><ol><li>如果已经创建了子进程，那么不能再次创建</li><li>只能start由当前进程创建的<code>Process</code>实例</li><li>不允许创建daemon进程的子进程</li></ol><p>接着<code>_children</code>中清理当前已经结束的进程，然后调用<code>self._Popen(self)</code>开始创建子进程。使用<code>os.fork()</code>创建子进程，用法和posix的fork一样，不多说。要注意的一点是，调用<code>os.pipe()</code>创建了<code>parent_r</code>和<code>child_w</code>，而<code>parent_r</code>将会被用于<code>join()</code>的实现。</p><p>子进程中，执行<code>_bootstrap()</code>进行初始化和运行<code>target</code>，</p><ol><li>初始化了<code>process</code>模块的全局变量，<code>_current_process</code>、<code>_process_counter</code>、<code>_children</code></li><li>清空<code>util._finalizer_registry</code>，执行<code>util._run_after_forkers()</code></li><li><code>run()</code>运行<code>target</code></li><li><code>util._exit_function()</code>做进程结束后的收尾工作<ul><li><code>util._exit_function()</code>会调用<code>_run_finalizers()</code>，这个函数会把优先级高于<code>minpriority</code>的<code>finalizer</code>执行一遍  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_finalizers</span>(<span class="params">minpriority=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Run all finalizers whose exit priority is not None and at least minpriority</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Finalizers with highest priority are called first; finalizers with</span></span><br><span class="line"><span class="string">    the same priority will be called in reverse order of creation.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li><li>默认情况下子进程的<code>_finalizer_registry</code>是空的，没有任何的<code>finalizer</code>会被执行，但可以通过<code>multiprocessing.util.Finalize</code>手动的进行注册，来完成一些收尾工作，例如：关闭db连接。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Finalize</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Class which supports object finalization using weakrefs</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj, callback, args=(<span class="params"></span>), kwargs=<span class="literal">None</span>, exitpriority=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># ......</span></span><br><span class="line">        _finalizer_registry[self._key] = self</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>创建子进程的时候，也创建了pipe <code>parent_r</code>，并set <code>self.sentinel = parent_r</code>，且关闭了<code>child_w</code>。此时唯一打开<code>child_w</code>的进程是子进程，唯一打开<code>parent_r</code>的是主进程。主进程调用<code>join()</code>时，实际上是等待<code>parent_r</code>变为可读状态（<code>wait</code>返回）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.connection <span class="keyword">import</span> wait</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> wait([self.sentinel], timeout):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>那么何时<code>wait</code>返回？<code>wait</code>循环调用<code>select</code>，当<code>parent_r</code> ready的时候，wait返回，</p><ul><li><code>parent_r</code>可读</li><li>所有writing side被关闭</li></ul><p>当子进程结束的时候，os会关闭这个进程关联的所有fd，又因为主进程已经关闭了<code>child_w</code>，所以此时<code>parent_r</code> ready，主进程中的<code>join()</code>也就返回了。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing — Process-based parallelism</a></li><li><a href="https://stackoverflow.com/questions/19265191/why-should-you-close-a-pipe-in-linux">Why should you close a pipe in linux?</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前有记录过&lt;a href=&quot;/2018/2018-07-04-python-multiprocessing-communication&quot;&gt;python进程间通信&lt;/a&gt;的几个方式，现在来看看这个模块的具体的是怎样工作的（本文基于Python 3.7.4）。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="python" scheme="https://chaomai.github.io/categories/python/"/>
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Raft Refloated Do We Have Consensus?笔记</title>
    <link href="https://chaomai.github.io/2019/2019-08-28-notes-of-raft-refloated/"/>
    <id>https://chaomai.github.io/2019/2019-08-28-notes-of-raft-refloated/</id>
    <published>2019-08-28T08:32:52.000Z</published>
    <updated>2021-06-27T14:57:29.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>文章主要使用实验验证了raft是否如原论文所阐述的易于理解和实现。重新阐述了raft，使用OCaml实现了raft，开发了一个事件驱动的模拟器来进行测试，重现了raft原论文中的测试，并提出了几个优化。</p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>对于raft的性能，raft原论文中提到了两点，</p><ol><li>典型的情况下，leader复制entry的时间。</li><li>最坏情况下，leader失败后，选举出新leader的时间。<ol><li>选举能否快速收敛？</li><li>集群能达到的最小下线时间是什么？</li></ol></li></ol><h2 id="典型的情况下，leader复制entry的时间"><a href="#典型的情况下，leader复制entry的时间" class="headerlink" title="典型的情况下，leader复制entry的时间"></a>典型的情况下，leader复制entry的时间</h2><p>需要耗费一个rtt来复制到多数派server，可以做batching和piplining优化。</p><h2 id="最坏情况下，leader失败后，选举出新leader的时间"><a href="#最坏情况下，leader失败后，选举出新leader的时间" class="headerlink" title="最坏情况下，leader失败后，选举出新leader的时间"></a>最坏情况下，leader失败后，选举出新leader的时间</h2><p>关于这点，raft原论文中使用5个server的集群做了两个测试。为了模拟最坏情况，</p><ul><li>每次测试server都有不一样长度的log，使得有的candidate不能成为leader。</li><li>为了制造易于出现split vote的环境，在每次终止leader前，都同步地广播heartbeat，目的是重置election timeout。</li></ul><p><img data-src="/images/2019/15674125053563.jpg" alt="-w302"></p><p>两个测试表明了：</p><ol><li>election time中加入少量的随机，能够明显的减少选举新leader的时间，减少split vote的出现。</li><li>集群的最小下线时间随着election time的减少而减少，但如果少于broadcast time，那么会集群产生不必要选举，降低可用性。</li></ol><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>本文中提出了几个优化，</p><ol><li>Different Follower and Candidate Timers</li><li>Binary Exponential Backoff</li><li>Combined</li></ol><p><img data-src="/images/2019/15674141041720.jpg" alt="-w293"></p><h2 id="Different-Follower-and-Candidate-Timers"><a href="#Different-Follower-and-Candidate-Timers" class="headerlink" title="Different Follower and Candidate Timers"></a>Different Follower and Candidate Timers</h2><p>raft原论文建议$\textit{candidate timeout} = \textit{follower timeout} ∼ U(T, 2T), T=150ms$，但在高竞争的情况下，例如：$U(150ms, 151ms)$，将两个时间设置在不同的范围，可以大大减少选举leader的时间。</p><h2 id="Binary-Exponential-Backoff"><a href="#Binary-Exponential-Backoff" class="headerlink" title="Binary Exponential Backoff"></a>Binary Exponential Backoff</h2><p>类似tcp超时重传的指数回退。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;文章主要使用实验验证了raft是否如原论文所阐述的易于理解和实现。重新阐述了raft，使用OCaml实现了raft，开发了一个事件驱动的模拟</summary>
      
    
    
    
    <category term="distritubed system" scheme="https://chaomai.github.io/categories/distritubed-system/"/>
    
    
    <category term="replication" scheme="https://chaomai.github.io/tags/replication/"/>
    
    <category term="raft" scheme="https://chaomai.github.io/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>6.824 2018 Lecture 6 Fault Tolerance Raft</title>
    <link href="https://chaomai.github.io/2019/2019-08-19-6.824-Spring-2018-Lecture-6/"/>
    <id>https://chaomai.github.io/2019/2019-08-19-6.824-Spring-2018-Lecture-6/</id>
    <published>2019-08-19T11:56:05.000Z</published>
    <updated>2021-06-27T14:57:29.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-Section-6-to-end-论文"><a href="#Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-Section-6-to-end-论文" class="headerlink" title="Readings - In Search of an Understandable Consensus Algorithm (Extended Version) (Section 6 to end)论文"></a>Readings - In Search of an Understandable Consensus Algorithm (Extended Version) (Section 6 to end)论文</h1><h2 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h2><p>实际应用中，常常会有配置变更的需求，即：成员变更。手动的方式有下面两种，</p><ul><li>把集群整体下线，配置修改完毕以后再上线是可行的，但会造成服务不可用。</li><li>新server可以通过获取其ip来替换集群成员，需要保证被替换的server不会再加入集群。</li></ul><p>但这两个方式都有明显的弊端，且任何手动的步骤都有引起错误的可能。</p><p>配置切换需要保证安全性，在同一个term内，集群不能够同时存在两个leader。由于无法一次性原子的切换所有server的配置，一次增减多个server并直接切换配置可能会出现disjoint majorities的情况。</p><p>raft变更的方案有两种：</p><ol><li>single-server change</li><li>使用joint consensus</li></ol><h3 id="single-server-change"><a href="#single-server-change" class="headerlink" title="single-server change"></a>single-server change</h3><p>每次增减一个server。</p><p><strong>配置的变更</strong><br>具体变更过程如下，</p><ol><li>leader收到变更请求，AppendEntries RPC按新配置发送$C_{new}$。</li><li>每个server收到$C_{new}$后<em>立即生效</em>。</li><li>新配置下，$C_{new}$复制到大多数server，则达成committed。<ul><li>此时，就算有剩下的server未得到新配置，也不会构成多数派，</li><li>且，未得到新配置的server也不被选举为leader。</li></ul></li></ol><p>$C_{new}$提交后，</p><ol><li>leader可以响应client，告知本次配置变更已经完成。</li><li>如果配置是移除一个server，那么这个server可以下线了。</li><li>可以开始下一次配置更新。</li></ol><p><strong>安全性</strong><br><img data-src="/images/2019/15662026435774.jpg" alt="-w543"></p><p>总共有四种情况：</p><table><thead><tr><th></th><th>member change</th><th>变更后达成disjoint majorities的条件</th></tr></thead><tbody><tr><td>奇数个成员，增加一个</td><td>2k+1 -&gt; 2k+2</td><td>old = k+1, new = k+2</td></tr><tr><td>奇数个成员，减少一个</td><td>2k+1 -&gt; 2k</td><td>old = k+1, new = k+1</td></tr><tr><td>偶数个成员，增加一个</td><td>2k -&gt; 2k+1</td><td>old = k+1, new = k+1</td></tr><tr><td>偶数个成员，减少一个</td><td>2k -&gt; 2k-1</td><td>old = k+1, new = k</td></tr></tbody></table><p>任意一种情况对应的条件都是不可能<em>同时</em>达成的，因为要求的成员数目都大于真正的成员数目，不会产生同一个term两个leader的现象。换句话说，旧配置集群与新配置集群的<em>任意多数派必然有交集</em>，即：至少存在一个voter（接受旧leader的$C_{new}$，并且为新leader投票），不会出现disjoint majorities。</p><p>因此增减一个server情况，直接切换配置是安全的。</p><p>这个交集也保证了在变更配置的过程中，在$C_{old}$中、以及变更期间复制的日志，最后一定会出现在$C_{new}$。</p><p><strong>何时开始下一次变更</strong><br>能够开始下一次配置更新的<em>前提是当前的配置已经commit</em>，否则无法保证安全性。如果server在$C_{new}$commit以后才使用$C_{new}$，会带来很多不必要的、额外的维护工作，</p><ol><li>leader很难知道旧配置集群的多数派使用$C_{new}$的时间。</li><li>需要跟踪哪些server知道了commit，且做持久化。但这些是raft本身不具备的功能。</li><li>如果leader改变了，那么需要移除$C_{new}$的entry，此时，server还需要准备回滚到上一个配置。</li></ol><p><strong>majority的是对谁而言的</strong><br>对于选举和append entry，都是仅由<em>调用方</em>来判断是否达成多数派，接收方不负责，否则会存在类似“鸡生蛋蛋生鸡”的问题。</p><p><strong>可用性</strong><br>配置变更给保证集群的可用性带来了几个问题。</p><ol><li><p>Catching up new servers<br> <img data-src="/images/2019/15662894360490.jpg" alt="-w517"></p><p> 一个新server加入集群，新server通常并不包含任何entry，那么可能需要花费较长的时间来同步日志。在这段时间，集群更容易出现不可用的问题。例如：3-&gt;4，此时要求的majority是3，但是s3挂了。</p><p> 为了最小化不可用的出现，需要<em>保证不可用的时间在一次election timeout内</em>。</p><p> <img data-src="/images/2019/15662902585664.jpg" alt="-w530"></p><p> 具体方法是，</p><ul><li>新加入的server先作为non-voting成员。</li><li>复制到新server的过程分为多个round，每个round都复制leader所有的entry。</li><li>当前复制的round内，leader可能又有新的entry了，下一个round会进行复制。</li><li>在固定round内（例如：10），如果最后一个round的时间 &lt; election timeout，此时假设不存在更多的entry会导致明显的不可用，添加新server。</li><li>否则leader终止变更配置。</li></ul></li><li><p>Removing the current leader<br> 如果使用joint Consensus，或没有leadership transfer的情况下，需要一个leader下线的方法：旧leader等到$C_{new}$ commit以后让位（转变为follower状态）。</p><p> 在commit之前，当前leader管理集群不包含leader自己，复制和投票的时候不把自己算入majority。</p></li><li><p>Disruptive servers<br> 被排除在$C_{new}$之外的server，由于不再收到heartbeat，会不断的发起投票。虽然新选出的leader始终会出现在$C_{new}$中，但是这干扰了集群正常的工作。</p><p> 第一个思路是引入一个Pre-Vote阶段，在发起选举前，检查自己是否有成为leader的资格，即：candidate的log比大多数server更新。但并不总是有效。例如：{ABCD}-&gt;{ABC}的时候，A是Leader，在尝试复制$C_{new}$到BC的时候，D可能发起了Pre-Vote，D的log相对于BC足够新，可以获得BC的投票成为leader。因此检查log的方式是不可行的。</p><p> raft使用的方式是，如果一个server获得上一次heartbeat的时间在最小election timeout内，这个server收到RequestVote时就不更新term或投票。</p><p> 如果确实需要发起选举，例如：进行leadership transfer的时候，可以用一个标志位来区分。</p></li></ol><p><strong>bug in single-server change</strong><br>如果配置变更是在同一个term内完成的，那么不会有问题。但如果出现在跨term且并发的配置变更，就不一定了。</p><p>例如先后增减一个server，具体过程如下，<br><img data-src="/images/2019/15663835361828.jpg" alt="-w630"></p><p>2中，s1把D复制到s1和s5然后挂了，接着s2接受s2、s3、s4的投票（使用C判断majority）成为term2的leader。5中，s2把E复制到s2和s3，并标记为committed（使用E判断majority）。然后s1恢复，接受s1、s4、s5的投票（使用D判断majority）成为term3的leader，继续复制D，最后在7中覆盖已提交的E。</p><p>这个问题类似<a href="/2019/2019-07-15-6.824-Spring-2018-Lecture-5/#%E5%AE%89%E5%85%A8%EF%BC%88Safety%EF%BC%89">提交上一个term的entry</a>，解决方法是一样的，<em>leader当选以后，直到当前term的entry提交以后，才能开始下一次配置变更</em>。可以通过append一个no-op entry来实现。</p><p>原文的single-server change保证了，在同一个term内不会出现未提交的configuration entry。这个patch保证了，来自先前term未提交的configuration entry永远不会被提交。</p><p>回到前面的例子，3中s2成为term2的leader以后立即append no-op entry，此时使用C判断majority，假设复制到s2、s3、s4的index 2。接着s2继续把E复制到s2和s3。如果接下来s1恢复并发生了选举，s1不可能成为leader，因而避免了已提交的E被覆盖的情况。</p><h3 id="使用joint-consensus"><a href="#使用joint-consensus" class="headerlink" title="使用joint consensus"></a>使用joint consensus</h3><p>这个方法并不建议在工程中使用，更简单的single-server change足以将集群变更为任何期望的配置。</p><p><img data-src="/images/2019/15663598511958.jpg" alt="-w344"></p><p><strong>joint consensus</strong><br>joint consensus状态混合了新旧配置，允许每个server在不同的时间安全地切换配置，且在这个过程中能持续提供服务，这个状态中，</p><ul><li>entry会被复制到所有新旧配置。</li><li>来自任何配置的机器都可以被选举为leader。</li><li>选举和append的majority，需要分别来自新旧配置。</li></ul><p>相比single-server change，joint consensus引入了一个中间的entry $C_{old,new}$，具体过程是，</p><ol><li>将新旧配置存储到$C_{old,new}$，并复制，进入joint consensus状态。</li><li>每个server收到$C_{old,new}$后<em>立即生效</em>，leader使用$C_{old,new}$来判断是否提交。<br> $C_{old,new}$复制的过程中，如果leader挂了，那么新的leader可能在$C_{old,new}$或$C_{old}$中选举出。无论leader来自哪个配置，$C_{new}$不能单方进行决策。</li><li>$C_{old,new}$提交后，leader可以复制$C_{new}$。<br> 一旦$C_{old,new}$提交，$C_{new}$或$C_{old}$都不能单方进行决策。</li><li>leader使用$C_{new}$来判断是否提交，提交后，完成配置变更。</li></ol><p><strong>安全性</strong><br>在joint consensus过程中，发生选举时，可能从以下情况选出leader（按joint consensus的步骤顺序列举），</p><ol><li>来自$C_{old}$，log不包含$C_{old,new}$。</li><li>来自$C_{old}$，log包含$C_{old,new}$。</li><li>来自$C_{new}$，log包含$C_{old,new}$。</li><li>来自$C_{new}$，log包含$C_{new}$。</li></ol><p>而任何两个leader的组合都是不可能同时出现的。</p><table><thead><tr><th>leader组合</th><th>不可能出现的原因</th></tr></thead><tbody><tr><td>1+1 or 4+4</td><td>选举规则限制</td></tr><tr><td>1+2</td><td>先看2的选举，需要分别来自新旧配置的多数派，此时已经不能再从$C_{old}$中选举1</td></tr><tr><td>1+3</td><td>类似1+2</td></tr><tr><td>1+4</td><td>a. 先看4，既然$C_{new}$出现了，那么$C_{old,new}$肯定提交了，这个提交需要分别来自新旧配置的多数派，因此$C_{old}$中不包含$C_{old,new}$的server无法选举为leader</br>b. $C_{new}$是在$C_{old,new}$提交后才复制，如果选举出4，1就不会存在</td></tr><tr><td>2+2</td><td>类似1+2</td></tr><tr><td>2+3</td><td>类似1+2</td></tr><tr><td>2+4</td><td>类似1+2</td></tr><tr><td>3+3</td><td>类似1+2</td></tr><tr><td>3+4</td><td>类似1+2</td></tr></tbody></table><p>因此不会出现disjoint majorities的情况。</p><p><strong>是否受single-server change的bug影响</strong><br>不受。</p><h2 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h2><p>raft的日志随着客户端不断的请求增长。一旦entry已经提交并执行，那么中间的状态和操作就不再需要，可以被压缩。</p><p>文章讨论了几种进行日志压缩的方法，</p><ul><li>Snapshotting memory-based state machines</li><li>Snapshotting disk-based state machines</li><li>Incremental cleaning approaches</li><li>Leader-based approaches</li></ul><p>这几个方法有一些核心概念基本都是相通的，</p><ol><li>每个server独立的负责日志压缩，而非由leader集中决定。</li><li>raft向状态机转移维护prefix of the log的职责。</li><li>raft丢弃部分日志前缀a prefix of the log后，状态机会承担两个新的职责<ol><li>如果server重启，状态机在apply entry前，需要先load那些被丢弃的日志。</li><li>为了落后较多的server或新server能够追上，状态机可能需要输出一个状态的镜像。</li></ol></li></ol><h3 id="Snapshotting-memory-based-state-machines"><a href="#Snapshotting-memory-based-state-machines" class="headerlink" title="Snapshotting memory-based state machines"></a>Snapshotting memory-based state machines</h3><p>适用于状态机的数据是存放在内存的情况。每个server独立的创建已经提交entry的snapshot。主要过程是，</p><ul><li>状态机序列化当前状态。</li><li>一旦状态机完成snapshot的写入以后，日志就可以被截断了，raft首先保存snapshot中lastIncludedIndex和lastIncludedTerm，以及这个index对应的lastIncludedConf。</li><li>raft可以丢弃截止index的entry和先前的snapshot。</li></ul><p><img data-src="/images/2019/15663712160542.jpg" alt="-w318"></p><p><strong>InstallSnapshot</strong><br>为了落后较多的server或新server能够追上，这个方法里使用InstallSnapshot来实现。leader仅当丢弃了需要复制的next entry的时候，才发送snapshot，snapshot以chunks的形式有序发送。</p><p><strong>并发创建</strong><br>创建snapshot时，状态机需要维持一个不变的状态，但进行序列化和落盘需要较长的时间，因此创建的过程需要与普通操作并发执行。可以使用copy-on-write实现，有两种方法，</p><ol><li>状态机使用不可变数据结构。</li><li>依赖os的copy-on-write支持，例如：linux的fork。</li></ol><p>copy-on-write占用额外的内存，在创建的过程中，占用的额外内存与状态的修改成正相关，因此需要事先计划和管理。如果在snapshot的过程中，内存满了，那么server只能暂停服务，此时集群可能还是可用的。最好不要终止稍后重试，下次创建的时候很可能还会有类似的问题。</p><p><strong>何时创建</strong><br>如果创建的过于频繁，会浪费磁盘带宽和其他资源，如果过于稀少，会导致创建出过大的snapshot，增加传输和回放的时间。</p><p>有这么几个判断的方法，</p><ul><li>如果size(log)明显大于一个预定的值。<br>  当这个值明显大于snapshot的大小时，磁盘写入开销会很小。但对于较小的状态机，需要等待较长的时间才会有满足大小要求的log。</li><li>如果size(log)大于size(snapshot)的倍数。<br>  不过判断当前状态机的snapshot大小并不容易。</li><li>如果size(log)大于size(prev snapshot)的倍数，expansion factor。<br>  expansion factor控制了磁盘带宽的开销。</li></ul><p>还可以仅在少数派server上创建snapshot，不影响服务client。</p><h2 id="Client交互"><a href="#Client交互" class="headerlink" title="Client交互"></a>Client交互</h2><h3 id="查找cluster"><a href="#查找cluster" class="headerlink" title="查找cluster"></a>查找cluster</h3><p>如果配置固定，这个过程很简单。难点在于成员不断变更的情况，可用的方法有，</p><ul><li>广播，但受限于特定的网络环境。</li><li>使用外部的目录服务，例如：DNS。需要在变更的过程中增减相应的server。</li></ul><h3 id="路由请求到leader"><a href="#路由请求到leader" class="headerlink" title="路由请求到leader"></a>路由请求到leader</h3><p>client的请求是由leader处理的，因此client需要找到leader，可以随机的选取一个server发起请求，如果不是leader，server拒绝，client重试直到找到为止，尝试次数期望是$(n+1)/2$。在此基础上可以做一些优化，</p><ul><li>server拒绝的时候返回leader。</li><li>server做代理，转发请求到leader。</li></ul><p>还需要避免过期的leader信息导致处理client请求的时候产生不必要的延迟，</p><ul><li>leader：如果产生网络分区，且client向拥有少数派的leader发送了请求，在分区恢复前，这个请求一直都无法得到处理。因此当<em>超过election timeout以后，leader都没有向多数派成功的发送心跳，那么leader让位</em>。</li><li>follower：如果follower发起新的选举或者term变更，那么follower丢弃当前维护的leader信息。</li><li>client：当丢失与某个server的连接，应该随机选取一个server进行重试。</li></ul><h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>截止目前，raft提供了at-least-once的语义。client重试、以及网络导致请求重复会导致命令被执行多次。但是at-least-once对于一个基于共识的系统是不够的，raft需要<em>可线性化的语义</em>，通过对请求去重，可以实现这一点。</p><p><strong>使用session去重</strong><br>每个client分配一个唯一id，每个请求分配一个唯一的递增序号。server维护每个client的session，这个session跟踪了每个client的最新序号和对应的response，如果收到了一个已经处理过的序号，那么直接返回。</p><p>这样每个命令就做到了以log中第一次出现的顺序立即生效且只执行一次。</p><p>对于来自同一个client的并发请求，server维护一个&lt;序号，response&gt;的集合。每个请求中携带一个client未收到的最小序号，server丢弃小于这个序号的response。</p><p><strong>session保存的多久</strong><br>受存储的限制，session不能永久保存，server需要对何时过期session达成共识。</p><ul><li>一个方法是设置存储session数的上限，并使用lru淘汰session。</li><li>另一个方法是基于对时间源达成的共识来淘汰session（原文中的描述不是非常清晰，待补充）。</li></ul><p><strong>处理session过期的client请求</strong><br>当session过期后，client还继续操作时，这被看做异常情况（待补充）。</p><h3 id="更高效的处理read-only请求"><a href="#更高效的处理read-only请求" class="headerlink" title="更高效的处理read-only请求"></a>更高效的处理read-only请求</h3><p>raft日志的目的是以相同的顺序把变更复制到server上，并保证读写时候的线性一致性语义。read-only命令只涉及查询状态机，可以绕开日志的复制，避免同步磁盘写入，会大大的提升性能。但如果没有额外的控制，client会读取到过期的值。</p><p>为了使得绕开raft日志的read-only请求保持线性一致性，针对每次read-only请求，leader需要，</p><ol><li>如果当前term还没有提交过entry，等待直到有。如果是刚成为leader，则需要先提交一个no-op entry。</li><li>leader将当前的commit index记录到本地变量<em>readIndex</em>，这个会作为read-only操作的下界。</li><li>leader需要自己的身份是有效的，不存在在自己不知情的情况下（网络分区）选举出了新的leader。这里的方法与<a href="#%E8%B7%AF%E7%94%B1%E8%AF%B7%E6%B1%82%E5%88%B0leader">路由请求到leader</a>中避免过期的leader类似，如果成功向多数派发送了heartbeat，那么leader可以知道在发送heartbeat的时候，身份仍然是有效的。</li><li>leader等待lastApplied &gt;= readIndex，此时的readIndex是<em>能保证线性一致性的最小index</em>。</li><li>leader向自己的状态机发起查询请求，并返回结果。</li></ol><p><strong>优化leadership确认</strong><br>每次查询请求都需要执行3，可以把所有累计的查询通过一次heartbeat来确认leadership。</p><p><strong>follower分担read-only负载</strong><br>同样需要保证不读取到过期的数据，保证线性一致性。为此follower可以向leader发送一个<em>查询当前readIndex的请求</em>，然后leader执行上面的1-3，follower执行4-5。</p><p><strong>使用时钟减少heartbeat带来的延迟</strong><br>虽然有batch优化，read-only查询仍然需要做一次heartbeat来确认leadership，可以用时钟来避免heartbeat带来的延迟。</p><p><img data-src="/images/2019/15668148723093.jpg" alt="-w262"></p><ul><li>leader使用heartbeat来维持一个lease，如果leader成功向多数派发送了heartbeat，那么leader可以认为在接下来的election time时间内都不会有新的leader产生，这个lease可以扩展到$start+\frac{\textit{election timeout}}{\textit{clock drift bound}}$，在这个时间之前都不用执行上面的步骤3。</li><li>在进行leadership transfer的时候需要将lease主动过期，因为会导致更早的产生新leader。</li></ul><p><em>要注意的是</em>，使用lease的方式假设了server之间时钟漂移的上界（在给定的一段时间内，没有server的时钟增加的时间会超过这个上界），找到并维护这个值会增加额外的运维成本。如果假设失效了，系统可能会返回任意过期的信息。</p><p>可以使用一个的扩展来增强对client提供的保证，<em>即使上述假设失效的情况下，读操作满足线性一致性</em>，不至于错的离谱。具体方法是，</p><ol><li>server返回client的时候，带上状态机状态对应的index。</li><li>client跟踪自己看到的与结果对应的最新index，发送请求的时候带上这个index。</li><li>如果server收到的index &gt; lastApplied，那么server暂时不处理这次请求。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>创建snapshot的时候，有什么限制？<ul><li>不能丢弃未提交的和未执行的</li><li>已执行的entry可能需要用于使其他server更新</li></ul></li><li>snapshot和log的关系？<br> snapshot反映的是已经执行的log。</li><li>server持久化了哪些数据在磁盘上？<ul><li>截止到某个entry的snapshot + 后续的log = server完整的log。</li><li>其他状态信息，如：currentTerm，votedFor等。</li></ul></li><li>如果某个follower落后了，同时leader丢弃了follower的所需的log，怎么办？<br>  nextIndex将无法会退到那个entry，leader会使用InstallSnapshot RPC。</li><li>leader何时会向落后follower发送InstallSnapshot RPC？<br> 上面的问题即为答案。</li><li>为何leader不仅仅丢弃所有follower都有的entry？<ul><li>每个server是独立创建snapshot的。</li><li>少数落后或失败的follower会导致leader log的持续增加。</li></ul></li><li>snapshot包含什么信息？<ul><li>term</li><li>lastIncludedIndex</li><li>lastIncludedTerm of lastIncludedIndex</li><li>lastIncludedConf at lastIncludedIndex</li><li>snapshot data</li></ul></li><li>follower InstallSnapshot RPC的流程是什么？<ul><li>检查term</li><li>检查是否已包含lastIncludedIndex/lastIncludedTerm</li><li>set lastApplied = lastIncludedIndex，写入data</li><li>使用snapshot重置状态机</li></ul></li><li>server收到InstallSnapshot RPC以后，有没有可能会导致状态机的状态回退？<br> 不会。follower会检查是否已经包含lastIncludedIndex/lastIncludedTerm。</li><li>为什么在处理read-only请求的时候需要提交一个no-op entry？<br>问题类似于<a href="/2019/2019-07-15-6.824-Spring-2018-Lecture-5/#%E5%AE%89%E5%85%A8%EF%BC%88Safety%EF%BC%89">提交上一个term的entry</a>，新leader并不知道先前term的entry是否已提交。需要append一个no-op entry，如果成功提交，那么表示在此之前的所有entry都是已提交了的。</li><li>配置变更时，从集群移除的server如果发起选举，会[影响集群的可用性](#single-server change)，为何不直接把离开集群的server关闭？<br>$C_{new}$不会复制到那些离开集群的server，因此无法做到$C_{new}$提交以后，就立即下线这些server。在关闭前的这段时间里，这些server可能会影响集群的可用性。</li><li>joint consensus过程中，选举和提交需要同时获得新旧配置的多数派，这对性能的影响有多大？<ul><li>在大多数不发生错误的情况下，获得新旧配置的多数派应该是一个比较快的过程。</li><li>获得新旧配置的多数派仍然会比普通的commit要慢，但考虑到配置变更并不经常发生，所以这个代价可以忍。</li></ul></li><li>joint consensus过程中，选举和提交需要同时获得新旧配置的多数派是否是必须的？<br>是，这是为了确保安全性所必须的。在joint consensus关于[安全性的讨论中](#使用joint consensus)，列举了如果leader失败，发生选取时的情况，除特殊的两个外，获得新旧配置多数派的要求<em>避免了disjoint majority出现</em>。</li><li>配置变更时，新server是作为non-voting成员加入的，这个要求为何可以提升可用性？<br>当$C_{old,new}$提交以后，集群才可以继续处理请求。而$C_{old,new}$的提交需要新配置的多数派复制成功，空server会拖慢达这个过程。</li><li>离开集群的server发起投票会影响集群的可用性，为何不直接使用当前配置来判断，看发起请求的server是否在配置中？</li><li>joint consensus的起止时刻是什么？<ul><li>开始：leader append $C_{old,new}$。</li><li>终止：<ul><li>leader未成功提交$C_{old,new}$就挂了。</li><li>leader成功提交$C_{new}$。</li></ul></li></ul></li><li>配置的entry是否可能被后续leader覆盖？<br>可能。如果前任leader未成功提交$C_{old,new}$就挂了。</li><li>如果log和创建的snapshot大小差别不大，那snapshot是否还有用（例如：k/v server大量插入新key）？<br>有。<ul><li>避免raft log entry一直占用内存。</li><li>恢复服务时，使用snapshot可能会比直接使用log能更快（比如snapshot数据的组织方式更好）。</li></ul></li><li>InstallSnapshot会占用带宽不？<br>会，如果状态很大的话。可以用一些方式来减少InstallSnapshot RPC的调用，<ul><li>考虑让leader保留更久的log，来应对follower的lag或暂时的下线。</li><li>只发送两个server diff的部分。</li></ul></li><li>follower的entry是否有可能不在收到的snapshot里面？<br>有可能，例如：leader尚未提交的entry。</li><li>InstallSnapshot是否是原子的？如果在InstallSnapshot执行途中，follower挂了，重发InstallSnapshot是否ok？<br>是原子的、幂等的。</li></ol><h1 id="Lecture"><a href="#Lecture" class="headerlink" title="Lecture"></a>Lecture</h1><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>raft牺牲了性能来换取简洁的设计：</p><ol><li>follower拒绝乱序的append，不允许日志有空洞。</li><li>尚未支持batch或pipeline方式的append。</li><li>对于大的状态，snapshot比较浪费。</li><li>慢leader会影响系统的性能。</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://loopjump.com/raft_one_server_reconfiguration/">Raft One-Server成员变更</a></li><li><a href="https://zhuanlan.zhihu.com/p/30706032">一文看尽 Raft 一致性协议的关键点</a></li><li><a href="https://gist.github.com/ongardie/a11f32b70581e20d6bcd">ongardie/raft-single-server-changes-safety</a></li><li><a href="https://groups.google.com/forum/#!topic/raft-dev/t4xj6dJTP6E">bug in single-server membership changes</a></li><li><a href="https://github.com/peterbourgon/raft/blob/master/JOINT-CONSENSUS.md">raft/JOINT-CONSENSUS.md</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-Section-6-to-end-论文&quot;&gt;&lt;a href=&quot;#Readings-In-Search-of-an</summary>
      
    
    
    
    <category term="distritubed system" scheme="https://chaomai.github.io/categories/distritubed-system/"/>
    
    
    <category term="6.824" scheme="https://chaomai.github.io/tags/6-824/"/>
    
    <category term="replication" scheme="https://chaomai.github.io/tags/replication/"/>
    
    <category term="raft" scheme="https://chaomai.github.io/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>DDIA 第一章 可靠、可扩展、可维护的应用</title>
    <link href="https://chaomai.github.io/2019/2019-08-16-ddia-chapter1/"/>
    <id>https://chaomai.github.io/2019/2019-08-16-ddia-chapter1/</id>
    <published>2019-08-15T16:22:53.000Z</published>
    <updated>2021-06-27T14:57:29.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据密集型应用"><a href="#数据密集型应用" class="headerlink" title="数据密集型应用"></a>数据密集型应用</h1><p>现在的很多应用是<em>数据密集型</em>的，数据是这些应用的主要挑战-数据的总量、数据的复杂度和数据变化的速度。</p><p>很多数据密集型的应用都是基于已有的数据系统提供的常用功能来构建的。例如：</p><ul><li>存储数据，以便自己或其他应用能够找到（基于数据库实现此功能）</li><li>记住一个昂贵操作的结果，来加速读取（缓存）</li><li>允许用户通过关键词搜索数据，或多种方式过滤数据（搜索索引）</li><li>发送消息到另一个进程进行异步处理（流式处理）</li><li>定时处理大量累积的数据（批处理）</li></ul><p>由于数据系统的抽象，这些功能都看似很简单。但是，数据系统在逐渐变得相似，不同的数据系统可能同时具有多种特性，例如：Redis的cache和消息队列功能；应用程序越来越宽泛的需求使得单一数据系统无法完成，需要使用程序代码来组合不同的数据系统；同一需求，可能有多种方式和数据系统来实现。因此选择合适的数据系统和权衡架构的设计是一个值得思考的问题。</p><h1 id="设计数据系统的原则"><a href="#设计数据系统的原则" class="headerlink" title="设计数据系统的原则"></a>设计数据系统的原则</h1><ul><li>可靠性（Reliability）<br>  就算出现问题的时候（硬件或软件错误，人为错误），系统都应该应该持续的正确工作（在期望的水平上提供正确的功能）。</li><li>可扩展性（Scalability）<br>  随着系统的增长（数据量、流量或数据复杂度），应该有合理的方法来应对这些增长。</li><li>可维护性（Maintainability）<br>  随着时间的推移，许多人都会参与系统相关的工作（开发和运维，他们保证系统现有行为正常、并使系统能够应对新的情况），他们应该高效的工作。</li></ul><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>系统具有容错性（fault-tolerant或resilient）。系统在遇到<strong>特定错误的时候</strong>，也能按预期正常工作。</p><blockquote><p>这里原文特别区别了fault和failure。fault指的是系统组件的运作偏离了预期，而failure指的是系统整体无法提供服务。设计一个完全没有fault的系统是不可能的，但是可以通过设计fault-tolerant机制来避免fault导致failure。<br>下面，failure会写为系统故障。</p></blockquote><p><strong>硬件故障</strong><br>每个硬件都有预期的寿命，系统使用的硬件规模够大、运行时间够长时，硬件总会出故障。</p><p>通过软件和硬件层面冗余的方式，可以避免出现硬件故障时无法提供服务。</p><p><strong>软件错误</strong><br>硬件错误的发生相对独立，但是软件错误更加难以预期，往往会导致很多的系统错误。</p><p>通过完善的考虑系统的假设和交互、测试、进程隔离、监控、允许进程挂了后重启等方式来避免软件错误。</p><p><strong>人为错误</strong><br>系统的设计、构建和运维是由人来进行的，但人是不可靠的。</p><p>通过如下方式来减少人为错误：</p><ul><li>以最小化错误机会的方式来设计系统。例如：设计良好的抽象、API和管理界面来避免“做错误的事”。</li><li>解耦人们最容易犯的错和犯错的地方。例如：提供完整功能的非生产环境sanbox。</li><li>完善的测试。例如：从单元测试到整个系统集成测试。</li><li>提供快速和简单的错误恢复机制。例如：快速的回滚配置，上线新代码应逐步从小范围内到大范围，提供重新计算数据的工具来修复老数据错误。</li><li>详尽和清晰的监控。例如：性能计数和错误率。</li></ul><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>即便一个系统现在能够可靠的工作，这不意味着未来也能。一个常见的原因就是负载的增加。当讨论可扩展性时，常常需要考虑，“如果系统以一个特定的方式增长，应该怎么办？”，“如何增加计算资源来应对额外的负载？”。</p><p><strong>描述负载</strong><br>首先需要简洁的描述负载，负载可以使用几个数字来描述，叫做负载参数（load parameters），参数的选择依赖于系统的架构，例如：</p><ul><li>web服务器每秒的请求个数。</li><li>数据库的读写比例。</li><li>聊天室同时活跃的用户数。</li><li>cache命中率。</li></ul><p><strong>描述性能</strong><br>一旦有了系统负载的描述，那么可以讨论负载增加时会发生什么，可以有两个角度：</p><ul><li>负载增加时，如果保持系统资源不变，系统的性能会怎样？</li><li>负载增加时，为了保持系统性能不变，需要增加多少资源？</li></ul><p>讨论这两个问题需要描述性能，</p><ol><li>吞吐量（批处理系统）</li><li>响应时间（在线系统）<ul><li>平均响应时间。</li><li>百分比响应时间。<br>  例如：p50，取time的中位数，如果是200ms，那么代表50%的响应时间小于200ms。类似的还有p90，p99。</li><li>高百分比响应时间，又叫做尾部延迟（tail latencies）。</li></ul></li></ol><p>性能与可用性一起被用在SLOs（service level objectives）和SLAs（service level agreements）中，规约定义了服务期望的性能和可用性。</p><p>高百分比响应时间常常受队列延迟（queueing delay）的影响，少量慢请求会阻塞后续请求的处理，这个现象又叫做head-of-line blocking。</p><p>如果一个请求需要进一步使用更多的后端调用来完成，那么一个较慢的调用就会拖慢整个请求，这叫做尾部延迟放大（tail latency amplification）。</p><p><strong>应对负载的方法</strong></p><ol><li>scaling up<br> 垂直缩放，迁移到性能更强的机器。</li><li>scaling out<br> 水平缩放，把负载分布到多个小机器上。也叫做share-nothing architecture。</li></ol><p>实际工程上可能会混用两种方法，几个性能较强的机器可能比非常多的小机器来的划算。把无状态的服务分布到多个机器较为容易，但是把一个有状态的数据系统分布式化会引入很多额外的复杂性。</p><p>大规模分布式系统架构往往是针对应用高度定制化的，并不存在一个通用的分布式架构。因为要解决的问题可能是读为主、写为主、大量数据的存储为主、数据的复杂度、响应时间、访问方式，或者是前面各种因素的混合。</p><h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>软件开发的主要成本并不在最初的开发，而是持续的维护-修bug、运维、排错、兼容性的平台等。主要关注以下方面，</p><ol><li>可操作性，便于运维团队的维护。<br> 需要提供：<ul><li>完善的监控</li><li>自动化和集成工具</li><li>避免依赖特定的机器</li><li>文档</li><li>良好的默认行为，并提供修改默认行为的方法</li><li>自我恢复，并提供手动操作的方法</li><li>可预测的行为</li></ul></li><li>简单，管理复杂性，便于其他开发者理解系统。<br> 好的抽象可以隐藏复杂的细节。</li><li>可进化，便于修改和增加系统功能，又叫做可扩展性（extensibility）、可修改性（modifiability）、可塑性（plasticity）。<br> 增加数据系统的敏捷性。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据密集型应用&quot;&gt;&lt;a href=&quot;#数据密集型应用&quot; class=&quot;headerlink&quot; title=&quot;数据密集型应用&quot;&gt;&lt;/a&gt;数据密集型应用&lt;/h1&gt;&lt;p&gt;现在的很多应用是&lt;em&gt;数据密集型&lt;/em&gt;的，数据是这些应用的主要挑战-数据的总量、数据的复杂度和</summary>
      
    
    
    
    <category term="distritubed system" scheme="https://chaomai.github.io/categories/distritubed-system/"/>
    
    
    <category term="ddia" scheme="https://chaomai.github.io/tags/ddia/"/>
    
  </entry>
  
  <entry>
    <title>6.824 2018 Lecture 5 Fault Tolerance Raft</title>
    <link href="https://chaomai.github.io/2019/2019-07-15-6.824-Spring-2018-Lecture-5/"/>
    <id>https://chaomai.github.io/2019/2019-07-15-6.824-Spring-2018-Lecture-5/</id>
    <published>2019-07-15T07:13:32.000Z</published>
    <updated>2021-06-27T14:57:29.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-to-end-of-Section-5-论文"><a href="#Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-to-end-of-Section-5-论文" class="headerlink" title="Readings - In Search of an Understandable Consensus Algorithm (Extended Version) (to end of Section 5)论文"></a>Readings - In Search of an Understandable Consensus Algorithm (Extended Version) (to end of Section 5)论文</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>共识算法（Consensus algorithms）允许一组机器作为一个一致的组工作，这个组可以在某些成员失败的情况下存活。Paxos是过去10多年最常被讨论的共识算法，但是难以理解且不便于实现。提出Raft的主要目标是可理解性。通过解耦leader选举、log复制和安全，以及减少状态空间，来增加可理解性。</p><p><strong>多副本状态机（Replicated state machine）与共识算法</strong><br>共识算法常常出现在多副本状态机的讨论中。</p><p><img data-src="/images/2019/15633494887544.jpg" alt="-w384"></p><p>多副本状态机常用于解决分布式系统中的各种容错问题，使用复制log来实现，每个状态机以相同的顺序执行相同的命令，最终算出相同的状态和结果。保证replicated log的一致是由共识算法来实现的。</p><p>共识算法一般有以下几个特征：</p><ul><li>安全：<em>非拜占庭条件</em>（网络问题、丢包、乱序）下，不返回任何错误的结果。</li><li>可用性：大多数server可用，则系统整体可用。</li><li>不依赖时间来保证日志的一致性。</li><li>大多数server执行完毕则返回，少量慢server不影响系统性能。</li></ul><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>raft的工作过程是，首先选举leader，leader会负责管理replicated log。leader接受来自client的log，复制到其他机器，并在安全的时候通知其他机器把log输入状态机。</p><p>raft可以解耦为以下三个部分：</p><ol><li>leader选举（Leader election）</li><li>日志复制（Log replication）</li><li>安全（Safety）</li></ol><p>在理解这三个部分前，有几个基本概念需要知道，<br><strong>server 状态</strong></p><ul><li>leader：只能有一个leader</li><li>follower：只响应来自其他server的请求</li><li>candidate：用于选举</li></ul><p><img data-src="/images/2019/15633584684199.jpg" alt="-w433"></p><p><strong>时间</strong><br>raft把时间分为terms，term由一个递增的数字标识，表示<em>current term</em>。每个term以leader选举作为起始，如果未选举出leader，那么下一个term继续选。term内选举出的leader管理集群直到term结束。</p><p><img data-src="/images/2019/15633589391342.jpg" alt="-w351"></p><p>不同的server可能观察到不同的term转换，server使用current term（在server通信的时候发送）作为逻辑时钟，来确保能够探测到过期的信息。</p><p><strong>通信</strong><br>使用rpc。基本的共识算法使用两种rpc，</p><ol><li>RequestVote RPCs：candidates调用，来进行拉票，用于选主。</li><li>AppendEntries RPCs：leader发起，用于复制日志和心跳。</li></ol><h3 id="leader选举（Leader-election）"><a href="#leader选举（Leader-election）" class="headerlink" title="leader选举（Leader election）"></a>leader选举（Leader election）</h3><p>选举过程为，follower在election timeout内都没有收到leader的通信，则转换为candidate状态，并自增当前term、为自己投票、向其他server发送RequestVote RPCs。candidate维持在这个状态，直到下列情况出现：</p><ol><li>获得了相同term的多数派的投票，赢得选举。<br> 一旦candidate赢得选举，就转换为leader，并向其他server发送heartbeat，宣告leadership。</li><li>收到AppendEntries RPCs，其他candidate赢得了选举，成为leader。<ol><li>如果leader的term &gt;= 自己的term，那么这个leader是合法的，自己转换为follower状态。</li><li>如果leader的term &lt; 自己的term，那么拒绝这个rpc，自己维持在candidate状态。</li></ol></li><li>election timeout后，未获得足够的选票。<br> 多个candidate可能同时发起选举，发生了split vote，导致任何一个都无法获得多数派的投票。自增term，开始下一次选举。</li></ol><p>在下面的状态图中，状态转换的上方表示触发转换的event，下方表示发生转换时执行的action。</p><p><img data-src="/images/2019/leader%20election.jpg" alt="leader election"></p><p>选举安全性：</p><ul><li>在每个term内，每个server只能至多为一个candidate投票。</li></ul><p>在选举过程中，raft使用随机election timeout来保证，</p><ul><li>split votes（没有任何candidate能获得大多数投票）会很少出现。<br>  比较常见的是，C先timeout，然后投票给自己，并发送RequestVote RPCs，最终win。<br>  <img data-src="/images/2019/15634274004241.jpg" alt="-w397"></li><li>且split votes能够被快速解决。如果出现split votes，candidate先等待随机election timeout。</li></ul><h3 id="日志复制（Log-replication）"><a href="#日志复制（Log-replication）" class="headerlink" title="日志复制（Log replication）"></a>日志复制（Log replication）</h3><p><strong>如何复制</strong></p><ol><li>leader追加log entry。</li><li>AppendEntries RPC。</li><li>当log entry被安全复制（成为<em>committed</em> log entry，leader更新commit index），<ul><li>leader apply log entry，然后返回结果到client。</li><li>leader AppendEntries RPC通知follower committed entry，follower apply log entry。</li></ul></li></ol><p>如果follower失败、运行缓慢、丢包，leader重试AppendEntries RPC（就算leader已经返回client结果），直到所有follower最终收到所有log entry。raft保证了committed entry是<em>持久化的</em>，且最终能被所有可用的状态机执行。</p><p>那什么时候才算log entry被安全复制？当创建log entry的leader把entry复制到大多数server上以后。这同时也提交了在leader中所有先前的log，包括被前leader创建的log。</p><p><strong>应对出错</strong><br>raft在复制log时会维护如下性质来保证Log Matching Property（log consistency），</p><ul><li>如果两个entry在不同的log中有相同的index和term，那么它们的cmd是相同的。<br>  因为leader至多只创建一个带有相同index和term的entry，且entry不会在log中改变位置。</li><li>如果两个entry在不同的log中有相同的index和term，那么所有先前的log都是相同的。<br>  consistency check：AppendEntries RPC发送新的entry时，会包含前一个entry，如果follower没有找到与前一个entry相同的index和term，那么follower不会写入新的entry。</li></ul><p>根据以上两点，结合数学归纳法可知，Log Matching Property可以被满足。在正常情况下，leader和follower的log是保持一致的。</p><p>如果leader或follower崩溃引起了log不一致，如何恢复一致性？leader会强制follower复制自己的log，</p><ol><li>leader维护了<code>&#123;follower: nextIndex&#125;</code>，表示下一个将会发送到follower的entry。</li><li>leader启动时，将<code>nextIndex</code>置为<code>max(self log index) + 1</code>。</li><li>如果follower的日志不一致，那么接下来的AppendEntries RPC consistency check会失败。leader会将<code>nextIndex - 1</code>并重试，直到成功。</li></ol><h3 id="安全（Safety）"><a href="#安全（Safety）" class="headerlink" title="安全（Safety）"></a>安全（Safety）</h3><p>任何实现了日志复制的系统，都必须满足：一旦entry已经applied到状态机，那么任何其他状态机都不能为这条entry apply一个不同的值。</p><p>截止目前所描述的leader选举，存在的问题是，如果follower未收到leader的提交，那么当它成为leader以后，就会用自己的log覆盖其他server的。</p><p><strong>选举约束</strong><br>任何基于leader的共识算法，leader必须最终包含所有committed entry。raft需要保证所有committed entry，都出现在后续每个新的leader中，而这个保证确保了本节内容开头的安全性要求。</p><p>在选举的时候，使用voting process来避免未包含所有committed entry的candidate赢得选举。由于candidate在选举的时候需要联系大多数server，即只需要求每个committed entry必须出现在至少一个server（选举时联系的server）里面即可（抽屉原理）。</p><p>如果candidate包含的日志与大多数server包含的log<em>至少一样新</em>，那么这个candidate就包含了所有的log。具体判断方法是，</p><ol><li>在RequestVote RPC进行投票时，rpc包含了candidate最后一个entry的index和term。</li><li>如果voter（收到rpc call的一方）的log是更新的，即，<br> $$(lastTerm_v &gt; lastTerm_c) || ((lastTerm_v == lastTerm_c) \&amp;\&amp; (lastIndex_v &gt; lastIndex_c))$$<br> 那么voter拒绝此次投票。</li></ol><p><strong>提交上一个term的entry</strong><br>新leader能否直接提交上一个term的entry？</p><p><img data-src="/images/2019/15637956361681.jpg" alt="-w463"></p><p>c中s1成为term4的leader后继续复制term2的日志index2，此时日志已经复制到大多数机器上。按照之前的规则，s1可以认为日志已经是committed。但如果接着s5成为了leader（接受s3和s4的投票），s5会覆盖s1已经commit的日志。</p><p>因此不能仅通过副本数判断先前term的日志是不是committed，还需要满足<em>至少有一个属于当前term的log也复制到大多数server</em>，才能认为是。</p><h3 id="follower和candidate崩溃"><a href="#follower和candidate崩溃" class="headerlink" title="follower和candidate崩溃"></a>follower和candidate崩溃</h3><p>raft rpc是幂等的，leader无限重试。</p><h3 id="时间和可用性"><a href="#时间和可用性" class="headerlink" title="时间和可用性"></a>时间和可用性</h3><p>raft的安全性不依赖时间。但是系统的可用性依赖时间，这里有尤其指的是leader选举。election timeout需要满足下面的要求，raft才能选举并保持一个稳定的leader，</p><p>$$broadcastTime \ll electionTimeout \ll MTBF$$</p><h3 id="Leadership-transfer"><a href="#Leadership-transfer" class="headerlink" title="Leadership transfer"></a>Leadership transfer</h3><p>本质上还是使用leader选举的机制，通过主动触发目标server进行选举来实现来迁移，与后面的配置变更不同。过程如下：</p><ol><li>旧leader暂停服务。</li><li>旧leader进行正常的日志复制过程，把log复制到目标server。</li><li>旧leader发送TimeoutNow到目标server，触发目标server开始选举（相当于调快了timer，触发了election timeout）。</li><li>目标server大概率会比其他server先发起选举，并成为下一个term的leader。</li><li>选举成功后，旧leader收到heartbeat，出让leadership，至此transfer完成。</li></ol><p>如果迁移过程未在一个election timeout内完成，那么终止迁移。如果迁移成功了，但是旧leader误以为失败了，那最坏情况是进行一次额外的选举。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>日志复制时每个步骤都有可能出现错误，如何处理？<br> raft并不允许“false positives”的出现（返回client执行成功了，但实际上没有成功），但是可能会有“false negatives”的出现，告知client失败了，但实际上是成功了。为了避免false negatives，client必须重试直到成功，且每次只能有一个未完成的command，相应地，raft也必须提供去重机制。</p></li><li><p>为什么不能直接复制上一个term未committed的entry？</p></li><li><p>raft为何能够防止脑裂？<br> 2f+1个server，成为leader需要获得大多数server（f+1个）的投票。如果发生网络分区，必然有一个partition的分区少于f+1个。这个分区里面，</p><ul><li>如果没有leader，那么也不可能选举出leader。</li><li>如果有leader，由于日志无法被安全复制，因此不会对client做出任何承诺（不会成为committed entry，也不会被apply到状态机）。</li></ul></li><li><p>为什么需要leader？</p><ul><li>简化复制日志的过程。</li><li>保证所有的副本都以相同的顺序执行相同的命令。</li></ul></li><li><p>server变为candidate后会发生什么？<br> 开始选举：inc term，vote self，发送RequestVote RPC。可能结果如下，</p><ul><li>赢得选举。<br>  变为leader。</li><li>选举失败，收到来自其他leader的AppendEntries RPC。<br>  变为follower。</li><li>既没有赢得选举，也没有收到来自其他leader的AppendEntries RPC。<br>  维持candidate。election timeout，开始下一次选举。<br>  如果一直无法获得大多数server的投票，这个过程会一直重复，term会一直增加。<br>  <em>此时，如果client有请求会发生什么？</em></li></ul></li><li><p>如何保证同一个term内只有一个leader？</p><ul><li>leader需要获得来自大多数server的投票。</li><li>在同一个term内，每个candidate只能投票一次。</li><li>在同一个term内，至多只有一个server能获得大多数server的投票（即使出现网络分区）。</li></ul></li><li><p>什么情况下选举会失败？</p><ul><li>大多数server都失败了。</li><li>两个server获得了相同票数（例如：2f+1个server，挂了一个server）。</li></ul></li><li><p>选举失败会发生什么？<br> election timeout，开始下一次选举。</p></li><li><p>如何设置election timeout？</p><ul><li>$broadcastTime \ll electionTimeout \ll MTBF$</li><li>random</li><li>至少是几个heartbeat间隔</li></ul></li><li><p>replicated和committed entry的区别？</p><ul><li>replicated是做了复制，可能被覆盖。</li><li>committed，已提交，不会丢失。</li></ul></li><li><p>每个副本的日志会完全一致吗？<br>不会，可能落后，可能会有临时的不一致。但最终会一致，且状态机执行的命令是一致的。</p></li><li><p>为什么leader不能直接提交上一个term的entry？以及如何避免直接提交带来的问题？<br>提交时，需要等到至少一个当前term的entry也安全复制以后。</p></li><li><p>leader在什么时候覆盖follower的entry是合法的？<br>uncommitted entry。</p></li><li><p>leader覆盖follower的entry时，可能会覆盖committed entry吗？<br>不会。</p><ol><li>先看entry成为committed时，发生了什么。log entry需要安全复制，即发送到大多数server上。</li><li>candidate成为leader，需要联系大多数server，以保证自身的log与大多数server的一样新（选举约束）。因此成为leader的candidate一定包含了所有committed entry。</li></ol></li><li><p>如果下图中的leader（for term 8）挂了，a、d和f，哪个会被选举为leader？谁投的票？新leader产生后，哪些entry一定会保留下来？<br><img data-src="/images/2019/15639591300953.jpg" alt="-w478"></p><p>a-f每个server最多可能获得投票的情况如下：<br>a：a，b，e，f<br>b：b，f<br>c：a，b，c，e，f<br>d：a，b，c，d，e，f<br>e：b，e<br>f：f</p><p>所以a或d可能成为leader，一定会保留下的log是111445566。</p></li><li><p>如果server刚开始选举，此时收到了来自leader的AppendEntries RPC（假设leader与这个server都是处于同一个term），此时要怎么处理？</p><ul><li>candidate成为leader后，应该立即发送心跳来避免发生多余的选举。</li><li>如果发生这个情况，由于term一样，leader会忽略RequestVote RPC。</li></ul></li><li><p>如果leader完成复制，更新自身的commit index，且完成了apply，但在通知follower commit index前挂了（或丢失了leader资格），这个entry最终会丢失吗？</p></li><li><p>lastApplied是否应该做持久化？<br>这个地方有点争议。在<a href="https://github.com/ongardie/dissertation">ongardie/dissertation</a>的Errata中，指明了lastApplied是否做持久化应该与状态机一致。但在<a href="https://thesquareplanet.com/blog/raft-qa/">Raft Q&amp;A</a>中的说法是，状态机如果做持久化，那么也应该负责记住执行了哪些log。</p></li><li><p>follower拒绝AppendEntries RPC时，如何快速的解决冲突？<br>follower拒绝时，返回冲突entry的term，以及这个term首个entry的index。</p><ul><li>如果leader有这个entry，那么移动nextIndex到冲突的那个entry。</li><li>如果leader没有这个entry，那么移动nextIndex到那个term的首个index。</li></ul><p>还可以使用二分法，查找首个冲突的entry，这可以实现在最坏情况下的最佳时间复杂度。</p></li></ol><h1 id="Lab-2A-Raft"><a href="#Lab-2A-Raft" class="headerlink" title="Lab 2A: Raft"></a>Lab 2A: Raft</h1><h2 id="锁的使用建议"><a href="#锁的使用建议" class="headerlink" title="锁的使用建议"></a>锁的使用建议</h2><p>这个<a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">lecture</a>说了几点关于锁的建议，我觉得最重要的一点是，</p><blockquote><p>Be careful about assumptions across a drop and re-acquire of a<br>lock. One place this can arise is when avoiding waiting with locks<br>held.</p></blockquote><p>在减少锁的粒度的时候，可能也把变量的write和read分开了，进而导致在read的时候，变量已经被其他线程改变了。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://catkang.github.io/2017/11/30/raft-safty.html">Why Raft never commits log entries from previous terms directly</a></li><li><a href="https://www.jianshu.com/p/a89084103b6e">raft之 为什么不能直接commit 上一个term的entry</a></li><li><a href="https://yuerblog.cc/2018/07/28/understand-raft/">raft本质理解</a></li><li><a href="https://www.youtube.com/channel/UCy1xUHx0OWo3gnBC8AbnUqg">Raft user study lectures</a></li><li><a href="https://www.infoq.com/presentations/raft-consensus-algorithm/">The Raft Consensus Algorithm</a></li><li><a href="https://github.com/ongardie/dissertation">ongardie/dissertation</a></li><li><a href="https://runway.systems/?model=github.com/ongardie/runway-model-raft">ongardie/runway-model-raft</a></li><li><a href="https://thesquareplanet.com/blog/raft-qa/">Raft Q&amp;A</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Readings-In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version-to-end-of-Section-5-论文&quot;&gt;&lt;a href=&quot;#Readings-In-Search-of</summary>
      
    
    
    
    <category term="distritubed system" scheme="https://chaomai.github.io/categories/distritubed-system/"/>
    
    
    <category term="6.824" scheme="https://chaomai.github.io/tags/6-824/"/>
    
    <category term="replication" scheme="https://chaomai.github.io/tags/replication/"/>
    
    <category term="raft" scheme="https://chaomai.github.io/tags/raft/"/>
    
  </entry>
  
  <entry>
    <title>6.824 2018 Lecture 4 Primary-Backup Replication</title>
    <link href="https://chaomai.github.io/2019/2019-07-11-6.824-Spring-2018-Lecture-4/"/>
    <id>https://chaomai.github.io/2019/2019-07-11-6.824-Spring-2018-Lecture-4/</id>
    <published>2019-07-11T09:46:17.000Z</published>
    <updated>2021-06-27T14:57:29.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Readings-Practical-System-for-Fault-Tolerant-Virtual-Machines-Fault-Tolerant-Virtual-Machines论文"><a href="#Readings-Practical-System-for-Fault-Tolerant-Virtual-Machines-Fault-Tolerant-Virtual-Machines论文" class="headerlink" title="Readings - Practical System for Fault-Tolerant Virtual Machines Fault-Tolerant Virtual Machines论文"></a>Readings - Practical System for Fault-Tolerant Virtual Machines Fault-Tolerant Virtual Machines论文</h1><p>这篇论文讨论的主从复制与常见的相比，非常极端和雄心勃勃，论文基于vm构建了一个os级别的主从复制系统，较为细致的讨论了主从复制的设计和实现。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>主从复制是实现server容错的常用方法，如果primary挂了，backup可以继续提供服务。将primary的全量数据同步到backup是比较耗费带宽的操作。更好的方法是将server视为确定状态机，基本思路是把primary和backup置为相同的初始状态，并保证二者都能以相同的顺序收到相同的输入。由于存在某些操作是非确定的（如：中断和获得当前时间），因此还需要额外的协同。</p><h2 id="FT协议"><a href="#FT协议" class="headerlink" title="FT协议"></a>FT协议</h2><h3 id="Deterministic-Replay"><a href="#Deterministic-Replay" class="headerlink" title="Deterministic Replay"></a>Deterministic Replay</h3><p>为了实现在backup进行replay，需要保证：</p><ol><li>正确的捕获所有输入和非确定的操作，以保证backup的确定性执行。</li><li>在backup上正确的replay。</li><li>对性能没有影响。</li></ol><blockquote><p>论文中关于非确定的操作，零零散散在不少地方提到，不过总结下来其实就是，这个操作不是pure function，结果受除输入的外部状态影响。更具体的就是，非确定操作使用到的资源是与其他（来自vm或hypervisor）的进程共享的，竞争导致了非确定的结果。</p><p>在多核系统上，上述的竞争会更复杂，这也是为什么论文没有在多核系统上实现的原因。</p></blockquote><h3 id="FT协议-1"><a href="#FT协议-1" class="headerlink" title="FT协议"></a>FT协议</h3><p>primary的日志实时的通过logging channel发送到backup。为了保证在切换的时候，backup能够以与primary相同状态进行服务，需要满足：</p><p><strong>Output Requirement</strong>：如果primary失败，backup接替了primary，backup的执行需要保证所有的输出都与primary的一致。</p><p>只要满足Output Requirement，在发生主从切换的时候，client就感知不到打断和不一致。为了保证Output Requirement，需要backup在收到能够产生那个output的input之前，primary推迟输出，也就是下面的规则：</p><p><strong>Output Rule</strong>：只有当backup收到能够产生一个output的log，并返回ack（表示已经存入log buffer）给primary，primary才能输出。</p><blockquote><p>除了VM-FT有，在其他的多副本系统上都以某种形式出现着。</p></blockquote><p><img data-src="/images/2019/15628165996172.jpg" alt="-w470"></p><p>primary等待ack不必阻塞系统当前的执行。</p><h3 id="检测和响应失败"><a href="#检测和响应失败" class="headerlink" title="检测和响应失败"></a>检测和响应失败</h3><p>检测失败：</p><ul><li>server之间的heartbeat</li><li>logging channel的traffic是否一直存在</li></ul><p>如何避免split-brain：</p><ul><li>共享磁盘存储，原子的检测标志位</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="FT-VM启动"><a href="#FT-VM启动" class="headerlink" title="FT VM启动"></a>FT VM启动</h3><ul><li>使用基于VMware VMotion实现的FT VMotion完成clone，primary的中断小于1s。</li><li>使用VMware vShpere实现的集群服务来选择最佳server创建backup。</li></ul><h3 id="logging-channel管理"><a href="#logging-channel管理" class="headerlink" title="logging channel管理"></a>logging channel管理</h3><p><img data-src="/images/2019/15628298304504.jpg" alt="-w322"></p><p><strong>log buffer的局限：</strong><br>primary（或backup）的log buffer满了（或空了），primary（或backup）需要等待至log buffer可用为止，此时会暂停对client的服务。</p><p>主从切换的时间=检测primary失败的时间+backup消费log buffer的时间，为了减少切换的时间，在backup无法及时消费log的时候，会减慢primary的速度（限制CPU）。</p><h3 id="FT-VM上的操作"><a href="#FT-VM上的操作" class="headerlink" title="FT VM上的操作"></a>FT VM上的操作</h3><p>除VMotion外的所有运维操作（例如：调整cpu限制），都必须在primary上完成，然后通过特殊的日志项目发送到backup。</p><h3 id="关于磁盘io的实现问题"><a href="#关于磁盘io的实现问题" class="headerlink" title="关于磁盘io的实现问题"></a>关于磁盘io的实现问题</h3><ol><li>磁盘访问时的竞争会导致非确定的操作。<ul><li>检测这样的io竞争，并在primary和backup上以相同顺序执行。</li></ul></li><li>使用DMA时，对磁盘和内存的访问会导致非确定的操作。<ul><li>对磁盘的读写，改为读写bounce buffer。</li><li>只有当数据全部读到buffer以后，FT才会<em>从读指令处</em>恢复primary/backup的执行，避免二者出现差异（如果直接依赖DMA读取，primary和backup可能会在不可预知的时间点发生缺页中断，从而导致不一致）。</li></ul></li><li>primary在磁盘io完成前就挂了。<ul><li>backup切换为primary以后，无从得知io是否已经完成。FT会在backup上重试（前两点已经消除了导致非确定结果的操作）未完成的io操作。</li><li>那么<em>如何判断未完成的io操作是哪些</em>？io完成以后，设备会产生一个中断，如果某个io log缺少相应的中断，那么就需要重试。</li></ul></li><li>primary在磁盘io完成后挂了<ul><li>backup同样无从得知io是否已经完成。此时重新执行写磁盘是幂等的（而对于网络io，tcp会忽略重复的包）。</li></ul></li></ol><h3 id="关于网络io的实现问题"><a href="#关于网络io的实现问题" class="headerlink" title="关于网络io的实现问题"></a>关于网络io的实现问题</h3><p>hypervisor对vm buffer的更新导致了非确定操作，改为由vm触发hypervisor的中断，并记录到log。</p><h2 id="其他设计"><a href="#其他设计" class="headerlink" title="其他设计"></a>其他设计</h2><h3 id="非共享磁盘"><a href="#非共享磁盘" class="headerlink" title="非共享磁盘"></a>非共享磁盘</h3><p>优势：</p><ul><li>磁盘作为vm的内部状态，primary写磁盘时不必等待backup的ack。</li></ul><p>缺点：</p><ul><li>backup失败、执行FT VMotion时，需要同步磁盘数据。</li><li>需要使用其他方法来解决split-brain，例如：另外一个server作为共享存储；多个机器进行投票选主。</li></ul><h3 id="backup上执行read"><a href="#backup上执行read" class="headerlink" title="backup上执行read"></a>backup上执行read</h3><p>在从执行read，论文考虑的点并不是可以增加系统的read上限，而是考虑不发送read log可以减少logging channel的带宽。</p><p>具体看在backup上执行read，需要注意的点是：</p><ul><li>如果primary成功，backup失败，backup需要重试，直到成功。</li><li>如果primary失败，那么尝试读取的内存必须发送到backup。</li><li>如果primary执行了读，然后是写，那么在backup也必须按照这个顺序来执行。</li></ul><h1 id="Lecture"><a href="#Lecture" class="headerlink" title="Lecture"></a>Lecture</h1><h2 id="Fault-tolerance"><a href="#Fault-tolerance" class="headerlink" title="Fault tolerance"></a>Fault tolerance</h2><p><strong>理想的特性</strong></p><ul><li>可用性</li><li>强一致性</li><li>对client和server software透明</li><li>高效</li></ul><p><strong>容错，容什么错？</strong></p><ul><li>Fail-stop failures</li><li>Independent failures</li><li>Network drops some/all packets</li><li>Network partition</li></ul><p>不包括：</p><ul><li>Incorrect execution</li><li>Correlated failures</li><li>Configuration errors</li><li>Malice</li></ul><h2 id="Fault-tolerant-MapReduce-master"><a href="#Fault-tolerant-MapReduce-master" class="headerlink" title="Fault tolerant MapReduce master"></a>Fault tolerant MapReduce master</h2><p>lab 1中的woker由于是无状态的，且mapper和reducer执行的都是pure function，因此实现容错很简单。</p><p>master实现容错，需要考虑：</p><ul><li>需要复制什么状态？应用程序级？指令级？（woker list、完成的job、空闲的worker、tcp连接状态、程序memory和stack、cpu寄存器？）</li><li>primary是否需要等待backup？</li><li>什么时候切换到backup？</li><li>切换时是否能被观察到？</li><li>如何快速的切换？</li></ul><p><strong>主要方法有</strong></p><ol><li>State transfer，简单，但是state可能会很大，传输很慢<ul><li>主副本执行服务</li><li>primary把新状态发送到backup</li></ul></li><li>Replicated state machine，高效但复杂<ul><li>所有副本执行所有的操作</li><li>如果所有副本有相同的起始状态、相同的操作、相同的顺序、deterministic，那么就会有相同的最终状态</li><li>例如：VM-FT，GFS</li></ul></li></ol><h2 id="VM-FT"><a href="#VM-FT" class="headerlink" title="VM-FT"></a>VM-FT</h2><p>VM-FT是一个replicated state machine。</p><p>为了避免primary和backup出现差异，backup必须在指令流的相同位置、以相同的顺序看到相同事件。对于普通的指令，这个是比较容易实现的。FT对中断和磁盘/网络io会做特殊的处理。</p><p>例如：时钟中断</p><p><img data-src="/images/2019/ft%20time%20interrupt.jpg" alt="ft time interrupt"></p><h2 id="FT的有缺点"><a href="#FT的有缺点" class="headerlink" title="FT的有缺点"></a>FT的有缺点</h2><p><strong>适用场景</strong></p><ol><li>重要且低延迟的服务，例如：name server。</li><li>不便于修改的服务。</li></ol><p><strong>不适用的情况</strong></p><ol><li>高吞吐量的服务<ul><li>state仅仅是应用程序级别的，降低了开销，实现更高的性能。</li><li>例如：GFS适用应用程序级别的state。</li></ul></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://alvaro-videla.com/2013/12/failure-modes-in-distributed-systems.html">FAILURE MODES IN DISTRIBUTED SYSTEMS</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Readings-Practical-System-for-Fault-Tolerant-Virtual-Machines-Fault-Tolerant-Virtual-Machines论文&quot;&gt;&lt;a href=&quot;#Readings-Practical-System</summary>
      
    
    
    
    <category term="distritubed system" scheme="https://chaomai.github.io/categories/distritubed-system/"/>
    
    
    <category term="6.824" scheme="https://chaomai.github.io/tags/6-824/"/>
    
    <category term="replication" scheme="https://chaomai.github.io/tags/replication/"/>
    
  </entry>
  
  <entry>
    <title>6.824 2018 Lecture 3 GFS</title>
    <link href="https://chaomai.github.io/2019/2019-05-26-6.824-Spring-2018-Lecture-3/"/>
    <id>https://chaomai.github.io/2019/2019-05-26-6.824-Spring-2018-Lecture-3/</id>
    <published>2019-05-26T00:38:33.000Z</published>
    <updated>2021-06-27T14:57:29.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Readings-The-Google-File-System论文"><a href="#Readings-The-Google-File-System论文" class="headerlink" title="Readings - The Google File System论文"></a>Readings - The Google File System论文</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GFS是由Google设计和实现的，以满足Google对数据处理快速正常的需求。GFS和先前的分布式文件系统有很多相似的目标，例如：性能、可扩展性、可靠性和可用性。然而，GFS的设计是由Google对应用负载和技术环境的关键（当前和预期的）观察驱动的，这反映了与早期文件系统设计假设的显著不同。Google重新审视传统的选择，并探索在设计领域探索了彻底不同的观点。</p><ul><li>组件故障是常态而非例外。<br>  因此持续的监控、错误监测、容错和自动恢复是系统不可缺少的。</li><li>传统标准的文件是巨大的，常常很多GB。处理包含数十亿个对象、很多TB、且快速增长的数据集时，即便文件系统可以支持，也很难管理数十亿个约KB大小的文件。<br>  因此设计假设和参数，例如IO操作和block大小必须被重新审视。</li><li>大多数文件修改都是通过追加新数据的方式，而非覆盖已有的数据。对文件的随机写几乎已经不存在了。一旦写入，文件就是只读的，且常常只是顺序读。<br>鉴于这样对大文件的访问模式，追加成为了性能优化和原子保证的的关注点，而在client上对数据块的缓存失去了吸引力。</li><li>应用程序和文件系统api的协同设计，通过提升灵活性，有益于整个系统。</li></ul><h2 id="设计概览"><a href="#设计概览" class="headerlink" title="设计概览"></a>设计概览</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>虽然GFS没有实现例如POSIX的标准API，但也提供了一组熟悉的文件系统接口。文件以层次结构的方式用目录组织起来，并用路径名来标识。GFS支持<em>create，delete，open，close，read</em>和<em>write</em>文件。GFS还支持<em>snapshot</em>和<em>record append</em>。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>一个GFS集群由一个<em>master</em>和多个<em>chunkserver</em>构成，可以被多个<em>client</em>访问。</p><p><img data-src="/images/2019/15584874415545.jpg" alt="-w757"></p><p>文件被切分为固定大小的<em>chunks</em>。每个chunk都由一个不可变，且全局唯一的64位<em>chunk handle</em>标识，这个chunk handle在创建chunk时master分配的。chunkservers把chunk作为linux文件存储在本地磁盘上，并通过指定的chunk handle和byte range来读写文件。为了reliability（可靠性），每个chunk会在多个chunkservers上有复制。</p><p>master维护这整个文件系统的metadata，包括namespace，访问控制信息，文件到chunk的映射，以及chucks的当前位置。master还可控制着系统级别的活动，例如chuck租约管理，孤儿chunk的垃圾回收，以及chunkservers之间的chunk迁移。master定期与每个chunkserver以HeartBeat消息的形式进行通信，完成指令的发送和状态的收集。</p><p>client与master通信来进行metadata相关的操作，数据相关的通信是直接与chunkserver进行的。</p><p>client和chunkserver都不需要缓存数据。client缓存数据的收益很小，因为大多数程序都是流式读取大文件或者数据量太大而无法缓存。client不用缓存数据消除了缓存一致性的问题，简化了系统设计。但client会缓存metadata。chunkserver不必缓存文件数据，因为chunk都是以本地文件的形式保存的，linux buffer cache会把常访问的数据放入内存。</p><h3 id="单一master"><a href="#单一master" class="headerlink" title="单一master"></a>单一master</h3><p>单一master极大的简化了设计，并使master能够使用全局信息来进行复杂的chunk布局和复制决策。然而当读写时，必须最小化master的参与，这样master才不会成为瓶颈。client进行读写时，先询问master应该连接哪个chunkserver，并缓存这个信息一段时间，然后直接与这个chunkserver交互来完成后续的操作。</p><h3 id="chunk-size"><a href="#chunk-size" class="headerlink" title="chunk size"></a>chunk size</h3><p>chunk size是关键设计参数之一。GFS使用一个远大于典型文件系统的block size，64MB。每个chunk副本都以普通linux文件的形式存储在chunkserver，并在需要的时候扩展。惰性空间分配避免了由于内部碎片导致的空间浪费。</p><p>大型chunk size有这些优势，</p><ul><li>减少了client与master交互的需求。<br>  读写同一个chunk只需要向master请求一次chunk的位置信息。</li><li>由于chunk较大，client也较为可能在一个给定的chunk上进行很多的操作。<br>  通过在较长时间内保持与chunkserver的TCP连接，可以减少网络开销。</li><li>减少了存储在master上metadata的大小。<br>  由此可以将metadata放入内存。</li></ul><p>然而大型chunk size，即便有惰性空间分配，也存在弊端，</p><ul><li>chunkserver的热点访问。<br>  一个小文件仅有为数不多的chunks组成，可能就一个。如果大量的client都访问同一个文件，那么存储这些chunk的chunkserver可能会成为热点。</li></ul><h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>mater主要存储3类metadata：</p><ul><li>文件和chunk namespace</li><li>文件到chunks的映射关系</li><li>每个chunk副本的位置</li></ul><p>其他metadata还包括所有权和权限、每个chunk的版本、引用计数（用于实现copy-on-write）。</p><p>所有的metadata都是存储在内存中的。</p><ul><li>前两种还会进行持久化存储（使用write-ahead log），这是通过把记录修改到操作日志、在master落盘、以及在远程机器上存放副本来实现的。</li><li>对于最后一种metadata，master并不会做持久化存储。在master启动和有chunkserver加入集群的时候，master会询问每一个chunkserver存放的chunks。</li></ul><p><strong>In-Memory Data Structures</strong><br>由于metadata是存放在内存中的，因此mater的操作很快，除此之外还能完成定期在后台较快的完整扫描。这个定期扫描用于实现chunk的gc，chunkserver故障时副本重新复制，以及chunk的迁移。</p><p>一个潜在的问题是存储的chunk数目受限于内存的大小。但由于每个chunk的metadata少于64byte，且文件的namespace数据也少于64byte，并且启用了前缀压缩，因此这不是一个严重的问题。如果确实有必要支持更大的文件系统，加内存即可。</p><p><strong>Chunk Locations</strong><br>master并不对chunk locations做持久化。master启动时，会向所有chunkserver请求。之后，由于master控制着所有chunks的放置，并通过心跳消息来监控chunkserver，master能够确保自身的信息是最新的。</p><p>为什么不做持久化？</p><ol><li>消除了master和chunkserver的同步问题。<br> chunkserver可能加入、离开、重启、重命名、故障等。</li><li>chunkserver对自己有和没有哪些chunk有最终的话语权。<br> 在master维护此信息的一致视图是没有意义的，chunkser可能出现1中的各种问题。</li></ol><p><strong>Operation Log</strong><br>操作日志对GFS很重要，</p><ul><li>包含了metadata关键修改的历史记录，并持久化。</li><li>作为逻辑时间戳，定义了并发操作的顺序。<br>  文件和chunks，以及它们的版本，全都在创建的时候被逻辑时间唯一且永久的标识。</li></ul><p>可靠性保证，</p><ul><li>仅当metadata的修改完成持久化以后，这些修改才对client可见。</li><li>在多个远程机器上有复制。<ul><li>仅当把相应的log记录写入本地和远程机器的磁盘后，才响应client。</li><li>master会批量flush日志，来减少flush和复制对整个集群吞吐量的影响。</li></ul></li><li>master通过重放操作日志来恢复文件系统的状态。<ul><li>为了减少启动的时间，需要保证log较小。</li><li>当log增长超过特定大小时，master会checkpoint自身的状态，以便可以在恢复时载入最后一个checkpoint并重放在那之后的log。</li></ul></li></ul><p>checkpoint和恢复，</p><ul><li>checkpoint类似于压缩后的B树，可以直接map到内存，并用用户namespace的查找，且不需要额外的解析。</li><li>master创建checkpoint时，会切换到新log文件，并在另外的线程中创建checkpoint（包含了checkpoint前的所有修改），避免延误当前的修改。</li><li>恢复只需要最近的一个<em>完整</em>（需要检测是否完整）checkpoint和后续的log文件。更老的checkpoint和log是可以释放的。</li></ul><h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>GFS有一个宽松的一致性模型，这在支持高度分布式应用的同时，也相对简单和高效。</p><p><strong>Guarantees by GFS</strong><br>文件namespace修改（例如：创建文件）是原子的，由master专门执行。namespace锁保证了原子性和正确性；master的操作日志定义了这些操作的全局顺序。</p><p>一个文件区域有两种状态，</p><ol><li>consistent：无论client从哪个副本读取，都能看到相同的数据。</li><li>defined：在文件数据修改后，如果文件区域是consistent的，并且client能看到所有写入到文件的修改。</li></ol><p>数据修改包含，</p><ol><li>写入<ul><li>写入操作会把数据写到应用程序指定的文件offset。</li></ul></li><li>追加<ul><li>即使在并发修改存在的情况下，追加会把数据在GFS选择的offset处<em>至少一次原子</em>追加一次。</li><li>这个offset会返回给client，标记了一个defined文件区域的起始位置，这个区域包含了已追加记录。</li><li>GFS可能会插入填充或重复记录项。他们占据的区域被认为是inconsistent，且占用户数据总量的很小一部分。</li></ul></li></ol><table><thead><tr><th></th><th>Write</th><th>Record Append</th></tr></thead><tbody><tr><td>Serial success</td><td>defined（同时也是consistent）</td><td>defined interspersed with inconsistent</td></tr><tr><td>Concurrent success</td><td>consistent but undefined<br>1. 所有client都能看到相同的数据。<br>2. 但是这些数据并不能反映任何修改所写入的内容。<br>3. 这些数据一般包含混合了多个修改的片段。</td><td>defined interspersed with inconsistent</td></tr><tr><td>Failure</td><td>inconsistent（同时也是undefined）</td><td>inconsistent</td></tr></tbody></table><p>如何区分defined和undefined的文件区域？</p><p><em>在一些列的成功修改后，被修改的文件区域保证是defined</em>（？），且包含了最后一次修改所写入的数据。GFS通过以下方式来实现这个保证，</p><ol><li>在所有的副本上以相同的顺序对chunk进行修改。</li><li>用chunk版本号来检测过期的副本（由于chunkserver下线导致缺失修改）。<br> 过期的副本不会参与到修改或返回给client，会尽早的被gc掉。</li></ol><blockquote><p>不过这里我存疑，例如：concurrent write，并不能保证defined。</p></blockquote><p>某些client会cache chunk的位置。由于cache的timeout，读取到过期数据的时间窗是有限的。另外，对于大多数文件都是追加操作，一个过期的副本通常会返回过早结束（a premature end of chunk）的文件块，而非过期的数据。</p><p>在修改完成很长时间后，机器故障也会破坏或摧毁数据。GFS通过master和chunkserver定期的握手来检测失效的chunkserver，并通过校验和来检查数据损坏。当问题出现时，数据会尽快的从有效的副本进行恢复。如果在GFS来不及反应（没有足够的处理时间）的时候，所有的副本都丢失了，那应用能收到错误，而不是看到损坏的数据。</p><p><strong>Implications for Applications</strong><br>GFS应用可以通过一些已经用于其他目的的简单技术来适应宽松一致性模型，</p><ul><li>依赖追加而非覆盖，以及checkpointing<ul><li>例如：writer从头生成一个文件，待所有数据写入完毕以后，原子的把文件进行重命名。也可以定期创建checkpoints记录成功写入了多少。checkpoints也可以包含应用级别的校验和。readers只检查和处理至最后一个checkpoint之间的文件区域，这些文件区域是defined。</li><li>追加远比随机写要高效和有弹性的多。</li><li>checkpoint允许writer以增量的方式重新写入，并避免reader处理那些从应用的角度看仍是不完整的数据，尽管这些数据已被成功写入。</li></ul></li><li>写入时自我校验和自我识别的记录<ul><li>记录是以至少追加一次的语义来记录每个writer的输出的，因而reader需要处理偶然的填充和重复的情况。</li><li>writer写入的每个记录都包含额外的信息，例如校验和，用于验证。reader用校验和来识别并丢弃填充数据，以及记录片段。</li><li>如果无法容忍偶然出现的重复（例如，这些数据会触发非幂等的操作），那可以通过记录中的唯一标识来进行过滤。</li></ul></li></ul><blockquote><p>Checkpointing allows writers to restart incrementally and keeps readers from processing successfully written file data that is still incomplete from the application’s perspective.<br>我没有完全理解所谓的从应用的角度看仍是不完整的数据，是指的最后一个checkpoint之后的那些数据？</p></blockquote><h2 id="系统交互"><a href="#系统交互" class="headerlink" title="系统交互"></a>系统交互</h2><p>GFS的设计可以最大限度的减少master参与到所有的操作。</p><h3 id="租约和修改顺序"><a href="#租约和修改顺序" class="headerlink" title="租约和修改顺序"></a>租约和修改顺序</h3><p>文件的修改发生在chunk的所有副本上，GFS使用租约来维护副本之间一致的修改顺序。master会将一个chunk的租借给其中一个副本，这个部分叫做主副本。主副本选择对chunk所有修改的序列顺序，所有的副本在应用这些修改的时候都会遵循这个顺序。最后，全局的修改顺序，首先由master选择的租借授权顺序定义（先选择某个副本为primary，然后可能又选择了另一个为primary），并在租期内由主副本分配的序列号定义。</p><p>租约机制的好处是最小化master的管理开销。</p><ul><li>租约起始的timeout是60s，但只要chunk还在被修改，主副本可以无限次的请求，然后（一般情况下）得到timeout的扩展。</li><li>timeout扩展的请求的授权是存放在master和所有chunkservers定期交互的心跳包里面的。</li><li>master可能会在租约过期前撤销（例如master要禁止一个正在rename的文件的修改）。</li><li>即使master丢失了与primary的通信，master也可以在老的租约过期后，将新的租约授权给另一个副本。</li></ul><p><img data-src="/images/2019/15589671997749.jpg" alt="-w368"></p><p>下面以写入为例说明整个过程，</p><ol><li>client向master请求持有租约的chunkserver以及其他副本的位置。如果租约未被持有，master会授权一个副本。</li><li>master返回给client primary的标识和其他副本的位置。client cache这些数据，且仅在无法连接到primary或primary不在持有租约的时候才会联系master。</li><li>client将数据推送到所有副本，任何顺序均可。每个chunkserver会将这些数据存储在内部的LRU缓存中，直至数据被使用或过期。</li><li>一旦所有副本确认收到数据以后，client向primary发送写请求。写请求标识了先前推送到所有副本的数据。<ul><li>primary为所有收到的修改（可能来自多个client）分配连续的序列号，序列号提供了必要的序列化（necessary serialization）。</li><li>primary将修改以序列号顺序应用到本地状态。</li></ul></li><li>primary向所有从副本转发写请求。每个从副本都以primary分配的相同序列号顺序应用修改。</li><li>所有从副本回复primary，表明已完成操作。</li><li>primary回复client。</li></ol><p>如果上述过程出错，</p><ul><li>任何副本发生错误，都会汇报给client。</li><li>如果在primary发生错误，序列号将不会被分配和转发。</li><li>client的请求被认为已失败，被修改的文件区域将处于不一致状态。</li><li>client会做重试，先会重试步骤3~7，如果不行，会完全从头重试写入。</li></ul><p>如果存在另一个并发写入到相同位置的client，</p><ul><li>前一个client写入的内容被后一个写入的覆盖</li><li>所有副本都有相同的数据，但是混合了来自两个client的数据，consistent but undefined。</li></ul><p>如果一个写入的数据很大或跨越了chunk的边界，GFS client会把数据打散成多个写操作。这些写操作遵循了上述流程，但是可能会与其他client的并发写操作交替和被覆盖。因此文件区域将会出现consistent but undefined的情况。</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>从控制流解耦数据流是为了高效的使用网络，</p><ol><li>最大化利用每个机器的网络带宽<ul><li>数据以流水线的方式，沿着精心挑选的chunkservers链进行线性的推送，而非以其他拓扑形式来推送（例如：树）。</li><li>这样每个机器的所有出口带宽都会用书尽可能快的传输数据，而非将带宽拆分到多个接收者。</li></ul></li><li>避免网络瓶颈和高延迟的链路<ul><li>交换机链路通常有这两个问题。</li><li>每个机器会把数据转发到网络拓扑中最近（通过ip地址来估算）的且未收到数据的机器。</li></ul></li><li>最小化推送所有数据的延迟<ul><li>通过在TCP连接上以pipelining的方式进行数据传输来实现</li><li>一旦某个chunkserver收到一份数据，就立即开始转发。立即转发并不会降低接收数据的速度。</li><li>pipelining在使用全双工链路交换网络的情况下很有用。</li><li>在没有网络拥塞的情况下，传输一份R个副本B byte的数据，理想的时间开销是<code>B/T + RL</code>，T是网络吞吐量，L是机器间的传输延迟。</li></ul></li></ol><h3 id="Atomic-Record-Appends"><a href="#Atomic-Record-Appends" class="headerlink" title="Atomic Record Appends"></a>Atomic Record Appends</h3><p>GFS提供了原子追加记录的操作，叫做record append。</p><ul><li>传统的写操作中，client指定data需要写入的offset。并发写入到同一个区域是不可序列化的。</li><li>record append中，client指定data，GFS在自己选择的offset处以原子的方式至少一次追加数据到文件末尾，并将offset返回给client。</li></ul><p>record append是一种修改操作，遵循前面描述的控制流。</p><ol><li>client向文件最后一个chunk的所有副本推送数据，然后向primary发送请求。</li><li>primary检查追加到当前chunk是否会导致chunk超出大小限制。<ul><li>如果是，那么填充当前chunk，并告知从副本也填充。返回client需要在下一个chunk上重试。</li><li>追加记录被限制在<code>0.25 * maximum chunk size</code>，以限制碎片在可接受的范围内。</li><li>如果没有超过，那么primary进行追加，并告知从副本也在相同的offset追加，最后返回client操作成功。</li></ul></li><li>如果在任何副本上追加失败，client会重试。</li></ol><p>重试追加时，</p><ul><li>重试的结果是，同一个chunk的副本可能会包含不同的数据，可能包括部分或全部相同的记录。</li><li>GFS并不保证所有副本每个字节都是相同的，只能保证数据会以一个原子单位的形式至少一次写入。</li><li>对于一个成功的写入操作，数据一定写在某个chunk的<em>所有副本的相同offset位置</em>。在这之后，所有副本都至少与记录的结尾一样长。因此任何后续的记录，即使另一个副本成为primary的情况下，都会被分配到更高的offset，或者另一个chunk。</li></ul><h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>GFS使用copy-on-write的方式来实现文件或目录的快照，创建snapshot的速度很快。</p><ul><li>master收到快照请求时，首先撤销将要做snapshot的所有授权chunk的租约。</li><li>租约撤销或过期后，master在磁盘记录操作日志。接着通过复制文件或目录树的metadata，把日志应用到内存状态。新创建的文件快照与原文件指向相同的chunks。</li><li>client写入某个chunk C时，先通过master找到primary。master发现引用计数不唯1，选择一个新的chunk handle C’，并通知相关chunkserver本地复制创建C’。</li><li>最后client遵循前面的过程进行写入。</li></ul><blockquote><p>对目录进行snapshot的时候，复制的metadata是什么？</p></blockquote><h2 id="master操作"><a href="#master操作" class="headerlink" title="master操作"></a>master操作</h2><p>master执行，</p><ul><li>所有namespace的操作。</li><li>管理chunk副本的放置、创建、复制、以及与各种系统级活动协调来保证：chunk是完全备份的、平衡chunkserver的负载、回收未使用的空间。</li></ul><h3 id="namespace管理和锁"><a href="#namespace管理和锁" class="headerlink" title="namespace管理和锁"></a>namespace管理和锁</h3><p>GFS使用<em>完整路径名到metadata</em>的map来从逻辑上表示namespace。存储的时候使用前缀压缩。</p><p>锁以及加锁方式，</p><ul><li>namespace树的每个节点（绝对文件名或绝对目录名）都有关联的读写锁，读写锁是惰性分配的。</li><li>master进行每个操作前，都会对路径名<code>/d1/d2/.../dn</code>的每一级父目录加上读锁，并对<code>/d1/d2/.../dn/leaf</code>加上读锁或写锁，leaf可能是文件或目录。<br>  这里不需要对父级目录加写锁，因为并没有真正意义上的父级目录，也没有需要避免并发修改的数据。只要能防止被删除、重命名或被snapshot即可。</li><li>锁是以一个一致的全序来获取的，以避免死锁。首先按namespace树的层级排序，然后按同一级的字典序排序。</li></ul><h3 id="副本放置"><a href="#副本放置" class="headerlink" title="副本放置"></a>副本放置</h3><p>副本放在分布在多个机器内是不够的，还需要分布在不同的机架，放置策略有两个目的：</p><ul><li>最大化数据可靠性和可用性。</li><li>最大化带宽利用。</li></ul><h3 id="Creation，Re-replication，Rebalancing"><a href="#Creation，Re-replication，Rebalancing" class="headerlink" title="Creation，Re-replication，Rebalancing"></a>Creation，Re-replication，Rebalancing</h3><p>chunks在三种情况下会进行创建：</p><ol><li>master创建新chunk。<br> 创建时会考虑这些因素，<ul><li>chunkserver磁盘使用率低于平均值。</li><li>限制每个chunkserver最近创建数。结合上一点，如果不限制，那么对于一个空chunkserver，迁移时繁重的写操作，会导致磁盘I/O过高。</li><li>跨多个机架。</li></ul></li><li>副本数低于目标值（由于机器不可达、副本损坏、目标值增加），master重新创建副本。<ul><li>每个需要被re-replicated的chunk的优先级由多个指标衡量：低于目标值多少？优先为存在的文件（live files）创建而不是最近被删除的。优先创建任何阻塞了client操作的的chunk。</li><li>创建时，chunkserver会从有效的副本直接复制，会考虑1中的各种因素。</li><li>为了避免对client流量的影响，master会限制集群和每个chunkserver的clone数目。chunkserver会限制从源chunkserver的读请求来实现限速。</li></ul></li><li>平衡磁盘空间和负载。<ul><li>master定期进行rebalance，一般来说选择移除磁盘空闲空间低于平均值的。</li><li>新chunkserver会被逐渐的填满，而非立即将新chunk和写流量都直接打上去。</li></ul></li></ol><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>当文件删除的时候，GFS不会立即回收物理存储。GFS会在定期的gc期间，在文件和chunk级别进行回收。</p><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>当文件被删除的时候，</p><ul><li>master立即记录删除日志，并将文件重命名到一个包含删除时间的隐藏名字。</li><li>master定期扫描文件系统的namespace时，删除存在3天以上（可配置）的隐藏文件，这有效的切断了与chunks的连接。</li><li>master定期扫描chunk namespace，识别出孤儿chunk，并清除它们的metadata。</li><li>chunkserver与master的心跳包汇报了有哪些chunks，master告知哪些是已经不在metadata中的，可以自由删除。</li></ul><p>这个删除机制相比立即删除，有很多好处，</p><ul><li>在机器故障很常见的大规模分布式系统中，这个机制简单可靠。<br>  chunk的创建可能只在部分chunkserver上成功；副本删除消息可能丢失，master必须重发。</li><li>将存储回收合并到了mater常规的后台活动里。<br>  可以批量完成，开销被均摊了。</li><li>仅在master相对空闲的时候完成。</li><li>延迟回收提供了应对意外、不可逆删除的保障。</li></ul><p>最大的缺点是，延迟机制妨碍了用户在存储紧张的时候，对空间使用的调优。</p><ul><li>GFS通过加快对再次明确删除已删除的文件的回收来解决这一问题。</li><li>GFS还允许对namespace的不同部分设置不同的复制和回收机制。</li></ul><h2 id="过期副本检测（Stale-Replica-Detection）"><a href="#过期副本检测（Stale-Replica-Detection）" class="headerlink" title="过期副本检测（Stale Replica Detection）"></a>过期副本检测（Stale Replica Detection）</h2><p>副本在chunkserver失败且错过修改的时候会过期。</p><ul><li>master维护了一个<em>chunk version number</em>来区分最新和过期的副本。在授权租约前，master会增加chunk version number，并通知所有最新的副本。master和所有副本都会将版本号进行持久化存储。</li><li>失败的chunkserver在重启后，master通过心跳包可得知副本过期。</li><li>反过来，如果chunkserver的版本号高于master记录的，master会假设在授权的时候自己失败了，并把更高的版本号作为最新的。</li><li>过期的副本使用gc进移除。</li><li>mater把primary返回给client的时候，以及通知chunkserver进行clone副本的时候，会带上版本号，二者会检查版本号以保证访问到最新的数据。</li></ul><h2 id="容错和诊断"><a href="#容错和诊断" class="headerlink" title="容错和诊断"></a>容错和诊断</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>GFS通过两个简单却有效的策略来实现系统高可用：快速恢复、副本。</p><ul><li>快速恢复<ul><li>master和chunkserver可快速启动。</li><li>不区分正常和非正常终止。</li></ul></li><li>chunk副本<ul><li>除副本外，<a href="https://en.wikipedia.org/wiki/Parity_bit">parity</a>和<a href="https://en.wikipedia.org/wiki/Erasure_code">erasure coding</a>对于只读的场景，也是有用的。</li></ul></li><li>master副本<ul><li>为了master状态的可靠性，操作日志和checkpoint会被复制到多个机器上。只有<em>flush到本地和所有远程机器</em>上的修改，才认为是已经提交了的。</li><li>提交与写入数据的顺序是什么，在写入数据完成前还是后？</li><li>如果在log复制到多个机器前，master挂了？如果未复制log无法恢复？</li><li>shadow master<ul><li>提供了文件系统的只读访问，因为log可能落后于master；不可写，会导致脑裂。</li><li>与primary相同的顺序apply操作日志。</li><li>启动时定位chunk副本的位置（启动后就不会很频繁），并定期与chunkserver通信监控它们的状态。</li><li>仅当primary更新副本位置时，需要依赖master。</li><li>可被晋升为master。</li></ul></li><li>主从切换是如何进行的？</li></ul></li></ul><h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><ul><li>chunkserver使用checksum来检查数据损坏。<ul><li>直接对比两个chunkserver上的副本是不不现实的。</li><li>两个不同的副本<em>可能是</em>合法的（详见<a href="#Atomic-Record-Appends">Atomic Record Appends</a>）。</li><li>每个chunkserver必须独立维护checksum来维护副本完整性。</li></ul></li></ul><p>chunk结构：</p><ul><li>细分为64KB block。</li><li>每个block都有32bit checksum。</li><li>保留在内存中，且与log一起持久化存储，和用户数据分离。</li></ul><p>对于读操作：</p><ul><li>在返回给client或chunkserver前，会检查与读取范围重叠的部分。因此损坏的数据不会传播开。</li><li>如果checksum不匹配，返回错误给请求方，并通知master。请求方会读取其他副本，master会从其他副本clnoe数据。新副本到位后，通知chunkserver删除错误的副本。</li></ul><p>checksum对（读和追加）性能的影响较小：</p><ol><li><p>读</p><ul><li>绝大多数读只跨越少数几个block，因此只需要对少量数据进行校验checksum。</li><li>GFS client在读取是对尝试对齐checksum block的边界。</li><li>checksum的查找和比较不需要做I/O，checksum的计算可以和I/O同时进行。</li></ul></li><li><p>追加</p><ul><li><p>只需要增量的更新最后一个block的last partial checksum，并计算后续新block的checksum。</p></li><li><p>计算last partial checksum block已经损坏，现在无法检测到它，新的checksum也将与存储的数据不匹配，并且在下次读取时将像往常一样检测到损坏。</p><blockquote><p>现在无法检测到它（we fail to detect it now），这具体指的是？</p></blockquote></li></ul></li></ol><p>但对于覆盖现有chunk某个range的写操作，必须先读取和检查被覆盖range的首个和最后一个block（为了避免新的checksums可能隐藏存在于未被覆盖区域内的数据损坏），然后写入，最后计算和存储新的checksum。</p><h3 id="诊断工具"><a href="#诊断工具" class="headerlink" title="诊断工具"></a>诊断工具</h3><p>大规模和细致的诊断日志可以极大帮助问题隔离、debug和性能分析，且只有很小的开销。</p><h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><p>以下问题部分是我自己提出，部分来自<a href="https://github.com/feixiao/Distributed-Systems/blob/master/Lec03_GFS/Question.md">Distributed-Systems/Lec03_GFS/Question.md</a></p><ul><li>为什么存储三个副本？而不是两个或者四个？</li><li>为什么不适用RAID？<br>  重点是整机的容错，而非存储设备的容错。</li><li>chunk的大小为何选择64MB？这个选择主要基于哪些考虑？<ul><li>减少了client与master交互的需求。</li><li>由于chunk较大，client也较为可能在一个给定的chunk上进行很多的操作。</li><li>减少了存储在master上metadata的大小。</li></ul></li><li>master的checkpoint与application checkpointing的区别是什么？</li><li>论文提到append机制可以用于multiple-producer/single-consumer queues，这个具体是如何实现的？</li><li>GFS主要支持追加（append）、改写（overwrite）操作比较少。为什么这样设计？如何基于一个仅支持追加操作的文件系统构建分布式表格系统Bigtable？</li><li>为什么要将数据流和控制流分开？如果不分开，如何实现追加流程？<ul><li>最大化利用每个机器的网络带宽</li><li>避免网络瓶颈和高延迟的链路</li><li>最小化推送所有数据的延迟</li></ul></li><li>GFS有时会出现重复记录或者补零记录（padding），为什么？</li><li>租约（lease）是什么？在GFS起什么作用？它与心跳（heartbeat）有何区别？</li><li>GFS追加操作过程中如果备副本（secondary）出现故障，如何处理？如果主副本（primary）出现故障，如何处理？</li><li>GFS master需要存储哪些信息？master数据结构如何设计？</li><li>假设服务一千万个文件，每个文件1GB，master中存储的元数据大概占用多少内存？</li><li>master如何实现高可用性？</li><li>负载的影响因素有哪些？如何计算一台机器的负载值？</li><li>master新建chunk时如何选择chunkserver？如果新机器上线，负载值特别低，如何避免其他chunkserver同时往这台机器迁移chunk？</li><li>如果某台chunkserver报废，GFS如何处理？</li><li>如果chunkserver下线后过一会重新上线，GFS如何处理？</li><li>如何实现分布式文件系统的快照操作？</li><li>chunkserver数据结构如何设计？</li><li>磁盘可能出现“位翻转”错误，chunkserver如何应对？</li><li>chunkserver重启后可能有一些过期的chunk，master如何能够发现？</li></ul><h1 id="Lectures"><a href="#Lectures" class="headerlink" title="Lectures"></a>Lectures</h1><h2 id="什么是一致性？"><a href="#什么是一致性？" class="headerlink" title="什么是一致性？"></a>什么是一致性？</h2><ul><li>正确性条件</li><li>重要但是当存在数据副本的时候难以实现，尤其是应用并发访问时</li><li>弱一致性<br>  <code>read()</code>可能返回过期的数据。</li><li>强一致性<br>  <code>read()</code>使用返回最近<code>write()</code>的数据。</li></ul><h2 id="“理想”的一致性模型"><a href="#“理想”的一致性模型" class="headerlink" title="“理想”的一致性模型"></a>“理想”的一致性模型</h2><ul><li>一个存在副本的FS行为和不存在副本的FS一样。</li><li>读可以观察到最近的写。</li></ul><h2 id="实现“理想”的一致性模型的挑战"><a href="#实现“理想”的一致性模型的挑战" class="headerlink" title="实现“理想”的一致性模型的挑战"></a>实现“理想”的一致性模型的挑战</h2><ul><li>并发</li><li>机器失败：任何操作都可能失败</li><li>网络分区：每个机器/磁盘不是总能访问到的</li><li>为什么这些挑战难以克服？<ul><li>需要c/s间的通信：可能影响性能</li><li>复杂的协议：难以正确的实现</li><li>不少系统没有提供理想的一致性模型</li></ul></li></ul><h2 id="GFS是否实现了“理想”的一致性模型"><a href="#GFS是否实现了“理想”的一致性模型" class="headerlink" title="GFS是否实现了“理想”的一致性模型"></a>GFS是否实现了“理想”的一致性模型</h2><ul><li>对于目录：实现了<ul><li>强一致性，只有一个副本</li><li>不是高可用，可扩展性受限</li></ul></li><li>对于文件：不总是</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>GFS优秀的地方：<ul><li>顺序读写性能高</li><li>追加</li><li>吞吐量大</li><li>数据容错</li></ul></li><li>GFS不好的地方：<ul><li>master容错</li><li>小文件（master是瓶颈）</li><li>client可能看到过期的数据</li><li>追加可能重复</li></ul></li></ul><h1 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h1><ul><li>Lecture 3没有关于GFS的实验，不过我找到了<a href="https://bitbucket.org/abcdabcd987/ppca-gfs/src/master/">ppca-gfs</a>，看介绍是上交ACM班一个课程的作业，就用这个来补上GFS的实验吧。</li><li>lab的代码在<a href="https://github.com/chaomai/mit-6.824/tree/master/ppca-gfs">github.com/chaomai/mit-6.824</a></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://queue.acm.org/detail.cfm?id=1594206">Case Study GFS: Evolution on Fast-forward</a></li><li><a href="http://highscalability.com/blog/2010/9/11/googles-colossus-makes-search-real-time-by-dumping-mapreduce.html">Google’s Colossus Makes Search Real-Time By Dumping MapReduce</a></li><li>大规模分布式存储系统：原理解析与架构实战</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Readings-The-Google-File-System论文&quot;&gt;&lt;a href=&quot;#Readings-The-Google-File-System论文&quot; class=&quot;headerlink&quot; title=&quot;Readings - The Google File</summary>
      
    
    
    
    <category term="distritubed system" scheme="https://chaomai.github.io/categories/distritubed-system/"/>
    
    
    <category term="6.824" scheme="https://chaomai.github.io/tags/6-824/"/>
    
    <category term="gfs" scheme="https://chaomai.github.io/tags/gfs/"/>
    
  </entry>
  
  <entry>
    <title>Apache Hadoop YARN笔记</title>
    <link href="https://chaomai.github.io/2019/2019-05-23-apache-yarn-notes/"/>
    <id>https://chaomai.github.io/2019/2019-05-23-apache-yarn-notes/</id>
    <published>2019-05-23T13:49:24.000Z</published>
    <updated>2021-06-27T14:57:29.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>YARN（Yet Another Resource Negotiator）是Hadoop的资源管理系统。</p><p>YARN把资源管理和任务的调度/监控拆分到了独立的进程，即ResourceManager（RM）和每个程序的ApplicationMaster，一个程序要么是一个单独的job或者是由DAG表示的多个job。</p><p>RM和NodeManager（NM）构成了数据计算的框架。RM拥有最大的权利来决断系统中每个程序所需的资源。NM是每个机器上的一个代理，负责container的管理，监控它们资源使用（cpu、内存、磁盘、网络），并汇报给RM。</p><p>每个程序的ApplicationMaster是框架的特定库，负责与RM协商资源，并与NMs一起工作来执行和监控任务。</p><p>RM有两个组成部分：Scheduler和ApplicationsManager（AM）。</p><p>Scheduler，在容量和队列的限制下，负责为各种程序分配资源。Scheduler只负责调度，不负责监控和跟踪程序的状态；也不为由于程序错误或硬件错误导致的任务失败提供重启保证。Scheduler基于程序的资源需求来执行调度功能；进一步说，是基于对资源的抽象，即Container（cpu、内存、磁盘、网络）来进行调度的。</p><p>Scheduler有一个可插拔策略，负责在各种队列和程序之间对集群资源进行划分。例如当前的scheduler有CapacityScheduler和FairScheduler。</p><p>AM负责接收job的提交、协商第一个container来运行程序的ApplicationMaster，以及为出错的ApplicationMaster container提供重启服务。每个程序的ApplicationMaster负责与Scheduler协商资源适当的的container，并追踪它们的状态和监控进度。</p><p>通过ReservationSystem，YARN还支持资源预定。</p><h1 id="YARN应用的运行"><a href="#YARN应用的运行" class="headerlink" title="YARN应用的运行"></a>YARN应用的运行</h1><p><img data-src="/images/2019/15585937581379.jpg"></p><h2 id="资源请求"><a href="#资源请求" class="headerlink" title="资源请求"></a>资源请求</h2><p>YARN的资源请求模型会考虑，</p><ul><li>每个容器需要的资源。</li><li>局部性（主要指数据的局部性）。<br>  例如如果使用了HDFS的数据，会优先使用存放副本的结点，其次是存有这些副本的机架，最后才是集群的任意结点。</li></ul><p>YARN应用可以在任意时刻提出资源的申请，</p><ul><li>在一开始就申请所有的资源。</li><li>以动态的方式，在需要更多资源的时候提出。</li></ul><h2 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h2><p>按照应用的类型，应用的生命周期会有较大差异，主要分为以下3个模型，</p><ol><li>一个应用对应一个用户的job，例如MR任务。</li><li>一个应用对应一个工作流或用户jobs的session，container可以在job之间复用，并cache数据，例如Spark。</li><li>一个长期运行的应用被多个用户共享。这样的应用一般作为协调者的角色存在。</li></ol><h1 id="YARN优势"><a href="#YARN优势" class="headerlink" title="YARN优势"></a>YARN优势</h1><ul><li>可扩展性（Scalability）<br>  每个应用都有一个专门的application master，分离了资源调度和task管理。就MR任务而言，这模型与Google MapReduce论文中所述的模型更加接近，即，一个master协调worker上的map和reduce任务。</li><li>可用性（Availability）<br>  拆分RM和application master简化了高可用的实现。先为RM提供高可用，再为YARN应用提供高可用。</li><li>利用率（Utilization）<br>  相比MapReduce 1，精细化了资源的管理，应用可以按需请求资源。</li><li>多租户（Multitenancy）<br>  YARN支持除MapReduce外的其他分布式计算框架。</li></ul><h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><p>YARN有3中调度器：FIFO调度器、容量调度器和公平调度器。</p><h2 id="关于container"><a href="#关于container" class="headerlink" title="关于container"></a>关于container</h2><p>vcore是一个host的cpu核心占用比例。</p><p>container是，</p><ul><li>cpu（vcore）、内存、磁盘、网络的抽象。</li><li>在有task或ApplicationMaster运行的时候，表示一个已分配的资源。</li><li><em>不同</em>于docker中的container概念。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerLaunchContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add the list of &lt;em&gt;commands&lt;/em&gt; for launching the container. All</span></span><br><span class="line"><span class="comment">   * pre-existing List entries are cleared before adding the new List</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> commands the list of &lt;em&gt;commands&lt;/em&gt; for launching the container</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Public</span></span><br><span class="line">  <span class="meta">@Stable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setCommands</span><span class="params">(List&lt;String&gt; commands)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FIFO调度器（FIFO-Scheduler）"><a href="#FIFO调度器（FIFO-Scheduler）" class="headerlink" title="FIFO调度器（FIFO Scheduler）"></a>FIFO调度器（FIFO Scheduler）</h2><p>按提交的顺序运行应用，首先为第一个应用分配资源，如果可以满足，再依次为其他应用服务。</p><h2 id="容量调度器（Capacity-Scheduler）"><a href="#容量调度器（Capacity-Scheduler）" class="headerlink" title="容量调度器（Capacity Scheduler）"></a>容量调度器（Capacity Scheduler）</h2><p>为每个组织分配一个专门的队列，每个队列可配置为使用一定量的集群资源，队列可以再进行划分。同一个队列内使用FIFO策略进行调度。</p><p>关于资源的使用，</p><ul><li>队列中单个任务使用的资源不会超过队列的容量。</li><li>如果队列满，且集群有空闲的资源，调度器可以把资源分配给此队列（可配置），弹性队列。</li><li>正常情况下，容量调度器不会抢占容器，因此如果一个队列随着使用，资源不够时，只能等待其他队列释放资源。<br>  容量调度器也可以执行work-preserving preemption，RM会请求应用返回容器。</li></ul><h2 id="公平调度器（Fair-Scheduler）"><a href="#公平调度器（Fair-Scheduler）" class="headerlink" title="公平调度器（Fair Scheduler）"></a>公平调度器（Fair Scheduler）</h2><ul><li>每个队列有权重元素，用于fair share的计算。</li><li>默认队列和动态创建的队列，权重为1（默认队列的可配置）。</li><li>调度器会使用最小资源数量来进行资源分配进行优先排序。如果两个队列的资源都低于fair share额度，那么远低于最小资源数量的队列，会被有限分配资源。</li></ul><h3 id="队列放置"><a href="#队列放置" class="headerlink" title="队列放置"></a>队列放置</h3><p>公平调度器使用一个规则的系统来判断应用所属队列。</p><h3 id="饥饿和抢占"><a href="#饥饿和抢占" class="headerlink" title="饥饿和抢占"></a>饥饿和抢占</h3><p>FairShare的计算会被用于判断饥饿以及是否进行抢占。在计算FairShare时，有两种：</p><ul><li>Steady FairShare，按照配置文件中所有queue的weight，计算出的。</li><li>Instantaneous FairShare，，按照配置文件中所有queue的weight，仅对包含活动应用程序的queue计算出的。</li></ul><p>在配置<code>yarn.scheduler.fair.preemption</code>和<code>yarn.scheduler.fair.preemption.cluster-utilization-threshold</code>后，抢占会启用。</p><p><strong>饥饿</strong>有两种：</p><ul><li><p>FairShare Starvation<br>  判定条件为：</p><ol><li><p>未获得所要求的资源。</p></li><li><p>应用程序资源使用低于Instantaneous FairShare。</p></li><li><p>应用程序的资源使用低于fairSharePreemptionThreshold，并持续fairSharePreemptionTimeout。</p><p>要注意的是，在同一个队列里面，如果存在多个应用程序，它们会平均的分摊Instantaneous FairShare。因此可能存在队列整体不是饥饿状态，但是每个应用程序是。</p></li></ol></li><li><p>MinShare Starvation<br>  判定条件为：</p><ol><li>未获得所要求的资源。</li><li>应用程序资源使用低于MinShare。</li><li>应用程序的资源使用低于MinShare，并持续MinSharePreemptionTimeout。</li></ol></li></ul><p>决定需要进行抢占的时候，可能在多个队列中都有可抢占的container，决定container是否可以被抢占，需要满足：</p><ul><li>所在队列是可抢占的。</li><li>杀死container以后不会导致应用程序的资源低于Instantaneous FairShare。</li></ul><p>启用抢占<strong>并不能</strong>保证队列或应用程序能够获得所有的Instantaneous FairShare。只能最终保证脱离饥饿的状态，即获得fairSharePreemptionThreshold份额的资源。</p><p>FairShare Starvation、MinShare Starvation以及抢占的关系如下：</p><p><img data-src="/images/2019/15598134204968.jpg"></p><h3 id="Best-Practice"><a href="#Best-Practice" class="headerlink" title="Best Practice"></a>Best Practice</h3><ul><li>一般<strong>不建议</strong>配置MinShare Starvation或minimum resources。<br>  增加复杂性的同时，并不能带来多少好处。</li><li>如果配置minimum resources，所有minimum resources的加和不能超出总的资源数。</li></ul><h2 id="延迟调度"><a href="#延迟调度" class="headerlink" title="延迟调度"></a>延迟调度</h2><p>局部性是YARN调度时优先考虑的，但如果发现所请求的节点资源不够，那么任务可能就会被调度到其他节点上了。此时如果等待几秒，能够增加在所请求节点上分配到container的机会。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html">Apache Hadoop YARN</a></li><li><a href="https://blog.cloudera.com/blog/2015/09/untangling-apache-hadoop-yarn-part-1/">Untangling Apache Hadoop YARN</a></li><li><a href="https://blog.cloudera.com/blog/2018/06/yarn-fairscheduler-preemption-deep-dive/">YARN FairScheduler Preemption Deep Dive</a></li><li>Hadoop - The Definitive Guide</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;YARN（Yet Another Resource Negotiator）是Hadoop的资源管理系统。&lt;/p&gt;
&lt;p&gt;YARN把资源管理和</summary>
      
    
    
    
    <category term="yarn" scheme="https://chaomai.github.io/categories/yarn/"/>
    
    
    <category term="yarn" scheme="https://chaomai.github.io/tags/yarn/"/>
    
    <category term="hadoop" scheme="https://chaomai.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>David Beazley - Python Concurrency From the Ground Up笔记</title>
    <link href="https://chaomai.github.io/2019/2019-05-13-notes-of-python-concurrency-from-the-ground-up/"/>
    <id>https://chaomai.github.io/2019/2019-05-13-notes-of-python-concurrency-from-the-ground-up/</id>
    <published>2019-05-12T16:17:47.000Z</published>
    <updated>2021-06-27T14:57:29.277Z</updated>
    
    <content type="html"><![CDATA[<p>Python Concurrency From the Ground Up，来自<a href="https://pythonhunter.org/episodes/1">捕蛇者说</a>的推荐，是David Beazley在PyCon 2015上的talk。在这个talk中，他边讲边写、外加开点玩笑，可以说David在各种意义上，都是并发的专家，很值得一看。视频和代码如下：</p><ul><li><a href="https://www.youtube.com/watch?v=MCs5OvhV9S4">David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015</a></li><li><a href="https://github.com/dabeaz/concurrencylive">dabeaz/concurrencylive</a></li></ul><p>本文记录了这个talk的主要内容，并加上了我自己的理解。</p><p>这个talk从零实现了一个能支持多客户端并发访问的server，server计算了菲波那切数列第n项的值，为了展示blocking调用，用的是普通的递归实现<code>fib(n) = fib(n-1) + fib(n-2)</code>。同时还写了两个简单的client来测试server性能：<code>perf1.py</code>无限循环<code>fib(30)</code>，并输出每次调用的时间；<code>perf2.py</code>无限循环<code>fib(1)</code>，测试ops，这个调用是立即返回的。</p><h1 id="版本1：简单单线程"><a href="#版本1：简单单线程" class="headerlink" title="版本1：简单单线程"></a>版本1：简单单线程</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_server</span>(<span class="params">address</span>):</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = sock.accept()</span><br><span class="line">        print(<span class="string">&quot;Connection&quot;</span>, addr)</span><br><span class="line">        fib_handler(client)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        req = client.recv(<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> req:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n = <span class="built_in">int</span>(req)</span><br><span class="line">        result = fib(n)</span><br><span class="line">        resp = <span class="built_in">str</span>(result).encode(<span class="string">&#x27;ascii&#x27;</span>) + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">        client.send(resp)</span><br><span class="line">    print(<span class="string">&quot;Closed&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个实现的问题是，server无法同时响应多个client。当某个client连接上后，<code>fib_handler(client)</code>会执行到这个client断开为止。</p><h1 id="版本2：多线程"><a href="#版本2：多线程" class="headerlink" title="版本2：多线程"></a>版本2：多线程</h1><p>在版本1的基础上，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_server</span>(<span class="params">address</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        print(<span class="string">&quot;Connection&quot;</span>, addr)</span><br><span class="line">        Thread(target=fib_handler, args=(client,), daemon=<span class="literal">True</span>).start()</span><br></pre></td></tr></table></figure><p>此时server可以响应多个client。但是由于GIL的存在，python是无法利用多个cpu核心的，因此，</p><ol><li><code>perf1.py</code>的结果（每次调用的时间）会随着<code>perf1.py</code>实例的增加而增加。同一时刻只能响应一个client，其他的等待，因此每次调用的时间大概是<code>单个client调用时间的均值 * perf1.py实例个数</code>。</li><li><code>perf2.py</code>的结果（ops）会受其他调用的影响，ops会下降，<code>n</code>越大，下降越多。David这里提到了，GIL的一个特性是会把优先级给到计算更加密集的任务上，而os的调度却不会受这个影响，运行时间短的任务优先级更高。</li></ol><p>python的每个线程实际上都有os实际的线程与其对应，用<code>ps -o cmd,nlwp &lt;pid&gt;</code>可看，但为何如此调度与其实现有关。对于os，Linux 2.6.23开始采用的是<a href="https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt">Completely Fair Scheduler</a>；FreeBSD和macOS采用的是<a href="https://en.wikipedia.org/wiki/Scheduling_(computing)">Multilevel feedback queue</a>的调度算法，这也就解释了上述为什么运行时间较短的任务优先级更高。因为总能在规定的时间片内运行完成，不会被调度到后面的队列。</p><h1 id="版本3：多线程-进程池"><a href="#版本3：多线程-进程池" class="headerlink" title="版本3：多线程+进程池"></a>版本3：多线程+进程池</h1><p>在版本2的基础上，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor <span class="keyword">as</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        future = pool.submit(fib, n)</span><br><span class="line">        result = future.result()</span><br></pre></td></tr></table></figure><p>由于需要与子进程通信，需要序列化和反序列化数据，引入了额外的开销，因此<code>perf2.py</code>的ops会下降；但与此同时，server端处理计算任务是在单独的进程中，相当于计算任务的调度是由os来完成了，结合<a href="#%E7%89%88%E6%9C%AC2%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B">版本2：多线程</a>中对os调度的解释，基本不受其他计算更加密集的任务影响。</p><h1 id="版本4：事件循环和协程"><a href="#版本4：事件循环和协程" class="headerlink" title="版本4：事件循环和协程"></a>版本4：事件循环和协程</h1><p>回看前三个版本的server，使用线程，本质上是为了解决blocking。而blocking主要发生在等待io的时候，可以考虑只有当io ready的时候才去处理socket。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">tasks = deque()</span><br><span class="line">recv_wait = &#123; &#125;   <span class="comment"># Mapping sockets -&gt; tasks (generators)</span></span><br><span class="line">send_wait = &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">any</span>([tasks, recv_wait, send_wait]):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> tasks:</span><br><span class="line">            <span class="comment"># No active tasks to run</span></span><br><span class="line">            <span class="comment"># wait for I/O</span></span><br><span class="line">            can_recv, can_send, _ = select(recv_wait, send_wait, [])</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> can_recv:</span><br><span class="line">                tasks.append(recv_wait.pop(s))</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> can_send:</span><br><span class="line">                tasks.append(send_wait.pop(s))</span><br><span class="line"></span><br><span class="line">        task = tasks.popleft()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            why, what = <span class="built_in">next</span>(task)   <span class="comment"># Run to the yield</span></span><br><span class="line">            <span class="keyword">if</span> why == <span class="string">&#x27;recv&#x27;</span>:</span><br><span class="line">                <span class="comment"># Must go wait somewhere</span></span><br><span class="line">                recv_wait[what] = task</span><br><span class="line">            <span class="keyword">elif</span> why == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">                send_wait[what] = task</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;ARG!&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            print(<span class="string">&quot;task done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncSocket</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, sock</span>):</span></span><br><span class="line">        self.sock = sock</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv</span>(<span class="params">self, maxsize</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;recv&#x27;</span>, self.sock</span><br><span class="line">        <span class="keyword">return</span> self.sock.recv(maxsize)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;send&#x27;</span>, self.sock</span><br><span class="line">        <span class="keyword">return</span> self.sock.send(data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;recv&#x27;</span>, self.sock</span><br><span class="line">        client, addr = self.sock.accept()</span><br><span class="line">        <span class="keyword">return</span> AsyncSocket(client), addr</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self.sock, name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_server</span>(<span class="params">address</span>):</span></span><br><span class="line">    sock = AsyncSocket(socket(AF_INET, SOCK_STREAM))</span><br><span class="line">    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind(address)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = <span class="keyword">yield</span> <span class="keyword">from</span> sock.accept()  <span class="comment"># blocking</span></span><br><span class="line">        print(<span class="string">&quot;Connection&quot;</span>, addr)</span><br><span class="line">        tasks.append(fib_handler(client))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        req = <span class="keyword">yield</span> <span class="keyword">from</span> client.recv(<span class="number">100</span>)   <span class="comment"># blocking</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> req:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n = <span class="built_in">int</span>(req)</span><br><span class="line">        result = fib(n)</span><br><span class="line">        resp = <span class="built_in">str</span>(result).encode(<span class="string">&#x27;ascii&#x27;</span>) + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> client.send(resp)    <span class="comment"># blocking</span></span><br><span class="line">    print(<span class="string">&quot;Closed&quot;</span>)</span><br><span class="line"></span><br><span class="line">tasks.append(fib_server((<span class="string">&#x27;&#x27;</span>,<span class="number">25000</span>)))</span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p>这个版本的核心在<code>def run()</code>，利用<code>yield</code>实现了协程。当遇到io时，<code>yield</code>跳出当前执行，<code>select</code>判断io ready后，才去读写socket。要注意的是，这个版本虽然没有使用多线程，但server是可以服务多个client的，因为在某个client的socket没有ready的时候，server可以做其他的事情。不过由于是单线程，对于所有client提交的计算任务，server只能逐一执行。协程并不能帮助解决多线程中GIL的问题，因为并没有利用到多个cpu核心，<a href="#%E7%89%88%E6%9C%AC2%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B">版本2：多线程</a>的两个性能问题，这里都存在。</p><p>我觉得这里的<code>yield</code>和事件循环是用的很出彩，换做是我，我首先考虑到的是<code>select</code>出ready的socket，然后进行读写。弊端在于需要把业务逻辑套在一个大循环里面，每次都先调用<code>select</code>，在不同的socket ready的时候，使用相应的业务逻辑进行处理。</p><h1 id="版本5：事件循环和协程-多进程"><a href="#版本5：事件循环和协程-多进程" class="headerlink" title="版本5：事件循环和协程+多进程"></a>版本5：事件循环和协程+多进程</h1><p>在版本4的基础上，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        future = pool.submit(fib, n)</span><br><span class="line">        result = future.result()    <span class="comment">#  Blocks</span></span><br></pre></td></tr></table></figure><p>考虑到上一个版本无法利用多个cpu核心进行计算，那么如果像<a href="#%E7%89%88%E6%9C%AC3%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B+%E8%BF%9B%E7%A8%8B%E6%B1%A0">版本3：多线程+进程池</a>一样把<code>fib</code>放入<code>pool</code>中，是否能解决问题呢？放入以后，会发现当某个协程执行到’future.result()’的时候就会阻塞，直到<code>pool</code>中的任务计算完毕，相当于server主线程会逐一等待每个计算任务。<a href="#%E7%89%88%E6%9C%AC2%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B">版本2：多线程</a>的两个问题，仍然存在。</p><h1 id="版本6：事件循环和协程-多进程"><a href="#版本6：事件循环和协程-多进程" class="headerlink" title="版本6：事件循环和协程+多进程"></a>版本6：事件循环和协程+多进程</h1><p>在版本5的基础上，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">future_wait = &#123; &#125;</span><br><span class="line"></span><br><span class="line">future_notify, future_event = socketpair()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">future_done</span>(<span class="params">future</span>):</span></span><br><span class="line">    tasks.append(future_wait.pop(future))</span><br><span class="line">    future_notify.send(<span class="string">b&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">future_monitor</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;recv&#x27;</span>, future_event</span><br><span class="line">        future_event.recv(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">tasks.append(future_monitor())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        task = tasks.popleft()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            why, what = <span class="built_in">next</span>(task)   <span class="comment"># Run to the yield</span></span><br><span class="line">            <span class="keyword">if</span> why == <span class="string">&#x27;recv&#x27;</span>:</span><br><span class="line">                <span class="comment"># Must go wait somewhere</span></span><br><span class="line">                recv_wait[what] = task</span><br><span class="line">            <span class="keyword">elif</span> why == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">                send_wait[what] = task</span><br><span class="line">            <span class="keyword">elif</span> why == <span class="string">&#x27;future&#x27;</span>:</span><br><span class="line">                future_wait[what] = task</span><br><span class="line">                what.add_done_callback(future_done)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_handler</span>(<span class="params">client</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">        future = pool.submit(fib, n)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;future&#x27;</span>, future</span><br><span class="line">        result = future.result()    <span class="comment">#  Blocks</span></span><br></pre></td></tr></table></figure><p>最后这个实现首先将<code>result = fib(n)</code>，放入了<code>pool</code>并得到一个<code>future</code>，<code>yeild</code>之后为这个future添加计算完成后的回调<code>future_done</code>。这个<code>pool</code>可以是线程池（无法利用多个cpu），也可以是进程池。比较hacking的地方是用<code>socketpair</code>把计算ready转变了socket ready。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>除去实现中用到的一些技巧，这个talk把GIL和blocking的影响、要用什么样的方式来绕开这些问题，以及事件循环和协程讲的很明白。</p><p>P.S. 小插曲，现场写的时候，David把</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can_recv, can_send, _ = select(recv_wait, send_wait, [])</span><br></pre></td></tr></table></figure><p>写成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can_recv, can_send, [] = select(recv_wait, send_wait, [])</span><br></pre></td></tr></table></figure><p>最后有个提问者表示，<em>the empty listing was just some incredible next-level thing that I was just not capable of</em>。</p><p>至于为什么unpack到空list，原因如下，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先unpack到一个变量的list是可以的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, [x, y] = <span class="number">1</span>, <span class="number">2</span>, [<span class="number">10</span>, <span class="number">20</span>]  <span class="comment"># a=1, b=2, x=10, y=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果对一个空list进行unpack，由于没有东西可以unpack，所以可以解到另一个空的list里面</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, [] = <span class="number">1</span>, <span class="number">2</span>, []   <span class="comment"># a=1, b=2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python Concurrency From the Ground Up，来自&lt;a href=&quot;https://pythonhunter.org/episodes/1&quot;&gt;捕蛇者说&lt;/a&gt;的推荐，是David Beazley在PyCon 2015上的talk。在这个talk</summary>
      
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/tags/concurrency/"/>
    
    <category term="python" scheme="https://chaomai.github.io/tags/python/"/>
    
    <category term="pycon" scheme="https://chaomai.github.io/tags/pycon/"/>
    
  </entry>
  
  <entry>
    <title>云南昆明和内蒙包头的星空</title>
    <link href="https://chaomai.github.io/2019/2019-05-12-night-sky-in-kunming-and-baotou/"/>
    <id>https://chaomai.github.io/2019/2019-05-12-night-sky-in-kunming-and-baotou/</id>
    <published>2019-05-12T05:55:23.000Z</published>
    <updated>2021-06-27T14:57:29.276Z</updated>
    
    <content type="html"><![CDATA[<p>一直很想拍到繁星点点的夜空，毕竟自己拍到和看网上别人拍的照片是完全不一样的体验。</p><p>下面两张图片，分别拍摄于过年时的云南昆明和五一的内蒙包头，用lr进行了简单的调整。</p><p><img data-src="/images/2019/DSC02905.jpg"><br><em>云南昆明，2019-02-08 23:57</em></p><p><img data-src="/images/2019/DSC04001.jpg"><br><em>内蒙包头，2019-05-02 23:49</em></p><p>两张的拍摄参数类似，受限于光圈不大，并且为了画面相对纯净调低了iso，因此为了得到足够多的进光量，就拉长了曝光时间，其实可以考虑拍摄多张进行叠加的（懒…。拍摄的时候还缺少三脚架，都是随手找几块砖头堆起来。</p><p>看来为了以后的户外拍摄，又得剁手了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一直很想拍到繁星点点的夜空，毕竟自己拍到和看网上别人拍的照片是完全不一样的体验。&lt;/p&gt;
&lt;p&gt;下面两张图片，分别拍摄于过年时的云南昆明和五一的内蒙包头，用lr进行了简单的调整。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/2019/DSC02905.jpg</summary>
      
    
    
    
    <category term="photography" scheme="https://chaomai.github.io/categories/photography/"/>
    
    
    <category term="starry sky" scheme="https://chaomai.github.io/tags/starry-sky/"/>
    
  </entry>
  
  <entry>
    <title>Go笔记</title>
    <link href="https://chaomai.github.io/2019/2019-03-17-golang-notes/"/>
    <id>https://chaomai.github.io/2019/2019-03-17-golang-notes/</id>
    <published>2019-03-17T06:22:40.000Z</published>
    <updated>2021-06-27T14:57:29.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文档和资源"><a href="#文档和资源" class="headerlink" title="文档和资源"></a>文档和资源</h1><ul><li><a href="https://golang.org/ref/spec">语言规范</a></li><li><a href="https://golang.org/doc/cmd">go命令行文档</a></li><li><a href="https://golang.org/pkg/">包列表</a></li><li><a href="https://github.com/golang/go/wiki">go wiki</a></li><li><a href="https://blog.golang.org/index">The Go Blog</a></li></ul><h1 id="要注意的点"><a href="#要注意的点" class="headerlink" title="要注意的点"></a>要注意的点</h1><ul><li><a href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B">关于引用类型</a></li><li><a href="#Slice">Slice的内部存储</a></li><li><a href="#Slice">Slice的for range</a></li><li><a href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3">method sets和calls</a></li></ul><h1 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h1><p>每个go程序都由package构成。</p><h2 id="Exported-name"><a href="#Exported-name" class="headerlink" title="Exported name"></a>Exported name</h2><p>在一个包中，如果一个name是以大写字母开头的，那么这个name将会被从这个包中导出。</p><p>当import一个包的时候，只能引用<strong>被导出</strong>的name。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数名称在前，类型在后，<a href="https://blog.golang.org/gos-declaration-syntax">Go’s Declaration Syntax</a>。</p><p>当多个连续的函数参数有共同的类型是，可以省略不写除最后一个外的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>一个函数可以返回任意个数的结果。</p><p>返回值可以是有名字的。当<code>return</code>不带任何参数时，函数返回named return values，这叫做”naked” return。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>var</code>声明多个变量时，只能写最后一个的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c, python <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="comment">// var c int, python bool</span></span><br></pre></td></tr></table></figure><p>如果声明时给出了初始值，那么会以初始值的类型作为变量的类型，此时声明中的类型可省略。</p><p>在函数内部可以用短变量声明<code>:=</code>来声明变量，类型由值的类型来决定。但在函数外部，由于所有语句都需要以关键字开头，因此不可用这个方法。</p><p><strong>初始化</strong><br>在声明变量的时候，变量的值总是会被初始化，要么是用指定的值，要么是零值（变量类型的默认值）。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line">     <span class="comment">// represents a Unicode code point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure><p>声明变量但不显式给出初始值，变量会被赋予零值。数值类型：<code>0</code>，bool类型：<code>false</code>，string：<code>&quot;&quot;</code>。</p><h2 id="类型转换和推断"><a href="#类型转换和推断" class="headerlink" title="类型转换和推断"></a>类型转换和推断</h2><p>在进行类型转换时，go只能使用<strong>显式</strong>类型转换。</p><p>使用<code>:=</code>或<code>var =</code>声明变量、未指明类型、但给出初始值时，变量的类型由对初始值进行类型推断得到。如果右侧是数值常量，那么变量的类型可能是<code>int</code>，<code>float64</code>，<code>complex128</code>。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>只可以用<code>const</code>来声明。数值常量可表示任意精度，且不会溢出。一个未指定类型的常量由上下文来决定其类型。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在程序运行期间，始终存在。声明和初始化方式与普通变量相同，需要在函数外部声明。</p><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比c语言，括号可选、大括号必须</span></span><br><span class="line"><span class="comment">// 不可以使用var的方式声明</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化语句和循环的每次更新可省略</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可当做while使用</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限循环</span></span><br><span class="line"><span class="keyword">for</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比c语言，括号可选、大括号必须</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用短语句，在判断之前执行，语句中声明的变量仅在if和后续的else语句块中可用</span></span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// else不能换行写</span></span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>求值顺序，按case的顺序，自上向下进行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比c语言，</span></span><br><span class="line"><span class="comment">// break可选，不写时自动提供</span></span><br><span class="line"><span class="comment">// case不必是integer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">     fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> ...</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不带条件的switch相当于switch true</span></span><br><span class="line"> <span class="keyword">switch</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">     fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>使用<code>defer</code>时，被<code>defer</code>的函数会被push到一个stack，参数会<strong>立即计算</strong>，但函数结束时，stack中的函数才会被pop出来执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;in func t: %s\n&quot;</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(t(<span class="string">&quot;you&quot;</span>))</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// in func t: you</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// you</span></span><br></pre></td></tr></table></figure><p><code>defer</code>的函数可以读取和赋值到函数的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c返回2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c1</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c1返回1</span></span><br></pre></td></tr></table></figure><p><strong>defer、panic和recover</strong><br>当调用<code>panic</code>时，所有<code>defer</code>的函数都被正常执行。然后函数返回到调用者。</p><p><code>recover</code>仅在<code>defer</code>的函数中有用，正常执行时调用，只会返回<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from f.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// g发生panic后，这个deferred的函数会执行，并捕获panic</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered in f&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Calling g.&quot;</span>)</span><br><span class="line">    g(<span class="number">0</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from g.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Panicking!&quot;</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Defer in g&quot;</span>, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Printing in g&quot;</span>, i)</span><br><span class="line">    g(i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><p>关于slice，map和channel，某些书中会将它们描述为引用，但从实现上看（例如：<a href="https://golang.org/src/runtime/slice.go">slice</a>、<a href="https://golang.org/src/runtime/map.go">map</a>、<a href="https://golang.org/src/runtime/chan.go">chan</a>），这些类型不过只是封装了底层指针的struct，且go spec也早就在文档中<a href="https://github.com/golang/go/commit/b34f0551387fcf043d65cd7d96a0214956578f94">移除</a>了reference一词的使用，而在THE WAY TO GO一书中虽然使用了reference一词，但也明确指出，</p><blockquote><p>A reference type variable r1 contains the address (a number) of the memory location where the value of r1 is stored.<br>…<br>When assigning r2 = r1, only the reference (the address) is copied.<br>…<br>In Go pointers (see § 4.9) are reference types, as well as slices (ch 7), maps (ch 8) and channels (ch 13). ……</p></blockquote><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>存储了内存地址，零值为<code>nil</code>。<code>&amp;</code>获得变量的地址，<code>*</code>解引用。</p><p>对比c的指针，go的指针无法进行算数运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure><p><strong>指针的类型转换</strong><br><code>unsafe.Pointer</code>：<code>type Pointer int</code>，代表了变量的内存地址，可以将任意变量的内存地址与<code>Pointer</code>指针相互转换。<br><code>uintptr</code>：<code>type uintptr int</code>，<code>Pointer</code>无法进行加减运算，需要转换为<code>uintptr</code>才可以，可以将<code>Pointer</code>与<code>uintptr</code>指针相互转换。<br><code>unsafe.Offsetof</code>：可以得到字段在结构体内的偏移量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*T &lt;=&gt; unsafe.Pointer &lt;=&gt; <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = Vertex &#123;<span class="number">50</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// *Vertex =&gt; Pointer =&gt; *int =&gt; int</span></span><br><span class="line"><span class="keyword">var</span> x = *(*<span class="keyword">int</span>)(unsafe.Pointer(&amp;v))</span><br><span class="line"><span class="comment">// *Vertex =&gt; Pointer =&gt; uintptr =&gt; Pointer =&gt; *int =&gt; int</span></span><br><span class="line"><span class="keyword">var</span> y = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span><br><span class="line"><span class="keyword">var</span> y = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v)) + unsafe.Offsetof(v.Y))</span><br></pre></td></tr></table></figure><h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><p>字段的集合，使用<code>.</code>来访问字段。首字母大写和小写分别代表公开和私有。私有变量只有同一个package才可以访问。</p><p>对于struct指针，可以使用<code>(*p).X</code>或直接使用<code>p.X</code>来进行访问。对比c，go不能用<code>-&gt;</code>来访问成员。</p><p><strong>初始化</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多行的形式指定一个或多个字段的值的时候，最后的逗号不可以省略。如果只是一行，最后的逗号的可选</span></span><br><span class="line"><span class="comment">// 如果没有指定字段值，那么会使用相应类型默认的零值进初始化。</span></span><br><span class="line"><span class="keyword">var</span> v1 = Vertex &#123;</span><br><span class="line">    X: <span class="number">1</span>,</span><br><span class="line">    Y: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = Vertex &#123;</span><br><span class="line">    X: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v3 = Vertex &#123; X: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 零值结构体实际分配了结构体的内存空间</span></span><br><span class="line"><span class="keyword">var</span> v4 = Vertex &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> v5 = Vertex &#123; <span class="number">1</span>, <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> v6 *Vertex = &amp;Vertex &#123; <span class="number">1</span>,<span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> v7 *Vertex = <span class="built_in">new</span>(Vertex)</span><br><span class="line"><span class="keyword">var</span> v8 Vertex</span><br><span class="line"></span><br><span class="line"><span class="comment">// nil结构体不会分配结构体内存</span></span><br><span class="line"><span class="keyword">var</span> v9 *Vertex = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p><strong>copy</strong></p><ul><li>结构体之间的copy是深拷贝，不共享结构体内部字段。</li><li>结构体指针的copy是浅拷贝，共享内部字段。</li></ul><p><strong>组合</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    v Vertex</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名组合，此时外部的结构体在使用时，可以直接使用内部结构体的成员和方法。如果内部和外部存在相同名字的方法，会调用外部结构体的方法。</span></span><br><span class="line"><span class="keyword">type</span> Circle2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Vertex</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>和c一样，数组的大小也是数组类型的一部分，声明数组时必须有大小，通过下标访问数组中的元素。</p><p>程序执行时，go会检查访问是否越界。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a[<span class="number">10</span>] <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">6</span>] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b[<span class="number">6</span>] <span class="keyword">int</span> = [<span class="number">6</span>] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">c := [<span class="number">6</span>] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">d := [...] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125; <span class="comment">// 自动推断长度</span></span><br><span class="line">e := [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">2</span>: <span class="number">20</span>&#125; <span class="comment">// len(e) = 5, e[1] = 10, e[2] = 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组字面值</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同类型（长度和元素类型）的数组可以相互赋值，会copy数组的内容</span></span><br><span class="line"><span class="keyword">var</span> e[<span class="number">6</span>] <span class="keyword">int</span></span><br><span class="line">e = a</span><br></pre></td></tr></table></figure><p><strong>内部存储</strong><br>连续分配的内存区域。</p><p><strong>copy</strong><br>数组的类型由元素的类型和数组的大小决定，相同类型的数组之间才可以copy。拷贝一个数组，数组的内部的元素也会被逐一拷贝，因此作为变量传递时，需要注意copy的开销。</p><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>slice的类型为<code>[]int</code>，对数组进行，</p><ul><li><code>a[low_index:high_index]</code>后得到，区间是前闭后开，可以省略<code>low_index</code>或<code>high_index</code>，默认值分别为<code>0</code>和数组长度。<br>  <code>cap(a)</code> = <code>len(array) - low_index</code></li><li><code>a[low_index:high_index:cap_index]</code>后得到，区间是“闭、开、开”。<code>cap_index</code>代表可用到的底层数组的最大index，必须小于<code>len(array)</code>。<br>  <code>cap(a)</code> = <code>cap_index - low_index</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a[<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">4</span>]</span><br><span class="line">a[:]</span><br><span class="line">b := []<span class="keyword">string</span> &#123;<span class="number">99</span>: <span class="string">&quot;&quot;</span>&#125; <span class="comment">// len(b) = 100, cap(b) = 100</span></span><br></pre></td></tr></table></figure><p><strong>内部存储</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       +---------------+</span><br><span class="line">slice: |pointer|len|cap|</span><br><span class="line">       +--+------------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">       +--v--------------+</span><br><span class="line">array: |item1|item2|...  |</span><br><span class="line">       +-----------------+</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> address = (**[<span class="number">10</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;s)) <span class="comment">// 底层数组的地址</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">len</span> = (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">cap</span> = (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">16</span>)))</span><br></pre></td></tr></table></figure><p><strong>slice和array</strong><br>slice本身并不存储任何数据，仅仅是数组选定区间的描述，和数组共享底层的数据。<code>len()</code>和<code>cap()</code>对应了slice的长度，和底层数组从<code>low</code>起的大小，即：<code>len(array) - low</code>。</p><p>对已有slice再做一次slice，实际上是改变slice对底层数组的引用范围。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125; <span class="comment">// len(s)=6, cap(s)=6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice the slice to give it zero length.</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend its length.</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>slice字面值类似数组的，区别是没有大小。底层实际上创建了相同大小的数组，然后再创建slice。</p><p><strong>nil slice</strong><br>一个nil slice，是未初始化的slice，<code>len</code>和<code>cap</code>都为0，且不会分配底层的数组，数组指针为<code>nil</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p><strong>空slice</strong><br>一个空slice的<code>len</code>和<code>cap</code>都为0，且不会分配底层的数组，数组指针值不为空，但是也未分配底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">b := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当想声明一个空的slice时，nil slice和空slice都可以，两者在功能上完全等价，但是更<a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices">推荐</a>nil slice。但二者进行序列化的时候，结果会不同，nil slice会编码为null，而空slice是<code>[]</code>。</p><p><strong>make slice</strong><br>通过<code>make</code>来创建动态长度的数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5, cap(a)=5</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>append</strong><br><code>append</code>函数能够将相同类型元素追加至现有slice，若底层数组大小不够，则会重新分配内存，并将slice指向新数组。</p><p>如果发生了扩容，且有另一个slice存在，那么另一个slice的仍然指向老的数组。</p><p>扩容时，如果<code>cap &lt; 1024</code>，那么会扩100%，否则扩25%。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure><p><strong>range</strong><br>除了普通方法遍历slice，还能使用<code>range</code>，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i是index，v是相应元素的copy。</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可忽略i或v的赋值</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>当使用<code>range</code>返回的值，<code>v</code>时，<strong>要注意的是</strong><code>range</code>返回的是<strong>元素的copy</strong>，而不是引用，如果对齐进行<code>&amp;</code>，那么得不到期望的结果。具体来说，Go会使用<strong>同一个</strong>变量，在每轮迭代中保存元素的copy。可以使用<a href="https://github.com/kyoh86/scopelint">kyoh86/scopelint</a>来检查代码中的unpinned variables。</p><ol><li><p>取地址。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Println(&amp;v, &amp;a[i]) <span class="comment">// v的地址保持不变，且不等于a中任意元素的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个原因还有可能导致使用goroutine时出现<a href="https://github.com/golang/go/wiki/CommonMistakes#using-goroutines-on-loop-iterator-variables">意外</a>。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于closure已经绑定到了val，又因为goroutine可能在for结束后才执行</span></span><br><span class="line"><span class="comment">// 因此打印出的可能全都是values的最后一个值。</span></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> valslice &#123;</span><br><span class="line">val := valslice[i] <span class="comment">// val在每次迭代中都会分配新的</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>copy</strong><br>slice的copy是浅拷贝，两个slice共享底层数组。本质上copy的是：指向底层数组的指针、<code>len</code>和<code>cap</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125; <span class="comment">// len(s)=6, cap(s)=6</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br></pre></td></tr></table></figure><p>go还提供了一个函数<code>copy</code>来实现数组内容的copy，copy时，会以目的切片的容量为准。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []T)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>结合slice的内部存储、<code>append</code>和拷贝，有的使用场景不注意可能导致意料之外的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncSlice</span><span class="params">(s []<span class="keyword">int</span>, t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[<span class="number">0</span>]++</span><br><span class="line">s = <span class="built_in">append</span>(s, t)</span><br><span class="line">s[<span class="number">0</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">FuncSlice(a, <span class="number">4</span>)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1 1 2 3]</span></span><br></pre></td></tr></table></figure><p>具体过程分析如下：</p><ol><li><code>s[0]++</code>：<code>a</code>和<code>s</code>都指向同一个底层数组<code>arr1</code>，此时<code>a-&gt;arr1</code>，<code>s-&gt;arr1</code>，修改了<code>arr1</code>。</li><li><code>append</code>：由于扩容，<code>append</code>返回了一个新的底层数组<code>arr2</code>，<code>a-&gt;arr1</code>，<code>s-&gt;arr2</code>。</li><li><code>s[0]++</code>：修改了<code>arr2</code>，<code>arr1</code>不变。</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>一个仅做了声明的map是<code>nil</code>，需要使用<code>make</code>来进行初始化。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的key，使用这些类型会造成编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">    <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map字面值和struct字面值类似。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123; <span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当最上层的类型只是类型名的时候，可以省略。</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: &#123; <span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;, <span class="comment">//最后的逗号不可缺少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mil map</strong><br>nil map未进行初始化，不能用于存储key-value。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br></pre></td></tr></table></figure><p><strong>make map</strong><br>通过<code>make</code>来创建map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>range</strong><br>类似slice，且slice中存在的问题，map中也同样存在。由于无法获取index，因此只能通过每轮迭代创建变量来解决。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k是key，v是相应元素的copy。</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可忽略k或v的赋值</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>操作</strong></p><ul><li>新增和更新：<code>m[key] = elem</code></li><li>访问key的值：<code>elem = m[key]</code>，如果不存在，那么<code>elem</code>为此类型的零值，但如果值真的是零值，那通过这个方法来判断key是否存在就失效了。</li><li>删除：<code>delete(m, key)</code></li><li>test：<code>var elem, ok = m[key]</code>，如果不存在，那么<code>elem</code>为此类型的零值。</li></ul><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><h3 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h3><p>rune字面值代表一个rune常量，是一个标识Unicode code point的整型值。<code>alias for int32</code>。</p><p>rune字面值可以用<code>&#39;单个字符&#39;</code>来表示，可以用<code>\</code>转义的多个字符来表示，具体见<a href="https://golang.org/ref/spec#Rune_literals">Rune literals</a>。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string字面值代表了包含一系列字符的string常量，只读。有两种形式：raw string字面值和interpreted string字面值。</p><ul><li>raw string字面值，是经过未转义处理的，在raw string内部，可以出现任意字符。string中出现的<code>&#39;\r&#39;</code>会被忽略。</li><li>interpreted string字面值，go会进行转义处理。具体见<a href="https://golang.org/ref/spec#String_literals">String literals</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;\U000065e5\U0000672c\U00008a9e&quot;)    \\ 日本語</span><br><span class="line"></span><br><span class="line">fmt.Println(&#96;\U000065e5\U0000672c\U00008a9e&#96;)    \\ \U000065e5\U0000672c\U00008a9e</span><br></pre></td></tr></table></figure><p><strong>内部存储</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            +---------------+</span><br><span class="line">byte slice: |pointer|len|cap|</span><br><span class="line">            +--+------------+</span><br><span class="line">               |</span><br><span class="line">               |</span><br><span class="line">            +--v------------+</span><br><span class="line">array:      |item1|item2|...|</span><br><span class="line">            +---^-----------+</span><br><span class="line">                |</span><br><span class="line">            +---+-----------+</span><br><span class="line">string:     |pointer|len|cap|</span><br><span class="line">            +---------------+</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello，你好&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, *(*[<span class="number">2</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;a)))    \\ [<span class="number">4</span>b9f3c e]</span><br><span class="line"></span><br><span class="line">b := a</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, *(*[<span class="number">2</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;b)))    \\ [<span class="number">4</span>b9f3c e]</span><br></pre></td></tr></table></figure><p>由于底层存储是数组，因此可以做slice，但要注意的是，这里本质上是对字节来做slice，因此如果slice的Unicode code point不是一个完整的字符，那么打印的时候，是不会正确显示的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello，你好&quot;</span></span><br><span class="line">b := a[<span class="number">0</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(b)    \\ Hello，�</span><br></pre></td></tr></table></figure><p>从字符串得到字节slice或者从字节slice得到字符串，会发生底层数组的copy。如果想避免copy，可以手动一个string或slice，获得一个原始string或者slice的“reference”，这种方式不可以通过slice修改string，因为修改后，“reference”到的原有string失效了，可能会被gc回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello，World&quot;</span></span><br><span class="line">b := []<span class="keyword">byte</span>(a) <span class="comment">// copy</span></span><br><span class="line">c := <span class="keyword">string</span>(b) <span class="comment">// copy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动构造</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strhead = *(*[<span class="number">2</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">    <span class="keyword">var</span> slicehead [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    slicehead[<span class="number">0</span>] = strhead[<span class="number">0</span>]</span><br><span class="line">    slicehead[<span class="number">1</span>] = strhead[<span class="number">1</span>]</span><br><span class="line">    slicehead[<span class="number">2</span>] = strhead[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;slicehead))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2str</span><span class="params">(bs []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历</strong></p><ul><li>按字节遍历：通过下标。</li><li>按字符遍历：range方式遍历。</li></ul><h2 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h2><p>函数也是值，可作为参数传递，作为返回值返回。</p><p>闭包（closure）是function value引用了函数体外部的变量，函数可以访问和修改这些变量。换句话说，闭包包含了<strong>函数、以及所在的环境的上下文</strong>。</p><h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><h2 id="方法集（method-sets）和调用"><a href="#方法集（method-sets）和调用" class="headerlink" title="方法集（method sets）和调用"></a>方法集（method sets）和调用</h2><p><a href="https://golang.org/ref/spec#Method_sets">方法集</a>和<a href="https://golang.org/ref/spec#Calls">函数调用</a>的规范明确了一个类型<strong>有哪些方法</strong>，以及<strong>在什么时候可以调用</strong>什么样的方法。go wiki上关于这两个概念有比较详细的<a href="https://github.com/golang/go/wiki/MethodSets">例子</a>。</p><p><strong>method set</strong></p><ol><li><p>对于一个接口类型，接口是方法集。</p></li><li><p>对于一个类型<code>T</code>，所有receiver为T的方法是方法集。</p><p> 对于类型T对应的指针类型<code>*T</code>，所有receiver为<code>T</code>或<code>*T</code>的方法是方法集。</p></li></ol><table><thead><tr><th>Type</th><th>method sets</th></tr></thead><tbody><tr><td>interface type</td><td>interface</td></tr><tr><td>T</td><td>func (T) f()</td></tr><tr><td>*T</td><td>func (*T) f(), func (T) f()</td></tr></tbody></table><p>一个类型<code>T</code>的方法集决定了，这类型<code>T</code>的接口类型的实现，和使用<code>T</code>作为receiver时可以被调用的方法。</p><p><strong>call</strong><br>对于一个方法调用<code>x.m()</code>，</p><ol><li><p>如果<code>x</code>的method set包含<code>m()</code>，且调用时的参数列表合法，那么这个调用是合法的。</p></li><li><p>如果<code>x</code>可以<a href="https://golang.org/ref/spec#Address_operators">取地址的</a>，并且<code>&amp;x</code>的method set包含<code>m()</code>，那么<code>x.m()</code>等价于<code>(&amp;x).m()</code>。</p><p> <em>map元素和interface存储的具体值不可取地址。</em></p></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是带有特殊receiver参数（<code>func</code>和函数名之间）的函数。这个receiver不必是struct，但要求receiver的类型定义必须在同一个package里面，且不能直接将内置类型作为receiver。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><strong>Point receiver</strong><br>若要修改字段，则必须使用point receiver，<strong>无论变量本身是否是指针类型</strong>，<strong>非指针receiver调用时发生了copy</strong>。</p><p>从这里可以得出使用point receiver的场景：1. 避免copy；2. 修改值本身。一般来说，某个类型的receiver应该<strong>统一</strong>，要么是point receive，要么是普通receiver。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123; v.X = v.X * f ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Scale2</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123; v.X = v.X * f ... &#125;</span><br></pre></td></tr></table></figure><ul><li>若v不是指针类型，那么go会把<code>v.Scale</code>自动转换为<code>（&amp;v）.Scale</code>。</li><li>反过来，若v是指针类型，在调用<code>Scale2</code>时，go会把<code>v.Scale2</code>转换为<code>（*v).Scale2</code>。</li></ul><p>对比c++的成员函数，<code>this</code>指针类似于point receiver，但go的普通receiver是不同于c++的。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是方法签名的集合。</p><p>接口的实现是隐式的，无需类似<code>implement</code>的关键字。隐式实现<strong>解耦</strong>接口的定义和实现，在package中，接口的定义可以出现在方法和类型定义之后。注意方法的实现<strong>区分普通receiver和point receiver</strong>。</p><p>一个接口值可以被赋值为<strong>任何实现了接口中所有方法的值</strong>。接口值底层实际包含了具体值的类型，接口值可以看做是值和具体类型的元组。调用接口值的方法，实际上会调用具体类型的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123; Abs() <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyInt)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">int64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(<span class="number">1</span>)</span><br><span class="line">i := MyInt(<span class="number">2</span>)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f</span><br><span class="line">a = i</span><br><span class="line">a = &amp;v</span><br><span class="line"></span><br><span class="line"><span class="comment">// a = v</span></span><br><span class="line"><span class="comment">// error，Vertex没有实现Abs()，*Vertex才实现了Abs()</span></span><br></pre></td></tr></table></figure><p>对比c++的多态，c++中通过继承基类，并覆盖基类的虚函数，在运行时进行动态绑定，以此实现多态。go的接口方法定义可以看做是基类和虚函数，而<code>a = f</code>相当于将子类的指针赋值给基类指针，这样完成了动态绑定。</p><p>不同的点还是receiver，实现接口的方法时，go区分了point receiver和普通receiver。</p><p><strong>内部存储</strong><br>实现上，一个接口值底层包含了指向类型和数据的指针。</p><p>接口类型之间的赋值和类型转换是共享数据的，而结构体之间的赋值、结构体转接口、接口转结构体，都会导致数据的copy。</p><p><strong>空的具体类型值</strong><br>如果接口的具体类型值是空的，那么将会使用<code>nil</code> receiver来调用方法，不引发空指针异常。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123; Abs() <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i Abser</span><br><span class="line"><span class="keyword">var</span> v *Vertex</span><br><span class="line">i = v</span><br><span class="line"></span><br><span class="line">i.Abs()</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">v.Abs()</span><br></pre></td></tr></table></figure><p><strong>空的接口值</strong><br>会发生运行时错误，没有具体的<code>Abs</code>方法可以调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123; Abs() <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="keyword">var</span> i Abser</span><br><span class="line">i.Abs()</span><br></pre></td></tr></table></figure><p><strong>空接口</strong><br>空接口的值可以包含任何类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var i interface &#123;&#125;</span><br><span class="line">i &#x3D; 32</span><br><span class="line">i &#x3D; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; i &#x3D; 100000000000000000000000000</span><br><span class="line">&#x2F;&#x2F; overflows int</span><br></pre></td></tr></table></figure><p><strong>接口变量的赋值</strong><br>对于数值类型，底层的具体类型<strong>只能是</strong><code>int</code>，<code>float64</code>，<code>complex128</code>。</p><p><strong>类型断言</strong><br>类型断言提供了访问接口底层具体类型值的能力。</p><ul><li><code>t := i.(T)</code>断言接口<code>i</code>拥有具体类型<code>T</code>，并把类型<code>T</code>的值赋值给<code>t</code>。如果不是类型<code>T</code>，则触发panic。</li><li>test：<code>t, ok := i.(T)</code>断言不正确的情况，不触发panic，而是<code>ok</code>为false，且t为类型<code>T</code>的零值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">100000000000000000000000000</span> <span class="comment">// overflow</span></span><br><span class="line">a := i.(<span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">100000</span></span><br><span class="line">a := i.(<span class="keyword">int64</span>) <span class="comment">// int</span></span><br></pre></td></tr></table></figure><p>Type swtiches是允许断言多个类型的结构。类似switch语句，但是每个case是特定的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果test成功，那么v会转换为相应的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// here v has type T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// here v has type S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// no match; here v has the same type as i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比scala的pattern matching，go的type swtiches像，但不是pattern matching。scala的pattern matching会检查值和pattern是否匹配，能够把值解构为构成值的各部分。<strong>猜测</strong>go的type swtiches是类型字符串是否相等的test。</p><h2 id="一些内置的接口"><a href="#一些内置的接口" class="headerlink" title="一些内置的接口"></a>一些内置的接口</h2><p><strong>Stringer</strong><br>类似python的<code>__str__</code>，定义在<code>fmt</code>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A ...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">a := A()</span><br><span class="line">fmt.Println(a) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p><strong>error</strong><br>类似Stringer，fmt在print的时候也会查找<code>error</code>接口。从fmt的实现上看，是error<strong>优先</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>error</code>更适合用于专门定义的错误类型。否则功能上，<code>stringer</code>和<code>error</code>就冗余了。</p><p>可以使用<code>fmt.Errorf</code>或<code>errors.New</code>来创建<code>error</code>类型的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Errorf(<span class="string">&quot;math: square root of negative number %g&quot;</span>, f)</span><br></pre></td></tr></table></figure><p><strong>Reader</strong><br>io包定义了<code>io.Reader</code>接口，代表读取stream，有多个实现（文件、网络等）。</p><p>其中<code>func (T) Read(b []byte) (n int, err error)</code>方法使用现有数据填充<code>b</code>，并返回填充的字节数和<code>error</code>。stream结束时，<code>error</code>为<code>io.EOF</code>。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>由go运行时管理的轻量级线程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure><p>参数的计算在当前goroutine中完成，函数<code>f</code>的调用发生在新的goroutine。所有子协程都是平级的关系（包括在子协程内部启动另一个协程）。</p><h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>channel是带类型的管道（typed conduit），每次只能发送或接受一个元素。默认情况下，发送方和接收方会一直阻塞到另一方ready，每次只能唤醒一个发送或接受方。</p><p><strong>方向</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T <span class="comment">// 可以发送和接受类型为T的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- T <span class="comment">// 可以发送类型为T的数据</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> T <span class="comment">// 可以接受类型为T的数据</span></span><br></pre></td></tr></table></figure><p><strong>unbuffered channel</strong><br>unbuffered channel必须保证先有goroutine正在接收，否则发送方会一直阻塞到有goroutine来接收为止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// len(ch) == 0, cap(ch) == 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// block</span></span><br><span class="line">v := &lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先有goroutine正在接收</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := &lt;-ch</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>buffered channel</strong><br><code>ch := make(chan int, 100)</code>，buffered channel在满或空的情况下，分别会导致发送方和接收方阻塞。</p><p><strong>range</strong><br><code>for i := range ch</code>可以从channel逐个接收值，直到channel被关闭。</p><p><strong>close</strong></p><ul><li>发送方可以通过<code>close(ch)</code>来告诉接收方没有后续的值会发送。如果向关闭的channel发送元素，那么会导致抛出异常。</li><li>接收方可以使用<code>v, ok := &lt;-ch</code>判断channel是否被关闭。如果从一个已经关闭的channel接收元素，会返回channel类型的零值，因此是不能用这个方式来判断channel是否关闭的。</li></ul><p><strong>select</strong><br>select语句可以让goroutine等待多个通信操作（发送或接受都可以），block直到其中某个case能执行。如果同时有多个case能执行，则随机选择一个。</p><p>若存在default，则当没有case ready的时候，执行default，因此可以通过default实现非阻塞式的发送或接受。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// receiving from c would block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h2><ul><li><a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go Concurrency Patterns</a></li><li><a href="https://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a></li></ul><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>go内存模型</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><h2 id="static-build"><a href="#static-build" class="headerlink" title="static build"></a>static build</h2><p><code>go build</code>启用race，也需要启用cgo。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>抛开go的运行时环境和gc不说，go很像c，同时还有着少量函数式语言的特性。</p><p>go中，我很喜欢的几点是：</p><ol><li>变量和函数的声明简洁清晰</li><li>goroutine</li><li>提供了CSP来实现goroutine之间的通信</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文档和资源&quot;&gt;&lt;a href=&quot;#文档和资源&quot; class=&quot;headerlink&quot; title=&quot;文档和资源&quot;&gt;&lt;/a&gt;文档和资源&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://golang.org/ref/spec&quot;&gt;语言规范&lt;/a&gt;&lt;/li&gt;
</summary>
      
    
    
    
    <category term="golang" scheme="https://chaomai.github.io/categories/golang/"/>
    
    
    <category term="golang" scheme="https://chaomai.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>python符号表、module和package</title>
    <link href="https://chaomai.github.io/2019/2019-03-05-python-symtable-module-package/"/>
    <id>https://chaomai.github.io/2019/2019-03-05-python-symtable-module-package/</id>
    <published>2019-03-05T14:12:40.000Z</published>
    <updated>2021-06-27T14:57:29.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="symbol-table"><a href="#symbol-table" class="headerlink" title="symbol table"></a>symbol table</h1><p>symbol table（符号表）是用于编译器或解释器中的一个数据结构，存储了源码中每个符号以及关联的信息。不同的作用域可能会有各自的符号表。在静态语言中，符号表尤为重要。</p><h2 id="python-variable"><a href="#python-variable" class="headerlink" title="python variable"></a>python variable</h2><p>python中的变量与c/c++的不一样，是绑定到对象的symbolic name。<code>aa</code>，<code>bb</code>都是绑定到一个list对象的名字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aa = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">bb = aa</span><br><span class="line">aa[<span class="number">0</span>] = <span class="number">666</span></span><br></pre></td></tr></table></figure><h2 id="python-symbol-table"><a href="#python-symbol-table" class="headerlink" title="python symbol table"></a>python symbol table</h2><p>虽然python是动态语言，没有编译时类型检查，但python也有符号表。python的符号表通过编译器由AST生成，用于计算每个标识符的作用域，最终符号表和AST会被共同用于生成字节码。<code>symtable</code>模块提供了关于标识符的作用域等信息，还能够输出在这些作用域中引用到的变量是哪个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">aa</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        bb = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> aa + bb + cc</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">src = <span class="built_in">open</span>(<span class="string">&#x27;add.py&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read()</span><br><span class="line"><span class="keyword">import</span> symtable</span><br><span class="line">table = symtable.symtable(src, <span class="string">&#x27;src.py&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_symbol</span>(<span class="params">sym</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">type</span>(sym) == symtable.Symbol</span><br><span class="line">    print(<span class="string">&quot;Symbol:&quot;</span>, sym.get_name())</span><br><span class="line">    <span class="keyword">for</span> prop <span class="keyword">in</span> [</span><br><span class="line">            <span class="string">&#x27;referenced&#x27;</span>, <span class="string">&#x27;imported&#x27;</span>, <span class="string">&#x27;parameter&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;declared_global&#x27;</span>, <span class="string">&#x27;local&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;free&#x27;</span>, <span class="string">&#x27;assigned&#x27;</span>, <span class="string">&#x27;namespace&#x27;</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">getattr</span>(sym, <span class="string">&#x27;is_&#x27;</span> + prop)():</span><br><span class="line">            print(<span class="string">&#x27;    is&#x27;</span>, prop)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table.get_children()[<span class="number">0</span>].get_children()[<span class="number">0</span>].get_symbols():</span><br><span class="line">    describe_symbol(i)</span><br><span class="line"></span><br><span class="line">Symbol: bb</span><br><span class="line">    <span class="keyword">is</span> referenced</span><br><span class="line">    <span class="keyword">is</span> local</span><br><span class="line">    <span class="keyword">is</span> assigned</span><br><span class="line">Symbol: aa</span><br><span class="line">    <span class="keyword">is</span> referenced</span><br><span class="line">    <span class="keyword">is</span> free</span><br><span class="line">Symbol: cc</span><br><span class="line">    <span class="keyword">is</span> referenced</span><br><span class="line">    <span class="keyword">is</span> <span class="keyword">global</span></span><br></pre></td></tr></table></figure><p>free variable：如果变量在一个代码块内使用（在代码内被绑定），但是并没有在其中定义，那么这个变量是自由变量。顺便提一句，使用了自由变量的函数就是闭包（closure）。<br>global variable：如果变量代码在模块级别被绑定，这个变量是全局变量。<br>local variable：如果变量在代码块内被绑定，这个变量是局部变量。</p><h1 id="python-module"><a href="#python-module" class="headerlink" title="python module"></a>python module</h1><p>module（模块）是一个包含python定义和语句的文件，文件名由module名和<code>.py</code>后缀构成。module名可由全局变量<code>__name__</code>获取。这个文件可被作为脚本使用或用于repl中，module中的定义可以被其他module或mainmodule导入。</p><p>例如：<code>p.py</code>，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>在repl中，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把module名p加入当前的符号表</span></span><br><span class="line"><span class="keyword">import</span> p</span><br><span class="line">p.add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Symbol: p</span><br><span class="line">    <span class="keyword">is</span> imported</span><br><span class="line">    <span class="keyword">is</span> local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把p中的add导入当前符号表</span></span><br><span class="line"><span class="keyword">from</span> p <span class="keyword">import</span> add</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Symbol: add</span><br><span class="line">    <span class="keyword">is</span> imported</span><br><span class="line">    <span class="keyword">is</span> local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把p中的除_开头的所有名字导入当前符号表</span></span><br><span class="line"><span class="keyword">from</span> p <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>一个module，可以包含可执行语句和函数定义，这些语句是用于初始化module的，仅仅在第一次导入这个模块的时候执行，作为脚本运行的时候也会执行。module作为脚本执行的时候，<code>__name__</code>会被设置为<code>&quot;__main__&quot;</code>，很常见的一个语句是<code>if __name__ == &quot;__main__&quot;:</code>，作为脚本执行的时候，运行<code>if</code>内的语句。</p><p>每个module有自己私有的符号表。module内部的全局变量不会与外部的产生冲突，另一个角度看，如果知道模块内的全局变量名称，可以通过<code>modname.itemname</code>的方式访问到。通过<code>dir()</code>函数可以得到module内定义的名字。</p><p>导入module时，module名字的search path为，</p><ol><li><p>内置的module</p></li><li><p><code>sys.path</code><br> 这个变量的值由下列几项初始化得到，</p><ul><li><p>脚本当前目录</p></li><li><p><code>PYTHONPATH</code>环境变量</p></li><li><p>the installation-dependent default</p><p><code>sys.path</code>初始化以后，可以在程序中修改。</p></li></ul></li></ol><h2 id="python-package"><a href="#python-package" class="headerlink" title="python package"></a>python package</h2><p>package是一种通过<code>modnameA.submodnameB</code>来组织module的方式。python会把包含<code>__init__.py</code>文件的文件夹当做package。<code>__init__.py</code>文件可以直接留空，也可以加入初始化package的代码或设置<code>__all__</code>变量（用于控制<code>from package imrpot *</code>的时候，导入哪些）。</p><p>导入的方式为，</p><ul><li><code>from package import item</code>。import语句首先测试item是否在package中定义，如果没有，那么假设item是一个module并尝试load。最终如果没有找到，那么会抛出<code>ImportError</code>异常。</li><li><code>import item.subitem.subsubitem</code>，最后一个item可以是module或package，但不能是类、函数或变量，其他必须是package。</li></ul><h1 id="class和module"><a href="#class和module" class="headerlink" title="class和module"></a>class和module</h1><p>在使用的时候，class和module有一些相似的地方，但是二者完全不同。</p><ul><li>class是创建带有属性和方法的实例的蓝图，支持继承等。这些module都不能做。</li><li>module仅仅只是组织代码的方式。</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="https://eli.thegreenplace.net/2010/09/18/python-internals-symbol-tables-part-1">Python internals: Symbol tables, part 1</a></li><li><a href="https://docs.python.org/2/library/symtable.html">symtable — Access to the compiler’s symbol tables¶</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;symbol-table&quot;&gt;&lt;a href=&quot;#symbol-table&quot; class=&quot;headerlink&quot; title=&quot;symbol table&quot;&gt;&lt;/a&gt;symbol table&lt;/h1&gt;&lt;p&gt;symbol table（符号表）是用于编译器或解释器中的一</summary>
      
    
    
    
    <category term="python" scheme="https://chaomai.github.io/categories/python/"/>
    
    
    <category term="symtable" scheme="https://chaomai.github.io/tags/symtable/"/>
    
  </entry>
  
  <entry>
    <title>Python进程间通信总结</title>
    <link href="https://chaomai.github.io/2018/2018-07-04-python-multiprocessing-communication/"/>
    <id>https://chaomai.github.io/2018/2018-07-04-python-multiprocessing-communication/</id>
    <published>2018-07-04T14:09:50.000Z</published>
    <updated>2021-06-27T14:57:29.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python进程间通信总结"><a href="#Python进程间通信总结" class="headerlink" title="Python进程间通信总结"></a>Python进程间通信总结</h1><p>Python的multiprocessing支持使用类似threading模块的API来创建进程，multiprocessing提供了本地和远程并发，有效的避免了线程中的GIL。下面对Python进程间通信的方法做了简单的总结，并列举了相应的例子。</p><h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">conn</span>):</span></span><br><span class="line">    i = conn.recv()</span><br><span class="line">    print(i)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe()</span><br><span class="line">    p = Process(target=f, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line">    parent_conn.send(<span class="number">1</span>)</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p><code>multiprocessing.Queue</code>使用pepe和locks/semaphores实现了进程间的共享队列。任何picklable对象都可以通过<code>queue</code>传递。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">q</span>):</span></span><br><span class="line">    i = q.get()</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = multiprocessing.Queue()</span><br><span class="line">    p = multiprocessing.Process(target=worker, args=(queue,))</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    queue.put(<span class="number">1</span>)</span><br><span class="line">    queue.close()</span><br><span class="line">    queue.join_thread()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><h1 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h1><h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p>一种简单的同步原语，用于固定数目的进程相互等待。当所有进程都调用<code>wait</code>以后，所有进程会同时开始执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">b</span>):</span></span><br><span class="line">    i = b.wait()</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&#x27;passed the barrier&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    barrier = multiprocessing.Barrier(<span class="number">2</span>)</span><br><span class="line">    p = multiprocessing.Process(target=worker, args=(barrier,))</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    q = multiprocessing.Process(target=worker, args=(barrier,))</span><br><span class="line">    q.start()</span><br><span class="line"></span><br><span class="line">    p.join()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h2 id="BoundedSemaphore"><a href="#BoundedSemaphore" class="headerlink" title="BoundedSemaphore"></a>BoundedSemaphore</h2><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>条件变量。多个进程可以等待同一个条件变量，直到他们被另一个进程通知。条件变量默认使用<code>RLock</code>，可以提供自己的锁，但必须是<code>Lock</code>或者<code>RLock</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">q, c</span>):</span></span><br><span class="line">    c.acquire()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(q) == <span class="number">0</span>:</span><br><span class="line">        c.wait()</span><br><span class="line"></span><br><span class="line">    i = q.pop()</span><br><span class="line">    print(i)</span><br><span class="line">    c.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">q, c</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        c.acquire()</span><br><span class="line">        q.append(i)</span><br><span class="line">        c.notify_all()</span><br><span class="line">        c.release()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = []</span><br><span class="line">    cond = multiprocessing.Condition()</span><br><span class="line">    p1 = multiprocessing.Process(target=consumer, args=(queue, cond,))</span><br><span class="line">    p1.start()</span><br><span class="line"></span><br><span class="line">    p2 = multiprocessing.Process(target=consumer, args=(queue, cond,))</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    q = multiprocessing.Process(target=producer, args=(queue, cond,))</span><br><span class="line">    q.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    q.join()</span><br></pre></td></tr></table></figure><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p><code>Event</code>提供了一种简单的方法来实现进程间的状态传递。event类似一个flag，状态是set或者unset。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_event</span>(<span class="params">e</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;wait_for_event: starting&#x27;</span>)</span><br><span class="line">    e.wait()</span><br><span class="line">    print(<span class="string">&#x27;wait_for_event: e.is_set()-&gt;&#x27;</span>, e.is_set())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_event_timeout</span>(<span class="params">e, t</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;wait_for_event_timeout: starting&#x27;</span>)</span><br><span class="line">    e.wait(t)</span><br><span class="line">    print(<span class="string">&#x27;wait_for_event_timeout: e.is_set()-&gt;&#x27;</span>, e.is_set())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    e = multiprocessing.Event()</span><br><span class="line">    w1 = multiprocessing.Process(name=<span class="string">&#x27;block&#x27;</span>, target=wait_for_event, args=(e,))</span><br><span class="line">    w1.start()</span><br><span class="line"></span><br><span class="line">    w2 = multiprocessing.Process(name=<span class="string">&#x27;nonblock&#x27;</span>, target=wait_for_event_timeout, args=(e, <span class="number">2</span>))</span><br><span class="line">    w2.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;main: waiting before calling Event.set()&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    e.<span class="built_in">set</span>()</span><br><span class="line">    print(<span class="string">&#x27;main: event is set&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h1 id="状态共享"><a href="#状态共享" class="headerlink" title="状态共享"></a>状态共享</h1><h2 id="shared-memory-map"><a href="#shared-memory-map" class="headerlink" title="shared memory map"></a>shared memory map</h2><p>通过使用<code>Value</code>或<code>Array</code>，数据可以被存储在shared memory map中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">n, a</span>):</span></span><br><span class="line">    n.value = <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        a[i] = -a[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    num = multiprocessing.Value(<span class="string">&#x27;d&#x27;</span>, <span class="number">0.0</span>)</span><br><span class="line">    arr = multiprocessing.Array(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    p = multiprocessing.Process(target=f, args=(num, arr))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    print(num.value)</span><br><span class="line">    print(arr[:])</span><br></pre></td></tr></table></figure><p><code>Value</code>和<code>Array</code>在shared memory分配了ctypes对象。默认情况下，返回的值是使用同步方法封装过的对象，即线程安全的。其中，参数<code>d</code>和<code>i</code>代表了值的类型。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="https://pymotw.com/3/multiprocessing/communication.html">Passing Messages to Processes</a></li><li><a href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing — Process-based parallelism</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python进程间通信总结&quot;&gt;&lt;a href=&quot;#Python进程间通信总结&quot; class=&quot;headerlink&quot; title=&quot;Python进程间通信总结&quot;&gt;&lt;/a&gt;Python进程间通信总结&lt;/h1&gt;&lt;p&gt;Python的multiprocessing支持使用</summary>
      
    
    
    
    <category term="python" scheme="https://chaomai.github.io/categories/python/"/>
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>Docker笔记</title>
    <link href="https://chaomai.github.io/2018/2018-06-15-notes-of-docker/"/>
    <id>https://chaomai.github.io/2018/2018-06-15-notes-of-docker/</id>
    <published>2018-06-15T14:09:50.000Z</published>
    <updated>2021-06-27T14:57:29.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker笔记"><a href="#Docker笔记" class="headerlink" title="Docker笔记"></a>Docker笔记</h1><h1 id="操作系统虚拟化"><a href="#操作系统虚拟化" class="headerlink" title="操作系统虚拟化"></a>操作系统虚拟化</h1><p>Operating-system-level virtualization, 又叫做容器化（containerization），指的是操作系统提供了这样一个功能，内核允许存在多个隔离的用户空间实例，每个实例叫做一个容器（container）。</p><p>Docker是一个容器化平台。</p><table><thead><tr><th>container</th><th>vm</th></tr></thead><tbody><tr><td><img data-src="/images/2018/15226880999438.png" alt="15226880999438"></td><td><img data-src="/images/2018/15226881122546.png" alt="15226881122546"></td></tr></tbody></table><ul><li>容器是应用层上的抽象，容器之间共享操作系统内核。</li><li>vm是硬件抽象，每个vm不仅仅包含要允许的程序，还包括了一个完整的os。</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h2><p>镜像是由一系列的只读层构成的，每层代表了对已有镜像的修改。相当于一个root文件系统。由一个sha256作为镜像ID<strong>唯一标识</strong>，一个镜像可以有<strong>多个标签</strong>。</p><p>对已有镜像中文件的修改，都是以Copy-on-Write的方式进行，例如：删除文件，在新的一层中进行标记删除，原有层的文件不变。</p><h3 id="scratch镜像"><a href="#scratch镜像" class="headerlink" title="scratch镜像"></a>scratch镜像</h3><p>scratch镜像代表一个空白的镜像，这是一个虚拟的镜像，不实际存在，意味着基于这个构建的新镜像不使用任何已有的基础镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="空悬镜像（Dangling-image）"><a href="#空悬镜像（Dangling-image）" class="headerlink" title="空悬镜像（Dangling image）"></a>空悬镜像（Dangling image）</h3><p>空悬镜像是没有tag，没有被其他镜像依赖的镜像。当创建一个新的镜像时，使用了一个已有的tag，那么老的镜像就会变为空悬镜像。可被删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -f dangling=<span class="literal">true</span></span><br><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h3 id="Docker-build-context"><a href="#Docker-build-context" class="headerlink" title="Docker build context"></a>Docker build context</h3><p>Docker是c/s架构的，实际的构建动作发生在server。当<code>ADD</code>文件到镜像中时，server需要知道这个文件，具体的方式都是通过打包构建时的上下文，并发送给server。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><ul><li><code>PATH</code>，即上下文；</li><li>若<code>URL</code>是一个压缩包，那么其内容会被当做上下文。</li></ul><h3 id="Untagged和Delete"><a href="#Untagged和Delete" class="headerlink" title="Untagged和Delete"></a>Untagged和Delete</h3><p>镜像的多层结构使得层与层之间存在依赖，在进行删除操作时，需要考虑这些的依赖关系。当某层没有被依赖时，才可以被删除。</p><p>删除一个镜像时，实际上是删除镜像的标签（Untagged），当一个镜像的所有标签都被删除了，才会触发删除这个镜像（Delete）。</p><p>如果有容器存在，同样不可以删除这个镜像，因为这个镜像被一个可读写层依赖。</p><h2 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h2><p>容器是镜像运行的实体，本质上是一个进程，拥有自己的独立的命名空间。在存储上与镜像的区别在于多了最上面的一个读写层，这个层是容器的运行态环境，生命周期与容器一致，<strong>不建议</strong>在这一层写入数据。</p><p><img data-src="/images/2018/15227153999553.jpg" alt="15227153999553"></p><h2 id="仓库（Registry）"><a href="#仓库（Registry）" class="headerlink" title="仓库（Registry）"></a>仓库（Registry）</h2><p>Docker仓库（Docker Registry）是存储和分发镜像的服务，包括多个Repository；每个Repository包含多个标签，通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的方式来指定一个镜像。</p><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><ul><li><p>数据卷（Volumes）</p><p>  数据卷独立于镜像和容器，可在多个容器之间共享，容器终止后，数据卷也会一直存在。</p></li><li><p>挂载主机目录（Bind mounts）</p></li></ul><h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><p>Docker的网络是通过可插拔的驱动来提供的。除了可以使用Docker已有的驱动，还能安装第三方网络驱动。</p><h2 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h2><p><img data-src="/images/2018/15261916795186.jpg" alt="15261916795186"></p><p>bridge网络是在链路层用于在不同网段之间转发流量的。bridge可以是一个硬件或软件设备。</p><p>bridge驱动创建了主机内部的私有网络，在这个网络中的容器可以相互通信，可以通过端口映射来实现外部的访问。docker通过规则在禁止不同bridge网络之间的通信。</p><p>docker的bridge是local scope的，这意味着一个bridge网络只能提供单机上的容器互联。docker提供了默认的bridge，用户也可以添加自定义的bridge。</p><p>user-defined bridge和default bridge略有不同，user-defined bridge提供了如下功能：</p><ul><li>连接到user-defined bridge的所有容器，都会自动的相互暴露所有端口。</li><li>提供了容器之间的自动DNS解析，可以直接通过host name来进行访问其他容器。</li><li>创建了可配置的bridge（默认的bridge也可以配置，但是这个操作是在docker之外进行的，需要重启docker）。</li></ul><p>默认的bridge特别的一点是，可以通过<code>--link</code>来在容器之间共享环境变量，但<code>--link</code>已被遗弃，user-defined bridge可以通过共享文件或目录、compose file来实现共享环境变量。</p><h2 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h2><p><img data-src="/images/2018/15261917479037.jpg" alt="15261917479037"></p><h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>使用host网络时，容器的网络栈没有与主机的隔离（存储、进程namespace、用户namespace都有隔离），如果在容器绑定到了80端口，那么容器的程序在主机的80端口可用。这也就意味着，绑定前要求主机的80端口未被占用。</p><p>host网络仅在linux上可用，<em>猜测</em>mac和windows上不可用是由于使用了虚拟化。</p><h2 id="macvlan"><a href="#macvlan" class="headerlink" title="macvlan"></a>macvlan</h2><p><img data-src="/images/2018/15261917609686.jpg" alt="15261917609686"></p><h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><h1 id="Docker上部署Hadoop"><a href="#Docker上部署Hadoop" class="headerlink" title="Docker上部署Hadoop"></a>Docker上部署Hadoop</h1><ol><li><a href="https://flat2010.github.io/2017/08/12/Docker%E4%B8%8A%E9%83%A8%E7%BD%B2Hadoop%E7%AD%89%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/">Docker上部署Hadoop等完全分布式集群</a></li><li><a href="https://blog.docker.com/2016/12/understanding-docker-networking-drivers-use-cases/">UNDERSTANDING DOCKER NETWORKING DRIVERS AND THEIR USE CASES</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/">Docker —— 从入门到实践</a></li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="https://docs.docker.com/">Docker Documentation</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker笔记&quot;&gt;&lt;a href=&quot;#Docker笔记&quot; class=&quot;headerlink&quot; title=&quot;Docker笔记&quot;&gt;&lt;/a&gt;Docker笔记&lt;/h1&gt;&lt;h1 id=&quot;操作系统虚拟化&quot;&gt;&lt;a href=&quot;#操作系统虚拟化&quot; class=&quot;header</summary>
      
    
    
    
    <category term="docker" scheme="https://chaomai.github.io/categories/docker/"/>
    
    
    <category term="docker" scheme="https://chaomai.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程相关</title>
    <link href="https://chaomai.github.io/2017/2017-05-12-about-functional-programming/"/>
    <id>https://chaomai.github.io/2017/2017-05-12-about-functional-programming/</id>
    <published>2017-05-12T01:10:55.000Z</published>
    <updated>2021-06-27T14:57:29.273Z</updated>
    
    <content type="html"><![CDATA[<p>Notes of Functional Programming in Scala and more.</p><h2 id="Pure-Function"><a href="#Pure-Function" class="headerlink" title="Pure Function"></a>Pure Function</h2><p>对于一个函数 <code>f: A =&gt; B</code>，如果任何一个值 <code>a: A</code> 都有只有一个 <code>b: B</code> 与之对应，使得 <code>b</code> 仅仅由 <code>a</code> 决定，那么这个函数是纯函数。任何内部或外部状态的改变都不影响 <code>f(a)</code> 的结果。</p><h2 id="Referential-Transparency"><a href="#Referential-Transparency" class="headerlink" title="Referential Transparency"></a>Referential Transparency</h2><p>引用透明是表达式的属性。如果一个表达式是引用透明的，那么把这个表达式替换为它求值后的结果不会影响程序的行为。引用透明是定义一个纯函数的必要条件。</p><p>如果表达式不是引用透明的，那么这个表达式就是有 side-effect（副作用）。根据引用透明的定义，对于一个纯函数函数 <code>f</code>，表达式 <code>f(x)</code> 不会有任何的副作用。</p><h2 id="Idempotence（幂等性）"><a href="#Idempotence（幂等性）" class="headerlink" title="Idempotence（幂等性）"></a>Idempotence（幂等性）</h2><p>纯函数的幂等的。</p><p>$$<br>\forall x, f(f(x)) = f(x)<br>$$</p><h1 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h1><p>一个 Curryied 函数是，把一个接受多个参数的函数重写为，一个首先接受第一个参数并返回一个函数接受第二个参数…的函数。</p><p>例如：foldLeft。</p><p><a href="https://oldfashionedsoftware.com/2009/07/10/scala-code-review-foldleft-and-foldright/">https://oldfashionedsoftware.com/2009/07/10/scala-code-review-foldleft-and-foldright/</a></p><h1 id="Currying-和-Partially-Applied-Function"><a href="#Currying-和-Partially-Applied-Function" class="headerlink" title="Currying 和 Partially Applied Function"></a>Currying 和 Partially Applied Function</h1><ul><li><a href="http://stackoverflow.com/questions/14309501/scala-currying-vs-partially-applied-functions">http://stackoverflow.com/questions/14309501/scala-currying-vs-partially-applied-functions</a></li><li><a href="http://stackoverflow.com/questions/8650549/using-partial-functions-in-scala-how-does-it-work/8650639#8650639">http://stackoverflow.com/questions/8650549/using-partial-functions-in-scala-how-does-it-work/8650639#8650639</a></li></ul><h1 id="trait-and-class"><a href="#trait-and-class" class="headerlink" title="trait and class"></a>trait and class</h1><ul><li><a href="http://stackoverflow.com/questions/1991042/what-is-the-advantage-of-using-abstract-classes-instead-of-traits">http://stackoverflow.com/questions/1991042/what-is-the-advantage-of-using-abstract-classes-instead-of-traits</a></li><li><a href="http://stackoverflow.com/questions/2005681/difference-between-abstract-class-and-trait">http://stackoverflow.com/questions/2005681/difference-between-abstract-class-and-trait</a></li><li><a href="http://www.artima.com/pins1ed/traits.html#12.7">http://www.artima.com/pins1ed/traits.html#12.7</a></li></ul><h1 id="Functions-and-Methods"><a href="#Functions-and-Methods" class="headerlink" title="Functions and Methods"></a>Functions and Methods</h1><p>In Scala there is a rather arbitrary distinction between functions defined as <em>methods</em>, which are introduced with the <code>def</code> keyword, and function values, which are the first-class objects we can pass to other functions, put in collections, and so on.</p><ul><li><a href="https://www.google.com/search?q=difference+scala+function+method">https://www.google.com/search?q=difference+scala+function+method</a></li><li><a href="http://www.cnblogs.com/shihuc/p/5082701.html">http://www.cnblogs.com/shihuc/p/5082701.html</a></li><li><a href="http://stackoverflow.com/questions/4839537/functions-vs-methods-in-scala">http://stackoverflow.com/questions/4839537/functions-vs-methods-in-scala</a></li><li><a href="http://stackoverflow.com/questions/2529184/difference-between-method-and-function-in-scala">http://stackoverflow.com/questions/2529184/difference-between-method-and-function-in-scala</a></li><li><a href="http://jim-mcbeath.blogspot.com/2009/05/scala-functions-vs-methods.html">http://jim-mcbeath.blogspot.com/2009/05/scala-functions-vs-methods.html</a></li><li><a href="https://dzone.com/articles/revealing-scala-magician%E2%80%99s">https://dzone.com/articles/revealing-scala-magician%E2%80%99s</a></li><li><a href="https://tpolecat.github.io/2014/06/09/methods-functions.html">https://tpolecat.github.io/2014/06/09/methods-functions.html</a></li><li><a href="https://www.quora.com/What-is-the-difference-between-function-and-method-in-Scala">https://www.quora.com/What-is-the-difference-between-function-and-method-in-Scala</a></li><li><a href="https://softwarecorner.wordpress.com/2013/09/06/scala-methods-and-functions/">https://softwarecorner.wordpress.com/2013/09/06/scala-methods-and-functions/</a></li><li><a href="http://www.marcinkossakowski.com/difference-between-functions-and-methods-in-scala/">http://www.marcinkossakowski.com/difference-between-functions-and-methods-in-scala/</a></li><li><a href="http://japgolly.blogspot.com/2013/10/scala-methods-vs-functions.html">http://japgolly.blogspot.com/2013/10/scala-methods-vs-functions.html</a></li><li><a href="http://blog.vmoroz.com/posts/2016-06-01-scala-should-i-use-a-method-or-a-function.html">http://blog.vmoroz.com/posts/2016-06-01-scala-should-i-use-a-method-or-a-function.html</a></li></ul><h1 id="Functional-Combinators"><a href="#Functional-Combinators" class="headerlink" title="Functional Combinators"></a>Functional Combinators</h1><ul><li><a href="http://stackoverflow.com/questions/7533837/explanation-of-combinators-for-the-working-man">Explanation of combinators</a></li></ul><p><code>List(1, 2, 3) map squared</code>把函数<code>squared</code>应用到了<code>List(1, 2, 3)</code>的每个元素上，并返回一个新的List。这个操作叫做map组合子（map combinators）。</p><h1 id="PartialFunction-and-Partially-Applied-Function"><a href="#PartialFunction-and-Partially-Applied-Function" class="headerlink" title="PartialFunction and Partially Applied Function"></a>PartialFunction and Partially Applied Function</h1><h1 id="Rank-1-polymorphism-and-Higher-Rank-Polymorphism"><a href="#Rank-1-polymorphism-and-Higher-Rank-Polymorphism" class="headerlink" title="Rank-1 polymorphism and Higher-Rank Polymorphism"></a>Rank-1 polymorphism and Higher-Rank Polymorphism</h1><ul><li><a href="https://apocalisp.wordpress.com/2010/07/02/higher-rank-polymorphism-in-scala/">https://apocalisp.wordpress.com/2010/07/02/higher-rank-polymorphism-in-scala/</a><ul><li>related:</li><li><a href="https://apocalisp.wordpress.com/2010/10/26/type-level-programming-in-scala-part-7-natural-transformation%C2%A0literals/">https://apocalisp.wordpress.com/2010/10/26/type-level-programming-in-scala-part-7-natural-transformation%C2%A0literals/</a></li><li><a href="https://apocalisp.wordpress.com/2011/03/20/towards-an-effect-system-in-scala-part-1/">https://apocalisp.wordpress.com/2011/03/20/towards-an-effect-system-in-scala-part-1/</a></li></ul></li><li><a href="http://existentialtype.net/2008/03/09/higher-rank-impredicative-polymorphism-in-scala/">http://existentialtype.net/2008/03/09/higher-rank-impredicative-polymorphism-in-scala/</a></li></ul><h1 id="Existential-Types"><a href="#Existential-Types" class="headerlink" title="Existential Types"></a>Existential Types</h1><ul><li><a href="http://www.drmaciver.com/2008/03/existential-types-in-scala/">http://www.drmaciver.com/2008/03/existential-types-in-scala/</a></li></ul><h1 id="Algebraic-Data-Type"><a href="#Algebraic-Data-Type" class="headerlink" title="Algebraic Data Type"></a>Algebraic Data Type</h1><ul><li><a href="http://tpolecat.github.io/presentations/algebraic_types.html">http://tpolecat.github.io/presentations/algebraic_types.html</a></li><li><a href="https://www.youtube.com/watch?v=YScIPA8RbVE">https://www.youtube.com/watch?v=YScIPA8RbVE</a></li></ul><h1 id="Variant"><a href="#Variant" class="headerlink" title="Variant"></a>Variant</h1><h2 id="Covariant-and-contravariant"><a href="#Covariant-and-contravariant" class="headerlink" title="Covariant and contravariant"></a>Covariant and contravariant</h2><p>对于所有类型<code>X</code>和<code>Y</code>，以及类型<code>Co[+A]</code>，<code>Ctr[-A]</code>，<code>Iv[A]</code>。如果X是Y的子类，</p><p>covariant：<code>Co[X]</code>是<code>Co[Y]</code>的子类。在类型参数A前加上+表示 covariant。<br>contravariant：<code>Ctr[Y]</code>是<code>Ctr[X]</code>的子类。在类型参数A前加上-表示 contravariant。<br>invariant：<code>Iv[X]</code>和<code>Iv[Y]</code>无关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───┐     ┌───────┐     ┌───────┐</span><br><span class="line">│ Y │     │ Co[Y] │     │Ctr[X] │</span><br><span class="line">└───┘     └───────┘     └───────┘</span><br><span class="line">  ▲           ▲             ▲</span><br><span class="line">  │           │             │</span><br><span class="line">  │           │             │</span><br><span class="line">┌───┐     ┌───────┐     ┌───────┐</span><br><span class="line">│ X │     │ Co[X] │     │Ctr[Y] │</span><br><span class="line">└───┘     └───────┘     └───────┘</span><br></pre></td></tr></table></figure><p>表述 covariant 的另一种方式是，在所有上下文中，都可安全的把<code>A</code>转换为<code>A</code>父类。contravariant 类似。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> sound = <span class="string">&quot;rustle&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> sound = <span class="string">&quot;call&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> sound = <span class="string">&quot;cluck&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">covariant1</span>[+<span class="type">A</span>]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="comment">// error:</span></span></span><br><span class="line"><span class="class"><span class="comment">// val covariant_b1: covariant1[Bird] = new covariant1[Animal]</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">variant_b2</span></span>: variant1[<span class="type">Bird</span>] = <span class="keyword">new</span> variant1[<span class="type">Chicken</span>]</span><br><span class="line">                │            │       │               │</span><br><span class="line">                └────────────┘       └───────────────┘</span><br><span class="line">                      ▲                       │</span><br><span class="line">                      └───────────────────────┘</span><br><span class="line">                           to supper <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">contravariant2</span>[-<span class="type">A</span>]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">contravariant_b3</span></span>: contravariant2[<span class="type">Bird</span>] = <span class="keyword">new</span> contravariant2[<span class="type">Animal</span>]</span><br><span class="line"><span class="comment">// error:</span></span><br><span class="line"><span class="comment">// val contravariant_b4: contravariant2[Bird] = new contravariant2[Chicken]</span></span><br></pre></td></tr></table></figure><h2 id="Covariant-and-Contravariant-Positions"><a href="#Covariant-and-Contravariant-Positions" class="headerlink" title="Covariant and Contravariant Positions"></a>Covariant and Contravariant Positions</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span> [-<span class="type">T1</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span></span></span><br></pre></td></tr></table></figure><p>以函数为例，</p><p>contravariant (positive) position：一个类型在函数参数的类型中。更一般的来说，是函数所使用的值的类型。<br>covariant (negative) position：一个类型在函数结果的类型中。更一般的来说，是函数产生的值的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                 ┌────────────────────────┐</span><br><span class="line">                 │ contravariant position │</span><br><span class="line">                 └────────────────────────┘</span><br><span class="line">                              ▲</span><br><span class="line">           ┌──────────────────┘</span><br><span class="line">           │</span><br><span class="line">def foo(a: A): B</span><br><span class="line">               │</span><br><span class="line">               └────────────┐</span><br><span class="line">                            ▼</span><br><span class="line">                 ┌────────────────────┐</span><br><span class="line">                 │ covariant position │</span><br><span class="line">                 └────────────────────┘</span><br></pre></td></tr></table></figure><p>对于高阶函数，从外层向内分析。类型最终是什么 position 由分析过程中，各个类型的“累加”得到。就函数 <code>foo</code> 而言，<code>A =&gt; B</code> 是在 contravariant position；就函数 <code>f</code> 而言， <code>A</code> 是在 contravariant position，<code>B</code> 是在 covariant position。因此，最终 <code>A</code> 是在 covariant position（可以理解为两个 negative position 合并，负负得正），而 <code>B</code> 是在 contravariant position。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                  ┌───────────────────────┐</span><br><span class="line">                  │ A: covariant position │</span><br><span class="line">                  └───────────────────────┘</span><br><span class="line">                              ▲</span><br><span class="line">                              │                    ┌───────────────────────────┐</span><br><span class="line">                                                   │ B: contravariant position │</span><br><span class="line">              ┌ ─ ─ ─ ─ ─ ─ ─ ┴ ─ ─ ─ ─ ─ ─ ─ ─    └───────────────────────────┘</span><br><span class="line">                                               │                 ▲</span><br><span class="line">              ├──────────────────────────────────────────────────┴──────────┐</span><br><span class="line">              │                                │                            │</span><br><span class="line">              │                   ┌────────────────────────┐                │</span><br><span class="line"> ┌────────────────────────┐       │ contravariant position │     ┌────────────────────┐</span><br><span class="line"> │ contravariant position │       └────────────────────────┘     │ covariant position │</span><br><span class="line"> └────────────────────────┘                    ▲                 └────────────────────┘</span><br><span class="line">              ▲                    ┌───────────┘                            ▲</span><br><span class="line">              │                    │    ┌───────────────────────────────────┘</span><br><span class="line">              │                    │    │</span><br><span class="line">           ┌────┐       ┌───────▶  A &#x3D;&gt; B</span><br><span class="line">           │    │───────┘</span><br><span class="line">def foo(f: A &#x3D;&gt; B): C</span><br><span class="line">                    │</span><br><span class="line">                    └────────────┐</span><br><span class="line">                                 ▼</span><br><span class="line">                      ┌────────────────────┐</span><br><span class="line">                      │ covariant position │</span><br><span class="line">                      └────────────────────┘</span><br></pre></td></tr></table></figure><p>Scala要求类型本身的variant与类型所在位置的variant一致。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error 1</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Option</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">orElse</span></span>(o: <span class="type">Option</span>[<span class="type">A</span>]): <span class="type">Option</span>[<span class="type">A</span>]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V1</span>[+<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">V2</span>[-<span class="type">B</span>] <span class="keyword">extends</span> <span class="title">V1</span>[<span class="type">B</span>]</span></span><br></pre></td></tr></table></figure><p>这个定义将会导致编译错误，<code>Error:... covariant type A occurs in contravariant position in type</code>。<code>orElse</code> 函数接受参数<code>Option[A]</code>，这个位置（contravariant position）是只能将 <code>A</code> 转换为 <code>A</code> 的子类型的地方。但是类型 <code>A</code> 是 covariant 的，也就是说在所有上下文中，都可安全的把 <code>A</code> 转换为 <code>A</code> 父类。这里出现了冲突。</p><p>对于 <code>orElse</code>，解决方式是不使用 <code>A</code>，使用边界限定类型为 <code>A</code> 的父类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orElse</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](o: <span class="type">Option</span>[<span class="type">B</span>]): <span class="type">Option</span>[<span class="type">B</span>] = <span class="keyword">this</span> <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; ob</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那为什么不，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orElse</span></span>[<span class="type">B</span> &lt;: <span class="type">A</span>](o: <span class="type">Option</span>[<span class="type">B</span>]): <span class="type">Option</span>[<span class="type">B</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orElse</span></span>[<span class="type">B</span>](o: <span class="type">Option</span>[<span class="type">B</span>]): <span class="type">Option</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure><p><code>orElse</code> 返回值可能的类型为 <code>Option[B]</code> 或 <code>Option[A]</code>，</p><ul><li>对于1，<code>B</code> 是 <code>A</code> 的子类，<code>Option[B]</code> 是 <code>Option[A]</code> 的子类，当返回 <code>this</code> 时，类型为 <code>Option[A]</code>，这里无法从父类转换到子类。</li><li>对于2，当返回 <code>this</code> 时，类型为 <code>Option[A]</code>，和 <code>Option[B]</code> 完全无关，类型不匹配。</li></ul><h1 id="Laziness-和-Non-strictness"><a href="#Laziness-和-Non-strictness" class="headerlink" title="Laziness 和 Non-strictness"></a>Laziness 和 Non-strictness</h1><p>二者都与求值策略<a href="https://en.wikipedia.org/wiki/Evaluation_strategy">^1</a>（evaluation strategy）有关。一个编程语言用求值策略来，</p><ul><li>确定合适计算一个函数调用的参数。</li><li>以什么样的形式来把数值传递给函数。</li></ul><p>求值策略包括，</p><ul><li><p>严格求值（strict evaluation）：一个函数调用的参数总是在应用这个函数之前进行完全求值。常见的有，</p><ul><li><p>call by value</p></li><li><p>call by reference</p><p>关于这个话题，不得不提的是计算顺序<a href="http://en.cppreference.com/w/cpp/language/eval_order">^2</a>（order of evaluation），在c++中，这个顺序未定义，由编译器决定。</p></li></ul></li><li><p>非严格求值（non-strict evaluation）：一个函数调用的参数只有在函数体内被使用到时，才进行求值。常见有，</p><ul><li>call by name：在函数体内被使用到时才进行求值，没有被用到则不会求值。如果被多次使用到，那么每次使用都需要重新求值。</li><li>call by need：记忆版的 call by name。当参数首次被求值时，值被保留用于后续使用。</li></ul></li><li><p>非确定性策略（nondeterministic strategies）</p><ul><li>call by future</li></ul></li></ul><p>在 Scala 中，非严格参数又叫做 call “by name” 参数，对应 Scala 中对这些参数使用的 call by name求值策略。当首次使用到某个参数的时候，通过 <code>lazy val</code> 缓存这个值，来达到 call by need（又叫做 lazy evaluation）。</p><h1 id="Nothing-和-NotNothing"><a href="#Nothing-和-NotNothing" class="headerlink" title="Nothing 和 NotNothing"></a>Nothing 和 NotNothing</h1><ul><li><a href="https://github.com/OlegIlyenko/hacking-scala-blog/blob/master/posts/Advanced-Type-Constraints-with-Type-Classes.md">Advanced Type Constraints with Type Classes</a></li><li><a href="https://github.com/mongodb/mongo-spark/blob/master/src/main/scala/com/mongodb/spark/NotNothing.scala">NotNothing.scala</a></li><li><a href="http://stackoverflow.com/questions/41403287/possible-to-make-scala-require-a-non-nothing-generic-method-parameter-and-return">Possible to make scala require a non-Nothing generic method parameter and return to type-safety</a></li></ul><p>Scala 中，关于多态，一个头疼的<a href="https://issues.scala-lang.org/browse/SI-2609">问题</a>是，如果没有为一个多态方法指定类型参数，并且无法从方法的参数中推断出类型，由于 <code>Nothing</code> 是所有类型的子类型，此时 Scala 就会把没有指定的类型推断为 <code>Nothing</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Dimension</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">sealed</span> <span class="title">trait</span> <span class="title">UnitDim</span> <span class="keyword">extends</span> <span class="title">Dimension</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">VarDim</span> <span class="keyword">extends</span> <span class="title">Dimension</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">sealed</span> <span class="title">trait</span> <span class="title">DimValue</span>[<span class="type">D</span> &lt;: <span class="type">Dimension</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimValue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">D</span> &lt;: <span class="type">Dimension</span>](v: <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">DimValue</span>[<span class="type">D</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Int</span> = v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>DimValue</code>，我希望 <code>apply</code> 中，<code>D</code> 为 <code>Dimension</code> 的子类型。如果在调用这个方法时为明确指定类型参数，结果就会是 <code>DimValue[Nothing]</code>。这不是我所期望的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dv = <span class="type">DimValue</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Pattern</span>: dv: <span class="type">DimValue</span>[<span class="type">Nothing</span>] <span class="keyword">with</span> <span class="type">Object</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Google 了 Scala NotNothing 以后，找到两个方法，</p><ul><li><a href="http://stackoverflow.com/questions/41403287/possible-to-make-scala-require-a-non-nothing-generic-method-parameter-and-return">Possible to make scala require a non-Nothing generic method parameter and return to type-safety Ask Question</a></li><li><a href="https://github.com/OlegIlyenko/hacking-scala-blog/blob/master/posts/Advanced-Type-Constraints-with-Type-Classes.md">Advanced Type Constraints with Type Classes</a></li><li><a href="https://github.com/mongodb/mongo-spark/blob/master/src/main/scala/com/mongodb/spark/NotNothing.scala">mongodb/mongo-spark</a></li><li><a href="http://baddotrobot.com/blog/2015/07/03/scala-implicit-parameters/">Implicit Parameters in Scala</a></li><li><a href="http://docs.scala-lang.org/tutorials/tour/implicit-parameters.html">Implicit Parameters</a></li></ul><h1 id="State-Action-and-FSM"><a href="#State-Action-and-FSM" class="headerlink" title="State Action and FSM"></a>State Action and FSM</h1><p><code>type State[S, +A] = S =&gt; (A, S)</code></p><p><code>State</code> 代表<em>携带者某种状态的计算</em>，或 state action，state transition，或 statement。<code>State</code> 类型表示将 <code>S</code> 从一个状态转换到另一个状态，并产生副作用 <code>A</code>。这有点像有限状态机。</p><p>考虑一个 Mealy 型的 FSM，根据定义（主要是转移函数和输出函数），把这个 FSM 表示为，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Mealy</span>[<span class="type">S</span>, <span class="type">I</span>, <span class="type">A</span>](<span class="params">t: (<span class="type">S</span>, <span class="type">I</span></span>) <span class="title">=&gt;</span> <span class="title">S</span>, <span class="title">g</span></span>: (<span class="type">S</span>, <span class="type">I</span>) =&gt; <span class="type">A</span>)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>S</code>：状态的有限集合</li><li><code>I</code>：输入字母表的有限集合</li><li><code>A</code>：输出字母表的有限集合</li><li><code>t</code>：转移函数</li><li><code>g</code>：输出函数</li></ul><p>转移函数和输出函数都接受 <code>S</code> 和 <code>I</code> 的值作为参数，可以把这两个函数合并，得到，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">S</span>, <span class="type">I</span>) =&gt; (<span class="type">A</span>, <span class="type">S</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// currying</span></span><br><span class="line"><span class="type">I</span> =&gt; <span class="type">S</span> =&gt; (<span class="type">A</span>, <span class="type">S</span>)</span><br></pre></td></tr></table></figure><p>根据 State 的定义得到，<code>I =&gt; State[S, A]</code>。<code>State[S, A]</code> 代表类型为 <code>S =&gt; (A, S)</code> 的函数，这个函数参数可以看做这个 Mealy 型的 FSM 的初始状态。</p><p>同样的一个 Moore 型的 FSM，根据定义可以表示为，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Moore</span>[<span class="type">S</span>, <span class="type">I</span>, <span class="type">A</span>](<span class="params">t: (<span class="type">S</span>, <span class="type">I</span></span>) <span class="title">=&gt;</span> <span class="title">S</span>, <span class="title">g</span></span>: <span class="type">S</span> =&gt; <span class="type">A</span>)</span><br></pre></td></tr></table></figure><p>转移函数和输出函数都接受 <code>S</code> 的值作为参数，合并得到，<code>S =&gt; (I =&gt; S, A)</code>，但此时就不能够用 <code>State</code> 数据类型来表示了。</p><h1 id="implicit"><a href="#implicit" class="headerlink" title="implicit"></a>implicit</h1><ul><li><a href="http://akmetiuk.com/posts/2017-05-12-implicits.html">Implicits mechanism in Scala</a></li><li><a href="http://docs.scala-lang.org/tutorials/tour/implicit-parameters.html">Implicit Parameters</a></li><li><a href="http://docs.scala-lang.org/overviews/core/implicit-classes.html">Implicit Classes</a></li><li><a href="http://stackoverflow.com/questions/10375633/understanding-implicit-in-scala">Understanding implicit in Scala</a></li><li><a href="http://www.lihaoyi.com/post/ImplicitDesignPatternsinScala.html">Implicit Design Patterns in Scala</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Notes of Functional Programming in Scala and more.&lt;/p&gt;
&lt;h2 id=&quot;Pure-Function&quot;&gt;&lt;a href=&quot;#Pure-Function&quot; class=&quot;headerlink&quot; title=&quot;Pure Fun</summary>
      
    
    
    
    <category term="functional programming" scheme="https://chaomai.github.io/categories/functional-programming/"/>
    
    
    <category term="scala" scheme="https://chaomai.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>scanRight和动态规划</title>
    <link href="https://chaomai.github.io/2017/2017-04-23-scanRight-and-Dynamic-Programming/"/>
    <id>https://chaomai.github.io/2017/2017-04-23-scanRight-and-Dynamic-Programming/</id>
    <published>2017-04-23T06:16:51.000Z</published>
    <updated>2021-06-27T14:57:29.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scanRight"><a href="#scanRight" class="headerlink" title="scanRight"></a>scanRight</h1><p>这是 Functional Programming in Scala 一书中，练习5.16的一个问题。问题是，把 <code>tail</code> 泛化为 <code>scanRight</code>，这个 <code>scanRight</code> 需要返回中间结果形式的 stream。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Stream</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>).scanRight(<span class="number">0</span>)(_ + _).toList</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><em>注：1. 给定一个 stream，<code>tail</code> 会将这个输入的所有后缀作为 stream 返回；2. 中间结果形式的 stream 意味着结果是以 call-by-name 的方式构造的；3. 遍历 <code>scanRight</code> 的时间复杂度应该为 $O(n)$。</em></p><p>先不考虑时间复杂度的要求，仅仅实现 <code>scanRight</code> 的功能，那很容易就可以写出下面的代码，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanRight1</span></span>[<span class="type">B</span>](z: <span class="type">B</span>)(f: (<span class="type">A</span>, =&gt; <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">Stream</span>[<span class="type">B</span>] =</span><br><span class="line">  foldRight((z, <span class="type">Stream</span>(z)))((e, acc_s) =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> acc_e = f(e, acc_s._1)</span><br><span class="line">    (acc_e, <span class="type">Stream</span>.cons(acc_e, acc_s._2))</span><br><span class="line">  &#125;)._2</span><br></pre></td></tr></table></figure><p><code>foldRight</code> 保留了累计值 <code>acc_e</code> 和 stream 的中间值 <code>acc_s</code>，在每次迭代（这里实际上是递归）中，使用这两个值来进行 <code>Stream.cons</code>，以得到最后结果。</p><h1 id="计算过程分析"><a href="#计算过程分析" class="headerlink" title="计算过程分析"></a>计算过程分析</h1><p>在看这题的答案的时候，发现答案并没有直接使用 <code>acc_s</code>，而是用 <code>lazy</code> 缓存了这个值，然后基于这个缓存的值进行计算。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanRight2</span></span>[<span class="type">B</span>](z: <span class="type">B</span>)(f: (<span class="type">A</span>, =&gt; <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">Stream</span>[<span class="type">B</span>] =</span><br><span class="line">  foldRight((z, <span class="type">Stream</span>(z)))((e, acc_s) =&gt; &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">val</span> p = acc_s</span><br><span class="line">    <span class="keyword">val</span> acc_e = f(e, p._1)</span><br><span class="line">    (acc_e, <span class="type">Stream</span>.cons(acc_e, p._2))</span><br><span class="line">  &#125;)._2</span><br></pre></td></tr></table></figure><p>这里我不理解的是缓存什么不好，为什么要缓存 <code>acc_s</code>。因为每次迭代都会遇到 stream 中的元素，为什么不 <code>lazy val p = e</code>。</p><p>下面以 <code>Stream(3, 2, 1).scanRight(0)(_ + _)</code> 为例，分析 <code>scanRight1</code> 计算过程。</p><ol><li><p>把求和的 function 叫 sum，</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.scanRight(<span class="number">0</span>)(sum)</span><br></pre></td></tr></table></figure></li><li><p>展开 scanRight，</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.foldRight((<span class="number">0</span>, <span class="type">Stream</span>(<span class="number">0</span>)))((e, acc_s) =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> acc_e = sum(e, acc_s._1)</span><br><span class="line">  (acc_e, <span class="type">Stream</span>.cons(acc_e, acc_s._2))</span><br><span class="line">&#125;)._2</span><br></pre></td></tr></table></figure></li><li><p>为了后续分析方便，对比 <code>foldRight</code> 的类型，提取出 <code>foldRight</code> 的 <code>f</code>，</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">B</span>](z: =&gt; <span class="type">B</span>)(f: (<span class="type">A</span>, =&gt; <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span></span><br><span class="line"></span><br><span class="line">f: (<span class="type">Int</span>, (<span class="type">Int</span>, <span class="type">Stream</span>[<span class="type">Int</span>])) =&gt; (<span class="type">Int</span>, <span class="type">Stream</span>[<span class="type">Int</span>]) = (e, acc_s) =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> acc_e = sum(e, acc_s._1)</span><br><span class="line">  (acc_e, <span class="type">Stream</span>.cons(acc_e, acc_s._2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>此时可以进行 <code>foldRight</code> 中的 pattern matching 了，</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cons</span>(h, t) =&gt;</span><br><span class="line">h: <span class="number">3</span></span><br><span class="line">t: <span class="type">Stream</span>(<span class="number">2</span>, <span class="number">1</span>).foldRight((<span class="number">0</span>, <span class="type">Stream</span>(<span class="number">0</span>)))(f)</span><br></pre></td></tr></table></figure></li><li><p>把参数代入 <code>f</code> 进行计算，</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acc_e: <span class="number">3</span></span><br><span class="line">acc_s: <span class="type">Stream</span>(<span class="number">2</span>, <span class="number">1</span>).foldRight((<span class="number">0</span>, <span class="type">Stream</span>(<span class="number">0</span>)))(f)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">val</span> acc_e = sum(<span class="number">3</span>, acc_s._1)</span><br><span class="line">  (acc_e, <span class="type">Stream</span>.cons(acc_e, acc_s._2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 根据 <code>foldRight</code> 的定义，逐层展开 <code>acc_s._1</code>，即：<code>Stream(2, 1).foldRight((0, Stream(0)))(f)._1</code>，省略了展开的详细过程和 <code>foldRight</code> 中对 <code>Empty</code> 的 pattern matching，</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">val</span> acc_e = sum(<span class="number">3</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="keyword">val</span> acc_e = sum(<span class="number">2</span>,</span><br><span class="line">                                        &#123;</span><br><span class="line">                                          <span class="keyword">val</span> acc_e = sum(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                                          (acc_e, <span class="type">Stream</span>.cons(acc_e, acc_s._2))</span><br><span class="line">                                        &#125;._1</span><br><span class="line">                                      )</span><br><span class="line"></span><br><span class="line">                      (acc_e, <span class="type">Stream</span>.cons(acc_e, acc_s._2))</span><br><span class="line">                    &#125;._1</span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">  (acc_e, <span class="type">Stream</span>.cons(acc_e, acc_s._2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 等价于，</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">val</span> acc_e = <span class="number">6</span></span><br><span class="line">  (<span class="number">6</span>, <span class="type">Stream</span>.cons(<span class="number">6</span>, acc_s._2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来计算 <code>acc_s._2</code>，即：<code>Stream(2, 1).foldRight((0, Stream(0)))(f)._2</code>。</p></li></ol><p>观察上述过程发现，<code>Stream(2, 1).foldRight((0, Stream(0)))(f)</code>，也就是 <code>acc_s</code> 会被计算两次，这就是 <code>lazy val p = acc_s</code> 的缘由。</p><h1 id="与动态规划的联系"><a href="#与动态规划的联系" class="headerlink" title="与动态规划的联系"></a>与动态规划的联系</h1><p>进一步分析，在第一次迭代中，当前的 <code>acc_s</code> 需要计算两次。在后续的迭代中（计算：<code>(Stream.cons(6, acc_s._2)</code>），每次迭代都重复计算了一部分结果。简单来说就是，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一次：3 + 2 + 1</span><br><span class="line">第二次：    2 + 1</span><br><span class="line">第三次：        1</span><br></pre></td></tr></table></figure><p>例如值 <code>1</code>，在 3 次迭代中，都被重复计算得到了 3 次。使用 <code>lazy val p = acc_s</code> 避免了这些多余的计算。</p><p>这时回过头去看 <code>scanRight</code>，可以将这个函数的功能看做是，对所有的后缀 stream 进行了 <code>foldRight</code> 操作。对长后缀 stream 计算 <code>foldRight</code> 时，实际上计算了短后缀 stream 的 <code>foldRight</code>。这实际上就是动态规划，</p><ul><li>最优子结构：当前长后缀 stream 的 <code>foldRight</code>可以由短后缀 stream 得到。</li><li>无后效性：短后缀 stream 的 <code>foldRight</code> 不受长后缀 stream 的影响。</li><li>子问题重叠：短后缀 stream 的 <code>foldRight</code> 会被多次计算。</li></ul><p>由于子问题重叠，因此常用，</p><ul><li>Memoization (Top Down)</li><li>Tabulation (Bottom Up)</li></ul><p>来存储子问题的解，避免重复计算。</p><p><code>scanRight</code> 实际上就是用了 Memoization 来存储子问题的解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;scanRight&quot;&gt;&lt;a href=&quot;#scanRight&quot; class=&quot;headerlink&quot; title=&quot;scanRight&quot;&gt;&lt;/a&gt;scanRight&lt;/h1&gt;&lt;p&gt;这是 Functional Programming in Scala 一书中，练习5</summary>
      
    
    
    
    <category term="functional programming" scheme="https://chaomai.github.io/categories/functional-programming/"/>
    
    
    <category term="scanRight" scheme="https://chaomai.github.io/tags/scanRight/"/>
    
  </entry>
  
  <entry>
    <title>6.824 - Spring 2017 Lecture 2 Infrastructure - RPC and threads</title>
    <link href="https://chaomai.github.io/2017/2017-04-20-6.824-Spring-2017-Lecture-2/"/>
    <id>https://chaomai.github.io/2017/2017-04-20-6.824-Spring-2017-Lecture-2/</id>
    <published>2017-04-20T07:27:54.000Z</published>
    <updated>2021-06-27T14:57:29.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lectures"><a href="#Lectures" class="headerlink" title="Lectures"></a>Lectures</h1><h2 id="Remote-Procedure-Call-RPC"><a href="#Remote-Procedure-Call-RPC" class="headerlink" title="Remote Procedure Call (RPC)"></a>Remote Procedure Call (RPC)</h2><p>分布式系统的关键组件。</p><p>目标：简化C/S通信的开发。</p><ul><li>隐藏 C/S 通信的大多数细节。</li><li>client 端进行 RPC 调用，就像调用普通的函数一样。</li><li>server 端处理 RPC 请求，就像处理普通的函数一样。</li></ul><p>RPC消息发送图示，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Client             Server</span><br><span class="line">  request---&gt;</span><br><span class="line">     &lt;---response</span><br></pre></td></tr></table></figure><p>软件结构，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client app         handlers</span><br><span class="line">  stubs           dispatcher</span><br><span class="line"> RPC lib           RPC lib</span><br><span class="line">   net  ------------ net</span><br></pre></td></tr></table></figure><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><ul><li>组织数据：把数据封装为数据包。</li><li>Binding：client 如何知道应该向谁发送请求？<ul><li>要么在 client 提供 server 的 host name。</li><li>要么有一个 name service，提供 service names -&gt; best server host 的map。</li></ul></li></ul><h2 id="RPC错误处理"><a href="#RPC错误处理" class="headerlink" title="RPC错误处理"></a>RPC错误处理</h2><p>可能存在的错误，</p><ul><li>lost packet</li><li>broken network</li><li>slow server</li><li>crashed server</li></ul><p>client 观察到的错误可能有，</p><ul><li>client 无法接收到 server 的 response。</li><li>client 无法得知 server 是否接受到了 request。<ul><li>server根本就没有收到请求。</li><li>server执行调用了，但在发送响应前，server出错了。</li><li>server执行调用了，但是发送响应的时候，网络出问题了。</li></ul></li></ul><h2 id="RPC语义"><a href="#RPC语义" class="headerlink" title="RPC语义"></a>RPC语义</h2><h3 id="at-least-once（best-effort）"><a href="#at-least-once（best-effort）" class="headerlink" title="at least once（best effort）"></a>at least once（best effort）</h3><p>client 等待 server 的 response，没有响应 -&gt; 重新发送请求，尝试多次仍然没有 response，返回 error。<br>重新发送请求可能导致 server 重复执行操作。如果重复执行操作是不可接受的，那相关接口必须是幂等的。</p><h3 id="at-most-once"><a href="#at-most-once" class="headerlink" title="at most once"></a>at most once</h3><p>由server 检测重复的请求，返回重复请求先前的 reply，而非重复执行。</p><p>如何检测：client 的每个请求包含一个唯一的 ID，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">if seen[xid]:</span><br><span class="line">  r &#x3D; old[xid]</span><br><span class="line">else</span><br><span class="line">  r &#x3D; handler()</span><br><span class="line">  old[xid] &#x3D; r</span><br><span class="line">  seen[xid] &#x3D; true</span><br></pre></td></tr></table></figure><p>at most once的难点，</p><ul><li>如何保证 ID 唯一？尤其是分布式多个 client 的情况下。<ul><li>大随机数？</li><li>唯一的 client ID + request seq id？</li></ul></li><li>server 最终是需要丢弃老的 request 的结果的。何时丢弃是安全的？<ul><li>类似TCP sequence #s 和 acks 的方法。使用唯一的 client ID；每个 client 的 RPC 有一个 seq id；对于每个 RPC，client 包含了 seen all replies &lt;= X。</li><li>只允许 client 有一个未完成的 RPC。对于 seq + 1 的 request，server 可以丢弃所有 &lt;= seq。</li></ul></li><li>当上一个 request 还在运行的时候，如何处理重复的 request？<ul><li>此时 server 还无法查到 reply，但又不想重复执行。可以为每个正在执行的 RPC 加上 pending 标签，重复的 RPC 进行等待/忽略。</li></ul></li><li>如果 server 挂了或重启怎么办？<ul><li>如果有 memory 中的数据备份，那么 server 可以在重启后忽略并接受重复的请求。</li><li>数据冗余是否应该写入磁盘？</li><li>备份 server 是否也应该有这些数据的备份？</li></ul></li></ul><h3 id="exactly-once"><a href="#exactly-once" class="headerlink" title="exactly once"></a>exactly once</h3><p>at most once + 无限重试 + 容错服务。</p><h2 id="Lab-1-MapReduce"><a href="#Lab-1-MapReduce" class="headerlink" title="Lab 1: MapReduce"></a>Lab 1: MapReduce</h2><p>这次的实验仍然继续 Lab 1: MapReduce。完成单机版的 MapReduce 以后，还要实现分布式的 MapReduce（模拟），这里需要 RPC 库。</p><p>Go RPC 都提供了 at most once 的语义，换句话说，并不保证送达。如果 worker 没有响应，但实际上是在执行 task 的，那么 master 会重新调度新的 worker 来执行这个任务。</p><p>Lab 1: MapReduce 给出的代码已经提供了框架，下面分析了原始代码中，master 初始化，以及注册 worker 的过程，</p><p><img data-src="/images/2017/mapreduce_registration.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lectures&quot;&gt;&lt;a href=&quot;#Lectures&quot; class=&quot;headerlink&quot; title=&quot;Lectures&quot;&gt;&lt;/a&gt;Lectures&lt;/h1&gt;&lt;h2 id=&quot;Remote-Procedure-Call-RPC&quot;&gt;&lt;a href=&quot;#Remo</summary>
      
    
    
    
    <category term="distritubed system" scheme="https://chaomai.github.io/categories/distritubed-system/"/>
    
    
    <category term="6.824" scheme="https://chaomai.github.io/tags/6-824/"/>
    
    <category term="rpc" scheme="https://chaomai.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Awk关键点记录</title>
    <link href="https://chaomai.github.io/2017/2017-04-12-Awk-Key-Points/"/>
    <id>https://chaomai.github.io/2017/2017-04-12-Awk-Key-Points/</id>
    <published>2017-04-12T05:54:34.000Z</published>
    <updated>2021-06-27T14:57:29.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h1><p>一个变量名就是一个合法的表达式。awk 的变量被默认初始化为空 string，当转换为数字时，是0，因此不需要显式初始化变量。</p><p>在为 awk 指定参数时，可以定义变量并赋值，<code>-v variable=text</code>，这样的变量在 <code>BEGIN</code> 之前就被定义，可以在 <code>BEGIN</code> 中使用。但 <code>-v</code> 必须先于文件名参数和程序文本。</p><p>如果在程序文本之后，<code>awk &#39;&#123; print $n &#125;&#39; n=4 inventory-shipped n=2 mail-list</code>，那么变量n会在读取每条记录时被赋值，会先打印文件 <code>inventory-shipped</code> 第四列的内容，然后打印文件 <code>mail-list</code> 第二列中的内容。</p><h2 id="Predefined-Variables"><a href="#Predefined-Variables" class="headerlink" title="Predefined Variables"></a>Predefined Variables</h2><p>少数变量是有特殊含义的，它们是 predefined variables。这些变量，要么被 awk 自动检查（User-modified），要么被自动设置（Auto-set）。</p><h3 id="User-modified"><a href="#User-modified" class="headerlink" title="User-modified"></a>User-modified</h3><ul><li>CONVFMT：控制数字到 string 转换。</li><li>FS：列分隔符，值为一个字符或匹配多个字符的正则表达式。 默认是 <code>&quot; &quot;</code>，会匹配任何 <code>\&quot; &quot;, \t, \n</code>。同时会使得每条记录开头和结尾的 <code>&quot; &quot;, \t, \n</code> 被忽略。</li><li>OFS：输出文件列分隔符。</li><li>ORS：输出文件记录分隔符（行尾）。</li><li>RS：输入文件记录分隔符（行尾）。</li><li>SUBSEP：下标分隔符，默认是 <code>\034</code>。</li></ul><h3 id="Auto-set"><a href="#Auto-set" class="headerlink" title="Auto-set"></a>Auto-set</h3><ul><li>ARGC, ARGV：awk 参数信息，ARGV 的起始下标为0。程序文本不会被包含到这两个变量中。</li><li>ENVIRON：关联数组，包含了 environment 的值。</li><li>FILENAME：当前输入文件的文件名。 未设置输入文件（stdin输入）时，值为 <code>&quot;-&quot;</code>；在BEGIN中时，值为 <code>&quot;&quot;</code>。</li><li>FNR：当前文件的行号，在每次打开新文件时被重置为0。</li><li>NF：当前记录的列数。在每读取一个新纪录的时候，或者 <code>$0</code> 改变的时候，被重置。</li><li>NR：已处理的行数。</li><li>RLENGTH：被 <code>match()</code> 匹配后，substring 的长度，没有匹配值为-1。</li><li>RSTART：被 <code>match()</code> 匹配后，substring 的起始位置，没有匹配值为0。</li></ul><h1 id="Pattern-Elements"><a href="#Pattern-Elements" class="headerlink" title="Pattern Elements"></a>Pattern Elements</h1><h2 id="Regexp-Patterns"><a href="#Regexp-Patterns" class="headerlink" title="Regexp Patterns"></a>Regexp Patterns</h2><p>awk 中正则表达式的形式为<code>/regexp/</code>。</p><h2 id="Expression-Patterns"><a href="#Expression-Patterns" class="headerlink" title="Expression Patterns"></a>Expression Patterns</h2><p>awk 表达式都可作为一个 pattern，如果表达式的值非空或非零，那么就是匹配上了。常见的是由比较运算符构成的，</p><ul><li><p><code>awk &#39;$1 == &quot;li&quot; &#123; print $2 &#125;&#39; mail-list</code><br>  用于直接比较 string 的操作符除了 <code>==</code>，还可以是<code>&lt;, &lt;=, &gt;, &gt;=, ==, !=</code>。以及判断array中是否有以subscript为下表的元素，subscript in array。</p></li><li><p><code>awk &#39;$1 ~ /li/ &#123; print $2 &#125;&#39; mail-list</code><br>  用于判断特定的 string 是否 match 正则表达式，需要用 <code>~, !~</code> 连接左右操作数。</p></li><li><p><code>awk &#39;/edu/ &amp;&amp; /li/&#39; mail-list</code><br>  也可以用布尔操作符连接正则表达式、由比较运算符构成的表达式，以及任何其他的 awk 表达式。</p></li></ul><h2 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h2><p>range pattern 由逗号分隔的两 个pattern 构成，<code>begpat, endpat</code>，用于匹配连续的记录。 当遇到匹配 <code>begpat</code> 的记录时，开始匹配包括这条记录在内的所有后续记录，直到遇到匹配 <code>endpat</code> 的记录时，停止匹配，然后开始下一轮。如果有某条记录使得两个 pattern 都为 true，那么只匹配一次，并开始下一轮。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file:</span><br><span class="line">awefawef</span><br><span class="line">aweawef%</span><br><span class="line">awefawfe</span><br><span class="line">aweawef%</span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;/%$/,/%$/ &#123;print&#125;&#x27;</span> test</span><br><span class="line">aweawef%</span><br></pre></td></tr></table></figure><h2 id="BEGIN-END"><a href="#BEGIN-END" class="headerlink" title="BEGIN/END"></a><code>BEGIN/END</code></h2><p>前面的几个 pattern 都是会匹配输入的，<code>BEGIN/END</code> 是特殊的 pattern，不会匹配（因为在它们执行的时候还没有记录，或者已经没有记录存在了），它们指定了 awk 程序起始和结束时的 action，都只会执行一次。</p><p>如果存在多个 <code>BEGIN/END</code>，那么按定义的顺序执行。 当仅有 <code>BEGIN</code>，执行完 <code>BEGIN</code> 后，程序结束；当仅有 <code>END</code>，程序会读取输入，然后执行 <code>END</code>。</p><h1 id="常用awk程序"><a href="#常用awk程序" class="headerlink" title="常用awk程序"></a>常用awk程序</h1><p>下面是我常用到的，或者看到觉得不错的awk程序。</p><h2 id="以某个字符串为key，统计对应的value总和"><a href="#以某个字符串为key，统计对应的value总和" class="headerlink" title="以某个字符串为key，统计对应的value总和"></a>以某个字符串为key，统计对应的value总和</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;a[$4&quot;\t&quot;$5&quot;\t&quot;$2]+=$3&#125; END &#123;for (x in a) print x&quot;\t&quot;a[x]&#125;&#x27;</span> <span class="variable">$geo_file_ret</span> | sort -k <span class="number">4</span> -n -r &gt; <span class="variable">$1</span></span><br></pre></td></tr></table></figure><h2 id="打印非空行"><a href="#打印非空行" class="headerlink" title="打印非空行"></a>打印非空行</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NF&#x27;</span></span><br></pre></td></tr></table></figure><p>因为 <code>NF</code> 是当前输入的列数，非空行的列数大于0。当条件为真，且没有其他的 action 时，awk执行默认操作，打印一行。扩展来说，可以只提供表达式，作为条件，表达式为真则打印响应行。</p><p>类似的，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;!a[$0]++&#x27;</span></span><br></pre></td></tr></table></figure><p><code>a</code> 是数组，每个元素被初始化为0，<code>$0</code> 作为索引。首次遇到的行，<code>++</code> 对以 <code>$0</code> 为下标的元素加1，后缀 <code>++</code> 返回原始值0，取反后为真，打印。后续如果再遇到相同的，可以取到一个非0的值，取反为false，不打印。因此实际上是去除了重复的行。</p><p>以及，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq <span class="number">1</span> <span class="number">30</span> | awk <span class="string">&#x27;ORS=NR%5?FS:RS&#x27;</span></span><br></pre></td></tr></table></figure><p>默认情况下，ORS是一个换行符 <code>&quot;\n\&quot;</code>。这里根据，已处理行数是否是5的倍数，为ORS赋值FS或RS，默认即，<code>&quot; &quot; or &quot;\n&quot;</code>。它们的值都不为0，作为条件都是true。因此每一行都会打印，只是被打印行的行为分隔符是FS或RS。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">6 7 8 9 10</span><br><span class="line">11 12 13 14 15</span><br><span class="line">16 17 18 19 20</span><br><span class="line">21 22 23 24 25</span><br><span class="line">26 27 28 29 30</span><br></pre></td></tr></table></figure><h2 id="替换分隔符"><a href="#替换分隔符" class="headerlink" title="替换分隔符"></a>替换分隔符</h2><p>在没有修改的情况下，awk 并不会重新 build <code>$0</code>，原因之一是，为了性能；二是，对于 <code>echo &#39;foo;bar&#39; | awk -v FS=&#39;;&#39; -v OFS=&#39;,&#39; &#39;/foo/&#39;</code>，如果真的替换了，那 <code>foo,bar</code> 并不是期望匹配到的 <code>foo;bar</code>。 因此，不同于上面的 ORS，这里直接指定 FS 以及 OFS 是没有用的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -v FS=<span class="string">&#x27;;&#x27;</span> -v OFS=<span class="string">&#x27;,&#x27;</span> <span class="string">&#x27;&#123;$1=$1&#125;1&#x27;</span></span><br></pre></td></tr></table></figure><p>这里的确修改了 <code>$0</code>，但内容没有变，因此会替换FS。如果没有空行，可以把1去除。</p><h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><p>利用 awk 中变量被初始化为空 string 或0这一点，可以方便的连接字符串</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string = string sep somedata; sep = <span class="string">&quot;;&quot;</span></span><br></pre></td></tr></table></figure><p>避免开头出现多余的 <code>&quot;;&quot;</code>。</p><h2 id="处理两个文件"><a href="#处理两个文件" class="headerlink" title="处理两个文件"></a>处理两个文件</h2><p>当处理两个文件时，awk 按命令中指定的顺序，顺序读取每个文件。当读取第一个文件时，<code>NR == FNR</code>总为true。 基于这点，有一个常用的写法，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR == FNR &#123; # some actions; next&#125; # other condition &#123;# other actions&#125;&#x27;</span> file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>常用的场景比如，</p><ul><li>两文件的交集，<code>awk &#39;NR == FNR&#123;a[$0];next&#125; $0 in a&#39; file1.txt file2.txt</code></li><li>两文件的差集（仅在第一个文件里出现），<code>awk &#39;NR == FNR&#123;a[$0];next&#125; $0 in a&#39; file1.txt file2.txt</code></li><li>基于某一列，join两文件，<code>awk &#39;NR == FNR&#123;a[$1]=$2;next&#125; &#123;$3=a[$3]&#125;1&#39; map.txt data.txt</code></li></ul><p>不过这个写法，仅适用于第一个文件非空的情况，如果为空，会直接用 <code>NR == FNR &#123; # some actions; next&#125;</code> 处理第二个文件，可以检测FILENAME是否等于ARGV[1]。</p><h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><ul><li><a href="http://coolshell.cn/articles/9070.html">http://coolshell.cn/articles/9070.html</a></li><li><a href="http://www.gnu.org/software/gawk/manual/gawk.html">http://www.gnu.org/software/gawk/manual/gawk.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Variables&quot;&gt;&lt;a href=&quot;#Variables&quot; class=&quot;headerlink&quot; title=&quot;Variables&quot;&gt;&lt;/a&gt;Variables&lt;/h1&gt;&lt;p&gt;一个变量名就是一个合法的表达式。awk 的变量被默认初始化为空 string，当转换</summary>
      
    
    
    
    <category term="linux" scheme="https://chaomai.github.io/categories/linux/"/>
    
    
    <category term="awk" scheme="https://chaomai.github.io/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Hive笔记</title>
    <link href="https://chaomai.github.io/2017/2017-04-10-Notes-of-Hive/"/>
    <id>https://chaomai.github.io/2017/2017-04-10-Notes-of-Hive/</id>
    <published>2017-04-10T09:39:19.000Z</published>
    <updated>2021-06-27T14:57:29.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cluster-by-vs-order-by-vs-sort-by"><a href="#cluster-by-vs-order-by-vs-sort-by" class="headerlink" title="cluster by vs order by vs sort by"></a>cluster by vs order by vs sort by</h1><ul><li><p>ORDER BY x: guarantees global ordering, but does this by pushing all data through just one reducer. This is basically unacceptable for large datasets. You end up one sorted file as output.</p></li><li><p>SORT BY x: orders data at each of N reducers, but each reducer can receive overlapping ranges of data. You end up with N or more sorted files with overlapping ranges.</p></li><li><p>DISTRIBUTE BY x: ensures each of N reducers gets non-overlapping ranges of x, but doesn’t sort the output of each reducer. You end up with N or unsorted files with non-overlapping ranges.</p></li><li><p>CLUSTER BY x: ensures each of N reducers gets non-overlapping ranges, then sorts by those ranges at the reducers. This gives you global ordering, and is the same as doing (DISTRIBUTE BY x and SORT BY x). You end up with N or more sorted files with non-overlapping ranges.</p></li></ul><h1 id="Hive-NULL处理"><a href="#Hive-NULL处理" class="headerlink" title="Hive NULL处理"></a>Hive NULL处理</h1><p>默认情况下，每行数据在被输入script前，列会被转换为 <code>\t</code> 分隔的string，所有 <code>NULL</code> 值会被转换为字符串 <code>\N</code>，目的是为了与空string（长度为0）区分开。script输出一行数据时，标准输出会将输出是为 <code>\t</code> 分隔的列，同时 <code>\N</code> 被转换为 <code>NULL</code>。</p><p>因此Hive的空值处理分为：</p><ul><li><p><code>NULL</code> 和 <code>\N</code></p><p>  HIVE底层是用\N代替NULL进行保存的，可以通过<code>alter table name SET SERDEPROPERTIES(&#39;serialization.null.format&#39; = &#39;\N&#39;);</code> 来更改底层以什么样的字符来存储NULL。</p><p>  查询空值字段可用：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a is null 或 a &#x3D; &#39;\\N&#39;</span><br></pre></td></tr></table></figure><p>  相应的在script在判断是否为 <code>NULL</code> 时，是需要判断<code>!= &#39;\N&#39;</code>。</p></li><li><p>空string</p><p>  <code>&#39;&#39;</code> 表示长度为0的 string，但此时字段并非为 <code>NULL</code>，而是一个长度为0的 string。</p><p>  查询空string可用：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#39;&#39; 或 length(a)&#x3D;0</span><br></pre></td></tr></table></figure><p>  在使用outer join的时候尤其要注意以上区别，要想清楚究竟是要判断字段为 <code>NULL</code>，还是判断string为空。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select case when t.idfa !&#x3D; &#39;&#39; and t.idfa !&#x3D; null then t.idfa end from (select &#39;B5BF3011-A8A0-46A2-B8C3-0A1976FDD4BE&#39; as idfa) as t;</span><br><span class="line">select case when t.idfa !&#x3D; &#39;&#39; and t.idfa !&#x3D; NULL then t.idfa end from (select &#39;B5BF3011-A8A0-46A2-B8C3-0A1976FDD4BE&#39; as idfa) as t;</span><br><span class="line">select case when t.idfamd5 !&#x3D; null then &#39;1&#39; else &#39;2&#39; end from (select &#39;\N&#39; as idfamd5) as t;</span><br><span class="line">select case when t.idfamd5 !&#x3D; null then &#39;1&#39; else &#39;2&#39; end from (select NULL as idfamd5) as t;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Insert-into-bucketed-table"><a href="#Insert-into-bucketed-table" class="headerlink" title="Insert into bucketed table"></a>Insert into bucketed table</h1><p>Hive 2.x之前，向分桶表中插入数据时，需要（二者之一），</p><ul><li><p>方法1：<code>set hive.enforce.bucketing = true</code></p></li><li><p>方法2：</p><ol><li>设置reducer数目，<code>set mapred.reduce.tasks</code>，使其等于bucket的数目</li><li>在select中使用，<code>cluster by</code></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cluster-by-vs-order-by-vs-sort-by&quot;&gt;&lt;a href=&quot;#cluster-by-vs-order-by-vs-sort-by&quot; class=&quot;headerlink&quot; title=&quot;cluster by vs order by vs </summary>
      
    
    
    
    <category term="hive" scheme="https://chaomai.github.io/categories/hive/"/>
    
    
    <category term="hive" scheme="https://chaomai.github.io/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>6.824 - Spring 2017 Lecture 1 Introduction</title>
    <link href="https://chaomai.github.io/2017/2017-04-02-6.824-Spring-2017-Lecture-1/"/>
    <id>https://chaomai.github.io/2017/2017-04-02-6.824-Spring-2017-Lecture-1/</id>
    <published>2017-04-02T07:18:30.000Z</published>
    <updated>2021-06-27T14:57:29.271Z</updated>
    
    <content type="html"><![CDATA[<p>最近看 mit-6.824，每个 lecture 会做一次笔记，每个笔记基本都分为，</p><ul><li>Readings：课前阅读的论文</li><li>Lecture：讲义</li><li>Lab：实验</li></ul><h1 id="Readings"><a href="#Readings" class="headerlink" title="Readings"></a>Readings</h1><h2 id="MapReduce-Simplified-Data-Processing-on-Large-Clusters论文"><a href="#MapReduce-Simplified-Data-Processing-on-Large-Clusters论文" class="headerlink" title="MapReduce: Simplified Data Processing on Large Clusters论文"></a>MapReduce: Simplified Data Processing on Large Clusters论文</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>map task运行时，</p><ul><li>定期将生成的kv pair写入本地磁盘，并被parition函数分为R个分区。</li><li>这些在磁盘上的pair的位置会被返回给master，master进而把这些位置发给reduce task。</li></ul><p>reduce task运行时，</p><ul><li>使用RPC读取map task缓存到磁盘的数据。</li><li>当reduce worker读取到所有数据时，按临时key对数据排序。因为多个intermediate key可能会由同一个Reducer处理，因此需要排序使得相同的key在一起。</li><li>reduce worker遍历已排序的中间数据，将key和中间value传给用户定义的reduce函数。</li></ul><h4 id="master数据结构"><a href="#master数据结构" class="headerlink" title="master数据结构"></a>master数据结构</h4><ul><li>对于每个map task和reduce task，master保存了任务状态（idle, in-progress, or completed），以及每个worker机器的身份。</li><li>对于每个已完成的map task，master保存了R个分区的中间数据文件的位置和大小，每当一个map task完成，中间数据文件的位置和大小就被更新。这些信息以增量的形式，发送给有正在运行reduce task任务的机器。</li></ul><h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><p>由于长时间未响应master的ping，worker故障，</p><ul><li>正在运行的map task或reduce task重置为idle-&gt;重跑。</li><li>已完成的map task重置为idle-&gt;重跑，因为map task生成的中间数据是本地存储的。</li><li>已完成的reduce task无需重跑，因为输出已经保存到GFS。</li></ul><p>当一个map task先被worker A执行，接着又被B执行（worker A失败），这次重跑会被通知到所有执行reduce task的机器。任何还没有从A读取数据的reduce task，都转而向B读取。</p><p>master故障，</p><ul><li>定期保存master数据结构的checkpoint。</li></ul><p>semantics in the presence of failures，</p><ul><li><p>当用户提供的 map 和 reduce 操作的执行结果是确定的，那么分布式的实现也会产生相同的执行结果，这个结果与整个程序顺序执行产生的结果一致。这依赖于，map task 和 reduce task 输出的原子提交。每个正在执行的任务都会把输出写到临时文件。当某个map task完成时，worker向master发送包含有R个临时文件列表的消息。如果master已经收到了这个任务完成的消息，那么本条就会被忽略。而对于 reduce task，输出到GFS的时候，GFS保证了原子性。</p></li><li><p>当 map 和 reduce 的执行结果是不确定的，那么最终结果也是不确定的，每个 reduce 任务的执行结果都不同的不确定的串行执行的结果。</p></li></ul><h4 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h4><p>GFS 将文件分为 64MB 的块，并在不同机器上冗余存储。Master 可以利用文件的位置信息，在包含这个副本的机器上调度 map 任务。如果无法进行上述调度，那么就近调度（例如：同一个交换机下的 worker）。</p><h4 id="任务粒度"><a href="#任务粒度" class="headerlink" title="任务粒度"></a>任务粒度</h4><p>MapReduce 把 map 任务和 reduce 任务分别分为 M 份和 R 份，理想情况下，M 和 R 应该远大于机器数目，这样有利于提高动态负载均衡和加速（当某个 worker 挂了情况下的）错误恢复：这个挂了的 worker 所执行的任务可以被重新调度到其他 worker 上进行。</p><p>实现时，master 需要进行 <code>O(M + R)</code> 次调度，需要 <code>O(M * R)</code> 状态跟踪 map 产生的临时文件位置（每个 map 产生 R 个临时文件），每个 map/reduce pair 需要一个 byte。</p><p>通常 R 的数量是由用户指定的，实际应用中对 M 的划分是要保证一个分片的数据量大小大约是 16-64M，R 的期望是一个比较小的数。</p><h4 id="任务备份"><a href="#任务备份" class="headerlink" title="任务备份"></a>任务备份</h4><p>一个导致任务执行总时间大大延长的重要原因是存在“拖后腿的任务”，这些执行缓慢的任务可能由多种原因导致。一个通用的解决方案是，当一个 MapReduce 任务将要执行完成时，master 调度一个备份执行。当主任务（原始的）或备份执行的其中之一完成时，这个任务被标记完成。这个方法在消耗少许额外资源的情况下，大大减少了总执行时间。</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>提升效率的方法。</p><h4 id="Partitioning-函数"><a href="#Partitioning-函数" class="headerlink" title="Partitioning 函数"></a>Partitioning 函数</h4><p>用户指定 reducer 的数目为 R，map 的中间结果按照 partitioning 函数对临时 key 的计算结果分成了 R 个部分。一般来说，默认的 partitioning 函数是足够的，但也可以自己提供 partitioning 函数来实现特定的 partition 目标。</p><h4 id="保证顺序"><a href="#保证顺序" class="headerlink" title="保证顺序"></a>保证顺序</h4><p>每个 partition 的 kv 是按照临时 key 升序的顺序处理的。这保证了，</p><ul><li>每个 reduce 产生的结果是有序的。</li><li>利于按 key 的随机访问。</li><li>用户觉得有序的结果方便。</li></ul><h4 id="Combiner-函数"><a href="#Combiner-函数" class="headerlink" title="Combiner 函数"></a>Combiner 函数</h4><p>当，</p><ul><li>每个 map 任务会产生大量重复的临时 key，</li><li>用户提供的 reduce 函数是可交换和可结合的，</li></ul><p>可以在 map 任务结束以后，使用 combiner 对 map 任务的结果进行部分合并，减少网络传输的开销。</p><h4 id="输入输出类型"><a href="#输入输出类型" class="headerlink" title="输入输出类型"></a>输入输出类型</h4><p>MapReduce 提供了读写多种文件格式的支持，用户也可以通过实现相应接口来自定义读写其他格式文件。</p><h4 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h4><p>MapReduce 允许 map 或 reduce 生成辅助的输出文件，其原子性依赖于应用的实现。</p><h4 id="跳过-Bad-Records"><a href="#跳过-Bad-Records" class="headerlink" title="跳过 Bad Records"></a>跳过 Bad Records</h4><p>某些特定的数据会让含有 bug 的 map 或 reduce 函数崩溃，有时无法修复这些 bug，且忽略这些数据是可接受的，那么可以使用 MapReduce 提供的机制来忽略。</p><p>每个 worker 都会监控 segmentation violations 和 bus errors，如果崩溃，发送记录 -&gt; master，如果 master 发现某条记录失败次数大于 1，那么下次执行时就会跳过这条记录。</p><h4 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h4><p>分布式环境下，debug 一个 map 或 reduce 函数是困难的。MapReduce 库允许在本地执行任务，便于调试。</p><h4 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h4><p>master 会运行一个内部的 HTTP 服务器，展示状态信息。</p><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>MapReduce 库提供了一个计数器来统计事件发生的次数。worker 响应 master 的 ping 时，计数器的值就被放在 pong 中，发送到 master。master 聚合计数器的值，并在 map 和 reduce 任务结束后返回给用户。当聚合时，重复执行任务的计数器只会被统计一次。有的计数器值是由 MapReduce 库直接维护的。</p><h1 id="Lectures"><a href="#Lectures" class="headerlink" title="Lectures"></a>Lectures</h1><h2 id="Distributed-System"><a href="#Distributed-System" class="headerlink" title="Distributed System"></a>Distributed System</h2><p>分布式系统提供了app使用的基础设施，通过抽象隐藏了实现的细节，这些抽象包括：</p><ul><li>存储（storage）</li><li>通信（communication）</li><li>计算（computation）</li></ul><p>在讨论分布式系统时，下面几个话题会时常出现：</p><ul><li><p>实现<br>  RPC，线程，并发控制。</p></li><li><p>性能</p><ul><li>理想情况：可扩展的吞吐量。N倍的服务器数量-&gt;（通过并行的CPU，磁盘，网络实现）N倍的吞吐量。因此为了处理更多的负载，只需要添加更多的机器。</li><li>可扩展性随着N增加而变得困难：<ul><li>负载不均衡（Load im-blance），集群里有慢的机器（stragglers）。</li><li>不可并行的代码：初始化，交互</li><li>共享资源的瓶颈：网络</li></ul></li></ul></li><li><p>容错</p><ul><li>大集群，复杂的网络-&gt;总会有出问题的地方</li><li>希望能够隐藏这些错误，使得错误对app不可见<ul><li>可用性（Availability）：在出错的情况下，app能继续使用数据。</li><li>持久性（Durability）：修复错误后，app能够继续正常工作。</li></ul></li><li>big idea：多个服务器。如果一个server crash，client能继续使用其他的。</li></ul></li><li><p>一致性（consistency）</p><ul><li>通用目的的架构需要有良好定义的行为。<ul><li>例如：<code>get(k)</code>应该返回最近的<code>put(k, v)</code>。</li></ul></li><li>实现良好定义的行为是困难的。<ul><li>难以保证多个服务器一致。</li><li>在含有多个操作的更新中，客户端执行到一半可能crash了。</li><li>服务器在尴尬的时刻崩溃，例如：执行了操作但没有返回结果。</li><li>由于网络问题，服务器看起来好像挂了。</li></ul></li><li>一致性和性能是冲突的。<ul><li>实现一致性需要通信。</li><li>“强一致性”常常导致系统性能低下。</li><li>高性能通常会对app造成“弱一致性”。</li></ul></li><li>开发者在这个范围内追求了很多设计点（People have pursued many design points in this spectrum）。</li></ul></li></ul><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><h3 id="MapReduce概述"><a href="#MapReduce概述" class="headerlink" title="MapReduce概述"></a>MapReduce概述</h3><ul><li>上下文：对海量数据进行多个小时的运算。</li><li>总目标：普通程序员能够在保证合理的效率的情况下，轻松的将数据处理切分到多个服务器。</li><li>需要定义Map和Reduce函数，非并发的代码，且常常是很简单的。</li><li>MR运行在集群上，处理海量数据，隐藏分布式的细节。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input is divided into M files</span><br><span class="line">Input1 -&gt; Map -&gt; a,1 b,1 c,1</span><br><span class="line">Input2 -&gt; Map -&gt;     b,1</span><br><span class="line">Input3 -&gt; Map -&gt; a,1     c,1</span><br><span class="line">                  |   |   |</span><br><span class="line">                  |   |   -&gt; Reduce -&gt; c,2</span><br><span class="line">                  |   -----&gt; Reduce -&gt; b,2</span><br><span class="line">                  ---------&gt; Reduce -&gt; a,2</span><br></pre></td></tr></table></figure><ul><li><code>MR</code>对每个输入文件调用<code>Map()</code>，生成<code>&lt;k2, v2&gt;</code>（中间数据）的集合</li><li><code>MR</code>收集每个<code>k2</code>对应的所有<code>v2</code>，并输入给Reduce调用</li><li>最后从<code>Reduce（）</code>输出<code>&lt;k2, v3&gt;</code>的集合</li></ul><h3 id="MapReduce隐藏了很多痛苦的细节"><a href="#MapReduce隐藏了很多痛苦的细节" class="headerlink" title="MapReduce隐藏了很多痛苦的细节"></a>MapReduce隐藏了很多痛苦的细节</h3><ul><li>在服务器上启动s/w</li><li>跟踪已结束的任务</li><li>数据移动</li><li>错误恢复</li></ul><h3 id="MapReduce有很好的可扩展性"><a href="#MapReduce有很好的可扩展性" class="headerlink" title="MapReduce有很好的可扩展性"></a>MapReduce有很好的可扩展性</h3><p>N台机器-&gt;N倍吞吐量。假设M和R都&gt;=R（大量的输入文件和map输出的key）。由于<code>Map()</code>之间无交互，可以并行执行，<code>Reduce()</code>也是，都能够并行执行，因此可以通过添加机器来增加吞吐量。</p><h3 id="性能受限的潜在因素"><a href="#性能受限的潜在因素" class="headerlink" title="性能受限的潜在因素"></a>性能受限的潜在因素</h3><p>网络。在Map-&gt;Reduce的shuffle时，所有数据都需要通过网络传输，因此减少通过网络来移动的数据是关键。</p><h3 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h3><ul><li>mater：为worker分配任务，记录中间输出的位置。</li><li>M Map tasks, R Reduce tasks。</li><li>输入存储在GFS，3份冗余。</li><li>集群所有机器都运行GFS和MR worker。</li><li>input task比workder数量更多。</li><li>mater为每个worker分配Map task，在旧任务结束时分发新任务。</li><li>Map worker在本地磁盘将中间key hash到R个partition</li><li>只有当所有Map结束后，本地的Reduce调用才会开始。</li><li>mater告诉Reducer从Map worker获取中间数据partition（intermediate data partitions）。</li><li>Reduce workers将最终结果写入GFS（一个文件对应一个Reduce task）。</li></ul><h3 id="设计细节：减少低速网络的影响"><a href="#设计细节：减少低速网络的影响" class="headerlink" title="设计细节：减少低速网络的影响"></a>设计细节：减少低速网络的影响</h3><ul><li>Map从本地磁盘读入GFS上的数据副本（replica），而不是从网络。</li><li>中间数据仅仅在网络中传输一次。Map worker将数据写入本地磁盘，而不是GFS。</li><li>中间数据被partition到包含很多key的文件。大网络中的传输更加高效。</li></ul><h3 id="如何实现良好的load-balance？"><a href="#如何实现良好的load-balance？" class="headerlink" title="如何实现良好的load balance？"></a>如何实现良好的load balance？</h3><p>load balance对于可扩展性很重要，N-1个server都等待1个server结束是不好的。但是有的任务就是会比其他花费更长的时间。</p><p>解决方案：任务数比worker数更多。<br>master为已完成当前任务的worker分配新的任务。一般来说，就不会有大任务占据主要的计算时间。那么快的server会比慢的server完成更多的任务，最终同时完成所有任务。</p><h3 id="如何实现容错？"><a href="#如何实现容错？" class="headerlink" title="如何实现容错？"></a>如何实现容错？</h3><p>如果某个server在执行MR任务期间crash怎么办？<br>不是重启整个job，MR只重新运行失败的<code>Map()</code>和<code>Reduce()</code>。这两个操作必须是纯函数：</p><ul><li>不保留调用之间的状态。</li><li>不读取和写入除了MR输入/输入的文件。</li><li>任务之间没有隐藏的通信。</li></ul><p>因此重新执行会生成相同的结果。纯函数的要求是MR相比于其他并发编程模型的主要局限，当它也是MR简洁的关键。</p><h3 id="crash-recovery的细节"><a href="#crash-recovery的细节" class="headerlink" title="crash recovery的细节"></a>crash recovery的细节</h3><ul><li>Map worker crashes：<ul><li>master观察到worker再也不响应ping。</li><li>crash的worker的中间Map输出丢失，但这个数据有可能每个Reduce任务都需要。</li><li>master根据GFS上输入数据的其他副本来分配任务，并重新执行。</li><li>某些Reduce worker可能已经读取了crash的worker生成的中间数据。此时就需要依赖于<code>Map()</code>的纯函数特性和确定性。</li><li>如果Reduce获取到了所有的中间数据，那么master就不需要重新运行Map。然后接下来的一个Reduce会crash，进而导致强制重跑失败的Map。</li></ul></li><li>Reduce worker crashes：<ul><li>已结束的任务不受影响，数据以冗余的形式存储在GFS。</li><li>master重新执行其他worker上未完成的任务。</li></ul></li><li>Reduce worker在写入输出数据期间crash：<ul><li>GFS的rename是atomic的，在写入完成前数据不可见。因此master可以安全的在其他地方重跑Reduce任务。</li></ul></li></ul><h3 id="其他错误和问题"><a href="#其他错误和问题" class="headerlink" title="其他错误和问题"></a>其他错误和问题</h3><ul><li>master给两个worker分配了相同的<code>Map()</code>任务怎么办？<br>  原因可能是master错误的认为worker挂了。master只会将其中一个告诉给Reduce worker。</li><li>master给两个worker分配了相同的<code>Reduce()</code>任务怎么办？<br>  两个都会尝试在GFS中写入相同的文件。GFS rename的atomic性质避免了结果是两者的混合，只有一个完整的文件可见。而<code>Reduce()</code>的纯函数特性使得两次输出的文件是一样的。</li><li>如果某个worker很慢怎么办？<br>  原因可能是硬件问题。master重新运行最后几个任务。</li><li>如果worker由于h/w或s/w问题计算出了错误的输出怎么办？<br>  ╮(╯_╰)╭，MR假设CPU和software是“<a href="https://github.com/chaomai/mit-6.824/blob/master/docs/LEC%201/FailStop.pdf">fail-stop</a>”的。</li><li>如果master crash了怎么办？<ul><li>从check-point恢复。</li><li>放弃执行任务。</li><li>使用多个master，一个可用，剩余standby。</li></ul></li></ul><h3 id="什么样的app不适用于MapReduce？"><a href="#什么样的app不适用于MapReduce？" class="headerlink" title="什么样的app不适用于MapReduce？"></a>什么样的app不适用于MapReduce？</h3><ul><li>不是所有app都适用于map/shuffle/reduce模式。</li><li>小数据量，因为开销很高。例如：网站的后端。</li><li>对海量数据的小更新。例如：为一个大索引添加小文件。</li><li>随机读写，因为Map和Reduce都不能选择输入数据。</li><li>多次shuffle，例如：page-rank。可以使用多个MR来实现，但是不高效。</li><li>更灵活的系统可以实现上述目标，但会导致更复杂的模型。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>MapReduce让集群计算受欢迎。</p><ul><li>不是最高效和灵活的。</li><li>可扩展性良好。</li><li>易于编程，错误和数据移动被隐藏了。</li></ul><p>这些在实践中是很好的权衡。</p><h2 id="Lab-1-MapReduce"><a href="#Lab-1-MapReduce" class="headerlink" title="Lab 1: MapReduce"></a>Lab 1: MapReduce</h2><ul><li>实验给出了框架代码，需要完成关键函数。</li><li>MapReduce的分布式实现除了需要关注task，还需要考虑存储，分布式存储不是这里的重点，因此实验在一台机器上运行worker thread，使用系统的文件系统模拟分布式存储。</li><li>实验要求实现两种模式的MR，顺序执行所有task，以及分别并行执行map和reduce task。实验给出了的框架代码使用了go的channel来实现并行执行task。而对于顺序执行task的实现，实际上是分别把所有map和reduce task做了一次封装，得到“一个map task”和“一个reduce task”，分别执行封装好的“map task”和“reduce task”，其中每个实际的map和reduce都是顺序执行的。</li><li>lab的代码在<a href="https://github.com/chaomai/mit-6.824/tree/master/src/mapreduce">github.com/chaomai/mit-6.824</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近看 mit-6.824，每个 lecture 会做一次笔记，每个笔记基本都分为，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Readings：课前阅读的论文&lt;/li&gt;
&lt;li&gt;Lecture：讲义&lt;/li&gt;
&lt;li&gt;Lab：实验&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Readings&quot;</summary>
      
    
    
    
    <category term="distritubed system" scheme="https://chaomai.github.io/categories/distritubed-system/"/>
    
    
    <category term="6.824" scheme="https://chaomai.github.io/tags/6-824/"/>
    
    <category term="mapreduce" scheme="https://chaomai.github.io/tags/mapreduce/"/>
    
  </entry>
  
  <entry>
    <title>Python Generator and Coroutine 1</title>
    <link href="https://chaomai.github.io/2017/2017-01-16-python-generator-and-coroutine-1/"/>
    <id>https://chaomai.github.io/2017/2017-01-16-python-generator-and-coroutine-1/</id>
    <published>2017-01-16T07:29:30.000Z</published>
    <updated>2021-06-27T14:57:29.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Generator（生成器）"><a href="#Generator（生成器）" class="headerlink" title="Generator（生成器）"></a>Generator（生成器）</h1><p>在Python中，说到generator，就不得不提iterator和iterable，下面这张图来自<a href="http://nvie.com/posts/iterators-vs-generators/">Iterables vs. Iterators vs. Generators</a>，这里做个简单的说明（文章很好的解释了这三者的关系与区别）。</p><p><img data-src="/images/2017/14839555031473.jpg"></p><ul><li>Container：是一个把元素组织在一起的数据结构，可以判断元素是否包含在容器当中。（大多数）容器提供了一种能够得到他们包含的每个元素的方法，这使得这些容器是iterable（可迭代对象）。</li><li>Iterable：iterable是任何一个可以返回iterator的对象（不限于容器）。</li><li>Iterator：带状态的对象，当对这个对象调用<code>next()</code>时，可以产生下一个值。任何有<code>__next__()</code>方法的对象都是一个iterator。Iterator就像一个lazy factory，当需要时，才产生一个值返回。</li></ul><p>下面是一个iterator的例子，与此同时也是一个iterable，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.prev = <span class="number">0</span></span><br><span class="line">        self.curr = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        value = self.curr</span><br><span class="line">        self.curr += self.prev</span><br><span class="line">        self.prev = value</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>下面着重要说的是<a href="http://stackoverflow.com/questions/231767/what-is-the-function-of-the-yield-keyword">generator</a>，genarator是一种特殊的iterator，因此它是一个惰性求值的factory。继续上面的例子，generator能够避免编写<code>__iter__()</code>和<code>__next__()</code>，而以一种简洁优雅的方式写出上面的<code>fib</code> iterator。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>():</span></span><br><span class="line">    prev, curr = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> curr</span><br><span class="line">        prev, curr = curr, prev + curr</span><br><span class="line"></span><br><span class="line">f = fib()</span><br><span class="line"><span class="built_in">list</span>(islice(f, <span class="number">0</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>当执行<code>fib()</code>时，实例化并返回了一个generator，除此之外什么代码都没有被执行，包括<code>prev, curr = 0, 1</code>。<code>islice</code>是一个iterator，因此<code>fib</code>的代码仍然未被执行。</p><p>而<code>list</code>会使用其参数，由其来构造一个list，它会对<code>islice</code>对象调用<code>next()</code>，进而会对<code>f</code>对象调用<code>next()</code>，此时才开始执行<code>fib()</code>里的代码，直至<code>yield curr</code>，返回<code>curr</code>中的值，并暂停执行<code>fib()</code>，<code>fib()</code>的状态被冻结了。这个值被返回给<code>islice</code>，最终被添加到list里面。然后重复上述过程，直到产生第10个元素。</p><p>generator的类型有函数generator和表达式generator，表达式generator语法类似列表生成式，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">square_list = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> numbers]</span><br><span class="line">square_set = &#123;x * x <span class="keyword">for</span> x <span class="keyword">in</span> numbers&#125;</span><br><span class="line"></span><br><span class="line">lazy_square_list = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure><p>到目前为止，似乎generator相比起iterator，除了更简洁以外，没有什么特别的东西。<a href="https://www.python.org/dev/peps/pep-0342/">pep-0342</a>（<em>A new method for generator-iterators is proposed, called send(). It<br>takes exactly one argument, which is the value that should be “sent in” to the generator</em>）.规定了一个genarator可以产生一个值，或者在产生一个值的同时还接收一个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>():</span></span><br><span class="line">    prev, curr = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        old_curr = curr</span><br><span class="line">        curr = <span class="keyword">yield</span> old_curr</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> curr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> curr == old_curr:</span><br><span class="line">            prev, curr = curr, curr + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev, curr = old_curr, prev + old_curr</span><br><span class="line"></span><br><span class="line">f = fib()</span><br><span class="line"><span class="built_in">list</span>(islice(f, <span class="number">0</span>, <span class="number">10</span>)) <span class="comment"># [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br><span class="line">f.send(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">list</span>(islice(f, <span class="number">0</span>, <span class="number">10</span>)) <span class="comment"># [201, 302, 503, 805, 1308, 2113, 3421, 5534, 8955, 14489]</span></span><br></pre></td></tr></table></figure><p>第二次的<code>list(islice(f, 0, 10))</code>结果不是<code>[89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]</code>，因为<code>send()</code>改变了curr的值。</p><p>在调用<code>send()</code>前，由于还未执行到<code>yield</code>处，因此必须先调用一次<code>next()</code>或<code>send(None)</code>。</p><h1 id="Coroutines（协程）"><a href="#Coroutines（协程）" class="headerlink" title="Coroutines（协程）"></a>Coroutines（协程）</h1><p>与Coroutines对应的概念是Subroutine（子程序）。一个普通的函数调用是这样的，从函数的第一行执行到<code>return</code>语句或exception，或者执行到函数的结尾，这样也叫做一个subroutine。但有时候又希望函数能够生成一系列的值，而不仅仅是返回一个值，此时函数不应该return（return control of execution），而是yield（transfer control temporarily and voluntarily），因为函数需要稍后继续执行。generator能够冻结函数的状态，继续执行的时候恢复。</p><p>下面是用generator来实现的一个生产者-消费者模型，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span>():</span></span><br><span class="line">    consumed_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = <span class="keyword">yield</span></span><br><span class="line">        consumed_count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">&#x27;Consuming &#123;&#125;, Total Consumed &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(data, consumed_count))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span>(<span class="params">consumer</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = random.random()</span><br><span class="line">        print(<span class="string">&#x27;Produced &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(data))</span><br><span class="line">        consumer.send(data)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line">consumer = consume()</span><br><span class="line">consumer.send(<span class="literal">None</span>) <span class="comment"># or consumer.next()</span></span><br><span class="line">producer = produce(consumer)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">   print(<span class="string">&#x27;Producing...&#x27;</span>)</span><br><span class="line">   <span class="built_in">next</span>(producer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Producing...</span></span><br><span class="line"><span class="comment"># Produced 0.4138693968479813</span></span><br><span class="line"><span class="comment"># Consuming 0.4138693968479813, Total Consumed 1</span></span><br><span class="line"><span class="comment"># Producing...</span></span><br><span class="line"><span class="comment"># Produced 0.5462849666609885</span></span><br><span class="line"><span class="comment"># Consuming 0.5462849666609885, Total Consumed 2</span></span><br><span class="line"><span class="comment"># Producing...</span></span><br><span class="line"><span class="comment"># Produced 0.06190270111408913</span></span><br><span class="line"><span class="comment"># Consuming 0.06190270111408913, Total Consumed 3</span></span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://www.bjhee.com/python-yield.html">谈谈Python的生成器</a> 里有一个关于<code>send</code>不错的例子</li><li><a href="https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/">Improve Your Python: ‘yield’ and Generators Explained</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Generator（生成器）&quot;&gt;&lt;a href=&quot;#Generator（生成器）&quot; class=&quot;headerlink&quot; title=&quot;Generator（生成器）&quot;&gt;&lt;/a&gt;Generator（生成器）&lt;/h1&gt;&lt;p&gt;在Python中，说到generator，就</summary>
      
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/tags/concurrency/"/>
    
    <category term="python" scheme="https://chaomai.github.io/tags/python/"/>
    
    <category term="coroutine" scheme="https://chaomai.github.io/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>Fence和非原子操作的ordering</title>
    <link href="https://chaomai.github.io/2016/2016-03-20-fence-and-ordering-nonatomic/"/>
    <id>https://chaomai.github.io/2016/2016-03-20-fence-and-ordering-nonatomic/</id>
    <published>2016-03-20T12:04:21.000Z</published>
    <updated>2021-06-27T14:57:29.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fence"><a href="#Fence" class="headerlink" title="Fence"></a>Fence</h1><p>除了在原子操作中标记memory ordering外，还可以单独使用fence指定memory ordering。Fence是全局的操作，它影响所执行线程中其他原子操作的ordering。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x.store(<span class="literal">true</span>,memory_order_relaxed);</span><br><span class="line">  atomic_thread_fence(memory_order_release);</span><br><span class="line">  y.store(<span class="literal">true</span>,memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(memory_order_relaxed));</span><br><span class="line">  atomic_thread_fence(memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span>(x.load(memory_order_relaxed))</span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，如果没有显式的fence，<code>z</code>的值是不确定的。</p><p>关于fence，有几个synchronizes-with规则：</p><ul><li>如果acquire操作能读取到位于release fence后面store的写入的值，那么这个fence synchronizes-with acquire操作。</li><li>如果位于acquire fence前面的load操作能够读取到release操作的值，那么这个release操作synchronizes-with acquire fence。</li><li>如果位于acquire fence前面的load操作能够读取到位于release fence后面的store写入的值，那么release fence synchronizes-with acquire fence。</li></ul><p>对于上面的代码，因为y的load能够读取到前面写入的值（由于fence存在，保证了ordering），所以release fence synchronizes-with acquire fence。</p><h1 id="Ordering-Nonatomic"><a href="#Ordering-Nonatomic" class="headerlink" title="Ordering Nonatomic"></a>Ordering Nonatomic</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> x;</span><br><span class="line">atomic&lt;<span class="keyword">bool</span>&gt; y;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">true</span>;</span><br><span class="line">  atomic_thread_fence(memory_order_release);</span><br><span class="line">  y.store(<span class="literal">true</span>,memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.load(memory_order_relaxed));</span><br><span class="line">  atomic_thread_fence(memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span>(x)</span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在把前面例子中的x换为普通的x，z的值仍然是有保证的，<strong>y必须是原子的</strong>。fence保证了x的store和y的store，以及y的load和x的load之间的ordering，而y的store和load之间有happens-before关系，因此x的store和load之间也有happens-before关系（传递）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Fence&quot;&gt;&lt;a href=&quot;#Fence&quot; class=&quot;headerlink&quot; title=&quot;Fence&quot;&gt;&lt;/a&gt;Fence&lt;/h1&gt;&lt;p&gt;除了在原子操作中标记memory ordering外，还可以单独使用fence指定memory ordering。F</summary>
      
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="fence" scheme="https://chaomai.github.io/tags/fence/"/>
    
  </entry>
  
  <entry>
    <title>Release Sequences</title>
    <link href="https://chaomai.github.io/2016/2016-03-17-release-sequences/"/>
    <id>https://chaomai.github.io/2016/2016-03-17-release-sequences/</id>
    <published>2016-03-17T11:10:31.000Z</published>
    <updated>2021-06-27T14:57:29.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Release-Sequences"><a href="#Release-Sequences" class="headerlink" title="Release Sequences"></a>Release Sequences</h1><p>如果</p><ul><li>有标记为<code>memory_order_release</code>，<code>memory_order_acq_rel</code>或<code>memory_order_seq_cst</code>的store，</li><li>和标记为<code>memory_order_consume</code>，<code>memory_order_acquire</code>或<code>memory_order_seq_cst</code>的load，</li><li>并且在<strong>操作链中的每个操作都load上一个操作write的值</strong>，</li></ul><p>那么这个操作链构成一个<strong>release sequence</strong>，并且</p><ul><li>初始的store synchronizes-with 用<code>memory_order_acquire</code>或<code>memory_order_seq_cst</code>标记的最后的load；</li><li>或初始的store dependency-ordered-before 用<code>memory_order_consume</code>标记的最后的load。</li></ul><p>操作链中的RMW操作可以被标记为任意一种memory ordering。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queue_data;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue_data.push_back(<span class="number">1</span>); <span class="comment">// (1)</span></span><br><span class="line">  count.store(number_of_items, memory_order_release); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> item_index;</span><br><span class="line">    <span class="keyword">if</span>((item_index = count.fetch_sub(<span class="number">1</span>, memory_order_acquire)) &lt;= <span class="number">0</span>) &#123; <span class="comment">// (3)</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(queue_data[item_index<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">a</span><span class="params">(f1)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">b</span><span class="params">(f2)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">c</span><span class="params">(f2)</span></span>;</span><br></pre></td></tr></table></figure><p>在上述代码中，执行<code>f2</code>的有两个线程，由于acquire-release语义，(2)肯定是与第一个(3)有synchronizes-with关系的。后面还有一个(3)，第一个(3)写入的值被第二个(3)读取，因此操作链构成一个release sequence，由因为最后一个(3)是<code>memory_order_acquire</code>（无论是哪个线程中的<code>fetch_sub</code>作为最后一个），因此有(2)synchronizes-with最后一个(3)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Release-Sequences&quot;&gt;&lt;a href=&quot;#Release-Sequences&quot; class=&quot;headerlink&quot; title=&quot;Release Sequences&quot;&gt;&lt;/a&gt;Release Sequences&lt;/h1&gt;&lt;p&gt;如果&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="release sequence" scheme="https://chaomai.github.io/tags/release-sequence/"/>
    
  </entry>
  
  <entry>
    <title>Data Dependency and memory_order_consume</title>
    <link href="https://chaomai.github.io/2016/2016-03-16-data-dependency-and-memory-order-consume/"/>
    <id>https://chaomai.github.io/2016/2016-03-16-data-dependency-and-memory-order-consume/</id>
    <published>2016-03-16T11:08:06.000Z</published>
    <updated>2021-06-27T14:57:29.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Dependency"><a href="#Data-Dependency" class="headerlink" title="Data Dependency"></a>Data Dependency</h1><p><code>memory_order_consume</code>是关于data dependency的，我的理解是更细粒度的acquire-release，通过使用<code>memory_order_consume</code>，可以避免对其他无依赖的数据强加同步。</p><p>关于data dependency，有两个关系（两个关系都有传递性），</p><ul><li>carries-a-dependency-to：在单线程中，如果操作A的结果被用作操作B的操作符，那么操作A carries-a-dependency-to 操作B。</li><li>dependency-ordered-before：在线程之间，有标记为<code>memory_order_release</code>，<code>memory_order_acq_rel</code>或<code>memory_order_seq_cst</code>的store操作A，如果标记为<code>memory_order_consume</code>的load操作B read了被store的数据，则操作A dependency-ordered-before 操作B。（操作A和B都是原子的）</li></ul><p>线程之间，如果A dependency-ordered-before B，那么A happens-before B。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>对于这种memory ordering，一个典型的应用就是load一个指针指向的数据，其中load是原子操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;X*&gt; p;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X* x = <span class="keyword">new</span> X;</span><br><span class="line">  x-&gt;i = <span class="number">42</span>;</span><br><span class="line">  x-&gt;s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  a.store(<span class="number">99</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  p.store(x, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X* x;</span><br><span class="line">  <span class="keyword">while</span> (!(x = p.load(<span class="built_in">std</span>::memory_order_consume))) &#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::microseconds(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(x-&gt;i == <span class="number">42</span>);</span><br><span class="line">  assert(x-&gt;s == <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  assert(a.load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="number">99</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>p</code>的store是<code>memory_order_release</code>的，它的load是<code>memory_order_consume</code>的，循环保证了load能够读取到store的指针，因此当load能够读取到store的指针时，<code>p</code>的store dependency-ordered-before 它的load。所以<code>p</code>的store happens-before 它的load。</p><p>又因为<code>x</code>的store happens-before <code>p</code>的store，<code>p</code>的load happens-before <code>x</code>的load。</p><p>因此<code>x</code>的store happens-before <code>x</code>的load，对于<code>x</code>的两个assert不会触发，但<code>a</code>的load读取到的值是没有保证的。</p><h1 id="kill-dependency"><a href="#kill-dependency" class="headerlink" title="kill_dependency"></a>kill_dependency</h1><p>用<code>kill_dependency</code>可以显式地打破依赖链。</p><p>对于如下代码（取自<a href="http://stackoverflow.com/questions/7150395/what-does-stdkill-dependency-do-and-why-would-i-want-to-use-it">stackoverflow</a>），</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r1 = x.load(memory_order_consume);</span><br><span class="line">r2 = r1-&gt;index;</span><br><span class="line">do_something_with(a[<span class="built_in">std</span>::kill_dependency(r2)]);</span><br></pre></td></tr></table></figure><p>使用<code>kill_dependency</code>让编译器知道不需要再次读取<code>r2</code>的值，因此编译器可以将代码优化为，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predicted_r2 = x-&gt;index; <span class="comment">// unordered load</span></span><br><span class="line">r1 = x; <span class="comment">// ordered load</span></span><br><span class="line">r2 = r1-&gt;index; <span class="comment">// ordered load</span></span><br><span class="line">do_something_with(a[predicted_r2]); <span class="comment">// 不需要再次读取r2</span></span><br></pre></td></tr></table></figure><p>甚至优化为，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predicted_r2 = x-&gt;index; <span class="comment">// unordered load</span></span><br><span class="line">predicted_a  = a[predicted_r2]; <span class="comment">// get the CPU loading it early on</span></span><br><span class="line">r1 = x; <span class="comment">// ordered load</span></span><br><span class="line">r2 = r1-&gt;index; <span class="comment">// ordered load</span></span><br><span class="line">do_something_with(predicted_a);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Data-Dependency&quot;&gt;&lt;a href=&quot;#Data-Dependency&quot; class=&quot;headerlink&quot; title=&quot;Data Dependency&quot;&gt;&lt;/a&gt;Data Dependency&lt;/h1&gt;&lt;p&gt;&lt;code&gt;memory_order</summary>
      
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="data dependency" scheme="https://chaomai.github.io/tags/data-dependency/"/>
    
  </entry>
  
  <entry>
    <title>Memory Ordering</title>
    <link href="https://chaomai.github.io/2016/2016-03-13-memory-ordering/"/>
    <id>https://chaomai.github.io/2016/2016-03-13-memory-ordering/</id>
    <published>2016-03-13T14:34:28.000Z</published>
    <updated>2021-06-27T14:57:29.269Z</updated>
    
    <content type="html"><![CDATA[<p>Memory ordering描述了CPU访问系统内存，执行load和store的顺序。Memory ordering包括编译时编译器生成的和运行时CPU生成的。为了高效地执行指令，<strong>只要不影响单线程程序的行为</strong>，编译器和CPU常常会对指令进行memory reordering，使得访问内存的操作不会按照程序代码中指定的顺序执行。</p><p>在单线程程序中，可以忽略reordering的存在；在多线程程序中，mutex，semaphores等互斥方法会保证在相关函数的调用周围没有reordering。在多核环境下（或对称多处理器架构）下，用C、C++等编写lock-free代码时，memory reordering是可观察到的，是重点要考虑的问题。</p><h2 id="Compiler-Reordering"><a href="#Compiler-Reordering" class="headerlink" title="Compiler Reordering"></a>Compiler Reordering</h2><p>从源代码得到CPU指令的过程中，编译器会做很多事情，其中之一就是reordering。（例子摘自<a href="http://preshing.com/20120625/memory-ordering-at-compile-time/">Preshing on Programming</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Value;</span><br><span class="line"><span class="keyword">int</span> IsPublished = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendValue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  Value = x;</span><br><span class="line">  IsPublished = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>IsPublished = 1;</code>被reordered到<code>Value = x;</code>之前，那么<code>IsPublished</code>作为flag的作用就丧失了。既是是在单线程中，也会有问题。如果该线程在两次store之间被抢占，那么其他使用<code>Value</code>的线程就会访问到<code>Value</code>的旧值，而不是新值。</p><h3 id="Compiler-Barriers"><a href="#Compiler-Barriers" class="headerlink" title="Compiler Barriers"></a>Compiler Barriers</h3><p>防止编译器reordering最简单的办法莫过于使用compiler barriers，在不想被reordered的两个操作（load和store）之间加入compiler Barrier<code>asm volatile(&quot;&quot; ::: &quot;memory&quot;)</code>，但在多核环境下，这并不足够。还需要下面的CPU fence来提供运行时memory barrier的保障。如果使用了CPU fence，那么fence也会作为compiler Barrier。</p><p>另一种compiler barrier是函数调用，<strong>无论函数是否包含</strong>compiler barrier，除了inline函数、声明带有<code>pure</code><a href="http://lwn.net/Articles/285332/">属性</a>的函数和使用了链接时代码生成的函数，大多数函数调用都可以作为compiler barrier。因为编译器根本不知道该函数调用是否会修改先前的值，也不知道这个值是否在函数调用返回后会被继续使用，如果进行了reordering，那么很可能会违反一开始提到的原则。而对于包含的函数，无论是不是inline的，都可以作为compiler barrier。</p><p>C/C++中，<code>volatie</code>会阻止编译器的优化，编译器<a href="http://hedengcheng.com/?p=725">不会</a>对<code>volatie</code>变量间的操作进行reordering，<strong>但是</strong><code>volatie</code>对处理器的reordering是无能为力的，并没有happens-before语义。与此同时，<code>volatie</code>也不能阻止多个线程的<a href="https://www.kernel.org/doc/Documentation/volatile-considered-harmful.txt">并发访问</a>。对于下面的代码，无论<code>shared_data</code>是不是<code>volatie</code>，<code>spin_lock</code>都是必须的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spin_lock(&amp;the_lock);</span><br><span class="line">do_something_on(&amp;shared_data);</span><br><span class="line">do_something_else_with(&amp;shared_data);</span><br><span class="line">spin_unlock(&amp;the_lock);</span><br></pre></td></tr></table></figure><p>代码里的<code>spin_lock</code>也下面将说的memory barrier。</p><h2 id="Processor-Reordering"><a href="#Processor-Reordering" class="headerlink" title="Processor Reordering"></a>Processor Reordering</h2><p>除了编译器会进行reordering，CPU同样会。CPU的reordering仅在多核或多处理器环境下才是可见的。（例子摘自<a href="http://preshing.com/20120515/memory-reordering-caught-in-the-act/">Preshing on Programming</a>）</p><p>考虑下面的一段代码，<code>thread1Func</code>和<code>thread2Func</code>分别在两个线程中运行，最后<code>r1</code>和<code>r2</code>的结果会是什么？为了阻止编译器的reordering，已经在store和load之间加入了compiler barrier。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> X, Y;</span><br><span class="line"><span class="keyword">int</span> r1, r2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1Func</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">  X = <span class="number">1</span>;</span><br><span class="line">  asm volatile(&quot;&quot; ::: &quot;memory&quot;)；</span><br><span class="line">  r2 = Y;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2Func</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">  Y = <span class="number">1</span>;</span><br><span class="line">  asm volatile(&quot;&quot; ::: &quot;memory&quot;)；</span><br><span class="line">  r2 = X;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于是并发执行，两个线程的load和store会<a href="http://www.yebangyu.org/blog/2016/01/09/memoryconsistencyandcachecoherence/">交替执行</a>，因此<code>r1</code>和<code>r2</code>的结果可能为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r1&#x3D;0 r2&#x3D;1</span><br><span class="line">r1&#x3D;1 r2&#x3D;0</span><br><span class="line">r1&#x3D;1 r2&#x3D;1</span><br></pre></td></tr></table></figure><p>但<code>r1=0 r2=0</code>也是完全可能的，如果重复的进行测试，那么这个结果会<a href="https://gist.github.com/ChaoMai/f756356369fe0b1d4859">频繁的发生</a>。Intel在64 and IA-32 Architectures Software Developer’s Manual中的8.2.3.4指出，</p><blockquote><p>At each processor, the load and the store are to different locations and hence may be reordered.</p></blockquote><p>代码中每个线程的store和load是不同的内存位置，所以发生StoreLoad Reordering是完全可能的。</p><h3 id="Memory-Barrier"><a href="#Memory-Barrier" class="headerlink" title="Memory Barrier"></a>Memory Barrier</h3><p>上述例子的reordering只是众多memory reordering中的一种，主要有<a href="http://preshing.com/20120710/memory-barriers-are-like-source-control-operations/">四种memory reordering</a>，</p><ul><li>LoadLoad</li><li>StoreStore</li><li>LoadStore</li><li>StoreLoad</li></ul><p>类似compiler reordering，需要compiler barrier来阻止CPU的reordering，这里是memory barriers，也叫fence指令。Fence保证了fence之前的load或store和之后的load或store是严格有序的。针对以上四种reordering，有对应的四种barrier，<code>#LoadLoad</code>、<code>#StoreStore</code>、<code>#LoadStore</code>和<code>#StoreLoad</code>。对于现实中CPU的fence指令的行为，通常是上述<a href="http://g.oswego.edu/dl/jmm/cookbook.html">几种的融合</a>，且还会有其他的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Store1; #StoreLoad; Load2;</span><br></pre></td></tr></table></figure><p>需要特别说明的是<code>#StoreLoad</code>，这个barrier是<strong>唯一</strong>能够保证上述例子不出现<code>r1=0 r2=0</code>的。<code>#StoreLoad</code>保证了在barrier前执行<code>Store1</code>对其他处理器是<strong>可见的</strong>，在barrier后执行的<code>Load2</code>能够得到<strong>在barrier之后最新的值</strong>（不一定是<code>Store1</code>的值）。<code>#StoreLoad</code><a href="http://g.oswego.edu/dl/jmm/cookbook.html">防止</a>了后续的load错误的使用<code>Store1</code>的值，而不是其他处理器在同一内存位置store的更新的值。<code>#StoreLoad</code>几乎在所有现代的多处理器上都是必须的，同时也是代价最高昂的一种barrier。</p><p>除了fence指令，memory barrier还有，</p><ul><li>C++11中，很多原子类型的操作；</li><li>pthread中，mutex，spin_lock，semaphore的操作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Memory ordering描述了CPU访问系统内存，执行load和store的顺序。Memory ordering包括编译时编译器生成的和运行时CPU生成的。为了高效地执行指令，&lt;strong&gt;只要不影响单线程程序的行为&lt;/strong&gt;，编译器和CPU常常会对指令进行</summary>
      
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="memory ordering" scheme="https://chaomai.github.io/tags/memory-ordering/"/>
    
  </entry>
  
  <entry>
    <title>Happens-before</title>
    <link href="https://chaomai.github.io/2016/2016-03-06-happens-before/"/>
    <id>https://chaomai.github.io/2016/2016-03-06-happens-before/</id>
    <published>2016-03-06T13:51:54.000Z</published>
    <updated>2021-06-27T14:57:29.269Z</updated>
    
    <content type="html"><![CDATA[<p>取自<a href="http://preshing.com/">preshing博客</a>上的几篇文章（<a href="http://preshing.com/20120913/acquire-and-release-semantics/">1</a>，<a href="http://preshing.com/20130702/the-happens-before-relation/">2</a>，<a href="http://preshing.com/20130823/the-synchronizes-with-relation/">3</a>）。除了部分翻译外，还有自己的理解。</p><h1 id="Happens-before关系"><a href="#Happens-before关系" class="headerlink" title="Happens-before关系"></a>Happens-before关系</h1><p>假设A和B两个操作是由多线程程序执行的，如果<strong>A happens-before B</strong>，那么A对内存的操作在<strong>B被执行前</strong>对执行B的线程切实可见。</p><p>关于happens-before要注意的是一下看起来自相矛盾的两点。因为happens-before所描述的是操作之间的关系，这个关系是<strong>独立于时间的</strong>，并不是happening before。</p><h2 id="Happens-before并不意味着happening-before"><a href="#Happens-before并不意味着happening-before" class="headerlink" title="Happens-before并不意味着happening before"></a>Happens-before并不意味着happening before</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> B = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A = B + <span class="number">1</span>;              <span class="comment">// (1)</span></span><br><span class="line">  B = <span class="number">1</span>;                  <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，只看program order的话，(1)是happens-before(2)的。但编译器可能会对上面的代码进行reorder（用clang++ 3.7 -O2没有发生），使得B的store<strong>先于A完成</strong>。</p><p>从happens-before定义来看，(1)对内存的修改必须在(2)执行前切实可见，也就是说A的store必须影响到B的store。但从这个例子来看，A的store并未影响到A，就算没有(1)，(2)的行为也是一样的，这就等价于(1)的操作是<a href="http://preshing.com/20130702/the-happens-before-relation/">可见的</a>。</p><p>因此(1)和(2)行为并不违背happens-before，happens-before并不意味着happening before。</p><h2 id="Happening-before并不意味着happens-before"><a href="#Happening-before并不意味着happens-before" class="headerlink" title="Happening before并不意味着happens-before"></a>Happening before并不意味着happens-before</h2><p>假设下面对的int的store和load都是原子的，有两个线程分别执行两个函数。就program order而言，(1)和(2)，(3)和(4)之间有happens-before关系。再假设在运行时，(2)在(3)之前完成，(3)读到了1。</p><p>但是并不意味着(2)和(3)之间有happens-before关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isReady = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  answer = <span class="number">42</span>;                      <span class="comment">// (1)</span></span><br><span class="line">  isReady = <span class="number">1</span>;                      <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isReady)                      <span class="comment">// (3) &lt;-- Let&#x27;s suppose this line reads 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, answer);         <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>happens-before关系仅仅在标准指明的地方有。C++11中并未规定在普通的store和load之间有happens-before关系。进一步看，(1)和(4)之间也没有。因此(1)和(4)是可以被编译器或CPU reordered的。即使(3)读到了1，(4)可能打印0。</p><h1 id="单线程中的happens-before关系"><a href="#单线程中的happens-before关系" class="headerlink" title="单线程中的happens-before关系"></a>单线程中的happens-before关系</h1><p>如果操作A和B是由同一个线程执行的，且就program order而言，A的语句位于B之前，那么A <strong>happens-before</strong> B。</p><p>然而这并不是唯一实现happens-before关系的方法。</p><h1 id="多线程中的happens-before关系"><a href="#多线程中的happens-before关系" class="headerlink" title="多线程中的happens-before关系"></a>多线程中的happens-before关系</h1><p>上面提到了单线程中的happens-before关系是如何产生的，下面来看多线程中的happens-before关系，C++11指出可以通过acquire和release语义，在不同线程的操作中实现happens-before。</p><h2 id="Acquire和Release语义"><a href="#Acquire和Release语义" class="headerlink" title="Acquire和Release语义"></a>Acquire和Release语义</h2><p>Acquire语义：Acquire语义是一个属性，这个属性只能应用于从共享内存中的<strong>read操作</strong>，无论这些read是RMW还是普通的load。Acquire语义保证了在program order上位于read-acquire之后的read和write不会被编译器和CPU reordered到read-acquire之前。<br>Release语义：Release语义也是一个属性，这个属性只能应用于从共享内存中的<strong>write操作</strong>，无论这些read是RMW还是普通的store。Release语义保证了在program order上位于write-release之前的read和write不会被编译器和CPU reordered到write-release之后。</p><p>Raymond Chen的另一个解释，<br>一个带有acquire语义的操作不允许后续的内存操作提前到该操作之前执行，相对的，一个带有release语义的操作不允许前面的内存操作被滞后到该操作之后执行。</p><p>关于Acquire和Release语义，<a href="http://hedengcheng.com/?p=725">这里</a>还有一个比较好的解释。</p><h3 id="通过显式的CPU-fence指令实现acquire和release语义"><a href="#通过显式的CPU-fence指令实现acquire和release语义" class="headerlink" title="通过显式的CPU fence指令实现acquire和release语义"></a>通过显式的CPU fence指令实现acquire和release语义</h3><p>下面代码中有两个全局变量<code>A</code>和<code>Ready</code>，两个线程分别执行两段代码，<code>Ready</code>作为flag表示<code>A</code>的write是否完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 1</span></span><br><span class="line">A = <span class="number">42</span>;</span><br><span class="line">#StoreStore</span><br><span class="line">Ready = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread 2</span></span><br><span class="line"><span class="keyword">int</span> r1 = Ready;</span><br><span class="line">#LoadLoad</span><br><span class="line"><span class="keyword">int</span> r2 = A;</span><br></pre></td></tr></table></figure><p>通过两个fence，可以保证当线程2发现<code>r1 == 1</code>时，<code>A</code>的值是1，进而保证<code>r2 == 1</code>。</p><p>规范的来说就是，对<code>Ready</code>的write synchronizes-with对<code>Ready</code>的read。</p><h2 id="Synchronizes-with关系"><a href="#Synchronizes-with关系" class="headerlink" title="Synchronizes-with关系"></a>Synchronizes-with关系</h2><p>Synchronizes-with用于描述源码级操作的内存影响（describe ways in which the memory effects of source-level operations），即使是非原子操作，也能够保证结果是对其他线程可见。一个较为常见的事情是，无论何时在两个线程间有<strong>synchronizes-with</strong>关系（一般是在不同的线程间）那么在这些操作之间都会有<strong>happens-before</strong>关系。</p><h3 id="一个Write-Release能够Synchronize-with一个Read-Acquire的"><a href="#一个Write-Release能够Synchronize-with一个Read-Acquire的" class="headerlink" title="一个Write-Release能够Synchronize-with一个Read-Acquire的"></a>一个Write-Release能够Synchronize-with一个Read-Acquire的</h3><p>C++11标准规定了，一个对<strong>原子对象M</strong>执行<strong>release</strong>操作的<strong>原子操作A</strong> <em>synchronize-with</em>一个对<strong>M</strong>执行<strong>acquire</strong>操作的<strong>原子操作B</strong>，且能够得到以A为起始的release sequence操作的所有副作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Message</span> &#123;</span></span><br><span class="line">  <span class="keyword">clock_t</span>     tick;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* str;</span><br><span class="line">  <span class="keyword">void</span>*       param;</span><br><span class="line">&#125;;</span><br><span class="line">Message g_payload;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">g_guard</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendTestMessage</span><span class="params">(<span class="keyword">void</span>* param)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Copy to shared memory using non-atomic stores.</span></span><br><span class="line">  g_payload.tick  = clock();</span><br><span class="line">  g_payload.str   = <span class="string">&quot;TestMessage&quot;</span>;</span><br><span class="line">  g_payload.param = param;</span><br><span class="line">  <span class="comment">// Perform an atomic write-release to indicate that the message is ready.</span></span><br><span class="line">  g_guard.store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryReceiveMessage</span><span class="params">(Message&amp; result)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Perform an atomic read-acquire to check whether the message is ready.</span></span><br><span class="line">  <span class="keyword">int</span> ready = g_guard.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (ready != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Yes. Copy from shared memory using non-atomic loads.</span></span><br><span class="line">    result.tick  = g_payload.tick;</span><br><span class="line">    result.str   = g_payload.str;</span><br><span class="line">    result.param = g_payload.param;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，为了能够把<code>g_payload</code>安全的在线程中传递，使用了acquire和release。当<code>TryReceiveMessage</code>中<code>g_guard</code>的read-acquire执行完后，<strong>如果<code>ready</code>是1</strong>，那么<code>g_payload</code>的三个成员一定被成功写入。</p><p>与前面的标准对照，可以看到，</p><ul><li>原子操作A是<code>SendTestMessage</code>中的write-release；</li><li>原子对象M是<code>g_guard</code>；</li><li>原子操作B是<code>TryReceiveMessage</code>中的read-acquire。</li></ul><p>前面所说的takes its value from any side effect in the release sequence headed by A，这里指read-acquire能够读取到write-release所写的值。<strong>如果读取到了</strong>，那么synchronize-with关系就出现了。此时，两个线程间就有了happens-before关系。有时这也叫做synchronize-with或happens-before“边”。</p><p><img data-src="/images/2016/happens_before_two-cones.png"></p><p>标准中还保证了只要有synchronize-with边存在，happens-before关系就能够<strong>扩展到临近的操作</strong>。对应到上例中就是，当其他线程读取<code>g_payload</code>时，保证能够读取到对<code>g_payload</code>写入的值。</p><h3 id="运行时关系"><a href="#运行时关系" class="headerlink" title="运行时关系"></a>运行时关系</h3><p>想要通过静态的分析代码，来寻找代码中的synchronize-with关系是错误的。synchronize-with是<strong>运行时关系</strong>。</p><p><img data-src="/images/2016/happens_before_no-cones.png"></p><p>如果<code>g_guard</code>读取的过早，线程1还没有写入<code>g_guard</code>，那么就没有synchronize-with关系。</p><h3 id="其他实现Synchronize-with的方法"><a href="#其他实现Synchronize-with的方法" class="headerlink" title="其他实现Synchronize-with的方法"></a>其他实现Synchronize-with的方法</h3><p><img data-src="/images/2016/happens_before_org-chart.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;取自&lt;a href=&quot;http://preshing.com/&quot;&gt;preshing博客&lt;/a&gt;上的几篇文章（&lt;a href=&quot;http://preshing.com/20120913/acquire-and-release-semantics/&quot;&gt;1&lt;/a&gt;，&lt;a href</summary>
      
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="happens-before" scheme="https://chaomai.github.io/tags/happens-before/"/>
    
  </entry>
  
  <entry>
    <title>C++ Copy Elision</title>
    <link href="https://chaomai.github.io/2016/2016-03-05-cpp-copy-elision/"/>
    <id>https://chaomai.github.io/2016/2016-03-05-cpp-copy-elision/</id>
    <published>2016-03-05T05:03:30.000Z</published>
    <updated>2021-06-27T14:57:29.268Z</updated>
    
    <content type="html"><![CDATA[<p>在写代码是发现拷贝构造函数有时候没有调用，想起C++ Primer中提到过</p><blockquote><p>the compiler can omit calls to the copy constructor.</p></blockquote><p>后来查到是发生了copy elision。</p><p>首先有那么一个类定义，其中静态成员c是对象编号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  C() &#123;</span><br><span class="line">    name_ = c;</span><br><span class="line">    ++c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  C(<span class="keyword">const</span> <span class="keyword">int</span> name) : name_(name) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  C(<span class="keyword">const</span> C &amp;rhs) : name_(c++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy from c&quot;</span> &lt;&lt; rhs.name_ &lt;&lt; <span class="string">&quot;, c&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; __func__</span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;rhs) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy assign from c&quot;</span> &lt;&lt; rhs.name_ &lt;&lt; <span class="string">&quot;, c&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">         &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> name_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C::c = <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><p>然后是有下面的几个函数定义和调用，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(C c)</span> </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">tmp</span><span class="params">()</span></span>;</span><br><span class="line">  tmp = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">C <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> C(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">C <span class="title">c1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">f(c1);</span><br><span class="line">f(C(<span class="number">2</span>));</span><br><span class="line">C c = f();</span><br></pre></td></tr></table></figure><p>以上三个f的调用分别输出什么？</p><p>下面是结果，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c1: C</span><br><span class="line">copy from c1, c10000: C</span><br><span class="line">c10001: C</span><br><span class="line">copy assign from c10000, c10001: operator&#x3D;</span><br><span class="line">-----</span><br><span class="line">c2: C</span><br><span class="line">c10002: C</span><br><span class="line">copy assign from c2, c10002: operator&#x3D;</span><br><span class="line">-----</span><br><span class="line">c10003: C</span><br></pre></td></tr></table></figure><p>第一个没什么好说的，首先用<code>c1</code>对形参<code>c</code>做拷贝初始化，接着<code>tmp</code>进行默认初始化，然后用拷贝赋值，将<code>c</code>赋值给<code>tmp</code>。</p><p>第二个的结果就有点怪了，为什么<code>C(2)</code>得到的临时对象直接进行了赋值，而不首先初始化形参<code>c</code>？而第三个，为什么返回的临时对象一次拷贝都没发生？</p><p>因为在这两种情况中发生了copy elision（<a href="http://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization">1</a>，<a href="http://stackoverflow.com/questions/8451212/passing-temporary-object-as-parameter-by-value-is-copy-constructor-called">2</a>，<a href="https://en.wikipedia.org/wiki/Copy_elision">3</a>，<a href="http://cstdlib.com/tech/2014/07/12/nrvo-and-copy-elision/">4</a>）。<strong>Copy elision</strong>是一种优化手段，满足特定条件时会发生，当传入的参数是rvalue的时候，无需进行额外的拷贝，直接使用源对象。<strong>RVO</strong>，全称叫<a href="https://en.wikipedia.org/wiki/Return_value_optimization">return value optimization</a>，编译器会让调用函数在其栈上分配空间，被调函数返回值处的临时对象会在这块内存上构造，进而避免了return时临时对象的拷贝，是copy elision常见形式。根据返回的对象是否是临时的，有<strong>named return value optimization</strong>和<strong>return value optimization</strong>。</p><p>Copy elision和rvo即使在有可观察的到的side-effects时，也会发生，是<a href="https://en.wikipedia.org/wiki/As-if_rule">As-if rule</a>的例外中的一种。Dave Abrahams写过pass by value的一系列<a href="https://web.archive.org/web/20140205194657/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/">文章</a>。Ayman B. Shoukry在<a href="https://msdn.microsoft.com/en-us/library/ms364057(v=vs.80).aspx#nrvo_cpp05_topic3">这里</a>讨论了nrvo的局限（multiple return points和conditional initialization）。</p><p>clang++和g++可以用<code>-fno-elide-constructors</code>控制是否开启优化。关闭优化后，输出的结果就和期待的一致了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c1: C</span><br><span class="line">copy from c1, c10000: C</span><br><span class="line">c10001: C</span><br><span class="line">copy assign from c10000, c10001: operator&#x3D;</span><br><span class="line">-----</span><br><span class="line">c2: C</span><br><span class="line">copy from c2, c10002: C</span><br><span class="line">c10003: C</span><br><span class="line">copy assign from c10002, c10003: operator&#x3D;</span><br><span class="line">-----</span><br><span class="line">c10004: C</span><br><span class="line">copy from c10004, c10005: C</span><br><span class="line">copy from c10005, c10006: C</span><br></pre></td></tr></table></figure><p>stackoverflow的这个<a href="http://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization">答案</a>，给出了Standard reference和发生copy elision以及return value optimization常见的例子，下面是搬运例子，</p><ul><li>nrvo</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Thing();</span><br><span class="line">  ~Thing();</span><br><span class="line">  Thing(<span class="keyword">const</span> Thing&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Thing <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thing t;</span><br><span class="line">  <span class="keyword">return</span> t; <span class="comment">// optimization</span></span><br><span class="line">&#125;</span><br><span class="line">Thing t2 = f();</span><br></pre></td></tr></table></figure><ul><li>rvo</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Thing();</span><br><span class="line">  ~Thing();</span><br><span class="line">  Thing(<span class="keyword">const</span> Thing&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Thing <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Thing(); <span class="comment">// optimization</span></span><br><span class="line">&#125;</span><br><span class="line">Thing t2 = f();</span><br></pre></td></tr></table></figure><ul><li>pass a temporary object by value</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Thing();</span><br><span class="line">  ~Thing();</span><br><span class="line">  Thing(<span class="keyword">const</span> Thing&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Thing t)</span></span>; <span class="comment">// optimization</span></span><br><span class="line"></span><br><span class="line">foo(Thing());</span><br></pre></td></tr></table></figure><ul><li>exception is thrown and caught by value</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Thing</span>&#123;</span></span><br><span class="line">  Thing();</span><br><span class="line">  Thing(<span class="keyword">const</span> Thing&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Thing c;</span><br><span class="line">  <span class="keyword">throw</span> c; <span class="comment">// optimization</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    foo();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(Thing c) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在写代码是发现拷贝构造函数有时候没有调用，想起C++ Primer中提到过&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the compiler can omit calls to the copy constructor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后来查到是</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="copy elision" scheme="https://chaomai.github.io/tags/copy-elision/"/>
    
  </entry>
  
  <entry>
    <title>Single Number</title>
    <link href="https://chaomai.github.io/2016/2016-02-16-single-number/"/>
    <id>https://chaomai.github.io/2016/2016-02-16-single-number/</id>
    <published>2016-02-16T11:59:44.000Z</published>
    <updated>2021-06-27T14:57:29.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Single-Number-I"><a href="#Single-Number-I" class="headerlink" title="Single Number I"></a>Single Number I</h1><p>问题：给定一个数组，除了其中一个数出现一次，其他数都出现了两次，找到这个数。</p><p>最简单的办法用莫过于用map统计每个数出现的次数，但这除了需要遍历数组外，还需要遍历map，且需要O(n)空间。</p><p>使用异或操作更为方便，根据<code>a xor a = 0</code>和<code>a xor 0 = a</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">    ret ^= n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成对的数字进行xor后是0，最后ret便是只出现一次的那个数字。</p><h1 id="Single-Number-II"><a href="#Single-Number-II" class="headerlink" title="Single Number II"></a>Single Number II</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>问题：给定一个数组，除了其中一个数出现一次，其他数都出现了三次，找到这个数。</p><p>此时I的xor方法不可用，因为出现次数是奇数次。</p><p>考虑每个数的二进制表示，但凡这个数出现了三次，那么二进制表示中，如果某个bit有1，则这个1也在该bit上出现了三次。统计所有数字每个bit上1出现的次数，最后mod 3，余数就是那个数相应bit上的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2    2    2    11   11   11   12</span><br><span class="line">0010 0010 0010 1011 1011 1011 1000</span><br><span class="line">                              ----</span><br><span class="line">count 1 for each bit,</span><br><span class="line">bit index: 3 2 1 0</span><br><span class="line">count:     4 0 6 3</span><br><span class="line">mod 3:     1 0 0 0</span><br></pre></td></tr></table></figure><p>以下是代码，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != count.size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((n &gt;&gt; j) &amp; <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        count[<span class="number">31</span> - j] += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != count.size(); ++i) &#123;</span><br><span class="line">    result |= (count[<span class="number">31</span> - i] % <span class="number">3</span>) &lt;&lt; i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码是遍历每个数，统计每个数中bit为1的数目。还可以遍历每个bit，统计所有数字该bit上1的数目，这样可以合并两个for。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != count.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">      count[<span class="number">31</span> - i] += (n &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result |= (count[<span class="number">31</span> - i] % <span class="number">3</span>) &lt;&lt; i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>但是上述方法需要O(n)的空间。在这个<a href="https://leetcode.com/discuss/857/constant-space-solution">discuss</a>中看到了更好的方法，结合例子能明白做了什么，但是无法理解这样位操作的idea是如何想出来的。。。最后在另一个<a href="(http://traceformula.blogspot.com/2015/08/single-number-ii-how-to-come-up-with.html)">blog</a>和另一个<a href="https://leetcode.com/discuss/81165/explanation-manipulation-method-might-easier-understand">disscus</a>中找到了另一个方法，用了卡诺图。</p><p>在上面的代码中，每个bit的计数器<code>count[31 - i]</code>值为多少是无所谓的，最终需要的只是<code>count[31 - i] % 3</code>的结果。每当计数器为3，可以把它重置为0，即0 (00) -&gt; 1 (01) -&gt; 2 (10) -&gt; 0 (00)，因此可以使用一个Two Bit Counter来表示状态的转换，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于数字的每个bit b，</span><br><span class="line">old_two, old_one b -&gt; two, one</span><br><span class="line">0        0       0    0    0</span><br><span class="line">0        1       0    0    1</span><br><span class="line">1        0       0    1    0</span><br><span class="line">0        0       1    0    1</span><br><span class="line">0        1       1    1    0</span><br><span class="line">1        0       1    0    0</span><br></pre></td></tr></table></figure><p>上图变为卡诺图，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">two:                       one:</span><br><span class="line">     old_two old_one       old_two old_one</span><br><span class="line">     00 01 10              00 01 10</span><br><span class="line">b 0   0  0  1         b 0   0  1  0</span><br><span class="line">  1   0  1  0           1   1  0  0</span><br></pre></td></tr></table></figure><p>可以得到，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">two &#x3D; (old_two &amp; ~old_one &amp; ~b) | (~old_two &amp; old_one &amp; b)</span><br><span class="line">one &#x3D; (~old_two &amp; old_one &amp; ~b) | (~old_two &amp; ~old_one &amp; b)</span><br></pre></td></tr></table></figure><p>由上面的式子可得，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != count.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> old_two, old_one;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">      old_two = two;</span><br><span class="line">      old_one = one;</span><br><span class="line">      <span class="keyword">int</span> b = (n &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      two = (old_two &amp; ~old_one &amp; ~b) | (~old_two &amp; old_one &amp; b);</span><br><span class="line">      one = (~old_two &amp; old_one &amp; ~b) | (~old_two &amp; ~old_one &amp; b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result |= (one &lt;&lt; i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着发现blog里面实际上是对每个数字使用了上面的公式，而不是对数字的每个bit。观察上面的状态转换图和代码，对每个bit进行计算的时候，two和one始终都是在使用最后一个bit，没有进位的情况，如果多个bit同时计算，没有相互影响，不会有问题，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> old_two = two;</span><br><span class="line">    <span class="keyword">int</span> old_one = one;</span><br><span class="line"></span><br><span class="line">    two = (old_two &amp; ~old_one &amp; ~n) | (~old_two &amp; old_one &amp; n);</span><br><span class="line">    one = (~old_two &amp; old_one &amp; ~n) | (~old_two &amp; ~old_one &amp; n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的公式还可简化，计算two时，由于<code>old_two = two</code>且<code>old_one = one</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">two &#x3D; (two &amp; ~one &amp; ~b) | (~two &amp; one &amp; b)</span><br><span class="line">    &#x3D; one &amp; (two ^ b)</span><br><span class="line">one &#x3D; (~old_two &amp; one &amp; ~b) | (~old_two &amp; ~one &amp; b)</span><br></pre></td></tr></table></figure><p>对one还可以简化，在状态转换表中用11代替old_two和old_one的10，进而在式子中消除old_two（<code>one = two | (one ^ b)</code>）。还有，如果使用了不同的状态转换表示，最后的结果也会有所差异。</p><h1 id="Single-Number-III"><a href="#Single-Number-III" class="headerlink" title="Single Number III"></a>Single Number III</h1><p>问题：给定一个数组，除了其中两个数分别出现一次，其他数都出现了两次，找到这两个数。</p><p>用I的方法来做的话，ret是那两个数的xor，因此现在需要从ret中区分出两个数。</p><p>假设有如下数组，且ret中只有第3个bit被置为1，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c, b, d, a]</span><br><span class="line">ret &#x3D; c ^ d</span><br></pre></td></tr></table></figure><p>如果ret中某一bit出现了1，那么这两个数中，对应的bit必然是一个为1，另一个为0。根据该bit是否为1，可以把原数组分为两组，c和d不会在同一个组里，有下面两种情况，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 某个组里只有c或d</span><br><span class="line">[c]</span><br><span class="line">[a, b, d, b, a]</span><br><span class="line">c &#x3D; c</span><br><span class="line">a ^ b ^ d ^ b ^ a &#x3D; d</span><br><span class="line"></span><br><span class="line">[a b c b a]</span><br><span class="line">[d]</span><br><span class="line">a ^ b ^ c ^ b ^ a &#x3D; a</span><br><span class="line">d &#x3D; d</span><br><span class="line"></span><br><span class="line">2. 每个组除了c或d，还有其他数</span><br><span class="line">[a c a]</span><br><span class="line">[b d b]</span><br><span class="line">a ^ c ^ a &#x3D; c</span><br><span class="line">b ^ d ^ b &#x3D; d</span><br></pre></td></tr></table></figure><p>无论是情况1或2，如果某个组除了c或d，还有其他数，那么这些数必定是成对出现的。接下来把两个组的数分别xor即可，两个xor的结果就是c和d。</p><p>上述例子是假设了ret中只有一个bit被置为1，如果ret中有多个bit为1，则只需要根据其中的一个bit来分组，因此需要从ret中提取出一个为1的bit。下面提取最后一个为1的bit，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">last_bit_one &#x3D; r &amp; ~(r - 1);</span><br><span class="line"></span><br><span class="line">若ret为1010010，</span><br><span class="line">ret           1010010</span><br><span class="line">r- 1          1010001</span><br><span class="line">~(r - 1)      0101110</span><br><span class="line">r &amp; ~(r - 1)  0000010</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">    r ^= n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> last_bit_one = r &amp; ~(r - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> n : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((last_bit_one &amp; n) != <span class="number">0</span>) &#123;</span><br><span class="line">      res[<span class="number">0</span>] ^= n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[<span class="number">1</span>] ^= n;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p>问题：给定一个数组，除了其中一个数出现两次，其他数都出现了三次，找到这个数。</p><p>类似Single Number II，如果用vector对值为1的bit进行计数，那么最后mod 3，如果余数为2，那么该bit就是那个数字的相应bit，代码改为<code>result |= (count[31 - i] % 3 == 2) &lt;&lt; i;</code>。</p><p>如果是使用第二个方法，直接返回two即可。</p><h2 id="II"><a href="#II" class="headerlink" title="II"></a>II</h2><p>问题：给定一个数组，除了其中一个数出现l次，其他数都出现了k次，找到这个数。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol><li><a href="https://leetcode.com/discuss/81165/explanation-manipulation-method-might-easier-understand">My own explanation of bit manipulation method, might be easier to understand</a></li><li><a href="https://leetcode.com/discuss/857/constant-space-solution">Constant space solution</a></li><li><a href="http://www.cnblogs.com/daijinqiao/p/3352893.html">leetcode Single Number II - 位运算处理数组中的数</a></li><li><a href="http://stackoverflow.com/questions/22952651/explain-using-xor-to-find-two-non-duplicate-integers-in-an-array">Explain using xor to find two non-duplicate integers in an array</a></li><li><a href="http://traceformula.blogspot.com/2015/08/single-number-ii-how-to-come-up-with.html">Single Number II : How to come up with Bit Manipulation Formula</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Single-Number-I&quot;&gt;&lt;a href=&quot;#Single-Number-I&quot; class=&quot;headerlink&quot; title=&quot;Single Number I&quot;&gt;&lt;/a&gt;Single Number I&lt;/h1&gt;&lt;p&gt;问题：给定一个数组，除了其中一个数出</summary>
      
    
    
    
    <category term="algorithms" scheme="https://chaomai.github.io/categories/algorithms/"/>
    
    
    <category term="bit manipulation" scheme="https://chaomai.github.io/tags/bit-manipulation/"/>
    
  </entry>
  
  <entry>
    <title>home is our world</title>
    <link href="https://chaomai.github.io/2016/2016-02-01-home-is-our-world/"/>
    <id>https://chaomai.github.io/2016/2016-02-01-home-is-our-world/</id>
    <published>2016-02-01T14:48:59.000Z</published>
    <updated>2021-06-27T14:57:29.268Z</updated>
    
    <content type="html"><![CDATA[<p>临近春节，想起了前两个月重温的游戏，HomeWorld。</p><p>2008年，高中时，我首次接触到了HomeWorld 2，游戏的画面和操作深深的震撼我。这个游戏是首个完全的3D RTS、视角能够3D旋转、舰船可以在空间中任意移动，不限于一个平面、舰船精细的建模和纹理，这些让我很长时间都沉浸在游戏当中。</p><p><img data-src="/images/2016/homeworld_hyper_space_jump.jpg"></p><p>后来了解到这个游戏是一个系列，还有1999年发布的HomeWorld和2000的Homeworld: Cataclysm，而二代是2003年的，一代发布之初就夺得了多项重量级的大奖。由于从二代到一代画面和操作的落差有点大，最后没有把一代通关。对于Homeworld: Cataclysm，当时没有买到游戏cd，也找不到下载，这一作也没有玩，</p><p>玩过二代以后，就一直关注着这个游戏的后续进展。在街边买过“HomeWorld 3”（其实是2代+高达Mod），发现Relic在2003年就公布了HomeWorld的源码以后，也在Linux下折腾过一代。</p><p>一代和二代的开发团队是Relic，也叫水雷社，进入游戏时的水雷动画，至今还历历在目。Relic的第一个作品便是Homeworld，后续开发的游戏也基本都是RTS的。二代发布半年后，也就是2004年，THQ收购Sierra旗下的Relic，随之被收购的还有HomeWorld系列的知识产权。当时了解到这里才意识到，续作恐怕是没戏了。</p><p>直到2013年事情出现了转机，THQ破产，旗下游戏的所有权被拍卖。Gearbox最终收购下HomeWorld系列，随后便宣布重制一代和二代，但没有重制Cataclysm的消息，说是源码丢了。。。</p><p><img data-src="/images/2016/homeworld_homeworld.jpg"></p><p>去年末，重制版发布半年多，我入手了。时隔7年，终于是把一代通关，也重温了二代的战役。</p><h1 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h1><p>二代的重制版相比起原版，由于引擎就是二代所用的升级版，画面上的提升不算很大，新鲜感少些，提升最大的是一代。一代的重制可谓是非常出色，精细的模型、游戏开头的黑白动画重画、即时演算动画的内容也与原作一致。</p><h1 id="音乐和配音"><a href="#音乐和配音" class="headerlink" title="音乐和配音"></a>音乐和配音</h1><p>Paul Ruskay是HomeWorld系列的配乐的作曲者，他最值得瞩目的作品便是HomeWorld的配乐，带有中东气息的配乐和吟唱为Ruskay赢得了很多奖项。一代和二代的背景音乐都是相当不错的，很好的展现了在无垠的太空中的孤独和壮丽的奇观。</p><p>还有一个不得不提的声音，从游戏伊始直至结束的旁白和Bentusi的配音都是由Campbell Lane完成的，他被很多玩家誉为The Last Bentusi，The Voice of Bentusi。旁白的厚重感和沧桑感为游戏增色不少，而Bentusi这一种族神秘和古老的特点，完全就是由配音体现的。不幸的是2014年初，老头子因肺癌去世。</p><p>一代的主题曲Homeworld (The Ladder)是游戏的点睛之笔，主唱Anderson的填词很好的诠释了Hiigarans和他们返回家乡的历程。由于版权问题，重制版中并未包含。</p><h1 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h1><p>HomeWorld其实只有一个主题，回家。</p><p><img data-src="/images/2016/homeworld_path.jpg"></p><p>Peter Watts创作了一代和二代的剧情。一代，Hiigarans先被流放，而后拓荒者Kushan经历千山万水，重重阻难，最终回到家乡Hiigara的故事，而二代重夺Hiigara要逊色一些。</p><h1 id="You-are-here"><a href="#You-are-here" class="headerlink" title="You are here"></a>You are here</h1><p>隔了7年，重新再玩HomeWorld，我已经不像当时，被Kushan、受难的Hiigara和舍生取义的Bentusi打动。但游戏制作人员名单最后的一个画面打动了我，随着音乐结束，屏幕上的星星越来越多时，一个箭头指向了一个星星，</p><p><img data-src="/images/2016/homeworld_you_are_here.jpg"></p><p>这即代表了玩家多年的等待，也说出了在这浩瀚宇宙中，人类不过是沧海一粟。</p><p>感谢Peter Watts、Paul Ruskay、Campbell Lane，感谢Relic、Sierra和Gearbox。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;临近春节，想起了前两个月重温的游戏，HomeWorld。&lt;/p&gt;
&lt;p&gt;2008年，高中时，我首次接触到了HomeWorld 2，游戏的画面和操作深深的震撼我。这个游戏是首个完全的3D RTS、视角能够3D旋转、舰船可以在空间中任意移动，不限于一个平面、舰船精细的建模和纹理</summary>
      
    
    
    
    <category term="game" scheme="https://chaomai.github.io/categories/game/"/>
    
    
    <category term="homeworld" scheme="https://chaomai.github.io/tags/homeworld/"/>
    
  </entry>
  
  <entry>
    <title>素数相关问题及算法</title>
    <link href="https://chaomai.github.io/2016/2016-01-18-the-prime-and-realted-algorithms/"/>
    <id>https://chaomai.github.io/2016/2016-01-18-the-prime-and-realted-algorithms/</id>
    <published>2016-01-18T07:38:59.000Z</published>
    <updated>2021-06-27T14:57:29.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h1><p>根据素数的定义，对于自然数$n$，只要能够找到除了1和它本身以外，能够整除该数的正整数，那么它就不是素数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> &amp;&amp; i != n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又因为，如果$d$是$n$的约数，那么$n=d \times n/d$，故$n/d$也是，且$\min{d, n/d} \leq \sqrt{n}$,</p><p>因此只需要测试到$\sqrt{n}$即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// i won&#x27;t equal to n, so i != n is unnecessary.</span></span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法需要约$2^{n/2}/((n/2)\ln 2)$次测试。</p><h1 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h1><p>对于单个小整数，试除法尚可，但是如果要枚举$n$以内的素数，使用试除法就需要对$n$以内的所有自然数都做测试，效率太低。</p><p>埃拉托斯特尼筛法，简称埃氏筛，从2开始，将每个素数的所有倍数标记为合数，如果这个$n$小于最后一个标出的素数的平方，那么所有小于$n$且未标记的都是素数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i * i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i * j &lt;= n) &#123;</span><br><span class="line">            isPrime[i * j] = <span class="literal">false</span>;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>埃氏筛的时间复杂度为$O(n\log n \log n)$，但这个方法最大的问题在于，需要的内存随着$n$的增大而增大。</p><h1 id="整数分解"><a href="#整数分解" class="headerlink" title="整数分解"></a>整数分解</h1><h2 id="试除法-1"><a href="#试除法-1" class="headerlink" title="试除法"></a>试除法</h2><p>分解整数，普通方法是用短除法，从最小的素数除起，知道结果为素数为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是从最小的素数除起，上述代码在每次<code>++i</code>后，为什么不检测<code>i</code>是否为素数？</p><p>原因是，内层循环相当于已经把当前<code>i</code>的所有倍数去除了，类似埃氏筛，故下次取到的能够整除$n$的<code>i</code>是素数。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="https://en.wikipedia.org/wiki/Trial_division">Trial division</a></li><li><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a></li><li><a href="http://algorithm.yuanbin.me/zh-hans/basics_algorithm/math/prime.html">Prime</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;试除法&quot;&gt;&lt;a href=&quot;#试除法&quot; class=&quot;headerlink&quot; title=&quot;试除法&quot;&gt;&lt;/a&gt;试除法&lt;/h1&gt;&lt;p&gt;根据素数的定义，对于自然数$n$，只要能够找到除了1和它本身以外，能够整除该数的正整数，那么它就不是素数。&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="algorithms" scheme="https://chaomai.github.io/categories/algorithms/"/>
    
    
    <category term="prime" scheme="https://chaomai.github.io/tags/prime/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数</title>
    <link href="https://chaomai.github.io/2016/2016-01-04-cpp-virtual-function/"/>
    <id>https://chaomai.github.io/2016/2016-01-04-cpp-virtual-function/</id>
    <published>2016-01-04T13:03:55.000Z</published>
    <updated>2021-06-27T14:57:29.267Z</updated>
    
    <content type="html"><![CDATA[<p>C++中有编译时多态和运行时多态，运行时多态是由虚函数实现的。虚函数是用过虚函数表（vftable，virtual function table）来实现的，这个表包含了这个类的虚函数地址，解决了继承、覆盖。当使用父类指针来操作一个子类对象的时候，通过子类对象的虚函数表指针（vfptr，virtual function table pointer）找到子类的vftable，进而找到应该调用的函数。</p><h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>当一个类声明了虚函数或者继承了带有虚函数的父类，这个类就会有自己的vftable。vftable的实现大都为一个函数指针数组，每个函数指针指向该类的一个虚函数，同时该类的每个对象都会包含一个vfptr，vfptr指向vftable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::a&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::b&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::c&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base::d&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义一个<code>Base</code>类型对象，<code>Base b</code>，<code>b</code>的vfptr如下：</p><p><img data-src="/images/2016/cpp_virtual_function_base_b.png"></p><ul><li>address of vfptr: <code>&amp;b</code>,</li><li>address of vftable: <code>*(int*)(&amp;b)</code>,</li><li>address of the first function in vftable: <code>(int*)(*(int*)(&amp;b))</code>,</li><li>the first function pointer: <code>(void(*)(void))*(int*)(*(int*)(&amp;b))</code>,</li><li>the second function pointer: <code>(void(*)(void))*((int*)*(int*)(&amp;b) + 1)</code> or <code>(void(*)(void))*(int*)(*(int*)(&amp;b) + 4)</code>,</li><li>the third function pointer: <code>(void(*)(void))*((int*)*(int*)(&amp;b) + 2)</code> or <code>(void(*)(void))*(int*)(*(int*)(&amp;b) + 8)</code>.</li></ul><h1 id="一般继承"><a href="#一般继承" class="headerlink" title="一般继承"></a>一般继承</h1><h2 id="无虚函数override"><a href="#无虚函数override" class="headerlink" title="无虚函数override"></a>无虚函数override</h2><p>对于一般继承、无虚函数override的情况，虚函数按照声明顺序放在表中，父类的虚函数在子类的虚函数前。</p><h2 id="有虚函数override"><a href="#有虚函数override" class="headerlink" title="有虚函数override"></a>有虚函数override</h2><p>如果有覆盖，那么被覆盖的虚函数被替换为子类中的函数，没有被覆盖的虚函数不变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::a&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::ad&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::bd&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::cd&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义一个<code>Base</code>类指针，<code>Base* bd = new Derived()</code>，<code>bd</code>的vfptr下如下：</p><p><img data-src="/images/2016/cpp_virtual_function_derived_bd.png"></p><p>上图并未列出在<code>Derived</code>定义的三个函数，查看<code>bd</code>处内存，</p><p><img data-src="/images/2016/cpp_virtual_function_derived_bd_mem.png"></p><p>前12 byte是前面列出的，接下来的12 byte就是<code>Derived::ad()</code>、<code>Derived::bd()</code>和<code>Derived::cd()</code>，可以通过<code>((void(*)(void))*((int*)*(int*)bd + 3))()</code>等调用。</p><h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><h2 id="无虚函数override-1"><a href="#无虚函数override-1" class="headerlink" title="无虚函数override"></a>无虚函数override</h2><p>对于没有虚函数覆盖的多重继承，每个父类都有自己的虚函数表，按照声明顺序，子类的成员函数被放到了第一个父类的表中。</p><h2 id="有虚函数override-1"><a href="#有虚函数override-1" class="headerlink" title="有虚函数override"></a>有虚函数override</h2><p>如果有虚函数覆盖，那么每个父类虚函数表中被覆盖的虚函数被替换为子类的函数指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base1::a&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base1::b&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base1::c&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base1::d&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base2::a&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base2::b&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base2::c&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base2::d&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base, <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::a&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::ad&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::bd&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::cd&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义一个<code>Base</code>类指针，<code>Base* bd = new Derived()</code>，<code>bd</code>的vfptr下如下：</p><p><img data-src="/images/2016/cpp_virtual_function_multi_derived_bd.png"></p><p>三个vfptr可分别由<code>(int*)*(int*)bd</code>、<code>(int*)*((int*)bd+1)</code>和<code>(int*)*((int*)bd+2)</code>得到，或者以数组的方式<code>(int*)(((int*)bd)[0])</code>、…。</p><h1 id="访问non-public函数"><a href="#访问non-public函数" class="headerlink" title="访问non-public函数"></a>访问non-public函数</h1><p>只要有类中定义了虚函数，那么一定有虚函数表。通过指针访问虚函数表的方式，就算虚函数是non-public的，也能够访问到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived1::ad&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived1::bd&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cd</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived1::cd&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived1* bd1 = <span class="keyword">new</span> Derived1();</span><br><span class="line">pf = (<span class="keyword">void</span>(*)(<span class="keyword">void</span>))*((<span class="keyword">int</span>*)*(<span class="keyword">int</span>*)bd1);</span><br><span class="line">pf();</span><br></pre></td></tr></table></figure><h1 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h1><p>Visual Studio 2015, platform x86。在Visual Studio 2015、platform x86下, <code>sizeof(int) = 4</code>, <code>sizeof(int*) = 4</code>。</p><p>如果是x64，则<code>sizeof(int*) = 8</code>，那么无论是在LP64（Linux常用）下，还是在LLP64（Windows）下，<code>(int*)(*(int*)(&amp;b))</code>并不能得到vftable中第一个函数的正确地址，解引用截断了高4 byte，把高4 byte的值作为<code>int</code>。如果vftable的正确地址是<code>0x00007ff6 1f5aaf08</code>，那么<code>(int*)(*(int*)(&amp;b))</code>得到的是<code>0x00000000 1f5aaf08</code>。</p><p>与此同时，不同的编译器对vfptr和vftable可能有不同的实现方式，上述访问方法不一定能够在其他编译器中使用。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://www.viva64.com/en/t/0012/">Data model</a></li><li><a href="http://glgjing.github.io/blog/2015/01/03/c-plus-plus-xu-han-shu-qian-xi/">C++虚函数浅析</a></li><li><a href="http://blog.csdn.net/haoel/article/details/1948051">C++ 虚表解析</a></li><li><a href="http://www.rudy-yuan.net/archives/128/">对陈皓博客《C++虚函数解析》的补充</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++中有编译时多态和运行时多态，运行时多态是由虚函数实现的。虚函数是用过虚函数表（vftable，virtual function table）来实现的，这个表包含了这个类的虚函数地址，解决了继承、覆盖。当使用父类指针来操作一个子类对象的时候，通过子类对象的虚函数表指针（</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="virtual" scheme="https://chaomai.github.io/tags/virtual/"/>
    
  </entry>
  
  <entry>
    <title>CKDTree(3)</title>
    <link href="https://chaomai.github.io/2015/2015-12-13-ckd-3/"/>
    <id>https://chaomai.github.io/2015/2015-12-13-ckd-3/</id>
    <published>2015-12-13T06:19:05.000Z</published>
    <updated>2021-06-27T14:57:29.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h1><p>使用的方法同样来自Trevor Brown。在他的论文，Range Queries in Non-blocking k-ary Search Trees中，阐述了如何实现range query。</p><p>由于进行range query时，需要tree局部的一个constant view，因此snapshot是一个合适的工具。</p><p>在update操作中，这里方法比先前的方法多了一个操作：每个leaf都带有一个<code>dirty</code> field。每次进行update时，就把old leaf的<code>dirty</code>设为dirty（实现的时候，是把update info放到<code>dirty</code>）。</p><p>进行snapshot的时候，</p><ol><li>把所有leaf都放到一个list，<code>snap</code>里面，</li><li>检测<code>snap</code>中每个leaf的<code>dirty</code>。如果发现<code>dirty</code>已被设置为update info，那么就help update info，并重新开始snapshot。</li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>Range Queries in Non-blocking k-ary Search Trees, Trevor Brown, Hillel Avni</li></ol>]]></content>
    
    
    <summary type="html">这篇是实现concurrent KDTree snapshot的第3个方法，也是打算写的最后一个方法。使用的方法来自的Range Queries in Non-blocking k-ary Search Trees。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="snapshot" scheme="https://chaomai.github.io/tags/snapshot/"/>
    
    <category term="ckdtree" scheme="https://chaomai.github.io/tags/ckdtree/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Range Queries in Non-blocking k-ary Search Trees</title>
    <link href="https://chaomai.github.io/2015/2015-12-12-notes-of-k-ary-range-query/"/>
    <id>https://chaomai.github.io/2015/2015-12-12-notes-of-k-ary-range-query/</id>
    <published>2015-12-12T06:20:46.000Z</published>
    <updated>2021-06-27T14:57:29.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Approaches-to-Range-Queries"><a href="#Approaches-to-Range-Queries" class="headerlink" title="Approaches to Range Queries"></a>Approaches to Range Queries</h1><ul><li>STM</li><li>Lock</li><li>Persistent data structures</li><li>Snapshot<ul><li>Ctrie</li><li>Snap</li></ul></li></ul><h1 id="Range-Query-in-k-ary-Search-Trees"><a href="#Range-Query-in-k-ary-Search-Trees" class="headerlink" title="Range Query in k-ary Search Trees"></a>Range Query in k-ary Search Trees</h1><h2 id="dirty-field"><a href="#dirty-field" class="headerlink" title="dirty field"></a><code>dirty</code> field</h2><p>The <code>dirty</code> field is set to dirty when the leaf is affected by some update operations (<code>helpInsert</code> and <code>helpMark</code>).</p><h2 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a><code>Validate</code></h2><p>The <code>Validate</code> check all leaves stored in <code>snap</code>. If any <code>dirty</code> field is true, than <code>Validate</code> returns false.</p><h2 id="Range-Query"><a href="#Range-Query" class="headerlink" title="Range Query"></a>Range Query</h2><p>The abridged <code>RangeQuery</code> follows few steps,</p><ol><li>Use DFS to populate <code>snap</code> with all leaves that may contain a key in range.</li><li>Invoke <code>Validate</code> to check all the leaves stored in <code>snap</code>. If <code>Validate</code> returns false, than retry.</li><li>Extract all keys in range from <code>snap</code> and return.</li></ol><h1 id="Differences-between-snaphots-in-BST-and-range-query-in-k-ary-search-trees"><a href="#Differences-between-snaphots-in-BST-and-range-query-in-k-ary-search-trees" class="headerlink" title="Differences between snaphots in BST and range query in k-ary search trees"></a>Differences between snaphots in BST and range query in k-ary search trees</h1><table><thead><tr><th>-</th><th align="center">snapshots in BST</th><th align="center">range query in k-ary search trees</th></tr></thead><tbody><tr><td>Efficiency</td><td align="center">low (iterate all nodes while checking)</td><td align="center">high</td></tr><tr><td>Scope</td><td align="center">global</td><td align="center">partial</td></tr></tbody></table><p><em>Just personal opinion, may contain errors.</em></p><h1 id="Some-Doubts"><a href="#Some-Doubts" class="headerlink" title="Some Doubts"></a>Some Doubts</h1><h2 id="Theorem-3-in-Proof"><a href="#Theorem-3-in-Proof" class="headerlink" title="Theorem 3 in Proof"></a>Theorem 3 in Proof</h2><p>In the paper,</p><blockquote><p>Theorem 3. All operations are non-blocking.</p></blockquote><p>After discussing this with Keren, both of us feel it should be a bug.</p><p>But actually it’s correct.</p><blockquote><p>My question:<br>If the update operations are always exist (insertion and deletion are frequently invoked), than <code>RangeQuery</code> cannot return. So the <code>RangeQuery</code> is actually blocked by these update operations.</p><p>Answer from Brown:<br>However, your intuition about range queries blocking is not quite correct. What you are referring to is <strong>starvation</strong>. <strong>Starvation can happen in any algorithm that is not wait-free.</strong> In order to be non-blocking, the algorithm simply needs to guarantee that, if operations are performed infinitely often, then operations will succeed infinitely often. (I.e., the system, as a whole, makes progress, even if some thread(s) starve.) Equivalently, a non-blocking progress guarantee simply states that it is impossible for /all/ threads to block forever. In your example, the fact that a range query is blocked by updates is not a problem, because the updates make progress.</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>Non-blocking k-ary Search Trees, Trevor Brown, Joanna Helga</li><li>Range Queries in Non-blocking k-ary Search Trees, Trevor Brown, Hillel Avni</li></ol>]]></content>
    
    
    <summary type="html">这篇是k-ary的第二篇，为k-ary加入了range query，列举了range query的各种实现方法：STM，lock，Persistent data structures和snapshots，并说明各种方法的优劣，提出了range query的新方法。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="k-ary search tree" scheme="https://chaomai.github.io/tags/k-ary-search-tree/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Non-blocking k-ary Search Trees</title>
    <link href="https://chaomai.github.io/2015/2015-11-30-notes-of-k-ary/"/>
    <id>https://chaomai.github.io/2015/2015-11-30-notes-of-k-ary/</id>
    <published>2015-11-30T07:09:25.000Z</published>
    <updated>2021-06-27T14:57:29.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="About-k-ary-Search-Trees"><a href="#About-k-ary-Search-Trees" class="headerlink" title="About k-ary Search Trees"></a>About k-ary Search Trees</h1><ul><li>No duplicate key</li><li>Leaf-oriented k-ST</li><li>Each leaf has zero children and at most k - 1 keys</li><li>Each internal node has exactly k children and k − 1 keys (in increasing order)</li></ul><p>Non-blocking k-ary Search Trees需要平衡，tree的深度和每个internal node进行search和update时的work总量。</p><p>大的k–&gt;减少tree的depth，但是增加了每个internal node进行search和update时的work总量。</p><p>k = 4的时候，在高contention和低contention的情况下，性能都是最好的。<br>高contention时，较少的小k减少了update时影响到的key的数目，增加了并行度；低contention时，较少的depth加快了search，加快了update。</p><h1 id="From-BST-to-k-ary-Search-Trees"><a href="#From-BST-to-k-ary-Search-Trees" class="headerlink" title="From BST to k-ary Search Trees"></a>From BST to k-ary Search Trees</h1><ul><li>Insert: the BST’s insertion -&gt; sprouting insertion</li><li>Delete: the  BST’s deletion -&gt; pruning deletion</li><li>Coordination: extended from BST</li></ul><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><h2 id="Nodes"><a href="#Nodes" class="headerlink" title="Nodes"></a>Nodes</h2><p>Each <strong>leaf</strong> has zero children and <strong>at most</strong> k − 1 keys (zero keys is permitted). Each <strong>internal node</strong> has exactly k children and k − 1 keys. Inside each node, keys are maintained in <strong>increasing order</strong>.</p><h2 id="Dummy-Nodes"><a href="#Dummy-Nodes" class="headerlink" title="Dummy Nodes"></a>Dummy Nodes</h2><p>Dummy nodes are used in BST to avoid special cases when there is no parent or grandparent to flag and mark. The following pruning deletion operation will meet similar problem. When perform pruning deletion, the leaf may <em>won’t have a parent or grandparent</em>. To avoid dealing with that, <strong>dummy nodes</strong> and <strong>empty leaves</strong> used again when initializing the tree.</p><p><img data-src="/images/2015/k-ary_dummy.png"></p><ul><li>Dummy nodes: each have k − 1 keys valued $\infty$.</li><li>Empty leaves: 2k - 1 empty keys in total.</li></ul><h1 id="Sequential-Operations"><a href="#Sequential-Operations" class="headerlink" title="Sequential Operations"></a>Sequential Operations</h1><h2 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h2><p>Search for the key first.</p><h3 id="Sprouting-Insertion"><a href="#Sprouting-Insertion" class="headerlink" title="Sprouting Insertion"></a>Sprouting Insertion</h3><p>If the leaf is full, replaces the leaf by a <em>newly created</em> subtree.</p><p>The newly created subtree:</p><ul><li>The k - 1 greatest keys among the original k - 1 keys and the new key.</li><li>The children are k (the original k - 1 keys and the new key) <em>new</em> nodes.</li></ul><h3 id="Simple-Insertion"><a href="#Simple-Insertion" class="headerlink" title="Simple Insertion"></a>Simple Insertion</h3><p>If the leaf is full, replaces the leaf by a <em>newly</em> leaf with k keys (the original k - 1 keys and the new key).</p><h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h2><p>First search for the key.</p><h3 id="Pruning-Deletion"><a href="#Pruning-Deletion" class="headerlink" title="Pruning Deletion"></a>Pruning Deletion</h3><p>If the leaf has one key <strong>and</strong> the parent of leaf has <em>exactly two non-empty children</em>, replace the parent with the sibling of leaf.</p><h3 id="Simple-Deletion"><a href="#Simple-Deletion" class="headerlink" title="Simple Deletion"></a>Simple Deletion</h3><p>If the leaf has more than one key <strong>or</strong> the parent of leaf has more than two non-empty children, replace the leaf by a <em>new</em> leaf with key removed.</p><h1 id="Coordination"><a href="#Coordination" class="headerlink" title="Coordination"></a>Coordination</h1><p>Interleaved execution between concurrent updates in some particular order may cause problems (of cause).</p><p>The Coordination is similar to BST, but here the scheme is extended.</p><p>The following <code>UpdateStep</code> (<code>ReplaceFlag</code>, <code>PruneFlag</code> and <code>Mark</code>) objects is just like lock.</p><h2 id="ReplaceFlag"><a href="#ReplaceFlag" class="headerlink" title="ReplaceFlag"></a>ReplaceFlag</h2><p>For both types of insertion and simple deletion.</p><h2 id="PruneFlag"><a href="#PruneFlag" class="headerlink" title="PruneFlag"></a>PruneFlag</h2><p>For pruning deletion.</p><h2 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h2><p>Before an internal node is to disappear from the tree, it must ﬁrst be marked. Once a internal node is marked, its child pointer will never be changed.</p><h2 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h2><p>Initial stat of the <code>pending</code> filed in internal node.</p><h1 id="Help-Mechanism"><a href="#Help-Mechanism" class="headerlink" title="Help Mechanism"></a>Help Mechanism</h1><p>If an operation is unexpectedly delayed while holding access to a ﬂagged or marked node, the progress cannot be guaranteed. So helping mechanism is necessary. The method taken here is similar to the one in BST.</p><p>But the helping <strong>should not be abused</strong>. To avoid many <em>duplicate operation</em>, the helping is used in limited cases.</p><h1 id="On-The-Whole"><a href="#On-The-Whole" class="headerlink" title="On The Whole"></a>On The Whole</h1><p>Just for clear the thought.</p><p>The following picture isn’t presented in the paper. Because the idea in the paper is similar to BST. So it easy to imitate the original one in BST.</p><p><img data-src="/images/2015/k-ary_states.png"></p><p><code>ReplaceFlag</code> is used in simple insertion, sprouting insertion and simple deletion. So the original notations, <code>ichild ...</code>, <code>dchild ...</code>, etc won’t apply.</p><h1 id="Differences-between-BST-and-k-ary-Search-Trees"><a href="#Differences-between-BST-and-k-ary-Search-Trees" class="headerlink" title="Differences between BST and k-ary Search Trees"></a>Differences between BST and k-ary Search Trees</h1><h2 id="Deletion-1"><a href="#Deletion-1" class="headerlink" title="Deletion"></a>Deletion</h2><p>There two types of deletion in k-ary Search Trees. And a particular interleave of insertion and deletion would result in key lost.</p><p><img data-src="/images/2015/k-ary_deletion.png"></p><p>Suppose there are some nodes in k-ary search tree (see above figure) and two threads concurrently perform update.</p><ul><li>Thread ti: insert d at b (the order doesn’t mater)</li><li>Thread td: delete b</li></ul><p>The following operation sequence is executed (direction of child isn’t mentioned, but it should be fairly easy to see),</p><ol><li>td: <code>PruneFlag</code> gp</li><li>ti: <code>ReplaceFlag</code> p<br>from now on, the p won’t be marked by td until ti finished.</li><li>ti: Finish insertion and <code>Clean</code> p</li><li>td: Mark p</li><li>td: Change the pointer in gp to s</li></ol><p><strong>Consequence:</strong> Insertion of key, d is lost. :(</p><p>The problem is that pruning deletion changes the child of gp to the child of p without knowing the modification in the another child of p.</p><p>Above problem won’t happen in BST’s deletion, <em>since the new node (internal node or leaf) is always built from scratch.</em></p><p>So the <code>pending</code> of p must be read before <code>PruneFlag</code> set at gp and checked when performing mark cas. If any insertion occurred, the <code>pending</code> of p will be bound to changed and deletion will perform backtracking cas and restart.</p><p>BTY: In BST and k-ary search tree, the <code>pending</code> of p is already  read by the end of search and the above prerequisites in implementation is <strong>already done</strong>. <em>But it has special purpose and meaning here.</em></p><h1 id="Some-Doubts"><a href="#Some-Doubts" class="headerlink" title="Some Doubts"></a>Some Doubts</h1><h2 id="CAS-and-CASet"><a href="#CAS-and-CASet" class="headerlink" title="CAS and CASet"></a>CAS and CASet</h2><p>In k-ary search trees, CASet (compare-and-set) is used to implement CAS.But the prerequisites is the algorithm doesn’t suffer from the ABA problem.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.CAS(expect, value)</span><br><span class="line">  result &#x3D; read(x)</span><br><span class="line">  if (result !&#x3D; expect) return result</span><br><span class="line">  if (x.CASet(expect, value)) return expect</span><br><span class="line">  return read(x)</span><br></pre></td></tr></table></figure><p>The reason why these algorithms doesn’t suffer from ABA problem is quite clear for me. But what does the prerequisites (doesn’t suffer from the ABA) for?</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>Non-blocking k-ary Search Trees, Trevor Brown, Joanna Helga</li><li>Non-blocking Binary Search Trees, Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel</li></ol>]]></content>
    
    
    <summary type="html">Brown在Toronto大学读PhD期间写过2篇关于k-ary的文章，他读PhD期间的导师是Ellen，而Ellen正是写了Non-blocking Binary Search Trees的那位。这篇文章里看到了好几个methods或者ideas是extended from Non-blocking Binary Search Trees。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="k-ary search tree" scheme="https://chaomai.github.io/tags/k-ary-search-tree/"/>
    
  </entry>
  
  <entry>
    <title>CKDTree (2)</title>
    <link href="https://chaomai.github.io/2015/2015-11-24-ckd-2/"/>
    <id>https://chaomai.github.io/2015/2015-11-24-ckd-2/</id>
    <published>2015-11-24T07:17:25.000Z</published>
    <updated>2021-06-27T14:57:29.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h1><p>这里使用的方法是Trevor Brown的non-blocking binary search tree的<a href="http://www.cs.utoronto.ca/~tabrown/ksts/StaticDictionary5.java">实现</a>里面提到的，并没有在论文里说明。</p><p>基本思想非常简单，</p><ol><li>读取并保存所有node；</li><li>接着检查已保存的node与当前tree里的node是否都一样，发现不一样的，重新snapshot；</li><li>基于已保存的node，构建一棵新的tree，返回snapshot。</li></ol><p>这里的snapshot和上一篇中的就有很大不同。上一篇的snapshot基本上可以算作是在调用<code>snapshot()</code>的时候，tree的状态（特殊情况下需要retry）；而这里的必须保证，从第1步完成读取的时刻起，到第2步检查结束，都没有update发生，才能返回snapshot。</p><p>要注意的是，在第1和2步中，需要保存和检查所有的node（internal node和leaf）。这不同于使用GCAS的snapshot，只update internal node，在某些时刻，某些leaf实际上是共享的。</p><h1 id="size-in-Snapshot"><a href="#size-in-Snapshot" class="headerlink" title="size in Snapshot"></a><code>size</code> in Snapshot</h1><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://www.cs.utoronto.ca/~tabrown/ksts/StaticDictionary5.java">http://www.cs.utoronto.ca/~tabrown/ksts/StaticDictionary5.java</a>, Trevor Brown</li></ol>]]></content>
    
    
    <summary type="html">这篇记录了另一种简单的方法来实现concurrent KDTree snapshot，当然简单是有代价的，那就是在snapshot的时候不允许并发的update（inset，delete）。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="snapshot" scheme="https://chaomai.github.io/tags/snapshot/"/>
    
    <category term="ckdtree" scheme="https://chaomai.github.io/tags/ckdtree/"/>
    
  </entry>
  
  <entry>
    <title>CKDTree (1)</title>
    <link href="https://chaomai.github.io/2015/2015-11-20-ckd-1/"/>
    <id>https://chaomai.github.io/2015/2015-11-20-ckd-1/</id>
    <published>2015-11-20T07:55:08.000Z</published>
    <updated>2021-06-27T14:57:29.265Z</updated>
    
    <content type="html"><![CDATA[<p>Concurrent KDTree with Snapshots, implemented in Java. This article is about some details in implementation.</p><h1 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h1><p>The methods used in this structure is heavily based on ideas in CTrie (snapshot) and Non-blocking Binary Search Trees (search, insert and delete).</p><ul><li>RDCSS</li><li>GCAS</li><li>Mark and Flag</li><li>Leaf-oriented tree</li></ul><h1 id="Problems-and-Solutions-in-Implementation"><a href="#Problems-and-Solutions-in-Implementation" class="headerlink" title="Problems and Solutions in Implementation"></a>Problems and Solutions in Implementation</h1><p>下面是实现的时候遇到的问题和自己对一些细节的思考，有的已经在两篇论文里面有所记录，但是自己没注意，又踩坑了，还有的是这个结构的设计隐含的问题。</p><h2 id="Dummy-Nodes"><a href="#Dummy-Nodes" class="headerlink" title="Dummy Nodes"></a>Dummy Nodes</h2><p>由于Non-blocking Binary Search Trees中的insert操作是需要mark parent的，因此，对于一棵空的tree（有一个root），parent并不存在，insert无法适用于这样的情况。delete也有类似的问题。</p><p>为了避免结点数目很少的时候需要考虑很多复杂的情况，Non-blocking Binary Search Trees里提到了使用两个key为$\infty_1$，$\infty_2$（其中$\infty_1 &lt; \infty_2$）的Dummy nodes，$\infty_1 &lt; \infty_2$这样的关系是为了保证Binary Search Trees的性质。</p><p>由于Java中，无法使用<code>Double.POSITIVE_INFINITY</code>来得到两个key，使得$\infty_1 &lt; \infty_2$，所以就干脆不管他们的关系，root的左右child都使用<code>Double.POSITIVE_INFINITY</code>作为key。</p><p><img data-src="/images/2015/ckd1_2015_11_18_16_42_Office_Lens.jpg"></p><p>这样一来，</p><ol><li>只有在insert第一个key或者delete最后一个key的时候需要操作leaf dummy node。</li><li>除（1）以外，所有update都发生在上图三角形的sub tree里面。</li></ol><h2 id="Right-Child-of-Root"><a href="#Right-Child-of-Root" class="headerlink" title="Right Child of Root"></a>Right Child of Root</h2><p>既然没有key会进入root的right child，那么为什么不把root的right child设置为<code>null</code>。</p><p>不行，这个也是在写后续代码的时候发现的。进行<code>helpMark1</code>和<code>helpMark2</code>的时候，需要判断<code>GCAS</code>处理grand parent哪边的child，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (info.p == info.gp.GCAS_READ_LEFT_CHILD(<span class="keyword">this</span>)) &#123;</span><br><span class="line">  direction = Direction.LEFT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  direction = Direction.RIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要delete的leaf是children of the left child of root，也就是说此时tree里面只有一个key。存在这么一种可能性，同时有多个thread来进行delete，其中一个thread已经成功进行了delete，其他某些的thread还没有执行上述代码。当开始执行以后，就会发现<code>p</code>不等于<code>gp</code>（即root）的left child，此时如果root的right为<code>null</code>，那么就会出错。</p><p><code>helpMark1</code>和<code>helpMark2</code>都包含上述操作，只是仅仅<code>helpMark1</code>才会触发问题。</p><h2 id="Type-Test-in-helpMarked1"><a href="#Type-Test-in-helpMarked1" class="headerlink" title="Type Test in helpMarked1"></a>Type Test in <code>helpMarked1</code></h2><p>当要delete的leaf，它的sibling是leaf时，<code>helpMarked1</code>来处理这种的情况。</p><p>在single thread的情况下，<code>helpDelete</code>在判断sibling的类型以后，如果是leaf，那么<code>helpMarked1</code>就会执行。</p><p>在multithread的情况下，某个thread看到update信息以后就直接执行<code>helpMarked1</code>，但是此时sibling的类型是不知道的。因为从update信息被发布，到<code>helpMarked1</code>被执行，sibling可能早就被其他thread改变了，如果变为internal node，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Leaf&lt;V&gt; ns = <span class="keyword">new</span> Leaf&lt;&gt;(sibling.key, ((Leaf&lt;V&gt;) sibling).value);</span><br></pre></td></tr></table></figure><p>那么上述代码就会报错。</p><h2 id="Mark-in-helpDelete"><a href="#Mark-in-helpDelete" class="headerlink" title="Mark in helpDelete"></a>Mark in <code>helpDelete</code></h2><p>Non-blocking Binary Search Trees提到marked的结点是不可更改的，实现的时候没有很在意，测试的时候就遇到了麻烦。</p><p><code>helpDelete</code>（1）首先mark parent，（2）read leaf的sibling，（3）根据sibling的类型来进行后续的操作。</p><p>（1）和（2）的顺序是不能改的，这也是mark的意义所在。mark以后，<code>helpMarked1</code>和<code>helpMarked2</code>中还会再次读取sibling，并用于构造新的node，然后<code>GCAS</code> grand parent的child。如果不能保证<code>helpDelete</code>中leaf的sibling在后续的操作中不变，那么构造出的新node很可能就是错的。</p><h2 id="startGen-in-searchKey"><a href="#startGen-in-searchKey" class="headerlink" title="startGen in searchKey"></a><code>startGen</code> in <code>searchKey</code></h2><p>这个结构使用了Ctrie里GCAS的idea，在search的时候来update从root到leaf的path。search使用的version number是在开始进行search前从root里read的。为什么不到每个node的时候就read一次version number？</p><p>因为如果在search到某个内部的结点的时候，执行了snapshot操作，那么root的version number就变了。此时search中read root的version number，就会造成path的错误更新，上半部分是老的version number，下面有一条新的version number的分支。</p><h2 id="Retry-after-GCAS-in-searchKey"><a href="#Retry-after-GCAS-in-searchKey" class="headerlink" title="Retry after GCAS in searchKey"></a>Retry after <code>GCAS</code> in <code>searchKey</code></h2><p><code>searchKey</code>中，如果发现要前往的branch是internal node，并且version低于<code>startGen</code>，那么就需要创建那个internal node新版本的copy，然后把cur node的branch设置为那个新版的node。</p><p>接下来，首先想到的是在cur node处重试（即下面代码里的<code>continue;</code>），但是如果<code>continue</code>了，那么<code>gp</code>，<code>gpupdate</code>和<code>depth</code>就会被“提前”更新（cur没有往下走，它们却被更新了），尤其是<code>depth</code>，可能被重复的加上了<code>p</code>的<code>skippedDepth</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cur <span class="keyword">instanceof</span> InternalNode) &#123;</span><br><span class="line">  gp = p;</span><br><span class="line">  gpupdate = pupdate;</span><br><span class="line">  ...</span><br><span class="line">  depth += p.skippedDepth;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keyCompare(key, cur.key, depth++) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (left <span class="keyword">instanceof</span> InternalNode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left.gen != startGen) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> SearchRes.RESTART;</span><br><span class="line">        <span class="comment">// continue;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>效率低些，但是更为稳妥的办法就是完全重新开始，<code>return SearchRes.RESTART;</code>。</p><h2 id="RDCSS"><a href="#RDCSS" class="headerlink" title="RDCSS"></a>RDCSS</h2><p><img data-src="/images/2015/ckd1_2015_11_19_16_26_Office_Lens.jpg"></p><h2 id="size-in-Snapshot"><a href="#size-in-Snapshot" class="headerlink" title="size in Snapshot"></a><code>size</code> in Snapshot</h2><p>未解决。</p><h2 id="Readonly-Iterator"><a href="#Readonly-Iterator" class="headerlink" title="Readonly Iterator"></a>Readonly Iterator</h2><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>Concurrent Tries with Efficient Non-Blocking Snapshots, Aleksandar Prokopec, Nathan G. Bronson, Phil Bagwell, Martin Odersky</li><li>Non-blocking Binary Search Trees, Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel</li><li>A Practical Multi-Word Compare-and-Swap Operation, Timothy L. Harris, Keir Fraser, Ian A. Pratt</li></ol>]]></content>
    
    
    <summary type="html">Concurrent KDTree with Snapshots, implemented in Java. This article is about some details in implementation.</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="snapshot" scheme="https://chaomai.github.io/tags/snapshot/"/>
    
    <category term="ckdtree" scheme="https://chaomai.github.io/tags/ckdtree/"/>
    
  </entry>
  
  <entry>
    <title>RDCSS</title>
    <link href="https://chaomai.github.io/2015/2015-10-23-rdcss/"/>
    <id>https://chaomai.github.io/2015/2015-10-23-rdcss/</id>
    <published>2015-10-23T13:42:51.000Z</published>
    <updated>2021-06-27T14:57:29.265Z</updated>
    
    <content type="html"><![CDATA[<p>RDCSS是Harris提出的一种实现double compare single swap方法，它的语义（也就是DCAS）如下，</p><p><img data-src="/images/2015/rdcss_semantic.png"></p><h1 id="The-CAS1-Approach"><a href="#The-CAS1-Approach" class="headerlink" title="The CAS1 Approach"></a>The CAS1 Approach</h1><p>下面使用CAS1（single word compare and swap）来实现RDCSS。</p><p>这是descriptor和两个data section的示意图，</p><p><img data-src="/images/2015/rdcss_descriptor.png"></p><p>下面是RDCSS的伪代码，</p><p><img data-src="/images/2015/rdcss_implementation.png"></p><ol><li><p><strong>C1：</strong>首先尝试把a2变为descriptor d，如果CAS1成功，那么r == d-&gt;o2。</p></li><li><p><strong>H1：</strong>这步主要是针对C1失败的。如果C1成功，r不是descriptor。如果C1失败，有两种原因（其实是一种，只是分开看），（1）a2的数据被其他thread改为其他的数据，（2）a2被其他thread改为descriptor，那就帮助其他thread完成。</p></li><li><p><strong>B1：</strong>如果是H1（2），那么帮助其他thread完成以后，retry。</p></li><li><p><strong><code>if(r == d-&gt;o2) Complete</code>：</strong>这步是针对C1成功的。如果C1成功，继续执行。</p></li></ol><p><em>在<a href="http://cstheory.stackexchange.com/questions/7083/a-practical-multi-word-compare-and-swap-operation">A practical multi-word compare-and-swap operation - cstheory</a>里，axel22大神问这步能不能在不改变RDCSS语义的情况下省略。回答是，如果省略<strong>RDCSS的这个部分<code>if(... &amp;&amp; (*a1 == o1)) *a2=n2</code>就不会执行</strong>。或者运气好的话，其他thread帮助当前thread完成。</em></p><ol start="5"><li><strong><code>return r</code>：</strong>返回a2里老的value，包括执行成功的情况和H1（1）。</li></ol><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>C2的if进行比较以后，会不会有其他thread改变o1？</strong></p><p>这里是一直没有想明白的。在看了Ctrie的代码以后，发现在做snapshot的时候，里面的root，mainnode和这里的Data section，Control section是对应的。要是这里存在这个问题，那么Ctrie里也存在（会不会有其他thread改变root里mainnode的reference）。</p><p>从Ctrie的角度来看，只要有thread在执行<code>RDCSS_Complete</code>，那么root一定是<code>RDCSS_Descriptor</code>。而任何thread想要更改root里mainnode，就必须首先read root。所以mainnode不会在某个thread正执行<code>RDCSS_Complete</code>的时候被改变。<br>（在上一篇，Notes of Non-Blocking Snapshots Concurrent Tries的**A detail in <code>RDCSS_Complete</code>**部分，有详细的解释。）</p><p>再回过头来看这里的RDCSS，这里的Data section会不会相当于就是一个guard，要更改Control section，就必须首先read Data section。这样，在某个thread执行<code>RDCSS_Complete</code>的时候，其他thread直接去改变o1就是不可能的。（没有在这篇论文里面找到相关的说明，这里只是自己的理解。）</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>A Practical Multi-Word Compare-and-Swap Operation, Timothy L. Harris, Keir Fraser, Ian A. Pratt</li><li><a href="http://cstheory.stackexchange.com/questions/7083/a-practical-multi-word-compare-and-swap-operation">A practical multi-word compare-and-swap operationn - cstheory</a></li></ol>]]></content>
    
    
    <summary type="html">RDCSS是Harris提出的一种实现double compare single swap方法，使用了single word compare and swap来实现。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="rdcss" scheme="https://chaomai.github.io/tags/rdcss/"/>
    
    <category term="dcas" scheme="https://chaomai.github.io/tags/dcas/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Non-Blocking Snapshots Concurrent Tries</title>
    <link href="https://chaomai.github.io/2015/2015-10-22-notes-of-non-blocking-snapshots-concurrent-tries/"/>
    <id>https://chaomai.github.io/2015/2015-10-22-notes-of-non-blocking-snapshots-concurrent-tries/</id>
    <published>2015-10-22T14:15:12.000Z</published>
    <updated>2021-06-27T14:57:29.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hash-tries"><a href="#Hash-tries" class="headerlink" title="Hash tries"></a>Hash tries</h1><p>Hash tries (Hash array mapped tries) are trees composed of internal nodes and leaves. Leaves store key-value bindings.</p><h1 id="Race"><a href="#Race" class="headerlink" title="Race"></a>Race</h1><p><img data-src="/images/2015/ctrie_conflict.png"></p><p>T1要插入k5到C2，与此同时T2要插入k4到C1。T1成功的进行了CAS，但是T2进行的CAS操作是在老的C2上，最后导致k4丢失。</p><p>这里的race类似于Non-blocking Binary Search Trees的情况，两个线程各自进行操作，就线程自己来看，所做的操作是正确的，但是相互不知道有race。</p><p><em>这个结构能否使用Non-blocking Binary Search Trees的方法（mark和flag）？</em></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>引入各种中间结点。。。</p><h1 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h1><p><code>size</code>、<code>iterator</code>和<code>clear</code>不能简单的以lock-free的方式来实现，因为需要某一时刻的全局信息。基于atomic snapshot，这些操作可以高效和正确的得到结果。</p><p>当一个snapshot被创建时，root I-node被复制，并被设置为新的generation。这个generation count可以由每个I-node保存。当某些update操作检测到它gen比root老，它就创建带有最新gen的那个I-node的copy，并根据需要update parent。snapshot创建后最终的效果就是，当首次访问（update）那个leaf的时候，从root到leaf，整个path都被update。</p><p>这里用到的snapshot方法，我觉得本质上还是copy on write。</p><h2 id="Race-1"><a href="#Race-1" class="headerlink" title="Race"></a>Race</h2><p>创建snapshot的线程、读取了老的root且正在遍历并update的线程之间（插入操作的linearization point可能会先于snapshot的创建）。</p><h2 id="GCAS-generation-compare-and-swap"><a href="#GCAS-generation-compare-and-swap" class="headerlink" title="GCAS (generation-compare-and-swap)"></a>GCAS (generation-compare-and-swap)</h2><p>直接用CAS在这里并不可行，因为有gen，就需要同时比较新老数据，还有I-node和root的gen。</p><p>GCAS类似CAS，不同的地方是加入了I-node和root结点gen的比较。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCAS</span></span>(in, old, n)</span><br><span class="line">r = <span class="type">READ</span>(in.main)</span><br><span class="line"><span class="keyword">if</span> r = old &amp;&amp; in.gen = <span class="type">READ</span>(root).gen &#123;</span><br><span class="line"><span class="type">WRITE</span>(in.main. n)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>具体的操作是先不管gen的情况，把old Main node挂到new Main node的prev上，接着把new Main node挂到I-node，最后处理I-node下Main node的情况。</p><p><img data-src="/images/2015/ctrie_gcas.png"></p><p><em>现在的问题是怎么update从root到leaf的path？</em></p><p>当遍历时遇到一个I-node，如果gen &lt; startgen，那么就创建它的C-node和这个C-node下面所有I-node的copy，这个C-node下面其他类型的node（S-node）不copy。这样就update了从root到leaf的path。</p><h2 id="RDCSS"><a href="#RDCSS" class="headerlink" title="RDCSS"></a>RDCSS</h2><p><em>问题又来了，其他I-node可以被创建copy，但是第一个I-node，即root，它并没有在C-node下面，如何创建新gen的root？</em></p><p>直接创建新gen root的copy，然后cas挂上去，这个方法并不好完成。因为只有当root和old I-node一致，且old I-node的main和old main一致（因为原文代码165行的地方，需要old main来构建新的I-node）时才行。</p><p>这里使用的RDCSS源自Harris提出的方法，类似GCAS。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RDCSS</span></span>(ov, ovmain, nv)</span><br><span class="line">r = <span class="type">READ</span>(root)</span><br><span class="line"><span class="keyword">if</span> r = ov &amp;&amp; <span class="type">GCAS_READ</span>(ov.main) = ovmain &#123;</span><br><span class="line"><span class="type">WRITE</span>(root, nv)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>要注意的是：如果两个线程，一个GCAS对root I-node进行操作，另一个RDCSS对Ctrie的root成员进行操作，那么回导致死锁（<strong>为什么？与RDCSS中</strong>（<em>C2的if进行比较以后，会不会有其他thread改变o1？</em>）<strong>这个问题有关？</strong>)。</p><p>因此引入了ABORTABLE_READ。</p><h3 id="A-detail-in-RDCSS-Complete"><a href="#A-detail-in-RDCSS-Complete" class="headerlink" title="A detail in RDCSS_Complete"></a>A detail in <code>RDCSS_Complete</code></h3><p>在阅读源码的时候，想到这么一个问题，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> oldmain = ov.gcasRead(<span class="keyword">this</span>)</span><br><span class="line"> <span class="keyword">if</span> (oldmain eq exp) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="type">CAS_ROOT</span>(desc, nv)) &#123;</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><blockquote><p>My previous doubt lies in line 711. The <code>oldmain</code> is compared with <code>expectedmain</code>. If they are reference to same main node, then do <code>CAS_ROOT</code>.<br>Suppose thread A is executing <code>RDCSS_Complete</code> and just finished line 710. Thread B is inserting a key value pair at the mainnode of root. What if thread B changes the <code>MainNode</code> reference in the root into a new mainnode before thread A execute <code>CAS_ROOT</code>?</p></blockquote><blockquote><p>The doubt is unnecessary. Since thread A is executing <code>RDCSS_Complete</code>, the root must be <code>RDCSS_Descriptor</code>. If Thread B want to insert at the <code>MainNode</code> of root, it will read root first, find it’s <code>RDCSS_Descriptor</code> and call <code>RDCSS_Complete</code> to help thread A first. So Thread B can’t change the <code>MainNode</code> reference in the root directly.</p></blockquote><p>（与Aleksandar Prokopec邮件的内容，就是问题和自己的理解，这里只是做个整理，不翻译了，其实是懒。。。）</p><h2 id="Snashot"><a href="#Snashot" class="headerlink" title="Snashot"></a>Snashot</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot</span></span>()</span><br><span class="line">r = <span class="type">RDCSS_READ</span>()</span><br><span class="line">expmain = <span class="type">GCAS_READ</span>(r)</span><br><span class="line"><span class="keyword">if</span> <span class="type">RDCSS</span>(r, expmain, <span class="keyword">new</span> <span class="type">INode</span>(expmain, <span class="keyword">new</span> <span class="type">Gen</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Ctrie</span> &#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="type">INode</span>(expmain, <span class="keyword">new</span> <span class="type">Gen</span>)</span><br><span class="line">readonly = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> snapshot()</span><br></pre></td></tr></table></figure><p><code>snapshot()</code>以后，实际上是产生了两个新的root I-node，其中一个替换Ctrie自己的root，另一个用于构成返回Ctrie，这个返回的Ctrie就是所需的snapshot。</p><p>从上面伪代码来看，可能会产生怀疑的是，<code>snapshot()</code>刚刚完成时，两个root I-node都是reference到同一个C-node。<em>如果某个线程更改了root下的C-node，那snapshot中root下的C-node也被改，snapshot还有什么意思？</em></p><p>snapshot的中的东西不会被更改，具体的原因如下，注意看版本号，</p><p><img data-src="/images/2015/ctrie_snapshot.png"></p><p>换句话说，就是当没有update或access时，Ctrie和snapshot共享结点；但是如果Ctrie发生update或access，从root到访问位置的path就被copy和update了，snapshot里的不变。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snapshot</span></span>()</span><br><span class="line">r = <span class="type">RDCSS_READ</span>()</span><br><span class="line">expmain = <span class="type">GCAS_READ</span>(r)</span><br><span class="line"><span class="keyword">if</span> <span class="type">RDCSS</span>(r, expmain, <span class="keyword">new</span> <span class="type">INode</span>(expmain, <span class="keyword">new</span> <span class="type">Gen</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Ctrie</span> &#123;</span><br><span class="line">root = r</span><br><span class="line">readonly = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> snapshot()</span><br></pre></td></tr></table></figure><p>由于当计算snapshot的size或进行iterate时，snapshot是不变的，因此update涉及到的node是不必要的开销，因此使用旧的root，且把readonly设为true来构造snapshot。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>Concurrent Tries with Efficient Non-Blocking Snapshots, Aleksandar Prokopec, Nathan G. Bronson, Phil Bagwell, Martin Odersky</li><li>Non-blocking Binary Search Trees, Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel</li><li>A Practical Multi-Word Compare-and-Swap Operation, Timothy L. Harris, Keir Fraser, Ian A. Pratt</li></ol>]]></content>
    
    
    <summary type="html">Hash trie的并发会存在操作丢失的情况，类似Non-blocking Binary Search Trees里的情况，这里引入了中间结点来解决。同时文章还提出了一种snapshot的方法，这种方法对于tree很有用。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="concurrent tries" scheme="https://chaomai.github.io/tags/concurrent-tries/"/>
    
    <category term="snapshot" scheme="https://chaomai.github.io/tags/snapshot/"/>
    
  </entry>
  
  <entry>
    <title>Miscellaneous Material about Concurrency</title>
    <link href="https://chaomai.github.io/2015/2015-10-12-miscellaneous-material-about-concurrency/"/>
    <id>https://chaomai.github.io/2015/2015-10-12-miscellaneous-material-about-concurrency/</id>
    <published>2015-10-12T13:43:54.000Z</published>
    <updated>2021-06-27T14:57:29.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cuckoo-hashing"><a href="#Cuckoo-hashing" class="headerlink" title="Cuckoo hashing"></a>Cuckoo hashing</h1><p>Cuckoo hashing是Rasmus Pagh, Flemming Friche Rodler在2001年提出的，在hash table中用于解决hash collision的一种方法，是一种开放寻址法的hash table。</p><p>Cuckoo hashing维护了两个hash table，$T_1$和$T_2$，使用两个hash function，$h_1$和$h_2$。每个key存储在$T_1$的$h_1(x)$或者$T_2$的$h_2(x)$，但不会同时存储在两个地方。</p><p>由于使用了两个hash table，Cuckoo hashing保证了在最坏情况下，lookup和delete也能有$O(1)$的时间，insert的期望时间是$O(1)$。</p><p>原始的cuckoo hashing并不支持并发读写，同时对于每个inset和lookup需要多个内存引用。Bin Fan, David G. Andersen, Michael Kaminsky在2013年提出了Concurrent Cuckoo hashing，用optimistic version，使得cuckoo hashing在保证原有空间高效性的情况下，支持多个reader和一个writer的并发访问；同时使用了针对每个key的short summary，提高了hash table操作中cache的局部性；还优化了insert操作，提高了吞吐率。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>Rasmus Pagh, Flemming Friche Rodler. Cuckoo Hashing[J]. Algorithms, 2001, 51(2).</li><li>Bin Fan, David G. Andersen, Michael Kaminsky. MemC3: Compact and Concurrent MemCache with Dumber Caching and Smarter Hashing[C]. Networked Systems Design and Implementation, 2013: 371-384.</li><li>Xiaozhou Li, David G. Andersen, Michael Kaminsky, Michael J. Freedman. Algorithmic improvements for fast concurrent Cuckoo hashing[C]. Proceedings of the Ninth European Conference on Computer Systems, 2014, 27.</li></ol><h1 id="Hopscotch-hashing"><a href="#Hopscotch-hashing" class="headerlink" title="Hopscotch hashing"></a>Hopscotch hashing</h1><p>Hopscotch hashing是Maurice Herlihy, Nir Shavit, Moran Tzafrir在2008年提出的，在hash table中用于解决hash collision的一种方法，是一种开放寻址法的hash table，结合了linear探测、链式hash和cuckoo hash的优点。</p><p>它使用了一个hash function，$h$和hopscotch方法。hash table的每个项都包含一个hop-information，一个$H$-bit的一个bitmap（$H$是常数，通常是一个word），被hash到table里的每个item，x总会在$h(x)$或者下$H-1$个位置被找到。</p><p>它的insert，remove和contains的期望时间都是常数时间。</p><p>Hopscotch hashing在设计之初就考虑到了并发，使用了lock和time stamp的方式来保证了并发安全性。</p><h2 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h2><ol><li>Maurice Herlihy, Nir Shavit, Moran Tzafrir. Hopscotch Hashing[C]. Proceedings of the 22nd international symposium on Distributed Computing, 2008: 350-364.</li></ol><h1 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h1><p>spinlock是一种同步机制，它会导致线程进入忙等待，不断检查锁是否可用，并尝试获取锁。</p><p>它避免了操作系统进行调度时的开销。</p><p>由于spinlock是忙等待，因此在多处理器上使用才有意义。spinlock在锁可能耽搁一小段时间的情况下，很高效。因为这个原因，操作系统的内核中经常使用spinlock。</p><h2 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h2><ol><li>Maurice Herlihy, Nir Shavit. The Art of Multiprocessor Programming Revised Reprint [M]. Elsevier, 2012.</li></ol><h1 id="rwlock"><a href="#rwlock" class="headerlink" title="rwlock"></a>rwlock</h1><p>Readers-writer lock是一种同步原语。在访问共享对象时，对于仅有reader的情况，是完全不需要同步的，但如果有writer，就需要同步。当一个wirter范围共享数据的时候，其他所有的writer和reader都会被阻塞，直到这个writer结束访问。</p><p>在共享数据更新很少，读取很多的情况下，Readers-writer lock会拥有很高的效率。</p><h2 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h2><ol><li>Maurice Herlihy, Nir Shavit. The Art of Multiprocessor Programming Revised Reprint [M]. Elsevier, 2012.</li></ol><h1 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h1><p>RCU是一种同步机制，在Linux内核中有广泛的用途，Linux内核2.5.43版本就开始使用RCU，截至2014年，已经使用了超过9000个RCU API。它允许reader和writer并发的访问共享数据，支持一个writer和多个reader之间的并发。通过维护多个版本的数据，RCU保证了reader读取到的数据的一致性，还保证在reader完成读取前，被访问的数据不会被释放。</p><p>RCU有3个基本机制，用于insert的Publish-Subscribe机制、用于delete的Wait For Pre-Existing RCU Readers to Complete机制和允许reader容忍并发insert和delete的Maintain Multiple Versions of Recently Updated Objects机制。</p><h2 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h2><ol><li>Paul E. McKenney, John D. Slingwine. Read-Copy Update: Using Execution History to Solve Concurrency Problems[C]. Parallel and Distributed Computing and Systems, 1998: 509–518.</li><li>Paul E. McKenney, Jonathan Walpole. Introducing technology into the Linux kernel: a case study[C]. Special Interest Group on Operating Systems, 2008, 42(5): 4–17.</li></ol><h1 id="CPU-with-HTM-from-Intel-and-IBM"><a href="#CPU-with-HTM-from-Intel-and-IBM" class="headerlink" title="CPU with HTM from Intel and IBM"></a>CPU with HTM from Intel and IBM</h1><h2 id="Intel"><a href="#Intel" class="headerlink" title="Intel"></a>Intel</h2><p>Transactional Synchronization Extensions（TSX）是x86架构指令集的扩展，这个扩展加入了Hardware Transactional Memory（HTM）的支持。</p><p>在2013年6月，Intel推出了基于Haswell微架构的处理器。Haswell处理器成为了主流处理器中首次引入Transactional Memory的处理器，在这一系列的处理器中，型号低于45xx，R系列和K系列的不支持TSX。</p><h2 id="IBM"><a href="#IBM" class="headerlink" title="IBM"></a>IBM</h2><h3 id="Power8"><a href="#Power8" class="headerlink" title="Power8"></a>Power8</h3><p>IBM在2013年8月的Hot Chips会议上推出了Power8。Power8是基于Power架构的超标量体系结构对称多处理器家族。Power8加入了Hardware Transactional Memory的支持。</p><h3 id="Blue-Gene"><a href="#Blue-Gene" class="headerlink" title="Blue Gene"></a>Blue Gene</h3><p>Blue Gene是IBM的一个项目，目标是设计计算速度能够达到PFLOPS级别的，同时低能耗的超级计算机。这个项目产生了3代的超级计算机，Blue Gene/L，Blue Gene/P和Blue Gene/Q。其中Blue Gene/Q支持Transactional Memory。</p>]]></content>
    
    
    <summary type="html">简单记录了一些关于并发的资料（hash table，spinlock，rwlock和CPU对HTM的支持）。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Non-blocking Binary Search Trees</title>
    <link href="https://chaomai.github.io/2015/2015-10-04-notes-of-non-blocking-binary-search-trees/"/>
    <id>https://chaomai.github.io/2015/2015-10-04-notes-of-non-blocking-binary-search-trees/</id>
    <published>2015-10-04T09:21:49.000Z</published>
    <updated>2021-06-27T14:57:29.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="specification"><a href="#specification" class="headerlink" title="specification"></a>specification</h1><ul><li><p>no duplicate key</p></li><li><p>deleting non-existent key leads to return false</p></li><li><p>leaf-oriented BST</p><blockquote><ul><li>all keys currently in the dictionary are <strong>stored in the leaves of the tree.</strong></li><li>Internal nodes of the tree are used to direct a Find operation along the path to the correct leaf.</li><li>The keys stored in internal nodes may or may<br>not be in the dictionary.</li></ul></blockquote></li></ul><h1 id="features"><a href="#features" class="headerlink" title="features"></a>features</h1><ul><li><p>non-blocking</p></li><li><p>linearizable</p><blockquote><p>for every execution, one can assign a linearization point to each completed operation and some of the uncompleted operations <strong>so that the linearization point of each operation occurs after the operation starts and before it ends</strong>, and the results of these operations are the same <em>as if they had been performed sequentially, in the order of their linearization points.</em></p></blockquote></li></ul><h1 id="basic-idea"><a href="#basic-idea" class="headerlink" title="basic idea"></a>basic idea</h1><p>类似Harris’ Linked List里面的做法，这里是mark the parent of the leaf before<br>splicing that parent out of the tree。一旦被标记，那么其指向子结点的指针将不能被改变。</p><h1 id="problems"><a href="#problems" class="headerlink" title="problems"></a>problems</h1><p><img data-src="/images/2015/non-block-bst_problems.png"></p><p>上图中，两个线程分别delete C和E，两个concurrent operation同时看到了BST以后，接下来的操作是，<em>基于各自看到的的BST来进行的</em>，它们彼此并不知道对方进行了什么操作，最后导致E并没有被deleted，其中一个操作丢失了。</p><p>解决这个需要对parent的child pointer进行mark，但是要mark的pointer是存在两个不同的word（left and right child pointer）里面的，不能够用一个cas来同时mark。</p><h1 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h1><p>using a separate state <strong>ﬁeld of the node</strong> to mark or flag，而不是mark那个pointer。</p><ul><li>mark: node marked is unchangeable。</li><li>flag: indicate that an update is trying to change a child pointer of the node.</li></ul><p>mark和flag类似于加锁。</p><h2 id="insert和delete"><a href="#insert和delete" class="headerlink" title="insert和delete"></a>insert和delete</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p><img data-src="/images/2015/non-block-bst_insert.png"></p><p>Insert (C):</p><ol><li>ﬂag node D’s parent, node B,</li><li>change the appropriate child pointer of node B,</li><li>unﬂag node B.</li></ol><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><img data-src="/images/2015/non-block-bst_delete.png"></p><p>Delete (C):</p><ol><li>ﬂag C’s grandparent, node B,</li><li>mark C’s parent, node D,</li><li>change the appropriate child pointer of B,</li><li>unﬂag node B.</li></ol><p>insert在完成第一步以后，在insert进行后续操作时，其他线程将不能够block insert。delete类似的，在完成第一二步以后也是。</p><p><img data-src="/images/2015/non-block-bst_delete2.png"></p><p>但是delete在完成第一步以后，第二步mark有可能失败，比如insert把将要删除的node换为新的三个node。in which case the ﬂag is no longer on the node whose child pointer must be changed to accomplish the deletion.</p><p>如果mark失败，delete会remove flag，重新开始。</p><p><img data-src="/images/2015/non-block-bst_state.PNG"></p><h1 id="some-details-in-implementation"><a href="#some-details-in-implementation" class="headerlink" title="some details in implementation"></a>some details in implementation</h1><h2 id="helping-mechanism"><a href="#helping-mechanism" class="headerlink" title="helping mechanism"></a>helping mechanism</h2><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>类似Barnes的方法，将线程拥有lock换成操作拥有lock（marked or flagged）。一个操作在处理tree的同时，还保存了它在holding lock的时候要进行的操作，其他线程遇到lock，就帮助它完成，使得lock最终release。</p><p>为了避免helping mechanism带来的性能下降（多个线程会尝试进行同一个操作），这里用了保守的策略： a process P helps another process’s operation <strong>only if the other operation is preventing P’s own progress</strong>.</p><h3 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h3><p>线程之间是无法自动感知对方的存在的，也就是说实现helping mechanism，需要a data structure that is shared between threads holds the operating information。</p><h2 id="dummy-keys"><a href="#dummy-keys" class="headerlink" title="dummy keys"></a>dummy keys</h2><p>在delete时，需要flag grandparent和mark parent，如果BST的key少于4个，必然就会有一个leaf没有grandparent，那么在delete就需要考虑很多例外的情况（insert类似）。</p><p>为了避免这些特殊情况，下面引入两个特殊值$\infty_1$和$\infty_2$，使得BST在没有key的时候，也存在3个node。这两个dummy keys是不允许删除的。</p><p><img data-src="/images/2015/non-block-bst_dummy_keys.png"></p><h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol><li><strong>Excellent tutorial</strong> about helping mechanism!!!</li><li>在树上面进行并发操作的时候，这篇论文中描述的问题其实大都是存在的，因此论文中的方法可以考虑用到其他树型结构上面。</li></ol><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ol><li>Non-blocking Binary Search Trees, Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel</li></ol>]]></content>
    
    
    <summary type="html">使用了mark标记结点的方式，解决了single word cas无法同时操作multi-word的问题，同时使用外部树减少了操作影响到的结点的数目，还有就是Excellent tutorial about helping mechanism!</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="binary search tree" scheme="https://chaomai.github.io/tags/binary-search-tree/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Read-Log-Update A Lightweight Synchronization Mechanism for Concurrent Programming</title>
    <link href="https://chaomai.github.io/2015/2015-09-26-notes-of-rlu/"/>
    <id>https://chaomai.github.io/2015/2015-09-26-notes-of-rlu/</id>
    <published>2015-09-26T05:34:55.000Z</published>
    <updated>2021-06-27T14:57:29.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>RCU, this barrier-based mechanism, allows for simple epoch-based reclamation of the old copies, and the mechanism as a whole eliminates many of the atomic read-modify-write instructions, memory barriers, and cache misses that are so expensive on modern multicore systems.</p><h2 id="About-RLU"><a href="#About-RLU" class="headerlink" title="About RLU"></a>About RLU</h2><ul><li>Novel extension of RCU framework that support read-only traverals concurrently with multiple updates.</li><li>In a semi-automated way.</li><li>Removes from the programmer the burder of handcrafting the concurrent copy management using only single pointer manipulations.</li><li>Can be API-compatible with RCU.</li></ul><h2 id="About-Implementation-of-RLU"><a href="#About-Implementation-of-RLU" class="headerlink" title="About Implementation of RLU"></a>About Implementation of RLU</h2><ul><li>Clock-based logging mechanism.</li><li>Object-level write-log per thread.</li></ul><h1 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h1><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; For all operations:</span><br><span class="line"></span><br><span class="line">   +--------------+</span><br><span class="line">   |all operations|</span><br><span class="line">   +------+-------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">+---------v-----------+</span><br><span class="line">|read the global clock|</span><br><span class="line">+---------+-----------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">       +--v--+</span><br><span class="line">       |start|</span><br><span class="line">       +-----+</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; For writer:</span><br><span class="line">                              +------+</span><br><span class="line">              +--+            |writer|</span><br><span class="line">              |               +---+--+</span><br><span class="line">              |                   |</span><br><span class="line">              |                   |</span><br><span class="line">              |     +-------------v-------------------------------+</span><br><span class="line">              |     | copy the object into a its own              |</span><br><span class="line">modification&lt;-+     |thread wirte-log and lock the original object|</span><br><span class="line">              |     +-------------+-------------------------------+</span><br><span class="line">              |                   |</span><br><span class="line">              |                   |</span><br><span class="line">              |      +------------v-------------+</span><br><span class="line">              |      |manipulate the object copy|</span><br><span class="line">              +---+  +--------------+-----------+</span><br><span class="line">                                    |</span><br><span class="line">                                    |</span><br><span class="line">              +---+    +------------v------------------------------+</span><br><span class="line">              |        |increments the write clock and global clock|</span><br><span class="line">              |        +------------+------------------------------+</span><br><span class="line">              |                     |</span><br><span class="line">              |                     |</span><br><span class="line">              |      +--------------v----------------+</span><br><span class="line">              |      |splits operations into two sets|</span><br><span class="line">              |      +--------------+----------------+</span><br><span class="line">              |                     |</span><br><span class="line">      commit&lt;-+                     |</span><br><span class="line">              |     +---------------v-----------------+</span><br><span class="line">              |     |wait for old operations to finish|</span><br><span class="line">              |     +---------------+-----------------+</span><br><span class="line">              |                     |</span><br><span class="line">              |                     |</span><br><span class="line">              |     +---------------v--------------------+</span><br><span class="line">              |     |   write back the new objects       |</span><br><span class="line">              |     |from the writer-log into the memory,|</span><br><span class="line">              |     |  overwriting the old objects,      |</span><br><span class="line">              |     |      release the locks             |</span><br><span class="line">              +---+ +------------------------------------+</span><br></pre></td></tr></table></figure><p>The writer’s modifications are:</p><ul><li>hidden from concurrent reads,</li><li>avoid conflicts with concurrent writes.</li></ul><p>In the following figure, <strong>the order of updating new value</strong>, 23, at write-clock and global-clock is important. Because all new object copies of the write-log become visible at once to all concurrent RLU protected section <strong>after the increment of global clock</strong>.</p><p><img data-src="/images/2015/rlu_readers_and_writer.png"></p><p>Many of the lock mentioned is not really calling <code>pthread_mutex_lock()</code> but just performing a update at a specific filed in data.</p><h2 id="Synchronizing-Write-Operations"><a href="#Synchronizing-Write-Operations" class="headerlink" title="Synchronizing Write Operations"></a>Synchronizing Write Operations</h2><p>Two approaches:</p><ul><li>Execute writers serially.</li><li>Fine-grained locks.</li></ul><h3 id="Execute-Writers-Serially"><a href="#Execute-Writers-Serially" class="headerlink" title="Execute Writers Serially"></a>Execute Writers Serially</h3><p>Using a global lock for each writer is simplicity of the code and the concurrency that does exist between read-only and write operations.</p><p>But the drawback is a lack of scalability.</p><h3 id="Fine-grained-Locks"><a href="#Fine-grained-Locks" class="headerlink" title="Fine-grained Locks"></a>Fine-grained Locks</h3><p>Each object that a writer modifies is logged and locked (as shown in the former figure) by the RLU mechanism.</p><h2 id="Fine-grained-Locking-Using-RLU"><a href="#Fine-grained-Locking-Using-RLU" class="headerlink" title="Fine-grained Locking Using RLU"></a>Fine-grained Locking Using RLU</h2><p>RLU locks can be used as a fine-grained locking mechanism.</p><p>For standard lock, it is necessary to execute post-lock customized verifications to ensure that the state of the object is still the same as it was before locking. This action is unnecessary for RLU locks.</p><h2 id="Data-Structures"><a href="#Data-Structures" class="headerlink" title="Data Structures"></a>Data Structures</h2><p>Global:</p><ul><li>a global clock</li><li>a global array of threads</li></ul><p>Thread:</p><ul><li>two write-logs: new object copies<ul><li>header:<ul><li>a thread indentifier</li><li>a pointer: point to the actual object</li><li>the object size</li><li>a special pointer value that indicates this is a copy (constant)</li></ul></li></ul></li><li>a run counter: the thread is active or not</li><li>a local clock: stealing mechanism</li><li>write clock for each thread: stealing mechanism<ul><li>write clock of a thread is initially $\infty$ and write clock is updated first (than global clock), so stealing from a thread is only possible when is updates the write clock during the commit</li></ul></li></ul><p>Object header:</p><ul><li>a pointer: points to the copy of this object in a write-log</li></ul><p><strong>Note:</strong> The actually code is the way of much more complex than previously mentioned. But these code are also nice course of programming in C.</p><h1 id="RLU-Deferring"><a href="#RLU-Deferring" class="headerlink" title="RLU Deferring"></a>RLU Deferring</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------+</span><br><span class="line">|writer saves the current write-<span class="built_in">log</span>|</span><br><span class="line">|<span class="keyword">and</span> generates <span class="keyword">new</span> <span class="built_in">log</span> <span class="keyword">for</span> the next|</span><br><span class="line">|writer                            |</span><br><span class="line">+---------+------------------------+</span><br><span class="line">          |</span><br><span class="line">          | <span class="keyword">if</span> a writer tries to lock an object</span><br><span class="line">          | that is already locked</span><br><span class="line">          |</span><br><span class="line">+---------v---------------------------+</span><br><span class="line">|writer sends a <span class="string">&quot;sync request&quot;</span> to     |</span><br><span class="line">|the conflicting thread to force it to|</span><br><span class="line">|release it locks                     |</span><br><span class="line">|                                     |</span><br><span class="line">|(global-clock++ -&gt; rlu sync -&gt;       |</span><br><span class="line">| write back -&gt; unlock                |</span><br><span class="line">+-------------------------------------+</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li>Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming, Alexander Matveev, Nir Shavit, Pascal Felber, Patrick Marlier</li></ol>]]></content>
    
    
    <summary type="html">今年SOSP的文章，提出了Read-Log-Update，使用了Clock-based logging mechanism和Object-level write-log per thread，解决了RCU不能有多个writer等缺陷。其中的RLU Deferring减少了synchronize调用的次数，提高了cache hit。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="rcu" scheme="https://chaomai.github.io/tags/rcu/"/>
    
    <category term="rlu" scheme="https://chaomai.github.io/tags/rlu/"/>
    
  </entry>
  
  <entry>
    <title>RCU</title>
    <link href="https://chaomai.github.io/2015/2015-09-25-rcu/"/>
    <id>https://chaomai.github.io/2015/2015-09-25-rcu/</id>
    <published>2015-09-25T11:00:58.000Z</published>
    <updated>2021-06-27T14:57:29.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Brief-Introduction"><a href="#Brief-Introduction" class="headerlink" title="Brief Introduction"></a>Brief Introduction</h1><ol><li><p>a <strong>synchronization mechanism</strong>.</p></li><li><p>allowing read to occur concurrently with updates.</p></li><li><p>supports concurrency between a <strong>single updater and multiple readers</strong>.</p></li><li><p>ensures that reads are coherent by maintaining multiple versions of objects and ensuring that they are not freed up until all pre-existing read-side critical sections complete.</p></li><li><p>defines and uses efficient and scalable mechanisms for publishing and reading new versions of an object, and also for deferring the collection of old versions.</p></li><li><p>read-side primitives have zero overhead in non-preemptable kernels.</p></li></ol><h1 id="Fundamental-Mechanisms"><a href="#Fundamental-Mechanisms" class="headerlink" title="Fundamental Mechanisms"></a>Fundamental Mechanisms</h1><ol><li>Publish-Subscribe Mechanism (for insertion)</li><li>Wait For Pre-Existing RCU Readers to Complete (for deletion)</li><li>Maintain Multiple Versions of Recently Updated Objects (allow readers to tolerate concurrent insertions and deletions)</li></ol><h2 id="Publish-Subscribe-Mechanism-insertion"><a href="#Publish-Subscribe-Mechanism-insertion" class="headerlink" title="Publish-Subscribe Mechanism (insertion)"></a>Publish-Subscribe Mechanism (insertion)</h2><p>RCU uses what can be thought of as a publish-subscribe mechanism to provide <em>the ability to safely scan data, even though that data is being modified concurrently.</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">gp</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line"></span><br><span class="line">p = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">p-&gt;a = <span class="number">1</span>;</span><br><span class="line">p-&gt;b = <span class="number">2</span>;</span><br><span class="line">p-&gt;c = <span class="number">3</span>;</span><br><span class="line">gp = p;</span><br></pre></td></tr></table></figure><h3 id="Problem-1-rcu-assign-pointer"><a href="#Problem-1-rcu-assign-pointer" class="headerlink" title="Problem 1 - rcu_assign_pointer()"></a>Problem 1 - <code>rcu_assign_pointer()</code></h3><p>The <strong>memory reordering</strong> in updater may cause that concurrent readers could see the uninitialized values (<code>gp</code>). And this requires to use <strong>memory barriers (hard)</strong> to keep things ordered.</p><p>The primitive, <code>rcu_assign_pointer()</code>, encapsulates these memory barriers.</p><p>The <code>rcu_assign_pointer()</code> would <strong>publish</strong> the new structure, forcing both the compiler and the CPU to execute the assignment to <code>gp</code> after the assignments to the fields referenced by <code>p</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gp = p;</span></span><br><span class="line">rcu_assign_pointer(gp, p);</span><br></pre></td></tr></table></figure><h3 id="Problem-2-rcu-dereference"><a href="#Problem-2-rcu-dereference" class="headerlink" title="Problem 2 - rcu_dereference()"></a>Problem 2 - <code>rcu_dereference()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not good</span></span><br><span class="line">p = gp;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Not only the updater but also the reader requires enforce ordering because of the <strong>value-speculation compiler optimizations</strong> (the compiler guess the value p, access its filed, then fetch the actual value of p and check the guess) in the context of <strong>profile-driven optimization</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock();</span><br><span class="line">p = rcu_dereference(gp);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br></pre></td></tr></table></figure><p>The <code>rcu_dereference()</code> primitive can thus be thought of as <strong>subscribing</strong> to a given value of the specified pointer, guaranteeing that subsequent dereference operations <em>will see any initialization that occurred before the corresponding publish (<code>rcu_assign_pointer()</code>) operation</em>.</p><p>The <code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code> calls are absolutely required: they define the extent of the <strong>RCU read-side critical section</strong>. In non-<code>CONFIG_PREEMPT</code> kernels, they generate absolutely no code.</p><h3 id="Special-RCU-Variants"><a href="#Special-RCU-Variants" class="headerlink" title="Special RCU Variants"></a>Special RCU Variants</h3><p>Special RCU variants of Linux’s list-manipulation API contains <code>rcu_assign_pointer()</code> and <code>rcu_dereference()</code> primitives.</p><p>Doubly linked list in Linux:</p><ul><li>the circular <code>struct list_head</code></li><li>the linear <code>struct hlist_head</code>/<code>struct hlist_node</code> pair</li></ul><h3 id="RCU-Publish-and-Subscribe-Primitives"><a href="#RCU-Publish-and-Subscribe-Primitives" class="headerlink" title="RCU Publish and Subscribe Primitives"></a>RCU Publish and Subscribe Primitives</h3><table><thead><tr><th>Category</th><th>Publish</th><th>Retract</th><th>Subscribe</th></tr></thead><tbody><tr><td>Pointers</td><td><code>rcu_assign_pointer()</code></td><td><code>rcu_assign_pointer(..., NULL)</code></td><td><code>rcu_dereference()</code></td></tr><tr><td>Lists</td><td><code>list_add_rcu()</code> <code>list_add_tail_rcu()</code> <code>list_replace_rcu()</code></td><td><code>list_del_rcu()</code></td><td><code>list_for_each_entry_rcu()</code></td></tr><tr><td>Hlists</td><td><code>hlist_add_after_rcu()</code> <code>hlist_add_before_rcu()</code> <code>hlist_add_head_rcu()</code> <code>hlist_replace_rcu()</code></td><td><code>hlist_del_rcu()</code></td><td><code>hlist_for_each_entry_rcu()</code></td></tr></tbody></table><p>The <code>list_replace_rcu()</code>, <code>list_del_rcu()</code>, <code>hlist_replace_rcu()</code>, and <code>hlist_del_rcu()</code> introduce a new problem. When is it safe to free up the data element that was replaced or removed?</p><h2 id="Wait-For-Pre-Existing-RCU-Readers-to-Complete-deletion"><a href="#Wait-For-Pre-Existing-RCU-Readers-to-Complete-deletion" class="headerlink" title="Wait For Pre-Existing RCU Readers to Complete (deletion)"></a>Wait For Pre-Existing RCU Readers to Complete (deletion)</h2><p>RCU is a way of waiting for lots of (for example, 20,000) different things to finish without having to explicitly track each and every one of them.</p><h3 id="About-Waiting"><a href="#About-Waiting" class="headerlink" title="About Waiting"></a>About Waiting</h3><p><img data-src="/images/2015/rcu_waiting.png"></p><p>The things waited on RCU read-side critical sections, which can be <strong>nested, and may contain pretty much any code, as long as that code does not explicitly block or sleep **(**SRCU</strong> is a special case).</p><p>When readers are not inside a read-side critical section, they are in a <strong>quiescent state</strong>.</p><p>A time period during which all such pre-existing readers complete is called a <strong>grace period</strong>. (or a period of time during which every<br>thread goes through at least one quiescent state is called a<br>grace period.)</p><p>If the section begins after the beginning of a given grace period, the execution of that section will extend beyond the end of that grace period. Because after the beginning of a given grace period, *new readers won’t hold a reference to old data.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">LIST_HEAD(head);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* . . . */</span></span><br><span class="line"></span><br><span class="line">p = search(head, key);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="comment">/* Take appropriate action, unlock, and return. */</span></span><br><span class="line">&#125;</span><br><span class="line">q = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the following 4 lines gives RCU its name:</span></span><br><span class="line"><span class="comment">// 1. while permitting concurrent reads,</span></span><br><span class="line"><span class="comment">// 2. *q = *p copies,</span></span><br><span class="line"><span class="comment">// 3. q-&gt;b = 2, q-&gt;c = 3, list_replace_rcu(&amp;p-&gt;list, &amp;q-&gt;list) do an update.</span></span><br><span class="line"></span><br><span class="line">*q = *p;</span><br><span class="line">q-&gt;b = <span class="number">2</span>;</span><br><span class="line">q-&gt;c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// three main steps of the basic form of algorithms that use RCU to wait for readers</span></span><br><span class="line"><span class="comment">// 1. make a change</span></span><br><span class="line">list_replace_rcu(&amp;p-&gt;<span class="built_in">list</span>, &amp;q-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="comment">// 2. wait for all pre-existing RCU read-side critical sections to completely finish</span></span><br><span class="line"><span class="comment">// the key observation here is that subsequent RCU read-side critical sections have no way to gain a reference to the newly removed element.</span></span><br><span class="line">synchronize_rcu();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. clean up</span></span><br><span class="line">kfree(p);</span><br></pre></td></tr></table></figure><h3 id="synchronize-rcu"><a href="#synchronize-rcu" class="headerlink" title="synchronize_rcu()"></a><code>synchronize_rcu()</code></h3><h4 id="The-Trick"><a href="#The-Trick" class="headerlink" title="The Trick"></a>The Trick</h4><p>The trick is that RCU read-side critical sections is <strong>not permitted to block or sleep</strong>.</p><p>If a given CPU executes a context switch, <strong>the completion</strong> of any prior RCU read-side critical sections is guaranteed.</p><p>I think there must be an mechanism that the given CPU can <em>detect the existence of all RCU read-side critical sections and complete them</em> before the context switch.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simplified synchronize_rcu()</span></span><br><span class="line">for_each_online_cpu(cpu)</span><br><span class="line">    run_on(cpu);</span><br></pre></td></tr></table></figure><p><code>for_each_online_cpu(cpu)</code> loop through all CPU:<br><code>run_on()</code> switches the current thread to the specified CPU –&gt; forces<br>a context switch on that CPU –&gt; guarantee the completion</p><p>Therefore, the completion of all prior RCU read-side critical sections are guaranteed.</p><p>This approach works for for non-<code>CONFIG_PREEMPT</code> and <code>CONFIG_PREEMPT</code> kernels.</p><h2 id="Maintain-Multiple-Versions-of-Recently-Updated-Objects"><a href="#Maintain-Multiple-Versions-of-Recently-Updated-Objects" class="headerlink" title="Maintain Multiple Versions of Recently Updated Objects"></a>Maintain Multiple Versions of Recently Updated Objects</h2><p>The multiple versions of recently updated objects allow synchronization-free readers.</p><p>While the reader remains in its RCU read-side critical section, the data referenced must remain intact. (The readers are not permitted to maintain references to element after exiting from their RCU read-side critical sections.)</p><p>The multiple versions mentioned here doesn’t mean the RCU uses a version number. <strong>Versions exist logically</strong>. Because readers do not synchronize directly with updaters, readers might run concurrently with this entire update (insert, delete, or replacement) process. For example, some readers <em>might reference to a old element and see the old version of the list</em>, while other readers reference to a up-to-date element at same location.</p><p><img data-src="/images/2015/rcu_insert.png"><br>(The red border means that readers might be holding references to them.)</p><p>After the <code>synchronize_rcu()</code> returns, <em>a grace period will have elapsed</em>, and so all reads that started before the <code>list_replace_rcu()</code> will have completed. No readers will hold the reference to the old element. From the readers’ point of view, there is a single version of list.</p><h1 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h1><h2 id="Single-Updater"><a href="#Single-Updater" class="headerlink" title="Single Updater"></a>Single Updater</h2><p>RCU permit concurrency between a single updater and multiple readers. <em>(I think its should caused by <code>synchronize_rcu()</code>. I am not pretty sure for now because of being unaware of detailed design and implementation of RCU.)</em></p><p>So RCU only allow the existence of two versions of the list. If we want to permit more than two version of the list, one way is using lock.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note that this means that multiple concurrent deletions might be waiting in synchronize_rcu().</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;mylock);</span><br><span class="line">p = search(head, key);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">  spin_unlock(&amp;mylock);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    list_del_rcu(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">    spin_unlock(&amp;mylock);</span><br><span class="line">    synchronize_rcu();</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If a semaphore protecting the update is held across the grace period, then there can be at most two versions.</p><h2 id="Subtle-Priority-inversion-Scenario"><a href="#Subtle-Priority-inversion-Scenario" class="headerlink" title="Subtle Priority-inversion Scenario"></a>Subtle Priority-inversion Scenario</h2><p>Such as, a high-priority process blocked waiting for an RCU grace period to elapse can be blocked by low-priority RCU readers in -rt kernels. This can be solved by using RCU priority boosting or <code>call_rcu()</code> instead of <code>synchronize_rcu()</code>.</p><h2 id="Access-Old-Data-and-Inconsistencies"><a href="#Access-Old-Data-and-Inconsistencies" class="headerlink" title="Access Old Data and Inconsistencies"></a>Access Old Data and Inconsistencies</h2><p>RCU readers might access stale data, and might even see inconsistencies.</p><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><ol><li>a Reader-Writer Lock Replacement</li><li>a Restricted Reference-Counting Mechanism</li><li>a Bulk Reference-Counting Mechanism</li><li>a Poor Man’s Garbage Collector</li><li>a Way of Providing Existence Guarantees</li><li>a Way of Waiting for Things to Finish</li></ol><h2 id="Reader-Writer-Lock-Replacement"><a href="#Reader-Writer-Lock-Replacement" class="headerlink" title="Reader-Writer Lock Replacement"></a>Reader-Writer Lock Replacement</h2><p>Perhaps the most common use of RCU within the Linux kernel is as a replacement for reader-writer locking in <strong>read-intensive situations</strong>. The key similarity between RCU and reader-writer locking is that <em>both have read-side critical sections that can execute in parallel</em>.</p><h2 id="Restricted-Reference-Counting-Mechanism"><a href="#Restricted-Reference-Counting-Mechanism" class="headerlink" title="Restricted Reference-Counting Mechanism"></a>Restricted Reference-Counting Mechanism</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock();  <span class="comment">/* acquire reference. */</span></span><br><span class="line">p = rcu_dereference(head);</span><br><span class="line"><span class="comment">/* do something with p. */</span></span><br><span class="line">rcu_read_unlock();  <span class="comment">/* release reference. */</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;mylock);</span><br><span class="line">p = head;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">spin_unlock(&amp;mylock);</span><br><span class="line">synchronize_rcu();  <span class="comment">/* Wait for all references to be released. */</span></span><br><span class="line">kfree(p);</span><br></pre></td></tr></table></figure><p>Well, it is pretty much like the replacement for reader-writer lock. The difference is the perspective of thinking about it.</p><p>Again, the duration of read-side critical section matters here. The performance advantages of RCU are most pronounced for short duration.</p><h2 id="Bulk-Reference-Counting-Mechanism"><a href="#Bulk-Reference-Counting-Mechanism" class="headerlink" title="Bulk Reference-Counting Mechanism"></a>Bulk Reference-Counting Mechanism</h2><p>A single global reference counter for a large variety of data structures causes bouncing the cache line containing the reference count, and can degrade performance.</p><h2 id="Garbage-Collector"><a href="#Garbage-Collector" class="headerlink" title="Garbage Collector"></a>Garbage Collector</h2><p>OK, when I read about this section in the original article, I’m sure that I am the poor man. But they (RCU and Garbage Collector) has some differences.</p><p> RCU requires that</p><ul><li>manually indicate when a given data structure is eligible to be collected.</li><li>manually mark the RCU read-side critical sections where references might legitimately be held.</li></ul><h2 id="Providing-Existence-Guarantees"><a href="#Providing-Existence-Guarantees" class="headerlink" title="Providing Existence Guarantees"></a>Providing Existence Guarantees</h2><p>Since RCU protects data within the read-side critial section, the data is guaranteed to remain in existence for the duration of the read-side critial section.</p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="Kernel-Space"><a href="#Kernel-Space" class="headerlink" title="Kernel Space"></a>Kernel Space</h2><p>RCU was accepted into the Linux 2.5.43 kernel in 2002.</p><h2 id="User-Space"><a href="#User-Space" class="headerlink" title="User Space"></a>User Space</h2><p><a href="http://liburcu.org/">User-space RCU</a> is widely applicable for general-purpose code but in general does not perform as well as the kernel implementation.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://lwn.net/Articles/262464/">What is RCU, Fundamentally?</a></li><li><a href="http://lwn.net/Articles/263130/">What is RCU? Part 2: Usage</a></li><li><a href="http://lwn.net/Articles/264090/">RCU part 3: the RCU API</a></li><li><a href="http://www2.rdrop.com/~paulmck/RCU/">RCU</a></li><li><a href="http://codemacro.com/2015/04/19/rw_thread_gc/">使用RCU技术实现读写线程无锁</a></li><li><a href="http://lwn.net/Articles/609904/">The RCU API, 2014 Edition</a></li><li><a href="http://lwn.net/Articles/253651/">The design of preemptible read-copy-update</a></li><li><a href="http://www2.rdrop.com/~paulmck/RCU/">RCU by Paul McKenney</a></li><li><a href="http://liburcu.org/">Userspace RCU</a></li><li><a href="https://lwn.net/Articles/573424/">User-space RCU</a></li><li>Read-Log-Update: A Lightweight Synchronization Mechanism for Concurrent Programming, Alexander Matveev, Nir Shavit, Pascal Felber, Patrick Marlier</li><li>User-Level Implementations of Read-Copy Update, Mathieu Desnoyers, Paul E. McKenney, Alan S. Stern, Michel R. Dagenais and Jonathan Walpole</li></ol>]]></content>
    
    
    <summary type="html">RCU is a synchronization mechanism, which is widely used in the Linux kernel.</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="rcu" scheme="https://chaomai.github.io/tags/rcu/"/>
    
  </entry>
  
  <entry>
    <title>char *(*(**foo[][8])())[]...</title>
    <link href="https://chaomai.github.io/2015/2015-09-17-char-foo-8/"/>
    <id>https://chaomai.github.io/2015/2015-09-17-char-foo-8/</id>
    <published>2015-09-16T16:06:18.000Z</published>
    <updated>2021-06-27T14:57:29.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="declaration"><a href="#declaration" class="headerlink" title="declaration"></a>declaration</h1><p>one <strong>basic type</strong> + zero or more <strong>derived types</strong></p><h2 id="basic-type"><a href="#basic-type" class="headerlink" title="basic type"></a>basic type</h2><p><code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, <code>unsigned short</code>, <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>float</code>, <code>double</code>, <code>void</code>, <code>struct tag   </code>, <code>union tag</code>, <code>enum tag</code>, <code>long long</code>, <code>unsigned long long</code>, <code>long double</code></p><h2 id="derived-types"><a href="#derived-types" class="headerlink" title="derived types"></a>derived types</h2><p><code>*</code>: pointer to …   - always on the left side<br><code>[]</code>: array of …   - always on the left side<br><code>()</code>: function returning …   - always on the left side</p><h1 id="operator-precedence"><a href="#operator-precedence" class="headerlink" title="operator precedence"></a>operator precedence</h1><p>The <code>[]</code> and <code>()</code> have higher precedence than <code>*</code>.</p><h2 id="the-rule-to-read-declaration"><a href="#the-rule-to-read-declaration" class="headerlink" title="the rule to read declaration"></a>the rule to read declaration</h2><p>There is a <a href="http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html">“right-left” rule</a>. I think the rule is based on the precedence.</p><p><a href="http://stackoverflow.com/questions/859634/c-pointer-to-array-array-of-pointers-disambiguation">C pointer to array/array of pointers disambiguation</a> also mentioned <em>“go right when you can, go left when you must”</em>.</p><h2 id="find-error-in-declaration"><a href="#find-error-in-declaration" class="headerlink" title="find error in declaration"></a>find error in declaration</h2><p>Since we can read complex declaration by applying the rule mentioned before, we also can find error in declaration with the knowledge of what is legal in C.</p><p>Some illegal declarations,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array of functions?</span></span><br><span class="line"><span class="comment">// error: &#x27;a&#x27; declared as array of functions of type &#x27;int ()&#x27;</span></span><br><span class="line"><span class="keyword">int</span> a[]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// a function returning function?</span></span><br><span class="line"><span class="comment">// error: function cannot return function type &#x27;int ()&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// array of functions?</span></span><br><span class="line"><span class="comment">// a function returning array of int?</span></span><br><span class="line"><span class="comment">// error: function cannot return array type &#x27;int []&#x27;</span></span><br><span class="line"><span class="comment">// error: &#x27;c&#x27; declared as array of functions of type &#x27;int ()&#x27;</span></span><br><span class="line"><span class="keyword">int</span> c[]()[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// array of functions?</span></span><br><span class="line"><span class="comment">// error: &#x27;d&#x27; declared as array of functions of type &#x27;int ()&#x27;</span></span><br><span class="line"><span class="keyword">int</span> (*d)[]();</span><br></pre></td></tr></table></figure><h1 id="char-foo-8"><a href="#char-foo-8" class="headerlink" title="char *(*(**foo[][8])())[]"></a><code>char *(*(**foo[][8])())[]</code></h1><p>foo is array of array of 8 pointer to pointer to function returning pointer to array of pointer to char.</p><h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol><li>The key is the <a href="http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html">“right-left” rule</a>.</li><li>Be aware of what is legal in C.</li><li>数组指针，指针数组。。。Well, the Chinese description is really ambiguous.</li></ol><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ol><li><a href="http://unixwiz.net/techtips/reading-cdecl.html">Reading C type declarations</a></li><li><a href="http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html">The “right-left” rule</a></li><li><a href="http://stackoverflow.com/questions/859634/c-pointer-to-array-array-of-pointers-disambiguation">C pointer to array/array of pointers disambiguation</a></li></ol>]]></content>
    
    
    <summary type="html">Understand complex declaration in C.</summary>
    
    
    
    <category term="c" scheme="https://chaomai.github.io/categories/c/"/>
    
    
    <category term="pointer" scheme="https://chaomai.github.io/tags/pointer/"/>
    
  </entry>
  
  <entry>
    <title>Notes of To Lock, Swap, or Elide: On the Interplay of Hardware Transactional Memory and Lock Free Indexing</title>
    <link href="https://chaomai.github.io/2015/2015-09-05-notes-of-to-lock-swap-or-elide-on-the-interplay-of-hardware-transactional-memory-and-lock-free-indexing/"/>
    <id>https://chaomai.github.io/2015/2015-09-05-notes-of-to-lock-swap-or-elide-on-the-interplay-of-hardware-transactional-memory-and-lock-free-indexing/</id>
    <published>2015-09-05T04:27:15.000Z</published>
    <updated>2021-06-27T14:57:29.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决了这么几个问题"><a href="#解决了这么几个问题" class="headerlink" title="解决了这么几个问题"></a>解决了这么几个问题</h1><ul><li><p>Does HTM obviate the need for crafty lock-free index designs?<br>No.</p></li><li><p>How does HTM differ from lock-free index designs?</p></li><li><p>Given that lock-free designs are still relevant, can HTM help simplify lock-free design techniques while maintaining good performance?<br>Yes.</p></li></ul><h1 id="HTM"><a href="#HTM" class="headerlink" title="HTM"></a>HTM</h1><h2 id="Transactional-memory"><a href="#Transactional-memory" class="headerlink" title="Transactional memory"></a>Transactional memory</h2><p>ease the burden (<em>a tedious and error prone task leading to deadlocks and race conditions</em>) by delegating conflict detection and resolution from the developer to the system.</p><h2 id="Hardware-Transactional-Memory"><a href="#Hardware-Transactional-Memory" class="headerlink" title="Hardware Transactional Memory"></a>Hardware Transactional Memory</h2><p>a best-effort model, optimistic concurrency.</p><h3 id="Based-on-existing-features-in-CPU"><a href="#Based-on-existing-features-in-CPU" class="headerlink" title="Based on existing features in CPU"></a>Based on existing features in CPU</h3><ul><li><p>caches<br>store transaction buffers and provide isolation.</p></li><li><p>cache coherence protocol<br>detect conflicting transactional accesses.</p></li></ul><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><ul><li><p>read and write set of a transaction must fit in cache in order for it to be executed<br>limitation of CPU.</p></li><li><p>transaction duration<br>hardware events will abort a transaction.</p></li><li><p>the work of conflict detection<br>it is usually done at the granularity of a cache line. This may lead to cases of false sharing where aborts occur due to threads accessing and modifying separate items on the same cache line.</p></li></ul><h3 id="Solutions-lock-elision"><a href="#Solutions-lock-elision" class="headerlink" title="Solutions - lock elision"></a>Solutions - lock elision</h3><p>因为HTM是best-effort的，由于上述constraints的存在，transaction需要fallback path。</p><p>最简单的一种，是transaction不成功的时候，就改用lock，这个技术叫做lock elision；它将一个lock保护的区域作为transaction来执行，仅当transaction 没有成功commit的时候，它才falls back为block on the lock。</p><p>lock elision将MT作为一个fast path，slow path就是lock (a simple coarse grain locks).</p><p>In lock elision, the lock word needs to be included in the read set of a transaction, so that the transaction aborts when another thread acquires the lock (thus causing a conflict). Hence, once a thread resorts to non-transactional execution by taking the lock, <strong>all other concurrently executing transactions will abort, stalling overall progress.</strong></p><h2 id="Intel-TSX"><a href="#Intel-TSX" class="headerlink" title="Intel TSX"></a>Intel TSX</h2><p>the support of transactional memory in Intel starts from Haswell.</p><p>According to Intel, there is no guarantee that a transaction<br>will eventually succeed even if it is infinitely retried.</p><ul><li><p>HLE<br>Hardware Lock Elision (HLE)</p></li><li><p>RTM<br>Restricted Transactional Memory (RTM)</p></li></ul><h2 id="cpp-btree-and-Bw-tree"><a href="#cpp-btree-and-Bw-tree" class="headerlink" title="cpp-btree and Bw-tree"></a>cpp-btree and Bw-tree</h2><p>cpp-btree</p><ul><li>does not contain the fine-grained locking techniques and concurrency protocols</li></ul><p>Bw-tree</p><ul><li><p>a mapping table that maps logical page identifiers (LPIDs) to virtual addresses</p></li><li><p>Lock-free updates</p><ul><li>delta record</li><li>pages consolidation (to get search-optimized page)</li></ul></li><li><p>Structure modifications</p><ul><li>breaks an SMO into a sequence of atomic steps</li></ul></li></ul><h1 id="A-study-of-fundamental-differences-between-HTM-based-and-lock-free-index-designs"><a href="#A-study-of-fundamental-differences-between-HTM-based-and-lock-free-index-designs" class="headerlink" title="A study of fundamental differences between HTM-based and lock-free index designs"></a>A study of fundamental differences between HTM-based and lock-free index designs</h1><h2 id="Experiment-1-Throughput"><a href="#Experiment-1-Throughput" class="headerlink" title="Experiment 1 - Throughput"></a>Experiment 1 - Throughput</h2><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>for read operation, HTM provides high throughput with little effort.</p><h2 id="Experiment-2-Effect-of-Key-and-Payload-Sizes"><a href="#Experiment-2-Effect-of-Key-and-Payload-Sizes" class="headerlink" title="Experiment 2 - Effect of Key and Payload Sizes"></a>Experiment 2 - Effect of Key and Payload Sizes</h2><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>such a workload in experiment 1 <strong>do not hold in general</strong>.</p><ul><li><p>capacity limits <em>(for Haswell’s CPU)</em><br>L1 cache is 32KB. no transaction can write more than can fit in L1.</p></li><li><p>associativity <em>(for Haswell’s CPU)</em></p></li><li><p>hyper-threading <em>(for Haswell’s CPU)</em><br>L1 cache and other resources is shared among hardware threads.</p></li></ul><blockquote><p>many of the properties that determine the HTM abort rate for a given tree may not be known until runtime. A tree’s key size, payload size, total size, and address access patterns all affect performance.</p></blockquote><h3 id="Results-1"><a href="#Results-1" class="headerlink" title="Results"></a>Results</h3><p>even trees with relatively small keys and payloads cannot always parallelize. With Haswell’s HTM almost all transactions abort with payloads larger than a few kilobytes.</p><h2 id="Experiment-3-Highcontention-Performance"><a href="#Experiment-3-Highcontention-Performance" class="headerlink" title="Experiment 3 - Highcontention Performance"></a>Experiment 3 - Highcontention Performance</h2><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><ul><li><p>two other problematic ways</p><ul><li><p>speculation is not free</p></li><li><p>lemming effect<br>When a transaction falls back and acquires the lock, <strong>all other transactions in the critical section</strong> abort and cannot restart <strong>until the lock is released</strong>. The effect is that execution is <strong>fully serialized</strong> until the lock is released – even if the other transactions operate on non conflicting cache lines.</p><ul><li>mitigate the lemming effect<br>have transactions retry more than once</li><li>cost of retrying a contentious transaction &lt; serializing execution*</li></ul></li></ul></li></ul><h3 id="Results-2"><a href="#Results-2" class="headerlink" title="Results"></a>Results</h3><p><em>the workload skew: for the payload, the bigger the skew is, the latter it is updated at the end of a tree traversal operation, and the latter it is within the transaction.</em></p><p>The results show that as workload skew increases <strong>the performance of lock-elision drops sharply</strong>. At some point lock-elision performs even <strong>worse than spin-locks</strong>. Increasing the number of transactional attempts delays the performance cliff, and leads to a more graceful degradation of performance as skew increases.</p><h3 id="Optimal-Number-of-Transactional-Attempts"><a href="#Optimal-Number-of-Transactional-Attempts" class="headerlink" title="Optimal Number of Transactional Attempts"></a>Optimal Number of Transactional Attempts</h3><p>for a set of concurrent transactions, it may be possible that none of them commit: a situation worse than using a spinlock.</p><p>The optimal number of transactional attempts depends on workloads and varies highly. chooses the number of transactional attempts dynamically depending on the workload.</p><h2 id="Lock-coupling"><a href="#Lock-coupling" class="headerlink" title="Lock-coupling"></a>Lock-coupling</h2><p>lock-coupling is one of the most widely used approaches to achieve efficient fine-grained locking on B-Trees.</p><p>In lock-coupling a pair of locks are held as a worker traverses pages: one on a “source” page and another on a “target” page.</p><p><img data-src="/images/2015/stm_lock_coupling.png"></p><p>Because of restrictive support of lock-coupling in Haswell’s HTM interface, it is not possible on Haswell’s CPU.</p><h1 id="A-study-of-fundamental-differences-between-HTM-based-and-lock-free-index-designs-1"><a href="#A-study-of-fundamental-differences-between-HTM-based-and-lock-free-index-designs-1" class="headerlink" title="A study of fundamental differences between HTM-based and lock-free index designs"></a>A study of fundamental differences between HTM-based and lock-free index designs</h1><p><img data-src="/images/2015/stm_compare.png"></p><h2 id="Experiment-1-Impact-of-concurrent-writers-on-readers"><a href="#Experiment-1-Impact-of-concurrent-writers-on-readers" class="headerlink" title="Experiment 1 - Impact of concurrent writers on readers"></a>Experiment 1 - Impact of concurrent writers on readers</h2><h3 id="Results-3"><a href="#Results-3" class="headerlink" title="Results"></a>Results</h3><p>for high contention workloads the reader throughput that the cpp-btree can sustain begins to drop.</p><h2 id="The-Overheads-of-LockFreedom"><a href="#The-Overheads-of-LockFreedom" class="headerlink" title="The Overheads of LockFreedom"></a>The Overheads of LockFreedom</h2><ul><li><p>a garbage-collection mechanism for memory safety</p><ul><li>epoch mechanism used in Bw-tree，类似引用计数。</li></ul></li><li><p>additional indirection for atomic updates</p></li><li><p>lockfreedom influences the in-memory layout of structures*</p><ul><li>对于某些数据结构，如：Bw-tree，每次访问必须间接的通过一个额外的memory来进行，这就无形中增加了overheads。</li><li>额外的indirection同时还给内存分配带来压力。<ul><li>可能需要特别的或者lock-free的allocator。</li></ul></li></ul></li><li><p>cost of copy-on-write (when using paged copy-on-write semantics)</p><ul><li>the cost may be influenced by page size, access skew, the uniformity of payload sizes.</li></ul></li></ul><p>These costs are highly intertwined: tradeoffs for each influence the cost of the others</p><h1 id="A-study-of-how-HTM-can-help-lock-free-designs"><a href="#A-study-of-how-HTM-can-help-lock-free-designs" class="headerlink" title="A study of how HTM can help lock-free designs"></a>A study of how HTM can help lock-free designs</h1><p>it is very difficult to architect and build complex lock-free<br>data structures.</p><h2 id="MultiWord-CAS-using-HTM"><a href="#MultiWord-CAS-using-HTM" class="headerlink" title="MultiWord CAS using HTM"></a>MultiWord CAS using HTM</h2><ul><li>MW-CAS同时操作的word数受限于L1 cache的大小。过多的word，则无法用HTM来实现MW-CAS。Bw-tree可以。</li><li>MW-CAS是短时的transactions，也就是说不那么容易被interrupted。</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="https://lwn.net/Articles/534758/">Lock elision in the GNU C library</a></li><li><a href="https://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions">Transactional Synchronization Extensions</a></li><li>CPU Cache and Memory Ordering, 何登成</li><li><a href="http://www.ecs.umass.edu/ece/koren/architecture/Cache/tutorial.html">This is a basic Cache Tutorial</a></li><li>Computer Systems A Programmer’s Perspective, Randal E. Bryant, David R. O’Hallaron</li><li>To Lock, Swap, or Elide: On the Interplay of Hardware Transactional Memory and Lock Free Indexing, Darko Makreshanski, Justin Levandoski, Ryan Stutsman</li></ol>]]></content>
    
    
    <summary type="html">主要研究了HTM and lock-free indexing的相互影响。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="hardware transactional memory" scheme="https://chaomai.github.io/tags/hardware-transactional-memory/"/>
    
  </entry>
  
  <entry>
    <title>Harris&#39; Non-Blocking Linked-Lists</title>
    <link href="https://chaomai.github.io/2015/2015-07-30-harris-non-blocking-linked-lists/"/>
    <id>https://chaomai.github.io/2015/2015-07-30-harris-non-blocking-linked-lists/</id>
    <published>2015-07-30T15:30:59.000Z</published>
    <updated>2021-06-27T14:57:29.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="specification"><a href="#specification" class="headerlink" title="specification"></a>specification</h1><ul><li>ordered（ascending）</li><li>no duplicated key</li></ul><h1 id="features"><a href="#features" class="headerlink" title="features"></a>features</h1><ul><li>non-blocking</li><li>linearizable</li><li>compare-and-swap based</li></ul><h1 id="仅使用一个cas的缺陷"><a href="#仅使用一个cas的缺陷" class="headerlink" title="仅使用一个cas的缺陷"></a>仅使用一个cas的缺陷</h1><ul><li><p>insert<br>  <img data-src="/images/2015/harris_single_insert.png"></p></li><li><p>delete<br>  <img data-src="/images/2015/harris_single_delete.png"></p></li></ul><p>对于只有一个insert或者一个delete的情况，没有问题会出现。</p><ul><li>insert and delete<br>  <img data-src="/images/2015/harris_insert_and_delete.png"></li></ul><p>但是如果一个insert和一个delete同时进行，问题就会出现。删除30的时候，一个cas无法保证，也不能避免10和30之间的修改。</p><h1 id="解决方法：用两个cas"><a href="#解决方法：用两个cas" class="headerlink" title="解决方法：用两个cas"></a>解决方法：用两个cas</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><ul><li><p>stage 1<br>  <img data-src="/images/2015/harris_logically_delete.png"><br>  用一个cas mark将要被删除结点的next field（logically deleted）；</p></li><li><p>stage 2<br>  <img data-src="/images/2015/harris_physically_delete.png"><br>  另一个cas来进行删除结点（physically deleted）。</p></li></ul><p>stage 1结束以后，list的结构保持不变，mark以后的结点，避免了新节点insert到该结点的后面。</p><h1 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h1><h2 id="marked-and-unmarked"><a href="#marked-and-unmarked" class="headerlink" title="marked and unmarked"></a>marked and unmarked</h2><blockquote><p>A node is marked if and only if its next field is marked.</p></blockquote><p>这句话是关键：论文中的mark，实际上是mark了要被删除结点的next指针，而不是要被删除的结点本身。<br>我觉得从另一个视角来看，mark的效果是，不允许改变<strong>要被删除结点的后继结点</strong>。这点从避免前文提到的问题的角度来说，也应该是正确的理解。</p><p><code>get_marked_reference</code>和<code>get_unmarked_reference</code>是以copy的形式传入reference，mark或者unmark以后的并不是reference本身。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  key_type key;</span><br><span class="line">  node *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">  node *head;</span><br><span class="line">  node *tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p>满足这么几个要求：</p><ul><li>left_node.key &lt; search_key &lt;= right_node.key</li><li>left_node and right_node are unmarked</li><li>right_node is immediate successor（直接后继） of left_node</li></ul><p>有这么几个步骤：</p><ul><li>找到left_node和right_node</li><li>检查是不是直接后继<ul><li>是，直接返回</li></ul></li><li>移除left_node and right_node之间的一个或多个marked结点</li></ul><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><ul><li>找到left_node和right_node</li><li>cas插入</li></ul><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>如前文解决方法中描述的，分两个阶段：</p><ul><li>stage 1:<ul><li>找到left_node和right_node</li><li>logically delete</li></ul></li><li>stage 2:<ul><li>physically delete<ul><li>cas删除</li><li>或者search中删除</li></ul></li></ul></li></ul><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul><li>找到left_node和right_node</li><li>right_node == search_key</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>A Pragmatic Implementation of Non-Blocking Linked-lists, Timothy L. Harris.</li></ol>]]></content>
    
    
    <summary type="html">Harris的这篇论文提出了一种新的non-blocking linked-list，不同于Valois使用auxiliary node，Harris在操作的时候进行了mark，解决了插入丢失的问题。论文中有详细的伪代码，清晰的描述了实现的细节。但要注意的是，实际实现必然涉及到内存回收，没有自动内存回收机制的语言会有点麻烦。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="linked list" scheme="https://chaomai.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>C++ Concurrency in Action (5) - The C++ memory model and operations on atomic types</title>
    <link href="https://chaomai.github.io/2015/2015-07-18-cpp-concurrency-in-action-5/"/>
    <id>https://chaomai.github.io/2015/2015-07-18-cpp-concurrency-in-action-5/</id>
    <published>2015-07-18T10:41:54.000Z</published>
    <updated>2021-06-27T14:57:29.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Memory-model-basics"><a href="#Memory-model-basics" class="headerlink" title="Memory model basics"></a>Memory model basics</h1><p>two aspects:</p><ul><li>the basic structural aspects;</li><li>the concurrency aspects.</li></ul><h2 id="Objects-and-memory-location"><a href="#Objects-and-memory-location" class="headerlink" title="Objects and memory location"></a>Objects and memory location</h2><p>C++程序中所有的数据都是由object组成，object是”a region of storage”。一个对象存储在一个或多个<strong>memory location</strong>。</p><p>每个memory location，</p><ul><li>要么是，一个标量的一个对象（或子对象）；</li><li>要么是，相邻bit fields的序列。（虽然相邻的bit fields是不同对象，它们仍然算作相同的memory location，除非用长度为0的bit fields隔开。）</li></ul><h2 id="Modification-orders"><a href="#Modification-orders" class="headerlink" title="Modification orders"></a>Modification orders</h2><p>C++程序中的每个对象都定义了一个modification order，它由程序中的所有线程对这个对象的write组成， starting with the object’s initialization。</p><p>在绝大多数情况下，这个order在每次运行的时候都是不同的，但对于一个给定的执行，所有的线程都必须agree on the order。如果不使用原子类型，你就必须提供有效的同步来使得这些线程都agree on the modification order of each variable。但是线程并没有必要agree on the relative order of separate objects。</p><h1 id="Atomic-Operations-and-types-in-C"><a href="#Atomic-Operations-and-types-in-C" class="headerlink" title="Atomic Operations and types in C++"></a>Atomic Operations and types in C++</h1><p>一个atomic operation是<strong>indivisible operation</strong>，要么完成，要么不完成。</p><h2 id="The-standard-atomic-types"><a href="#The-standard-atomic-types" class="headerlink" title="The standard atomic types"></a>The standard atomic types</h2><p><code>is_lock_free()</code>：给定类型的操作是直接由atomic instructions完成，还是由编译器和库提供的内部锁完成。</p><p><code>std::atomic_flag</code>没有提供<code>is_lock_free()</code>成员函数。因为在这个类型上的操作required to be lock-free，一旦有了这个lock-free的类型，就能够以它为基础，进而实现所有其他的atomic类型。</p><p>在大多数平台上，所有内置类型的atomic变种都<strong>应该</strong>是lock-free的，但这并不是必须的。</p><p>要注意的是，由于历史的原因，在有的平台，atomic类型指的不一定是<code>std::atomic&lt;&gt;</code>的specialization（如：<code>atomic_bool</code>和<code>std::atomic&lt;bool&gt;</code>）。如果混用，就可能导致不兼容的情况出现。</p><p><strong>The alternative names for the standard atomic types and their corresponding <code>std::atomic&lt;&gt;</code> specializations.</strong></p><table><thead><tr><th>Atomic type</th><th>Corresponding specialization</th></tr></thead><tbody><tr><td><code>atomic_bool</code></td><td><code>std::atomic&lt;bool&gt;</code></td></tr><tr><td><code>atomic_char</code></td><td><code>std::atomic&lt;char&gt;</code></td></tr><tr><td><code>atomic_schar</code></td><td><code>std::atomic&lt;signed char&gt;</code></td></tr><tr><td><code>atomic_uchar</code></td><td><code>std::atomic&lt;unsigned char&gt;</code></td></tr><tr><td><code>atomic_int</code></td><td><code>std::atomic&lt;int&gt;</code></td></tr><tr><td><code>atomic_uint</code></td><td><code>std::atomic&lt;unsigned&gt;</code></td></tr><tr><td><code>atomic_short</code></td><td><code>std::atomic&lt;short&gt;</code></td></tr><tr><td><code>atomic_ushort</code></td><td><code>std::atomic&lt;unsigned short&gt;</code></td></tr><tr><td><code>atomic_long</code></td><td><code>std::atomic&lt;long&gt;</code></td></tr><tr><td><code>atomic_ulong</code></td><td><code>std::atomic&lt;unsigned long&gt;</code></td></tr><tr><td><code>atomic_llong</code></td><td><code>std::atomic&lt;long long&gt;</code></td></tr><tr><td><code>atomic_ullong</code></td><td><code>std::atomic&lt;unsigned long long&gt;</code></td></tr><tr><td><code>atomic_char16_t</code></td><td><code>std::atomic&lt;char16_t&gt;</code></td></tr><tr><td><code>atomic_char32_t</code></td><td><code>std::atomic&lt;char32_t&gt;</code></td></tr><tr><td><code>atomic_wchar_t</code></td><td><code>std::atomic&lt;wchar_t&gt;</code></td></tr></tbody></table><p><strong>The standard atomic <code>typedefs</code> and their corresponding built-in <code>typedefs</code></strong></p><table><thead><tr><th>Atomic <code>typedef</code></th><th>Corresponding Standard Library <code>typedef</code></th></tr></thead><tbody><tr><td><code>atomic_int_least8_t</code></td><td><code>int_least8_t</code></td></tr><tr><td><code>atomic_uint_least8_t</code></td><td><code>uint_least8_t</code></td></tr><tr><td><code>atomic_int_least16_t</code></td><td><code>int_least16_t</code></td></tr><tr><td><code>atomic_uint_least16_t</code></td><td><code>uint_least16_t</code></td></tr><tr><td><code>atomic_int_least32_t</code></td><td><code>int_least32_t</code></td></tr><tr><td><code>atomic_uint_least32_t</code></td><td><code>uint_least32_t</code></td></tr><tr><td><code>atomic_int_least64_t</code></td><td><code>int_least64_t</code></td></tr><tr><td><code>atomic_uint_least64_t</code></td><td><code>uint_least64_t</code></td></tr><tr><td><code>atomic_int_fast8_t</code></td><td><code>int_fast8_t</code></td></tr><tr><td><code>atomic_uint_fast8_t</code></td><td><code>uint_fast8_t</code></td></tr><tr><td><code>atomic_int_fast16_t</code></td><td><code>int_fast16_t</code></td></tr><tr><td><code>atomic_uint_fast16_t</code></td><td><code>uint_fast16_t</code></td></tr><tr><td><code>atomic_int_fast32_t</code></td><td><code>int_fast32_t</code></td></tr><tr><td><code>atomic_uint_fast32_t</code></td><td><code>uint_fast32_t</code></td></tr><tr><td><code>atomic_int_fast64_t</code></td><td><code>int_fast64_t</code></td></tr><tr><td><code>atomic_uint_fast64_t</code></td><td><code>uint_fast64_t</code></td></tr><tr><td><code>atomic_intptr_t</code></td><td><code>intptr_t</code></td></tr><tr><td><code>atomic_uintptr_t</code></td><td><code>uintptr_t</code></td></tr><tr><td><code>atomic_size_t</code></td><td><code>size_t</code></td></tr><tr><td><code>atomic_ptrdiff_t</code></td><td><code>ptrdiff_t</code></td></tr><tr><td><code>atomic_intmax_t</code></td><td><code>intmax_t</code></td></tr><tr><td><code>atomic_uintmax_t</code></td><td><code>uintmax_t</code></td></tr></tbody></table><p>要注意的是：</p><ol><li><p>标准的atomic类型<strong>不是copyable和assignable</strong>的；</p><blockquote><p>因为这些操作总是涉及到两个对象，必须从一个中read，然后write到另一个，这是两个单独的操作，合起来不可能是atomic。因此就不被允许。</p></blockquote></li><li><p>支持assignment from和implicit conversion to对应的内置类型；</p></li><li><p>赋值操作返回的并不是reference  to  the  object  it’s<br>assigned to，而是the value assigned。</p><blockquote><p>因为如果返回了reference  to atomic variable，那些使用这个变量的代码需要显示的<code>load()</code>，实际使用到值的可能是其他线程已经修改过的。</p></blockquote></li></ol><p><strong>Memory-ordering</strong></p><p>每个在atomic类型上的操作都有memory-ordering参数，来指定memory-ordering语义。不同的操作可传入不同的参数，操作分为三类：</p><ol><li>Store</li><li>Load</li><li>Read-modify-write</li></ol><p>默认是<code>memory_order_seq_cst</code>。</p><h2 id="Operations-on-std-atomic-flag"><a href="#Operations-on-std-atomic-flag" class="headerlink" title="Operations on std::atomic_flag"></a>Operations on <code>std::atomic_flag</code></h2><p>代表一个boolean flag，只能是两种状态：set或clear，并且总是starts clear。</p><p>必须用<code>ATOMIC_FLAG_INIT</code>来初始化，<code>std::atomic_flag guard = ATOMIC_FLAG_INIT</code>。这是唯一需要使用这样的特殊方式来初始化的类型，也是<strong>唯一一个</strong>保证lock-free的。</p><p>如果是<code>static</code>，那么在首次操作flag的时候初始化。</p><p>用于实现spinlock，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::atomic_flag flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    spinlock_mutex():</span><br><span class="line">        flag(ATOMIC_FLAG_INIT) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag.test_and_set(<span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag.clear(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Operations-on-std-atomic-lt-bool-gt"><a href="#Operations-on-std-atomic-lt-bool-gt" class="headerlink" title="Operations on std::atomic&lt;bool&gt;"></a>Operations on <code>std::atomic&lt;bool&gt;</code></h2><p>可用nonatomic bool来初始化，还可以向实例赋nonatomic bool值，**<code>std::atomic&lt;bool&gt;</code>可能不是lock-free的！**</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">b = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><ul><li>write：<code>store()</code>；</li><li>read-modify-write：<code>exchange()</code>；</li><li>nonmodifying query：<code>load()</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> x=b.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">b.store(<span class="literal">true</span>);</span><br><span class="line">x=b.exchange(<span class="literal">false</span>,<span class="built_in">std</span>::memory_order_acq_rel);</span><br></pre></td></tr></table></figure><p><strong>compare/exchange</strong></p><ul><li><code>compare_exchange_weak()</code></li><li><code>compare_exchange_strong()</code></li></ul><p>如果失败，expected value或被更新为original value，都接受两个memory-ordering参数。</p><p>有这么几个要注意的地方：</p><ol><li>一个failed compare/exchange是不会进行保存的，因此某些memory-ordering语义是不可用的（<code>memory_order_release</code>和<code>memory_order_acq_rel</code>）。</li><li>can’t supply stricter memory ordering for failure than for success。</li><li>如果不为failure提供memory-ordering参数，则<strong>在满足1的情况下</strong>，与success一致。</li><li>如果都不提供，则使用默认的<code>memory_order_seq_cst</code>。</li><li>它们是read-modify-write operation。</li></ol><p><em>蛋疼的作者啊，很多地方扯到memory-ordering语义，但是总是说“leave to section 5.3…”</em></p><h2 id="Operations-on-std-atomic-lt-T-gt"><a href="#Operations-on-std-atomic-lt-T-gt" class="headerlink" title="Operations on std::atomic&lt;T*&gt;"></a>Operations on <code>std::atomic&lt;T*&gt;</code></h2><p><code>std::atomic&lt;bool&gt;</code>有的成员函数，这个也有。</p><p><code>std::atomic&lt;T*&gt;</code>还提供了pointer arithmetic operations，由<code>fetch_add()</code>和<code>fetch_sub()</code>实现。</p><p><strong><code>fetch_add()</code>和<code>fetch_sub()</code></strong></p><ol><li><p>也叫做<em>exchange-and-add</em>，它们是atomic read-modify-write operation。</p></li><li><p>返回的是原始的值，而不是add或sub后的值。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span>&#125;;</span><br><span class="line">Foo some_array[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;Foo*&gt; <span class="title">p</span><span class="params">(some_array)</span></span>;</span><br><span class="line">Foo* x=p.fetch_add(<span class="number">2</span>);</span><br><span class="line">assert(x==some_array);</span><br><span class="line">assert(p.load()==&amp;some_array[<span class="number">2</span>]);</span><br><span class="line">x=(p-=<span class="number">1</span>);</span><br><span class="line">assert(x==&amp;some_array[<span class="number">1</span>]);</span><br><span class="line">assert(p.load()==&amp;some_array[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></li></ol><h2 id="Operations-on-standard-atomic-integral-types"><a href="#Operations-on-standard-atomic-integral-types" class="headerlink" title="Operations on standard atomic integral types"></a>Operations on standard atomic integral types</h2><p>Only division, multiplication, and shift operators are missing。因为atomic integral types通常作为计数器或位域来使用，如果需要额外的操作，可以在loop中用<code>compare_exchange_weak()</code>来实现。</p><h2 id="The-std-atomic-lt-gt-primary-class-template"><a href="#The-std-atomic-lt-gt-primary-class-template" class="headerlink" title="The std::atomic&lt;&gt; primary class template"></a>The <code>std::atomic&lt;&gt;</code> primary class template</h2><p>要将user-defined type用于<code>std::atomic&lt;&gt;</code>，UDT必须满足：</p><ol><li><p>必须有trivial copy-assignment operator；</p><blockquote><ul><li>不能有任何的virtual函数或者virtual基类；</li><li>必须使用编译器生成的copy-assignment operator。</li></ul></blockquote></li><li><p>每个基类和非static数据成员必须有trivial copy-assignment operator；</p><blockquote><ul><li>这可以使得编译器将<code>memcpy()</code>或等价的操作用于assignment operation。</li></ul></blockquote></li><li><p>这个类型必须是bitwise equality comparable。</p><blockquote><ul><li>这里接着2，不仅要能够使用<code>memcpy()</code>来copy，还要能使用<code>memcmp()</code>来比较（以便compare/exchange能工作）。</li></ul></blockquote></li></ol><p><strong>为什么要满足？</strong></p><ol><li>If <strong>user-supplied</strong> copy-assignment or comparison operators were permitted, this would <strong>require passing a reference to the protected data</strong> as an argument <strong>to a user-supplied function</strong>, thus violating the guideline.</li><li>增大了编译器对<code>std::atomic&lt;UDT&gt;</code>直接使用atomic instruction的可能，因为编译器可以把UDT看作a set of raw bytes。</li></ol><p><strong><code>std::atomic&lt;float&gt; and std::atomic&lt;double&gt;</code>？</strong></p><p>因为表示的不同，即使相等<code>compare_exchange_strong()</code>也会fail。</p><h2 id="Free-functions-for-atomic-operations"><a href="#Free-functions-for-atomic-operations" class="headerlink" title="Free functions for atomic operations"></a>Free functions for atomic operations</h2><p>与原子类型的成员函数相对应，也有相应的非成员函数，大多数前面都会加上<code>atomic_</code>。</p><p>要注意的地方有：</p><ol><li><p>用含有<code>_explict</code>的版本来指定memory ordering；</p></li><li><p>所有free functions的第一个参数类型都是pointer to atomic objcet(为了C-compatible)；</p><blockquote><p>对于CAS，要么不指定failure memory ordering，要么两个都要指定。</p></blockquote></li><li><p>对于<code>std::atomic_flag</code>只能，</p><ul><li><code>std::atomic_flag_test_and_set()</code></li><li><code>std::atomic_flag_clear()</code></li><li><code>std::atomic_flag_test_and_set_explicit()</code></li><li><code>std::atomic_flag_clear_explicit()</code></li></ul></li><li><p><code>std::shared_ptr&lt;&gt;</code>算是特殊，它非atomic type，但支持load, store, exchange and compare/exchange。这些free functions第一个参数接受<code>std::shared_ptr&lt;&gt;*</code>。</p></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://stackoverflow.com/questions/24437396/stdatomic-flag-as-member-variable">std::atomic_flag as member variable</a></li></ol>]]></content>
    
    
    <summary type="html">The C++ memory model and operations on atomic types的笔记。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="cpp" scheme="https://chaomai.github.io/tags/cpp/"/>
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="cpp11" scheme="https://chaomai.github.io/tags/cpp11/"/>
    
    <category term="c++ concurrency in action" scheme="https://chaomai.github.io/tags/c-concurrency-in-action/"/>
    
    <category term="atomic" scheme="https://chaomai.github.io/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS100.1x Introduction to Big Data with Apache Spark (1)</title>
    <link href="https://chaomai.github.io/2015/2015-06-26-notes-of-cs100-1x-introduction-to-big-data-with-apache-spark-1/"/>
    <id>https://chaomai.github.io/2015/2015-06-26-notes-of-cs100-1x-introduction-to-big-data-with-apache-spark-1/</id>
    <published>2015-06-26T09:15:43.000Z</published>
    <updated>2021-06-27T14:57:29.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lecture-3-Big-Data-Hardware-Trends-and-Apache-Spark-and-Lecture-4-Spark-Essentials"><a href="#Lecture-3-Big-Data-Hardware-Trends-and-Apache-Spark-and-Lecture-4-Spark-Essentials" class="headerlink" title="Lecture 3: Big Data, Hardware Trends, and Apache Spark and Lecture 4: Spark Essentials"></a>Lecture 3: Big Data, Hardware Trends, and Apache Spark and Lecture 4: Spark Essentials</h2><h3 id="The-Big-Data-Problem"><a href="#The-Big-Data-Problem" class="headerlink" title="The Big Data Problem"></a>The Big Data Problem</h3><ul><li>Growing data sources</li><li>Storage getting cheapper</li><li>But stalling CPU and storage bottlenecks</li></ul><h3 id="Hardware-for-Big-Data"><a href="#Hardware-for-Big-Data" class="headerlink" title="Hardware for Big Data"></a>Hardware for Big Data</h3><p>Problems with cheap hardware</p><ul><li>Failures</li><li>Network</li><li>Uneven performance</li></ul><h3 id="What’s-Hard-About-Cluster-Computing"><a href="#What’s-Hard-About-Cluster-Computing" class="headerlink" title="What’s Hard About Cluster Computing"></a>What’s Hard About Cluster Computing</h3><ul><li>Divide work across machines<ul><li>Must consider network, data locality</li><li>Moving data may be veay expensive</li></ul></li><li>Deal with failures</li></ul><h2 id="Spark-Essentials"><a href="#Spark-Essentials" class="headerlink" title="Spark Essentials"></a>Spark Essentials</h2><h3 id="PySpark"><a href="#PySpark" class="headerlink" title="PySpark"></a>PySpark</h3><p>A Spark program consists of two programs, a driver program<br>and a workers program.</p><ul><li>Drivers program: runs on the driver machine.</li><li>Worker programs: run on cluster nodes<br>or in local threads.</li></ul><p>RDDs are distributed across the workers.</p><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><p>An RDD is immutable, so once it is created, it cannot be changed.</p><p>types of operations:</p><ul><li><p>transformations</p><ul><li>lazily evaluated.</li><li>A transformed RDD is executed only when an action runs on it.</li><li>can also persist, or cache RDDs in memory or on disk.<br>?</li></ul></li><li><p>actions</p><ul><li>cause Spark to execute the recipe to transform the source data.</li></ul></li></ul><h3 id="Spark-Programming-Model"><a href="#Spark-Programming-Model" class="headerlink" title="Spark Programming Model"></a>Spark Programming Model</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lines = sc.textFile(<span class="string">&quot;...&quot;</span>, <span class="number">4</span>)</span><br><span class="line">comments = lines.<span class="built_in">filter</span>(isComment)</span><br><span class="line"><span class="built_in">print</span> lines.count(), comments.count()</span><br></pre></td></tr></table></figure><p><code>comments.count()</code> is going to cause Spark to re-compute lines. reread all of the data from that text file again, sum within the partition the number of lines, so the number of elements, and then combine those sums in the driver.</p><h3 id="Caching-RDDS"><a href="#Caching-RDDS" class="headerlink" title="Caching RDDS"></a>Caching RDDS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lines = sc.textFile(<span class="string">&quot;...&quot;</span>, <span class="number">4</span>)</span><br><span class="line">lines.cache()</span><br><span class="line">comments = lines.<span class="built_in">filter</span>(isComment)</span><br><span class="line"><span class="built_in">print</span> lines.count(), comments.count()</span><br></pre></td></tr></table></figure><p>create the comments RDD directly, instead of reading from disk.</p><h3 id="Spark-Program-Lifecycle"><a href="#Spark-Program-Lifecycle" class="headerlink" title="Spark Program Lifecycle"></a>Spark Program Lifecycle</h3><ol><li>create RDDs from some external data source or parallelize a collection in your driver program.</li><li>lazily transform these RDDs into new RDDs.</li><li>cache some of those RDDs for future reuse.</li><li>perform actions to execute parallel computation and to produce results.</li></ol><h3 id="Spark-Broadcast-Variables"><a href="#Spark-Broadcast-Variables" class="headerlink" title="Spark Broadcast Variables"></a>Spark Broadcast Variables</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">broadcast_var = sc.broadcast([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">...</span><br><span class="line">broadcast_var.value</span><br></pre></td></tr></table></figure><p>Keep a read-only variable cached at a worker and will be reused every time we need to access it instead of constructing another closure.</p><h3 id="Spark-Accumulators"><a href="#Spark-Accumulators" class="headerlink" title="Spark Accumulators"></a>Spark Accumulators</h3><p>could only be added to by an associative operation. They’re used to very efficiently implement parallel counters and sums, and only the driver can read an accumulator’s values, not the tasks.</p><p>can be used in actions or transformations:</p><ul><li>actions: each tasks update to the accumulator is guaranteed by spark to <strong>only be applied once</strong>.</li><li>transformations: no guarantee.</li></ul><p>support the types:</p><ul><li>integers</li><li>double</li><li>long</li><li>float</li><li>custom types</li></ul><h2 id="About-pySpark"><a href="#About-pySpark" class="headerlink" title="About pySpark"></a>About pySpark</h2><h3 id="Spark-Context"><a href="#Spark-Context" class="headerlink" title="Spark Context"></a>Spark Context</h3><p>When running Spark, you start a new Spark application by creating a SparkContext. When the SparkContext is created, it asks the master for some cores to use to do work. The master sets these cores aside just for you; they <strong>won’t be used for other applications</strong>.</p><p>Driver programs access Spark through a SparkContext object, which represents <strong>a connection to a computing cluster</strong>. A Spark context object (sc) is the main entry point for Spark functionality. A Spark context can be used to create Resilient Distributed Datasets (RDDs) on a cluster.</p><p><img data-src="http://spark-mooc.github.io/web-assets/images/executors.png"></p><h3 id="Resilient-Distributed-Datasets-RDDs"><a href="#Resilient-Distributed-Datasets-RDDs" class="headerlink" title="Resilient Distributed Datasets (RDDs)"></a>Resilient Distributed Datasets (RDDs)</h3><p><img data-src="http://spark-mooc.github.io/web-assets/images/partitions.png"></p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a><code>map()</code></h3><p>When you run <code>map()</code> on a dataset, a <strong>single stage of tasks</strong> is launched. A stage is <em>a group of tasks that all perform the same computation, but on different input data</em>. <strong>One task is launched for each partition</strong>. A task is <em>a unit of execution that runs on a single machine</em>. When we run <code>map(f)</code> within a partition, a new task applies f to all of the entries in a particular partition, and outputs a new partition.</p><p><img data-src="http://spark-mooc.github.io/web-assets/images/map.png"></p><p>When applying the <code>map()</code> transformation, each item in the parent RDD will map to one element in the new RDD.</p><h3 id="collect"><a href="#collect" class="headerlink" title="collect()"></a><code>collect()</code></h3><p>the data returned to the driver <strong>must fit into the driver’s available memory</strong>. If not, the driver will crash.</p><h3 id="first-and-take"><a href="#first-and-take" class="headerlink" title="first() and take()"></a><code>first()</code> and <code>take()</code></h3><p><code>first()</code> and <code>take()</code> actions, the elements that are returned depend on how the RDD is partitioned.</p><h3 id="takeOrdered"><a href="#takeOrdered" class="headerlink" title="takeOrdered()"></a><code>takeOrdered()</code></h3><p>The key advantage of using <code>takeOrdered()</code> instead of <code>first()</code> or <code>take()</code> is that <code>takeOrdered()</code> returns a <strong>deterministic result</strong>, while the other two actions may return different results, <em>depending on the number of partitions or execution environment</em>.</p><p><code>takeOrdered()</code> returns the list sorted in <strong>ascending order</strong>. The <code>top()</code> action is similar to <code>takeOrdered()</code> except that it returns the list in <strong>descending order</strong>.</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a><code>reduce()</code></h3><p>reduces the elements of a RDD to a single value by applying a function that takes two parameters and returns a single value.</p><p>The function should be <strong>commutative and associative（可交换和可结合）</strong>, as <code>reduce()</code> is applied at the partition level and then again to aggregate results from partitions.</p><h3 id="takeSample-and-countByValue"><a href="#takeSample-and-countByValue" class="headerlink" title="takeSample() and countByValue()"></a><code>takeSample()</code> and <code>countByValue()</code></h3><p>The <code>takeSample()</code> action returns an array with a random sample of elements from the dataset. It takes in a <code>withReplacement</code> argument, which specifies whether it is okay to randomly pick the same item multiple times from the parent RDD. It also takes an optional <code>seed</code> parameter that allows you to specify a seed value for the random number generator, so that reproducible results can be obtained.</p><p>The <code>countByValue()</code> action returns <strong>the count of each unique value</strong> in the RDD as a dictionary that maps values to counts.</p><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a><code>flatMap()</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">simpleRDD = sc.parallelize([[[<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>],<span class="number">2</span>,<span class="number">3</span>], [[<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>],<span class="number">3</span>,<span class="number">4</span>], [[<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>],<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span> simpleRDD.<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x).collect()</span><br><span class="line"><span class="built_in">print</span> simpleRDD.flatMap(<span class="keyword">lambda</span> x:x).collect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">[[[<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">2</span>, <span class="number">3</span>], [[<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">4</span>], [[<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">[[<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">2</span>, <span class="number">3</span>, [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">3</span>, <span class="number">4</span>, [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h3 id="groupByKey-and-reduceByKey"><a href="#groupByKey-and-reduceByKey" class="headerlink" title="groupByKey() and reduceByKey()"></a><code>groupByKey()</code> and <code>reduceByKey()</code></h3><p>Both of these transformations operate on <em>pair RDDs</em>. A pair RDD is an RDD where <em>each element is a pair tuple (key, value)</em>.</p><p><img data-src="http://spark-mooc.github.io/web-assets/images/reduce_by.png"></p><p><img data-src="http://spark-mooc.github.io/web-assets/images/group_by.png"></p><p><code>reduceByKey()</code> operates by applying the function first within each partition on a per-key basis and then across the partitions.</p><ul><li>the <code>reduceByKey()</code> transformation works much better for large distributed datasets. This is because Spark knows it can <em>combine output with a common key on each partition before shuffling</em> (redistributing) the data across nodes. Only use <code>groupByKey()</code> if the operation would not benefit from reducing the data before the shuffle occurs.</li><li>On the other hand, when using the <code>groupByKey()</code> transformation - all the key-value pairs are shuffled around, causing a lot of unnecessary data to being transferred over the network.</li></ul><h3 id="cache-and-unpersist"><a href="#cache-and-unpersist" class="headerlink" title="cache() and unpersist()"></a><code>cache()</code> and <code>unpersist()</code></h3><p>if you cache too many RDDs and Spark runs out of memory, it will delete the least recently used (LRU) RDD first. The RDD will be automatically recreated when accessed.</p><p>tell Spark to stop caching it in memory by using the RDD’s <code>unpersist()</code> method.</p>]]></content>
    
    
    <summary type="html">Notes of Lecture 3 Big Data, Hardware Trends, and Apache Spark.</summary>
    
    
    
    <category term="spark" scheme="https://chaomai.github.io/categories/spark/"/>
    
    
    <category term="spark" scheme="https://chaomai.github.io/tags/spark/"/>
    
    <category term="pyspark" scheme="https://chaomai.github.io/tags/pyspark/"/>
    
    <category term="edx" scheme="https://chaomai.github.io/tags/edx/"/>
    
  </entry>
  
  <entry>
    <title>Tmux</title>
    <link href="https://chaomai.github.io/2015/2015-06-22-tmux/"/>
    <id>https://chaomai.github.io/2015/2015-06-22-tmux/</id>
    <published>2015-06-22T12:36:57.000Z</published>
    <updated>2021-06-27T14:57:29.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><h3 id="Creating-Named-Sessions"><a href="#Creating-Named-Sessions" class="headerlink" title="Creating Named Sessions"></a>Creating Named Sessions</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new-session -s basic</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s basic</span><br></pre></td></tr></table></figure><h3 id="Detaching-Sessions"><a href="#Detaching-Sessions" class="headerlink" title="Detaching Sessions"></a>Detaching Sessions</h3><p><code>CTRL-b</code>, then <code>d</code></p><h3 id="Reattaching-to-Existing-Sessions"><a href="#Reattaching-to-Existing-Sessions" class="headerlink" title="Reattaching to Existing Sessions"></a>Reattaching to Existing Sessions</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new-session -s basic</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure><blockquote><ol><li>If there is only session, then <code>tmux attach</code>.</li><li>If there are multiple sessions, then <code>tmux attach -t second_session</code>. BTY, you can also use this when you only have one session.</li></ol></blockquote><h3 id="Killing-Sessions"><a href="#Killing-Sessions" class="headerlink" title="Killing Sessions"></a>Killing Sessions</h3><ul><li>In sesssion, use <code>exit</code>.</li><li>Kill specific session when not in session,</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux kill-session -t basic</span><br></pre></td></tr></table></figure><p>BTY, if there is no sessions, after typing <code>tmux ls</code>, you will get</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to connect to server: Connection refused</span><br></pre></td></tr></table></figure><h3 id="Creating-and-Naming-Windows"><a href="#Creating-and-Naming-Windows" class="headerlink" title="Creating and Naming Windows"></a>Creating and Naming Windows</h3><ul><li><p>In terminal</p><p>  <code>-n</code>: the name of new window.</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s windows -n shell</span><br></pre></td></tr></table></figure></li><li><p>In session</p><p>  <code>PREFIX c</code></p><p>  <code>PREFIX ,</code> will rename the new window.</p></li></ul><h3 id="Moving-Between-Windows"><a href="#Moving-Between-Windows" class="headerlink" title="Moving Between Windows"></a>Moving Between Windows</h3><ul><li><p>next and previous window</p><p>  <code>PREFIX n</code> and <code>PREFIX p</code></p></li><li><p>default id of window</p><p>  <code>PREFIX 0</code> to <code>PREFIX 9</code></p></li><li><p>find a window</p><p>  <code>PREFIX f</code></p></li><li><p>window list</p><p>  <code>PREFIX w</code></p></li></ul><h3 id="Close-a-Window"><a href="#Close-a-Window" class="headerlink" title="Close a Window"></a>Close a Window</h3><ul><li>type <code>exit</code> after command finish executed.</li><li><code>PREFIX &amp;</code></li></ul><p>If you want to quit a tmux session, you’ll have to close all windows.</p><h3 id="Panes"><a href="#Panes" class="headerlink" title="Panes"></a>Panes</h3><ul><li>vertically: <code>PREFIX %</code></li><li>horizontally: <code>PREFIX &quot;</code></li><li>switch between them:<ul><li>cycle through: <code>PREFIX o</code></li><li><code>PREFIX UP</code>, <code>PREFIX DOWN</code>, <code>PREFIX LEFT</code>, or <code>PREFIX RIGHT</code></li></ul></li></ul><h3 id="Pane-Layouts"><a href="#Pane-Layouts" class="headerlink" title="Pane Layouts"></a>Pane Layouts</h3><p>types:</p><ul><li>even-horizontal</li><li>even-vertical</li><li>main-horizontal</li><li>main-vertical</li><li>tiled</li></ul><p>cycle through these types by pressing <code>PREFIX SPACEBAR</code>.</p><h3 id="Closing-Panes"><a href="#Closing-Panes" class="headerlink" title="Closing Panes"></a>Closing Panes</h3><ul><li><code>exit</code></li><li><code>PREFIX X</code>. If there is only one pane in current window, it will close this window at the same time.</li></ul><h3 id="Command-Mode"><a href="#Command-Mode" class="headerlink" title="Command Mode"></a>Command Mode</h3><p>press <code>PREFIX :</code> to enter command mode.</p><ul><li>create new window with a name,</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new-window -n console</span><br></pre></td></tr></table></figure><ul><li>create new window with a name and a command,</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new-window -n processes <span class="string">&quot;top&quot;</span></span><br></pre></td></tr></table></figure><p><code>top</code> will execute immediately after new window created. What’s really cool is that <strong>this window close instantly when you press <code>q</code> to close top.</strong></p><h3 id="Quick-Reference"><a href="#Quick-Reference" class="headerlink" title="Quick Reference"></a>Quick Reference</h3><p><strong>创建会话</strong></p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>tmux new-session</code></td><td>创建一个未命名的会话。可以简写为 <code>tmux new</code> 或者就一个简单的 <code>tmux</code></td></tr><tr><td><code>tmux new -s development</code></td><td>创建一个名为“development”的会话</td></tr><tr><td><code>tmux new -s development -n editor</code></td><td>创建一个名为“development”的会话并把该会话的第一个窗口命名为“editor”</td></tr><tr><td><code>tmux attach -t development</code></td><td>连接到一个名为“development”的会话</td></tr></tbody></table><p><strong>会话、窗口和面板的默认快捷键</strong></p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td><code>PREFIX d</code></td><td>从一个会话中分离，让该会话在后台运行。</td></tr><tr><td><code>PREFIX :</code></td><td>进入命令模式</td></tr><tr><td><code>PREFIX c</code></td><td>在当前tmux会话创建一个新的窗口，是 new-window 命令的简写</td></tr><tr><td><code>PREFIX 0...9</code></td><td>根据窗口的编号选择窗口</td></tr><tr><td><code>PREFIX w</code></td><td>显示当前会话中所有窗口的可选择列表</td></tr><tr><td><code>PREFIX ,</code></td><td>显示一个提示符来重命名一个窗口</td></tr><tr><td><code>PREFIX &amp;</code></td><td>关闭当前窗口，带有确认提示</td></tr><tr><td><code>PREFIX %</code></td><td>把当前窗口垂直地一分为二，分割后的两个面板各占50%大小</td></tr><tr><td><code>PREFIX &quot;</code></td><td>把当前窗口水平地一分为二，分割后的两个面板各占50%大小</td></tr><tr><td><code>PREFIX o</code></td><td>在已打开的面板之间循环移动当前焦点</td></tr><tr><td><code>PREFIX q</code></td><td>短暂地显示每个面板的编号</td></tr><tr><td><code>PREFIX x</code></td><td>关闭当前面板，带有确认提示</td></tr><tr><td><code>PREFIX SPACE</code></td><td>循环地使用tmux的几个默认面板布局</td></tr></tbody></table><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li>[tmux-Productive-Mouse-Free-Development_zh(<a href="https://github.com/aqua7regia/tmux-Productive-Mouse-Free-Development_zh">https://github.com/aqua7regia/tmux-Productive-Mouse-Free-Development_zh</a>)</li></ol>]]></content>
    
    
    <summary type="html">tmux的简单操作。</summary>
    
    
    
    <category term="linux" scheme="https://chaomai.github.io/categories/linux/"/>
    
    
    <category term="tmux" scheme="https://chaomai.github.io/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>apt-get hold version</title>
    <link href="https://chaomai.github.io/2015/2015-06-16-apt-get-hold-version/"/>
    <id>https://chaomai.github.io/2015/2015-06-16-apt-get-hold-version/</id>
    <published>2015-06-16T14:56:47.000Z</published>
    <updated>2021-06-27T14:57:29.261Z</updated>
    
    <content type="html"><![CDATA[<p>If you want some specific package not to be processed（keep the current version with the current status whatever that is）, you can hold it.</p><h2 id="hold"><a href="#hold" class="headerlink" title="hold"></a>hold</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;package_name hold&quot;</span> | dpkg --set-selections</span><br></pre></td></tr></table></figure><h2 id="unhold"><a href="#unhold" class="headerlink" title="unhold"></a>unhold</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;package_name install&quot;</span> | dpkg --set-selecions</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://www.debian.org/doc/manuals/debian-faq/ch-pkg_basics.en.html">The Debian GNU/Linux FAQ<br>Chapter 7 - Basics of the Debian package management system</a></li></ol>]]></content>
    
    
    <summary type="html">在ubuntu上进行update的时候，有的时候会不想升级某些包，这时可以用dpkg来hold住包，不让它升级。</summary>
    
    
    
    <category term="linux" scheme="https://chaomai.github.io/categories/linux/"/>
    
    
    <category term="apt-get" scheme="https://chaomai.github.io/tags/apt-get/"/>
    
    <category term="ubuntu" scheme="https://chaomai.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>译 - Understand `std::atomic::compare_exchange_weak()` in C++11</title>
    <link href="https://chaomai.github.io/2015/2015-06-09-translation-understand-std-atomic-compare-exchange-weak-in-cpp11/"/>
    <id>https://chaomai.github.io/2015/2015-06-09-translation-understand-std-atomic-compare-exchange-weak-in-cpp11/</id>
    <published>2015-06-08T16:00:49.000Z</published>
    <updated>2021-06-27T14:57:29.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>原文是stackoverflow上的<a href="http://stackoverflow.com/questions/25199838/understanding-stdatomiccompare-exchange-weak-in-c11">一个关于<code>compare_exchange_weak()</code>问题和相应的答案</a>。</p></blockquote><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_exchange_weak</span> <span class="params">(T&amp; expected, T val, ..)</span></span>;</span><br></pre></td></tr></table></figure><p><code>compare_exchange_weak()</code>是C++11中提供的compare-exchange原语之一。之所以是<strong>weak</strong>，是因为即使在对象的值等于<code>expected</code>的情况下，也返回false。这是因为在某些平台上的<strong>spurious failure</strong>，这些平台使用了一系列的指令（而不是像在x86上一样，使用单条的指令）来实现CAS。在这种平台上，context switch, reloading of the same address (or cache line) by another thread等，将会导致这条原语失败。由于不是因为对象的值（不等于<code>expected</code>）导致的操作失败，因此是<code>spurious</code>。相反的，it’s kind of timing issues。</p><p>但是困扰我的是C++11标准（ISO/IEC 14882）里的，</p><blockquote><p>29.6.5 .. A consequence of spurious failure is that nearly all uses of weak compare-and-exchange will be in a loop.</p></blockquote><p>为什么in <strong>nearly all uses</strong>都必须在一个loop中？这是不是意味着因为有spurious failures，当它失败的时候，我们将会loop？如果这是原因，那么为什么我们还要那么麻烦的使用<code>compare_exchange_weak()</code>，并且自己写loop？我们可以直接使用<code>compare_exchange_strong()</code>，我认为这样可以让我们摆脱spurious failures。<code>compare_exchange_weak()</code>通常在什么情况下使用？</p><p>另一个相关的问题是，在Anthony的”C++ Concurrency In Action”一书中写到，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Because compare_exchange_weak() can fail spuriously, it must typically</span></span><br><span class="line"><span class="comment">//be used in a loop:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> expected=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="keyword">bool</span>&gt; b; <span class="comment">// set somewhere else</span></span><br><span class="line"><span class="keyword">while</span>(!b.compare_exchange_weak(expected,<span class="literal">true</span>) &amp;&amp; !expected);</span><br><span class="line"></span><br><span class="line"><span class="comment">//In this case, you keep looping as long as expected is still false,</span></span><br><span class="line"><span class="comment">//indicating that the compare_exchange_weak() call failed spuriously.</span></span><br></pre></td></tr></table></figure><p>为什么在loop的条件中有!expected？它是不是防止了所有线程可能会starve，并且在一段时间里make no progress？</p><p><strong>Edit：(最后一个问题)</strong></p><p>在那些没有单条硬件CAS指令的平台上，weak和strong版本都是使用LL/SC来实现的（像ARM，PowerPC等）。那么下面的两种loop之间是否有区别？如果有的话，为什么？（对我来说，我觉得它们应该有相似的性能）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use LL/SC (or CAS on x86) and ignore/loop on spurious failures</span></span><br><span class="line"><span class="keyword">while</span> (!compare_exchange_weak(..))</span><br><span class="line">&#123; .. &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use LL/SC (or CAS on x86) and ignore/loop on spurious failures</span></span><br><span class="line"><span class="keyword">while</span> (!compare_exchange_strong(..))</span><br><span class="line">&#123; .. &#125;</span><br></pre></td></tr></table></figure><p>你们都提到，在loop在可能会存在性能上的区别。这也在C++11（ISO/IEC 14882）标准中提到，</p><blockquote><p>When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</p></blockquote><p>但是根据上面的分析，两个版本的loop应该有相同或类似的性能。我遗漏了什么吗？</p><h2 id="Answer-1"><a href="#Answer-1" class="headerlink" title="Answer 1"></a>Answer 1</h2><h3 id="Why-doing-exchange-in-a-loop"><a href="#Why-doing-exchange-in-a-loop" class="headerlink" title="Why doing exchange in a loop?"></a>Why doing exchange in a loop?</h3><p>通常来说，你想要在进行下一步的工作前完成当前的工作，因此，你把<code>compare_exchange_weak</code>放入了一个loop，以便一直尝试exchange直到成功（也就是说，返回<code>true</code>）。</p><p>要注意的是，<code>compare_exchange_strong</code>也常常用在loop中。它不会因为spurious failure而失败，但会因为concurrent writes而失败。</p><h3 id="Why-to-use-weak-instead-of-strong"><a href="#Why-to-use-weak-instead-of-strong" class="headerlink" title="Why to use weak instead of strong?"></a>Why to use <code>weak</code> instead of <code>strong</code>?</h3><p>很简单：spurious failure并不会经常发生，因此这不会有大的性能损失。相反，tolerate这种failure允许在某些平台上有更高效的<code>weak</code>版本的实现（与<code>strong</code>相比较）。<code>strong</code>必须每次都检查spurious failure，并处理它，这是有代价的。</p><p>因此，<code>weak</code>在某些平台上比<code>strong</code>更快使得<code>weak</code>被使用。</p><h3 id="When-should-you-use-weak-and-when-strong"><a href="#When-should-you-use-weak-and-when-strong" class="headerlink" title="When should you use weak and when strong?"></a>When should you use <code>weak</code> and when <code>strong</code>?</h3><p>这个<a href="http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange">参考文献</a>指明了什么时候用<code>weak</code>，什么时候用<code>strong</code>：</p><blockquote><p>When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.</p></blockquote><blockquote><p>当compare-and-exchange在loop中，weak版本在某些平台上会有更高的性能。当一个weak的compare-and-exchange需要一个loop，而strong的不需要，那么用strong的更合适。</p></blockquote><p>因此这个答案很容易记住：如果你使用loop仅仅是由于spurious failure，那么不要使用loop；用<code>strong</code>。如果你无法避免的要使用loop，那么就是用<code>weak</code>。</p><h3 id="Why-is-expected-in-the-example"><a href="#Why-is-expected-in-the-example" class="headerlink" title="Why is !expected in the example?"></a>Why is <code>!expected</code> in the example?</h3><p>这视实际情况和期望的语义而定，但是通常it is not needed for correctness。忽略它会产生一个非常相似的语义。仅仅在另一个线程可能会把值reset为<code>false</code>的情况下，这个语义才会有细微的差别（但是我没有找到一个比较meaningful的例子），Tony D的评论有更详细的解释。</p><p><strong>Tony D：</strong></p><p>“Why is !expected in the example? It is not needed for correctness. Omitting it would yield the same semantics.”</p><p>并非如此。假设第一个exchange由于b已经是<code>true</code>而失败，此时<code>expected</code>变为<code>true</code>。如果没有<code>&amp;&amp; !expected</code>的话，它只会再次loop，并且（傻傻的）将<code>true</code>与<code>true</code>交换。这可能会成功并且退出<code>while</code> loop。But could exhibit meaningfully different behavior if b had meanwhile changed back to false, in which case the loop would continue and may ultimately set b true yet again before breaking.</p><p>当其他线程写入<code>true</code>时，这是个简单快捷的方法：我们只需要终止，而不是再次尝试写入<code>true</code>。</p><h3 id="About-your-last-question"><a href="#About-your-last-question" class="headerlink" title="About your last question"></a>About your last question</h3><blockquote><p>但是根据上面的分析，两个版本的loop应该有相同或类似的性能。我遗漏了什么吗？</p></blockquote><p>在<a href="http://en.wikipedia.org/wiki/Load-link/store-conditional">Wikipedia</a>：</p><blockquote><p>Real implementations of LL/SC do not always succeed if there are no concurrent updates to the memory location in question. Any exceptional events between the two operations, such as a context switch, another load-link, or even (on many platforms) another load or store operation, will cause the store-conditional to spuriously fail. Older implementations will fail if there are any updates broadcast over the memory bus.</p></blockquote><p>因此，LL/SC在发生context switch的时候将会fail spuriously。现在，<code>strong</code>版本的会使用它“自己的小loop”来检测spurious failure，并且通过重试来处理它。要注意的是，它自己的loop要比一个普通的CAS loop要复杂，因为它必须区分spurious failure（并处理它）和由于并发访问导致的失败（这会导致返回值为<code>false</code>）。<code>weak</code>版的并没有这样自己的loop。</p><p>既然你在两个例子中都显式的使用了loop，在<code>strong</code>版本中是完全没有必要使用loop的。结果是，在<code>strong</code>版本中，做了两次failure的检查；一次是<code>compare_exchange_strong</code>做的（由于它要区分spurious failure和并发访问，这要更复杂），另一是你自己的loop做的。这样代价高昂的检查时没有必要的，<code>weak</code>快的原因就在这里。</p><p>Also note that your argument (LL/SC) is just one possibility to implement this. There are more platforms that have even different instruction sets. In addition (and more importantly), note that std::atomic must support all operations for all possible data types, 因此即使你声明了一个一千万字节的结构体，你还是可以用compare_exchange来做这个。即使当CPU有CAS指令，你也不用能够CAS一千万字节，因此编译器会生成其他的指令（可能是acquire lock，然后进行non-atomic compare and swap，接着release lock）。现在，想想当swap一千万字节的时候会发生什么。因此尽管spurious error对于8 byte的exchanges可能是非常罕见的，在这种情况下，它可能更常见。</p><h2 id="Answer-2"><a href="#Answer-2" class="headerlink" title="Answer 2"></a>Answer 2</h2><p><strong>To be continued…</strong></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="http://stackoverflow.com/questions/25199838/understanding-stdatomiccompare-exchange-weak-in-c11">Understanding std::atomic::compare_exchange_weak() in C++11</a></li></ol>]]></content>
    
    
    <summary type="html">原文是stackoverflow上的一个关于compare_exchange_weak()问题和相应的答案，我做了简单的翻译和整理。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="cpp" scheme="https://chaomai.github.io/tags/cpp/"/>
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="cpp11" scheme="https://chaomai.github.io/tags/cpp11/"/>
    
    <category term="atomic" scheme="https://chaomai.github.io/tags/atomic/"/>
    
    <category term="cas" scheme="https://chaomai.github.io/tags/cas/"/>
    
  </entry>
  
  <entry>
    <title>转 - 如何实现一个malloc</title>
    <link href="https://chaomai.github.io/2015/2015-06-02-reproduce-a-malloc-tutorial/"/>
    <id>https://chaomai.github.io/2015/2015-06-02-reproduce-a-malloc-tutorial/</id>
    <published>2015-06-02T15:10:10.000Z</published>
    <updated>2021-06-27T14:57:29.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><blockquote><p>这篇是转自<a href="ttp://blog.codinglabs.org">CodingLabs</a>的文章，除了有原文的内容，我加入了自己的一些思考和理解。</p><footer><strong>张洋, CodingLabs</strong><cite><a href="http://blog.codinglabs.org/articles/a-malloc-tutorial.html">如何实现一个malloc</a></cite></footer></blockquote></blockquote><p>任何一个用过或学过C的人对malloc都不会陌生。大家都知道malloc可以分配一段连续的内存空间，并且在不再使用时可以通过free释放掉。但是，许多程序员对malloc背后的事情并不熟悉，许多人甚至把malloc当做操作系统所提供的系统调用或C的关键字。实际上，malloc只是C的标准库中提供的一个普通函数，而且实现malloc的<strong>基本</strong>思想并不复杂，任何一个对C和操作系统有些许了解的程序员都可以很容易理解。</p><p>这篇文章通过实现一个简单的malloc来描述malloc背后的机制。当然与现有C的标准库实现（例如glibc）相比，我们实现的malloc并不是特别高效，但是这个实现比目前真实的malloc实现要简单很多，因此易于理解。重要的是，这个实现和真实实现在基本原理上是一致的。</p><p>这篇文章将首先介绍一些所需的基本知识，如操作系统对进程的内存管理以及相关的系统调用，然后逐步实现一个简单的malloc。为了简单起见，这篇文章将只考虑x86_64体系结构，操作系统为Linux。</p><h1 id="什么是malloc"><a href="#什么是malloc" class="headerlink" title="什么是malloc"></a>什么是malloc</h1><p>在实现malloc之前，先要相对正式地对malloc做一个定义。</p><p>根据标准C库函数的定义，malloc具有如下原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p><ul><li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li><li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li><li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li><li>malloc应该尽快完成内存分配并返回（不能使用<a href="http://en.wikipedia.org/wiki/NP-hard">NP-hard</a>的内存分配算法）</li><li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li></ul><p>对于malloc更多的说明可以在命令行中键入以下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man malloc</span><br></pre></td></tr></table></figure><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p><h2 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h2><h3 id="虚拟内存地址与物理内存地址"><a href="#虚拟内存地址与物理内存地址" class="headerlink" title="虚拟内存地址与物理内存地址"></a>虚拟内存地址与物理内存地址</h3><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片$2^N$字节的内存，其中$N$是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为$2^{64}$Byte。</p><p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p><p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<a href="http://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>（Memory Management Unit）的硬件完成。</p><h3 id="页与地址构成"><a href="#页与地址构成" class="headerlink" title="页与地址构成"></a>页与地址构成</h3><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p><p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：</p><p><img data-src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-01.png" alt="内存地址构成"></p><p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内偏移都是用低12位表示，而剩下的高地址表示页号。</p><p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。</p><p><img data-src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-02.png" alt="内存地址翻译"></p><h3 id="内存页与磁盘页"><a href="#内存页与磁盘页" class="headerlink" title="内存页与磁盘页"></a>内存页与磁盘页</h3><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p><p>最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<a href="http://en.wikipedia.org/wiki/Page_table">图片来源页</a>）。</p><p><img data-src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-03.png" alt="较为完整的地址翻译流程"></p><h2 id="Linux进程级内存管理"><a href="#Linux进程级内存管理" class="headerlink" title="Linux进程级内存管理"></a>Linux进程级内存管理</h2><h3 id="内存排布"><a href="#内存排布" class="headerlink" title="内存排布"></a>内存排布</h3><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p><p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p><p>根据<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt">Linux内核相关文档</a>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p><p><img data-src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-04.png" alt="Linux进程地址排布"></p><p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p><ul><li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li><li>Data：这里存放的是初始化过的全局变量</li><li>BSS：这里存放的是未初始化的全局变量</li><li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li><li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li><li>Stack：这是栈区域，自高地址向低地址增长</li></ul><p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p><h3 id="Heap内存模型"><a href="#Heap内存模型" class="headerlink" title="Heap内存模型"></a>Heap内存模型</h3><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p><p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：</p><p><img data-src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-05.png" alt="Linux进程堆管理"></p><p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p><h3 id="brk与sbrk"><a href="#brk与sbrk" class="headerlink" title="brk与sbrk"></a>brk与sbrk</h3><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;</span><br></pre></td></tr></table></figure><p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p><p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p><p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p><h3 id="资源限制与rlimit"><a href="#资源限制与rlimit" class="headerlink" title="资源限制与rlimit"></a>资源限制与rlimit</h3><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> *<span class="title">limit</span> =</span> (struct rlimit *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct rlimit));</span><br><span class="line">    getrlimit(RLIMIT_AS, limit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;soft limit: %ld, hard limit: %ld\n&quot;</span>, limit-&gt;rlim_cur, limit-&gt;rlim_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中rlimit是一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p><h1 id="实现malloc"><a href="#实现malloc" class="headerlink" title="实现malloc"></a>实现malloc</h1><h2 id="玩具实现"><a href="#玩具实现" class="headerlink" title="玩具实现"></a>玩具实现</h2><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个玩具malloc */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    p = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sbrk(size) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p><h2 id="正式实现"><a href="#正式实现" class="headerlink" title="正式实现"></a>正式实现</h2><p>下面严肃点讨论malloc的实现方案。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p><p>可以用如下结构体定义一个block：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><em>注：</em><br><code>data</code>其实可以为<code>char data[]</code>。<br>详细的解释可以看[C语言结构体里的成员数组和指针]（<a href="http://coolshell.cn/articles/11377.html%EF%BC%89%E4%B8%AD%E7%9A%84%E5%85%B3%E4%BA%8E%E9%9B%B6%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84%E3%80%82">http://coolshell.cn/articles/11377.html）中的关于零长度的数组。</a></p></blockquote><p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：</p><p><img data-src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-06.png" alt="Block结构"></p><h3 id="寻找合适的block"><a href="#寻找合适的block" class="headerlink" title="寻找合适的block"></a>寻找合适的block</h3><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p><ul><li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li><li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li></ul><p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First fit */</span></span><br><span class="line"><span class="function">t_block <span class="title">find_block</span><span class="params">(t_block *last, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    t_block b = first_block;</span><br><span class="line">    <span class="keyword">while</span>(b &amp;&amp; !(b-&gt;<span class="built_in">free</span> &amp;&amp; b-&gt;size &gt;= size)) &#123;</span><br><span class="line">        *last = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到就返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p><h3 id="开辟新的block"><a href="#开辟新的block" class="headerlink" title="开辟新的block"></a>开辟新的block</h3><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 24 <span class="comment">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, <span class="keyword">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sbrk(BLOCK_SIZE + s) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(last)</span><br><span class="line">        last-&gt;next = b;</span><br><span class="line">    b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分裂block"><a href="#分裂block" class="headerlink" title="分裂block"></a>分裂block</h3><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：</p><p><img data-src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-07.png" alt="分裂block"></p><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_block</span><span class="params">(t_block b, <span class="keyword">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    t_block <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span> = b-&gt;data + s;</span><br><span class="line">    <span class="keyword">new</span>-&gt;size = b-&gt;size - s - BLOCK_SIZE ;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="malloc的实现"><a href="#malloc的实现" class="headerlink" title="malloc的实现"></a>malloc的实现</h3><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p><p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">align8</span><span class="params">(<span class="keyword">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &amp; <span class="number">0x7</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">return</span> ((s &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>注：</em></p><ol><li><p><code>0x7</code>？<br>如果数是8的倍数，那么它的二进制表示的最后3位都是0，其实可以看作<code>任意数*8</code>(<code>1000</code>)。</p></li><li><p><code>((s &gt;&gt; 3) + 1) &lt;&lt; 3</code>？<br>有了第1条，这里为什么是3位就很清楚了。之所以加1，是因为右移了以后，那3位丢了，s可能会变小；加1实际上是在第4位加。</p></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 24</span></span><br><span class="line"><span class="keyword">void</span> *first_block=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* other functions... */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    t_block b, last;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line">    <span class="comment">/* 对齐地址 */</span></span><br><span class="line">    s = align8(size);</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">        <span class="comment">/* 查找合适的block */</span></span><br><span class="line">        last = first_block;</span><br><span class="line">        b = find_block(&amp;last, s);</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">            <span class="comment">/* 如果可以，则分裂 */</span></span><br><span class="line">            <span class="keyword">if</span> ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                split_block(b, s);</span><br><span class="line">            b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 没有合适的block，开辟一个新的 */</span></span><br><span class="line">            b = extend_heap(last, s);</span><br><span class="line">            <span class="keyword">if</span>(!b)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = extend_heap(<span class="literal">NULL</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(!b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        first_block = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="calloc的实现"><a href="#calloc的实现" class="headerlink" title="calloc的实现"></a>calloc的实现</h3><p>有了malloc，实现calloc只要两步：</p><ol><li>malloc一段内存</li><li>将数据区内容置为0</li></ol><p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> number, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">size_t</span> s8, i;</span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(number * size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>) &#123;</span><br><span class="line">        s8 = align8(number * size) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s8; i++)</span><br><span class="line">            <span class="keyword">new</span>[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>注：</em></p><ol><li><p><code>align8(number * size) &gt;&gt; 3</code>？<br>每8字节一组置0。</p></li><li><p><code>将内存区域强制看做size_t类型</code>？<br>结合1，以及在x86_64的系统中，sizeof(size_t)是8字节。</p></li></ol></blockquote><h3 id="free的实现"><a href="#free的实现" class="headerlink" title="free的实现"></a>free的实现</h3><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p><ol><li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li><li>如何解决碎片问题</li></ol><p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p><ul><li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li><li>这个地址确实是之前通过我们自己的malloc分配的</li></ul><p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p><p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们定义检查地址合法性的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;</span><br><span class="line">    tmp = p;</span><br><span class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valid_addr</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &gt; first_block &amp;&amp; p &lt; sbrk(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p == (get_block(p))-&gt;ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>注：</em></p><ol><li>为何不直接与<code>data</code>的地址作比较，而是另外加入了一个指针指向<code>data</code>？</li></ol></blockquote><p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p><p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block prev; <span class="comment">/* 指向上个块的指针 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>合并方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">fusion</span><span class="params">(t_block b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span>) &#123;</span><br><span class="line">        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;</span><br><span class="line">        b-&gt;next = b-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next)</span><br><span class="line">            b-&gt;next-&gt;prev = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>注：</em></p><ol><li>仅有<code>prev</code>有何不可？感觉这里没有必要做成双向链表。</li></ol><p><strong>Update</strong>：不行。如果不是双向链表，那么没有办法知道，当前的block是不是最后一个block（这个block可能很大），也就没有办法释放它。</p></blockquote><p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        b-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;<span class="built_in">free</span>)</span><br><span class="line">            b = fusion(b-&gt;prev);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next)</span><br><span class="line">            fusion(b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;prev)</span><br><span class="line">                b-&gt;prev-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                first_block = <span class="literal">NULL</span>;</span><br><span class="line">            brk(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="realloc的实现"><a href="#realloc的实现" class="headerlink" title="realloc的实现"></a>realloc的实现</h3><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_block</span><span class="params">(t_block src, t_block dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *sdata, *ddata;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; (i * <span class="number">8</span>) &lt; src-&gt;size &amp;&amp; (i * <span class="number">8</span>) &lt; dst-&gt;size; i++)</span><br><span class="line">        ddata[i] = sdata[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p><ul><li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li><li>如果新的size变小了，考虑split</li><li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li></ul><p>下面是realloc的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line">    t_block b, <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">void</span> *newp;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="comment">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</span><br><span class="line">        s = align8(size);</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;size &gt;= s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                split_block(b,s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 看是否可进行合并 */</span></span><br><span class="line">            <span class="keyword">if</span>(b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span></span><br><span class="line">                    &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) &#123;</span><br><span class="line">                fusion(b);</span><br><span class="line">                <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</span><br><span class="line">                    split_block(b, s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 新malloc */</span></span><br><span class="line">                newp = <span class="built_in">malloc</span> (s);</span><br><span class="line">                <span class="keyword">if</span> (!newp)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">new</span> = get_block(newp);</span><br><span class="line">                copy_block(b, <span class="keyword">new</span>);</span><br><span class="line">                <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">return</span>(newp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遗留问题和优化"><a href="#遗留问题和优化" class="headerlink" title="遗留问题和优化"></a>遗留问题和优化</h2><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p><ul><li>同时兼容32位和64位系统</li><li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li><li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li><li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li></ul><p>还有很多可能的优化，这里不一一赘述。下面附上一些参考文献，有兴趣的同学可以更深入研究。</p><h1 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h1><ol><li>这篇文章大量参考了<a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf">A malloc Tutorial</a>，其中一些图片和代码直接引用了文中的内容，这里特别指出</li><li><a href="http://csapp.cs.cmu.edu/">Computer Systems: A Programmer’s Perspective, 2/E</a>一书有许多值得参考的地方</li><li>关于Linux的虚拟内存模型，<a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/">Anatomy of a Program in Memory</a>是很好的参考资料，另外作者还有一篇<a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/">How the Kernel Manages Your Memory</a>对于Linux内核中虚拟内存管理的部分有很好的讲解</li><li>对于真实世界的malloc实现，可以参考<a href="http://repo.or.cz/w/glibc.git/blob/HEAD:/malloc/malloc.c">glibc的实现</a></li><li>本文写作过程中大量参考了<a href="http://www.wikipedia.org/">维基百科</a>，再次感谢这个伟大的网站，并且呼吁大家在手头允许的情况下可以适当捐助维基百科，帮助这个造福人类的系统运行下去</li></ol>]]></content>
    
    
    <summary type="html">这篇是转自CodingLabs的文章，除了有原文的内容，我加入了自己的一些思考和理解。</summary>
    
    
    
    <category term="operating system" scheme="https://chaomai.github.io/categories/operating-system/"/>
    
    
    <category term="c" scheme="https://chaomai.github.io/tags/c/"/>
    
    <category term="malloc" scheme="https://chaomai.github.io/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>C++ Concurrency in Action (4) - Synchronizing concurrent operations</title>
    <link href="https://chaomai.github.io/2015/2015-05-31-cpp-concurrency-in-action-4/"/>
    <id>https://chaomai.github.io/2015/2015-05-31-cpp-concurrency-in-action-4/</id>
    <published>2015-05-31T05:26:54.000Z</published>
    <updated>2021-06-27T14:57:29.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Concurrency-in-Action-4"><a href="#C-Concurrency-in-Action-4" class="headerlink" title="C++ Concurrency in Action 4"></a>C++ Concurrency in Action 4</h1><h2 id="Waiting-for-an-event-or-other-condition"><a href="#Waiting-for-an-event-or-other-condition" class="headerlink" title="Waiting for an event or other condition"></a>Waiting for an event or other condition</h2><ol><li><p>一直检查某个flag（被mutex保护）</p><p> 消耗资源，被锁住的flag实际上并不能被其他线程访问。消耗资源导致了被等待的线程运行时得到的资源更少，使得等待时间更长。</p></li><li><p>condition variable</p><p> wait and notify</p></li><li><p><code>std::this_thread::sleep_for()</code></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lk.unlock();</span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line">        lk.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> sleep前unlock，以便其他线程有机会获得lock。但是难以掌握sleep的时长。</p></li></ol><h3 id="Waiting-for-a-condition-with-condition-variables"><a href="#Waiting-for-a-condition-with-condition-variables" class="headerlink" title="Waiting for a condition with condition variables"></a>Waiting for a condition with condition variables</h3><ul><li><code>std::condition_variable</code>：和mutex一起用，为了提供合适的同步。</li><li><code>std::condition_variable_any</code></li></ul><p>mutex_like即可，但是通用是要付出占用空间、性能或所需资源上的代价的。除非需要额外的灵活度，否则i用前者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;</span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(more_data_to_prepare()) &#123;</span><br><span class="line">        data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.push(data);</span><br><span class="line">        data_cond.notify_one(); <span class="comment">//notify waiting thread</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.wait(</span><br><span class="line">            lk, []&#123; <span class="keyword">return</span> !data_queue.empty(); &#125;);</span><br><span class="line">        data_chunk data=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();  <span class="comment">//不要在处理的时候（可能耗时）持有</span></span><br><span class="line">        process(data);</span><br><span class="line">        <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>wait()</code>，<code>mut</code>，predicate有什么关系？</p><p> thread wakes(notified by <code>notify_one()</code>) -&gt; lock mutex -&gt; check predicate；</p><blockquote><p>predicate false -&gt; unlock mutex -&gt; thread blocked or waiting；<br>predicate true -&gt; still leave mutex locked -&gt; return from <code>wait()</code>；</p></blockquote></li><li><p>为什么在<code>data_processing_thread()</code>要使用<code>std::unique_lock</code>？</p><p> 反过来考虑为什么不是<code>std::lock_guard</code>和<code>std::mutex</code>。</p><p> <code>std::lock_guard</code>直到销毁才会unlock，但是线程wait的时候，就隐式的进行了unlock。</p><p> <code>std::mutex</code>，<a href="http://stackoverflow.com/questions/13099660/c11-why-does-stdcondition-variable-use-stdunique-lock">这里</a>从API设计的角度上解释了为什么不是。</p></li></ol><p>在调用<code>wait()</code>期间，predicate会在mutex locked的条件下，被检查任意多次。当且仅当predicate true， <code>wait()</code>立即返回。</p><p><strong>spurious wake</strong></p><p>当等待线程重新获取锁并检查条件时，如果它不直接响应另一个线程的notification（例如：你的predicate和共享的变量无关，另一个线程notify的时候，predicate就不会直接respond），这就是spurious wake。是有side effect的。</p><p><strong><code>notify_one()</code>和<code>notify_all()</code></strong></p><ul><li>当有多个线程wait同一个event的时候，<code>notify_one()</code>并不能保证哪个线程会被通知。</li><li>当有多个线程wait同一个event，并且所有线程都需要respond的时候，<code>notify_all()</code>会导致这些线程都去check predicate。</li></ul><h2 id="Waiting-for-one-off-events-with-futures"><a href="#Waiting-for-one-off-events-with-futures" class="headerlink" title="Waiting for one-off events with futures"></a>Waiting for one-off events with futures</h2><p><code>std::future</code>：provides a mechanism to access the result of asynchronous operations。</p><p>由<code>std::unique_ptr</code>和<code>std::shared_ptr</code>建立：</p><ol><li><p>unique futures：<code>std::future&lt;&gt;</code></p><ul><li>moveable only</li><li>其实例是唯一关联到与它关联事件的实例。</li><li>ownership可以在实例间transfer，但是有一个实例可以引用到特定异步操作的结果。</li></ul></li><li><p>shared futures：<code>std::shared_future&lt;&gt;</code></p><ul><li>copyable</li><li>其多个实例可以指向同一个事件。在这个情况下，所有的实例都会同时ready，都可以访问与事件关联的数据。</li><li>可以有多个实例引用到关联状态。</li></ul></li></ol><p>如果无关联的数据，用<code>std::future&lt;void&gt;</code>或<code>std::shared_future&lt;void&gt;</code>。</p><h3 id="Returning-values-from-background-tasks"><a href="#Returning-values-from-background-tasks" class="headerlink" title="Returning values from background tasks"></a>Returning values from background tasks</h3><p>可以用<code>std::async()</code>开始一个<strong>异步任务</strong>。<code>std::async()</code>返回一个<code>std::future</code>对象，这个对象最终将持有函数的返回值，用<code>std::future</code>的<code>get()</code>获得（线程会block到future ready）。</p><p>对<code>std::async()</code>提供参数类似于<code>std::thread</code>和<code>std::call_once</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>,<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">bar</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="keyword">auto</span> f1=<span class="built_in">std</span>::async(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> f2=<span class="built_in">std</span>::async(&amp;X::bar,x,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Y y;</span><br><span class="line"><span class="keyword">auto</span> f3=<span class="built_in">std</span>::async(Y(),<span class="number">3.141</span>);</span><br><span class="line"><span class="keyword">auto</span> f4=<span class="built_in">std</span>::async(<span class="built_in">std</span>::ref(y),<span class="number">2.718</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp;)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::async(baz,<span class="built_in">std</span>::ref(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f5=<span class="built_in">std</span>::async(move_only()); <span class="comment">//对于右值，std::move会被隐式的调用</span></span><br></pre></td></tr></table></figure><p><code>std::async()</code>的运行由实现决定（自己试了发现libstdc++6用的是<code>std::launch::deferred</code>），但也可以由参数（<code>std::launch</code>类型）指定。</p><ul><li><code>std::launch::deferred</code>：函数调用推迟到在future上调用<code>wait()</code>或<code>get()</code>。</li><li><code>std::launch::async</code>：函数在它自己的线程上运行。</li><li><code>std::launch::deferred | std::launch::async</code>：默认，视实现而定。</li></ul><p>如果函数调用推迟了，那么它可能再也不会实际执行。</p><p>通过修改参数并运行下面这段代码，来体会它们的区别，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">timer t; <span class="comment">//可以自己简单的实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; the_answer = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, []() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999999</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;futuring...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999999</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; the_answer.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现使用<code>std::launch::deferred</code>的时间，几乎是<code>std::launch::async</code>的两倍，这里就能很形象的感受<strong>defer</strong>。</p><h3 id="Associating-a-task-with-a-future"><a href="#Associating-a-task-with-a-future" class="headerlink" title="Associating a task with a future"></a>Associating a task with a future</h3><p><code>std::packaged_task&lt;&gt;</code>把一个函数或callable对象绑定到一个future，当<code>std::packaged_task&lt;&gt;</code>被调用的时候，它进而调用关联的函数或callable对象使得future ready，返回值作为关联数据储存。</p><p><code>std::packaged_task</code>不是copyable，但是moveable。</p><p><code>std::packaged_task</code>的模板参数是函数签名。构造实例时，传入的callable对象要能接受指定的参数，并且返回值类型可以转换到所指定的返回类型。也就是说不必100% match，但是至少也要保证可以隐式转换。</p><blockquote><ul><li>函数签名的返回值类型指定了从<code>get_future()</code>返回的<code>std::future</code>的类型。</li><li>函数签名的参数列表指定了，封装的任务的函数调用的签名。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> b) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999999</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; res = task.get_future();</span><br><span class="line"><span class="comment">//res.wait();  //waiting endlessly</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; res.get() &lt;&lt; std::endl;  //waiting endlessly</span></span><br><span class="line">task(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; res.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li>上例中，在<code>task()</code>调用前，绑定的函数是没有执行的，因此这里无论是对future进行wait或是get，都是无限的等下去。</li><li>调用<code>task()</code>时，任务其实是在当前的线程中执行的，不会新建一个线程执行。</li></ul><h3 id="Making-std-promises"><a href="#Making-std-promises" class="headerlink" title="Making (std::)promises"></a>Making (std::)promises</h3><p><code>std::promise&lt;T&gt;</code>提供了一种设置值的方式，这个值可以稍后被关联的<code>std::future&lt;T&gt;</code>对象读取。等待线程会在future上block，提供数据的线程可以用promise的<code>set_value()</code>来设置值，使得future ready。如果没有设置值就销毁<code>std::promise</code>，那么exception将会被存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> b) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">999999999</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">p.set_value(f(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">auto</span> fu = p.get_future();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fu.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="Saving-an-exception-for-the-future"><a href="#Saving-an-exception-for-the-future" class="headerlink" title="Saving an exception for the future"></a>Saving an exception for the future</h3><ol><li><p><code>std::async</code></p><p> 就像直接调用函数一样，</p><blockquote><p>函数抛出exception -&gt; exception被存储在future中，替代所存储的值 -&gt; future ready -&gt; <code>get()</code>会再次抛出exception<br>但是<code>get()</code>抛出的exception是原始的对象或copy，标准没有规定。</p></blockquote></li><li><p><code>std::packaged_task</code></p><ul><li><p>类似<code>std::async</code>，</p><blockquote><p>调用task -&gt; 函数抛出exception -&gt; exception被存储在future中，替代所存储的值 -&gt; future ready -&gt; <code>get()</code>会再次抛出exception</p></blockquote></li><li><p>直接destory <code>std::packaged_task</code></p><blockquote><p>如果future没有ready -&gt; destructor存储<code>std::future_error</code> exception在关联的状态中。<br>error code = <code>std::future_errc::broken_promise</code></p></blockquote></li></ul></li><li><p><code>std::promise</code></p><ul><li><p>类似前两者，但是需要显式的函数调用。如果要存储的不是值，是exception，就要调用<code>set_exception()</code>。</p></li><li><p>通常在try/catch中使用，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">std</span>::promise&lt;<span class="keyword">double</span>&gt; some_promise;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    some_promise.set_value(calculate_value());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(...) &#123;</span><br><span class="line">    some_promise.set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">some_promise.set_exception(<span class="built_in">std</span>::copy_exception(<span class="built_in">std</span>::logic_error(<span class="string">&quot;foo&quot;</span>)));</span><br></pre></td></tr></table></figure><blockquote><p>上例使用了<code>std::current_exception()</code>来获取已引发的异常。还可以    用<code>std::copy_exception()</code>创建新的exception，在exception已知的情况下，这样更简洁。</p></blockquote></li><li><p>直接destroy <code>std::promise</code></p><blockquote><p>如果future没有ready -&gt; destructor存储<code>std::future_error</code> exception在关联的状态中。<br>error code = <code>std::future_errc::broken_promise</code></p></blockquote></li></ul></li></ol><p><strong>关于destory <code>std::packaged_task</code>和<code>std::promise</code></strong></p><ul><li><code>std::packaged_task</code>是<code>std::promise</code>更高层次的抽象，所以直接destroy以后，它们的行为是很相似的。</li><li>创建了future，你就promise to provide一个值或exception，如果你摧毁了他们的来源，你就break了promise。如果destructor不存储<code>std::future_error</code> exception，等待future的线程就会一直等下去。</li></ul><h3 id="Waiting-from-multiple-threads"><a href="#Waiting-from-multiple-threads" class="headerlink" title="Waiting from multiple threads"></a>Waiting from multiple threads</h3><p>在多个线程中访问<code>std::future</code>会有data race和undefined behavior。</p><p>原因：</p><blockquote><p>by design. It models unique ownership of the asynchronous result。因此并发的访问的没意义的，<code>get()</code>只能被调用一次。</p></blockquote><ol><li><p><code>std::shared_future</code></p><p> 就算有<code>std::shared_future</code>，特定对象的成员函数还是不同步的，要使用lock来避免data race，或者在每个线程创建并访问自己的copy。</p></li><li><p>构造<code>std::shared_future</code></p><p> 引用异步状态的<code>std::shared_future</code>实例是由引用了这些状态的<code>std::future</code>实例构造的。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(p.get_future())</span></span>;</span><br><span class="line"><span class="comment">// f refers to asynchronous state of p</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">sf</span><span class="params">(<span class="built_in">std</span>::move(f))</span></span>;</span><br><span class="line"><span class="comment">// 现在f是invalid</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">sf</span><span class="params">(p.get_future())</span></span>;</span><br><span class="line"><span class="keyword">auto</span> sf = p.get_future().share();  <span class="comment">// transfer ownership directly</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Waiting-with-a-time-limit"><a href="#Waiting-with-a-time-limit" class="headerlink" title="Waiting with a time limit"></a>Waiting with a time limit</h2><p>two sorts of timeouts:</p><ul><li>duration-based timeout</li><li>absolute timeout</li></ul><h3 id="Clocks"><a href="#Clocks" class="headerlink" title="Clocks"></a>Clocks</h3><ol><li><p><code>system_clock</code></p><p> Wall clock time from the system-wide real-time clock.</p><p> <code>std::chrono::system_clock::now()</code>返回系统当前时间，类型是<code>std::chrono::system_clock::time_point</code>。</p><p> 提供了与<code>time_t</code>类型相互转化的函数。</p></li><li><p><code>steady_clock</code></p><ul><li><p>Values of <code>time_point</code> never decrease as physical time advances;</p></li><li><p>Values of <code>time_point</code> advance at a steady rate relative to real time.</p><p>That is, the clock may not be adjusted.</p><p><code>is_steady</code>可以检测是否是。</p></li></ul></li><li><p><code>high_resolution_clock</code></p><p> Clocks with the shortest tick period. <code>high_resolution_clock</code> may be a synonym for <code>system_clock</code> or <code>steady_clock</code>.</p></li></ol><p><strong>the tick period of clock</strong></p><p>可由clock的<code>period</code>成员得到。例如：每秒25次 tick，则是<code>std::ratio&lt;1, 25&gt;</code>。</p><p>并不能够保证，$在一次运行中观察到的tick period=那个clock指定的period$。</p><h3 id="Durations"><a href="#Durations" class="headerlink" title="Durations"></a>Durations</h3><p><code>std::chrono::duration&lt;&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Rep, <span class="keyword">typename</span> _Period&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">duration</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> _Reprep; <span class="comment">// the type of representation</span></span><br><span class="line"><span class="keyword">typedef</span> _Period period;  <span class="comment">// 指定duration的每个unit代表多长时间</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>标准库预定义了很多种durations：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, nano&gt;     nanoseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, micro&gt;     microseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, milli&gt;     milliseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>&gt;     seconds;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, ratio&lt; <span class="number">60</span>&gt;&gt;   minutes;</span><br><span class="line"><span class="keyword">typedef</span> duration&lt;<span class="keyword">int64_t</span>, ratio&lt;<span class="number">3600</span>&gt;&gt;  hours;</span><br></pre></td></tr></table></figure><p>它们都使用足够大的整数类型。当然也可以使用预定义的ratio或自己定义的来定义新的duration。</p><p>当不会发生截断的时候，durations之间的转换是隐式的。显示的转换可用<code>duration_cast</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::chrono::seconds s=</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(ms);</span><br><span class="line"><span class="comment">//截断，而非四舍五入，s=54</span></span><br></pre></td></tr></table></figure><p>durations可以与一个常数（<code>_Rep</code>类型的）进行加减乘除。</p><p>在一个duration中，要知道units的数目，可以调用<code>count()</code>。</p><p><strong>基于duration的wait</strong></p><p>之前提到的所有的blocking call都是block一个不确定长度的时间。</p><p>当你将duration用于wait，wait会返回一个状态，来标识是超时，还是其他情况。</p><ul><li><code>std::future_status::timeout</code>：the wait times out</li><li><code>std::future_status::ready</code>：the future is ready</li><li><code>std::future_status::deferred</code>：the future is deferred</li></ul><p>基于duration的wait的时间是通过一个内部的steady clock来衡量的，但是因为调度，或者精度的原因，实际等待的时间可能会略长。</p><h3 id="Time-points"><a href="#Time-points" class="headerlink" title="Time points"></a>Time points</h3><p><code>std::chrono::time_points&lt;&gt;</code>：存储了从clock的epoch开始的时长（某个duration的倍数）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Clock, <span class="keyword">typename</span> _Dur&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">time_point</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> _Clockclock; <span class="comment">// clock的类型</span></span><br><span class="line"><span class="keyword">typedef</span> _Durduration;  <span class="comment">// 度量从epoch开始的时间</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对于一个time point，<code>time_since_epoch()</code>返回了从clock的epoch，到那个time point的时长。</p><ul><li>可以将duration与time point相加减，得到新的time point。</li><li>可以将两个share same clock的time point相减，得到duration。</li></ul><p><strong>基于time point的wait</strong></p><p>在condition variable中，如果不想向<code>wait()</code>传入一个predicate，那么最好是使用<code>wait_until()</code>，这样循环的总长度（看4.1.1）有限的。</p><h3 id="Functions-that-accept-timeouts"><a href="#Functions-that-accept-timeouts" class="headerlink" title="Functions that accept timeouts"></a>Functions that accept timeouts</h3><table><thead><tr><th>Class/Namespace</th><th>Functions</th><th>Return values</th></tr></thead><tbody><tr><td><code>std::this_thread</code> namespace</td><td><code>sleep_for(duration)</code>, <code>sleep_until(time_point)</code></td><td>N/A</td></tr><tr><td><code>std::condition_variable</code> or <code>std::condition_variable_any</code></td><td><code>wait_for(lock, duration)</code>, <code>wait_until(lock, time_point)</code></td><td><code>std::cv_status::timeout</code> or <code>std::cv_status::no_timeout</code></td></tr><tr><td></td><td><code>wait_for(lock, duration, predicate)</code>, <code>wait_until(lock, time_point, predicate)</code></td><td>bool—the return value of the predicate when awakened</td></tr><tr><td><code>std::timed_mutex</code> or <code>std::recursive_ timed_mutex</code></td><td><code>try_lock_for(duration)</code>, <code>try_lock_until(time_point)</code></td><td>bool—true if the lock was acquired, false otherwise</td></tr><tr><td><code>std::unique_ lock&lt;TimedLockable&gt;</code></td><td><code>unique_lock(lockable, duration)</code>, <code>unique_lock(lockable, time_point)</code></td><td>N/A—<code>owns_lock()</code> on the newly constructed object; returns true if the lock was acquired, false otherwise</td></tr><tr><td></td><td><code>try_lock_for(duration)</code>, <code>try_lock_until(time_point)</code></td><td>bool—true if the lock was acquired, false otherwise</td></tr><tr><td><code>std::future&lt;ValueType&gt;</code> or <code>std::shared_ future&lt;ValueType&gt;</code></td><td><code>wait_for(duration)</code>, <code>wait_until (time_point)</code></td><td><code>std::future_status::timeout</code> if the wait timed out, <code>std::future_ status::ready</code> if the future is ready, or <code>std::future_status::deferred</code> if the future holds a deferred function that hasn’t yet started</td></tr></tbody></table><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="http://stackoverflow.com/questions/13263277/difference-between-stdsystem-clock-and-stdsteady-clock">Difference between std::system_clock and std::steady_clock?</a></li><li>C++ Concurrency in Action</li></ol>]]></content>
    
    
    <summary type="html">Synchronizing concurrent operations的笔记。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="cpp" scheme="https://chaomai.github.io/tags/cpp/"/>
    
    <category term="synchronize" scheme="https://chaomai.github.io/tags/synchronize/"/>
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="cpp11" scheme="https://chaomai.github.io/tags/cpp11/"/>
    
    <category term="c++ concurrency in action" scheme="https://chaomai.github.io/tags/c-concurrency-in-action/"/>
    
  </entry>
  
  <entry>
    <title>C++ Concurrency in Action (3) - Sharing data between threads</title>
    <link href="https://chaomai.github.io/2015/2015-05-30-cpp-concurrency-in-action-3/"/>
    <id>https://chaomai.github.io/2015/2015-05-30-cpp-concurrency-in-action-3/</id>
    <published>2015-05-30T14:37:23.000Z</published>
    <updated>2021-06-27T14:57:29.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Concurrency-in-Action-3"><a href="#C-Concurrency-in-Action-3" class="headerlink" title="C++ Concurrency in Action 3"></a>C++ Concurrency in Action 3</h1><h2 id="Problems-with-sharing-data-between-threads"><a href="#Problems-with-sharing-data-between-threads" class="headerlink" title="Problems with sharing data between threads"></a>Problems with sharing data between threads</h2><p>在同一进程中，线程间的数据共享，不仅仅是便捷，还可能造成问题。</p><p>线程间共享数据的问题，全都可以归结到修改数据的顺序。</p><ul><li>如果所有数据都是只读的，那么不会有任何问题。</li><li>如果一个或多个线程修改它们之间共享的数据，现在的问题可能就会出现。</li></ul><p><strong>Invariant</strong>（不变条件）：关于某个特定的数据结构，始终为真的与君。</p><p>但是在多个线程修改共享数据时，invariant会被broken。</p><h3 id="Race-conditions"><a href="#Race-conditions" class="headerlink" title="Race conditions"></a>Race conditions</h3><p>并发中最常见的导致问题的原因。出现在两个或多个线程的执行结果依赖于相对的执行顺序。在某些情况下，race condition是无害的，但是如果race condition使得broken invariant，这将会导致问题。C++标准定义了一种特别的race condition - data race（由于并发的修改同一个对象），data race将会导致undefined behavior。</p><p>problematic race condition常常出现在完成一个操作需要修改两处或多处不同的数据。在一个线程正在修改数据，另一个可能在未修改完的时候就访问数据。</p><p>由于race condition是timing sensitive的，因此在debug的时候，debugger会影响程序的timing，问题就不会再现。</p><h3 id="Avoiding-problematic-race-conditions"><a href="#Avoiding-problematic-race-conditions" class="headerlink" title="Avoiding problematic race conditions"></a>Avoiding problematic race conditions</h3><ul><li>用某种保护机制来包装数据结构。</li></ul><blockquote><p>只有实际进行修改的线程才能看到invariants are broken的中间状态。</p></blockquote><ul><li>修改数据结构和invariants的设计，使得修改在一系列隐形的changes下完成，每个change可以保证invariants。</li></ul><blockquote><p>这一般指的就是lock-free。</p></blockquote><ul><li>将对数据结构的update作为transaction。</li></ul><blockquote><p>这就是software transactional memory（STM）。</p></blockquote><h2 id="Protecting-shared-data-with-mutexes"><a href="#Protecting-shared-data-with-mutexes" class="headerlink" title="Protecting shared data with mutexes"></a>Protecting shared data with mutexes</h2><p>mutex（mutual exclusion）：synchronization primitive。线程库保证一旦某个线程已经lock了某个mutex，其他所有尝试lock同一个mutex的线程，都必须等到那个成功lock这个mutex的线程unlock它。</p><p>这可以保证每个线程看到的都是self-consistent view的共享数据，避免broken invariant。</p><p>但mutex<strong>不是</strong>silver bullet！</p><h3 id="Using-mutexes-in-C"><a href="#Using-mutexes-in-C" class="headerlink" title="Using mutexes in C++"></a>Using mutexes in C++</h3><p>通过构造<code>std::mutex</code>的实例来创建一个mutex。</p><p>不推荐直接调用<code>std::mutex</code>的成员函数，尤其是<code>unlock()</code>。因为你必须在每段代码执行的尾部，包括异常中，都要记得unlock。<code>std::lock_guard</code>以<strong>RAII</strong>的方式来对mutex提供支持，在构造的时候lock，析构的时候unlock。</p><p>用类来封装。</p><h3 id="Structuring-code-for-protecting-shared-data"><a href="#Structuring-code-for-protecting-shared-data" class="headerlink" title="Structuring code for protecting shared data"></a>Structuring code for protecting shared data</h3><p>如果类的成员函数返回了指向受保护数据的指针或引用，那岂不就是开了后门？</p><p>那么是不是禁止返回指向受保护数据的指针或引用就ok了？</p><p>还有一个没有考虑到的就是，不要向那些不在你控制下的被调用函数，传入指向受保护数据的指针或引用。</p><blockquote><p>Don’t  pass  pointers  and  references  to  protected  data  outside  the  scope  of  the  lock,  whether  by returning them from a function, storing them in externally visible memory, or passing them as arguments to user-supplied functions.</p></blockquote><h3 id="Spotting-race-conditions-inherent-in-interfaces"><a href="#Spotting-race-conditions-inherent-in-interfaces" class="headerlink" title="Spotting race conditions inherent in interfaces"></a>Spotting race conditions inherent in interfaces</h3><p>考虑一个双向链表，如果要使得一个删除操作是线程安全的，那么要必须保证避免并发的访问三个结点（要删除的和两边的）。但这并不足以避免race condition，到目前为止，只能采用避免并发的访问整个list。</p><p>看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Container=<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt; &gt;</span><br><span class="line">class <span class="built_in">stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">bool</span> empty() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">stack</span>&amp;&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就算让<code>top()</code>返回copy，而不是reference，这个接口还是有race conditions。这并不是基于mutex的实现独有的问题，基于lock-free的实现也会有，这是接口设计的问题。</p><p>上例中，<code>empty()</code>和<code>top()</code>是不可靠的，因为在调用<code>empty()</code>或<code>size()</code>的线程使用它们返回的值之前，stack可能已经被其他线程改变了（可能已经empty），这时再去<code>top()</code>，stack已经不是调用<code>empty()</code>或<code>size()</code>时候的stack了。而在stack内使用mutex仅仅只能保证同一时刻，只有一个线程运行stack的成员函数，而这并不能解决这样的问题。</p><p>还有一个类似的问题是，<code>top()</code>和<code>pop()</code>之间，stack也有可能被修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">if</span>(!s.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> value=s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    do_something(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许你觉得可以合并<code>top()</code>和<code>pop()</code>，但是<code>std::stack</code>这样分开设计不是没有理由的，简单来说，如果分开了，在return的时候，系统资源不足，copy构造函数失败，造成已经pop了，但是元素丢失（因为没有return成功）。</p><p>但是，比较头疼的是，要消除race condition就是要避免这样的分开设计（lock的粒度太小，mutex不能保护整个操作），进而避免上例中，不同线程的interleave。</p><p><strong>解法1：PASS IN A REFERENCE</strong></p><p>缺陷：</p><ul><li>不实用，构造一个实例需要额外的时间或资源。</li><li>不总是可用，构造函数所需要的参数不是时时可以获得的。</li><li>需要类型可赋值，但是赋值不总是可用的，尤其是自定义的类型。</li></ul><p><strong>解法2：REQUIRE A NO-THROW COPY CONSTRUCTOR OR MOVE CONSTRUCTOR</strong></p><p>There’s only an exception safety problem with a value-returning pop() if the return by value can throw an exception.</p><p>缺陷：</p><ul><li>限制只让那些有不抛出异常的构造函数或move构造函数的的类型使用stack，虽然可行，但是不通用。</li></ul><p><strong>解法3：RETURN A POINTER TO THE POPPED ITEM</strong></p><p>优势：</p><ul><li>pointer可以被自由的copy，而不抛出异常。</li></ul><p>缺陷：</p><ul><li>普通的方式需要管理分配给对象的内存，内存管理的开销可能还大于return by value。</li></ul><p>如果要使用，<code>std::shared_ptr</code>值得考虑，可以避免很多<code>new</code>和<code>delete</code>。</p><p><strong>解法 4：PROVIDE BOTH OPTION 1 AND EITHER OPTION 2 OR 3</strong></p><p>万金油，糅合1，2或1，3，要用什么，给用户自己选择。</p><p><strong>EXAMPLE DEFINITION OF A THREAD-SAFE STACK</strong></p><ul><li>在接口中没有race condition，并糅合了1、3；</li><li>不可赋值，可copy（假设元素可copy）；</li><li>stack为空时，<code>pop()</code>抛出异常，但是stack仍然可以工作；</li><li>简化的操作，使得数据得到了更好的控制，可以保证在每个操作中，mutex都是locked；</li><li>对<code>std::stack</code>进行了包装；</li><li>可以加入copy的支持，只要copy的时候lock mutex即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> <span class="built_in">std</span>::exception &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    threadsafe_stack()&#123;&#125;</span><br><span class="line">    threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp; other) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data=other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.push(new_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data.top()))</span></span>;</span><br><span class="line">        data.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">        value=data.top();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>为什么m是mutable？</strong></p><p><code>empty()</code>后跟const，说明<code>empty()</code>不能修改类的成员，除非成员被设置为mutable。</p><p><strong>Granularity</strong></p><p>细粒度（fine-grained）锁会导致保护不完全，锁的粒度太大会导致并发失去意义。</p><p>有时细粒度锁意味着需要多个mutex，而这可能会导致deadlock。</p><h3 id="Deadlock：the-problem-and-a-solution"><a href="#Deadlock：the-problem-and-a-solution" class="headerlink" title="Deadlock：the problem and a solution"></a>Deadlock：the problem and a solution</h3><p>如果有两个mutex，那么总是以同样的顺序lock mutex就不会死锁 了。但是有时以同样的顺序lock mutex并不能满足需求。</p><p><code>std::lock</code>：可以一次性锁住两个或多个mutex，而不会deadlock。但是如果分别获得lock，它并不能保证不死锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X(some_big_object <span class="keyword">const</span>&amp; sd):some_detail(sd)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">std</span>::lock(lhs.m,rhs.m);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,<span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,<span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">        swap(lhs.some_detail,rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上例中有这么几个要注意的地方：</p><p><strong>为什么要检查是否是不同的实例？</strong></p><p><code>std::lock</code>做了这么一个事情：</p><blockquote><p>Locks the given Lockable objects lock1, lock2, …, lockn using a deadlock avoidance algorithm to avoid deadlock. The objects are locked by an unspecified series of calls to lock, try_lock, unlock. If a call to lock or unlock results in an exception, unlock is called for any locked objects before rethrowing.</p></blockquote><p>换句话说，作为参数的几个mutex都会被an unspecified series of calls to lock, try_lock, unlock一遍。</p><p>要注意的是，必须是<a href="http://en.cppreference.com/w/cpp/concept/Lockable">Lockable objects</a>。</p><p>对于已经在外部lock的lockables，deadlock是无法保证不发生的。</p><p>如果某个mutex是locked，deadlock是不能够保证会避免的。</p><p><strong><code>std::adopt_lock</code>是什么鬼？</strong></p><p>constexpr（常量表达式），tag type used to specify locking strategy 。其中std::adopt_lock：assume the calling thread already has ownership of the mutex。也就是说告诉<code>std::lock_guard</code>，给你的mutex已经锁上了，你就不要再lock一次了。</p><p>下面是<code>std::lock_guard</code>的构造函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; __m)</span> : _<span class="title">M_device</span><span class="params">(__m)</span></span></span><br><span class="line"><span class="function"></span>&#123; _M_device.lock(); &#125;</span><br><span class="line"></span><br><span class="line">lock_guard(mutex_type&amp; __m, <span class="keyword">adopt_lock_t</span>) : _M_device(__m)</span><br><span class="line">&#123; &#125; <span class="comment">// calling thread owns mutex</span></span><br></pre></td></tr></table></figure><p>可以很明确的看出使用了<code>adopt_lock_t</code>后，<code>std::lock_guard</code>并没有去lock。</p><p><strong>会不会抛出异常？什么地方会？抛出会怎样？</strong></p><p>比较可能会，如果抛出，函数就退出了，不会进行swap；<br><code>std::lock</code>可能会（确切的说是，<code>std::lock</code>内部<code>lock lhs.m</code>或<code>rhs.m</code>的时候可能会，接着异常会传出<code>std::lock</code>），如果抛出，函数就退出了，不会进行swap；<br>构造<code>lock_guard</code>不会，标准规定的。</p><p><code>std::lock</code>不万能，如果分别获得lock，它并不能保证不deadlock。</p><h3 id="Further-guidelines-for-avoiding-deadlock"><a href="#Further-guidelines-for-avoiding-deadlock" class="headerlink" title="Further guidelines for avoiding deadlock"></a>Further guidelines for avoiding deadlock</h3><p>deadlock不仅仅出现在有lock的时候，也不局限于两个线程。</p><p>避免deadlock的方法可以归结为：不要等待一个可能等待你的线程。</p><p>下面的准则能检查并消除，有其他线程等待你的可能性。</p><p><strong>AVOID NESTED LOCKS</strong></p><p>如果需要多个lock，用<code>std::lock</code>。</p><p><strong>AVOID CALLING USER-SUPPLIED CODE WHILE HOLDING A LOCK</strong></p><p>用户提供的代码可能会请求另一个lock，进而违反上一个准则。</p><p><strong>ACQUIRE LOCKS IN A FIXED ORDER</strong></p><p>如果要获取两个或更多的lock，并且不能使用<code>std::lock</code>一次性获取，次优的方案是在每个线程中以同样的顺序获取。the key is to define the order in a way that’s consistent between threads.</p><p><strong>USE A LOCK HIERARCHY</strong></p><p>lock hierarchy提供了一种方法，可以在运行时检查是否遵循lock oerding。如果一段代码已经获得了低层的lock，那么它不允许获得高层的lock。本质上就是为了保证获取lock的顺序。但是这种lock的机制，要求chain中每个mutex的hierarchy value都比前一个低，可能在某些情况下并不实用。</p><p>下面是一个hierarchical mutex的例子，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hierarchical_mutex</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::mutex internal_mutex;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hierarchy_value;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> previous_hierarchy_value;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (this_thread_hierarchy_value &lt;= hierarchy_value) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    previous_hierarchy_value = this_thread_hierarchy_value;</span><br><span class="line">    this_thread_hierarchy_value = hierarchy_value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span> :</span></span><br><span class="line">      hierarchy_value(value),</span><br><span class="line">      previous_hierarchy_value(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation();</span><br><span class="line">    internal_mutex.lock();</span><br><span class="line">    update_hierarchy_value();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    this_thread_hierarchy_value = previous_hierarchy_value;</span><br><span class="line">    internal_mutex.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    check_for_hierarchy_violation();</span><br><span class="line">    <span class="keyword">if</span> (!internal_mutex.try_lock())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    update_hierarchy_value();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;</span><br></pre></td></tr></table></figure><p>有这么几个要注意的地方：</p><p><strong><code>thread_local</code></strong></p><p>这个是这段代码的关键。<code>thread_local</code>变量允许你在每个线程中都有一个独立的实例。在namespace的变量、类的static data member和局部变量都可以被声明为<code>thread_local</code>，并且拥有thread storage duration。</p><p>{ %blockquote% }<br>When thread_local is applied to a variable of block scope, the storage-class-specifier static is implied if it does not appear explicitly.<br>{ %endblockquote% }</p><p>因此上例中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;</span><br></pre></td></tr></table></figure><p>又因为，C++规定const静态类成员可以直接初始化，其他非const的静态类成员需要在类声明以外初始化，所以有最后的初始化。</p><p><strong>一个线程有多个mutex的情况下，<code>thread_local</code>变量是共享的？</strong></p><p>是的，因为它属于类，而不是某个对象。</p><p><strong>三个value会不会在多个线程并发时，出现interleaving修改？</strong></p><p>不会，修改是在internal mutex的lock和unlock之间。</p><p>hierarchy mutex本质上说的还是lock的order，其目的就是为了避免多个线程中出现wait cycle，hierarchy mutex是把这种order强制化了。</p><h3 id="Flexible-locking-with-std-unique-lock"><a href="#Flexible-locking-with-std-unique-lock" class="headerlink" title="Flexible locking with std::unique_lock"></a>Flexible locking with std::unique_lock</h3><p><code>std::unique_lock</code>提供了比<code>std::lock_guard</code>更多的灵活度（构造函数的可传入：<code>std::defer_lock</code>、<code>std::try_to_lock</code>和<code>std::adopt_lock</code>），并且不总是拥有mutex的ownership（locked）。但这两者是有代价的，<code>std::unique_lock</code>要占用更多的空间，并且稍微慢一点点，这个可以用源码看出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">    unique_lock(mutex_type&amp; __m, <span class="keyword">defer_lock_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">    : _M_device(&amp;__m), _M_owns(<span class="literal">false</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    unique_lock(mutex_type&amp; __m, <span class="keyword">try_to_lock_t</span>)</span><br><span class="line">    : _M_device(&amp;__m), _M_owns(_M_device-&gt;try_lock())</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    unique_lock(mutex_type&amp; __m, <span class="keyword">adopt_lock_t</span>)</span><br><span class="line">    : _M_device(&amp;__m), _M_owns(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// XXX calling thread owns mutex</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    mutex_type* _M_device;</span><br><span class="line">    <span class="keyword">bool</span> _M_owns; <span class="comment">// XXX use atomic_bool</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><code>std::unique_lock</code>需要flag，<code>_M_owns</code>来存储mutex的ownership，在unlock、析构等时候，需要根据flag来判断是否要forward to<code> _M_device</code>的成员函数来做实际的工作。flag可以通过<code>std::unique_lock</code>的<code>owns_lock()</code>来获得。</p><p><code>std::unique_lock</code>还允许在实例销毁前释放lock，这样就可以在明确知道不再需要lock的时候，进行release，而不必等到销毁时，避免了其他线程额外的等待。</p><p>一般来说推荐使用<code>std::lock_gurad</code>，但是如果需要额外的灵活度，那就用<code>std::unique_lock</code>，例如：</p><ul><li>延迟锁</li><li>Transfer ownership of lock</li></ul><h3 id="Transferring-mutex-ownership-between-scopes"><a href="#Transferring-mutex-ownership-between-scopes" class="headerlink" title="Transferring mutex ownership between scopes"></a>Transferring mutex ownership between scopes</h3><p>Because <code>std::unique_lock</code> instances don’t have to own their associated mutexes, the ownership of a mutex can be transferred between instances by moving the instances around.</p><p><code>std::unique_lock</code>是movable，但不是copyable的。</p><p>其中一个应用是返回一个lock，来transfer ownership给调用函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">get_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">    prepare_data();</span><br><span class="line">    <span class="keyword">return</span> lk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">    do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Locking-at-an-appropriate-granularity"><a href="#Locking-at-an-appropriate-granularity" class="headerlink" title="Locking at an appropriate granularity"></a>Locking at an appropriate granularity</h3><p>lock的粒度是用来描述被一个锁保护的数据的数量。</p><p>如果可能，只有在真正访问共享数据的时候才lock a mutex。</p><p>一般来说，不要在拥有锁的时候做耗时的工作，尤其是等待其他的lock（就算知道不会deadlock），或者文件I/O（除非真的是需要保护文件的访问）。</p><p><code>std::unique_lock</code>很适合用于这样的情况，因为你可以在不需要访问共享数据的时候<code>unlock()</code>，需要的时候<code>再lcok()</code>。</p><p><strong>关于lock的粒度和拥有锁的时长</strong></p><ol><li>如果只有一个mutex来保护整个数据结构，那么不仅仅很可能会出现更多的竞争，而且减少了lock被held的时间。</li><li>对于同一个mutex，如果获得lock以后进行的操作越多，那么lock就会被held越长。</li></ol><p>找到一个合适的粒度，不仅仅要看锁住的数据的数量，还要看lock被获得的时长和获得lock的时候做了什么操作。In general, a lock should be held for only the minimum possible time needed to perform the required operations.</p><p>还有一个问题就是，由于改变了lock的方式，可能会导致代码语义上的改变，有时这样的改变会导致错误。</p><h2 id="Alternative-facilities-for-protecting-shared-data"><a href="#Alternative-facilities-for-protecting-shared-data" class="headerlink" title="Alternative facilities for protecting shared data"></a>Alternative facilities for protecting shared data</h2><p>在特殊情况下，有一些比mutex更合适的方式来保护共享数据。</p><h3 id="Protecting-shared-data-during-initialization"><a href="#Protecting-shared-data-during-initialization" class="headerlink" title="Protecting shared data during initialization"></a>Protecting shared data during initialization</h3><p>有时候可能共享数据在创建以后就是只读的，因此只需要在创建的时候进行保护。但是如果使用mutex，仅仅在初始化的时候保护，这是不必要的，并且还会带来不必要的性能损失。</p><p><strong>Double-Checked Locking</strong></p><p>最早接触<a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization">DCL</a>是在设计模式里，单例模式提到过。这个看似高效的方法之所以被骂，就是因为CPU乱序执行可能会导致线程访问没有初始化的对象。</p><p>在这里也是类似的，也会带来问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undefined_behaviour_with_double_checked_locking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resource_ptr) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!resource_ptr) &#123;</span><br><span class="line">            resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种类型的race condition叫做data race，是undefined behavior。</p><p><strong>lazy initialization with <code>std::once_flag</code>和<code>std::call_once</code></strong></p><p><code>std::call_once</code>通常比显式使用mutex会有更低的开销，尤其是当初始化已经完成的时候。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="built_in">std</span>::once_flag resource_flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(resource_flag,init_resource);</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当初始化函数是带有函数调用操作符的类的实例的时候，<code>std::call_once</code>也支持像<code>std::thread</code>和<code>std::bind()</code>的用法。</p><p>要注意的是，如果类的成员含有不能copy或move的，那么要为它们定义特殊成员函数。</p><p><strong>static</strong></p><p>C++11中，规范了在多线程的情况下初始化static变量。初始化被定义为只发生在一个线程上，直到初始化完成其他线程才能继续。</p><p>这可以作为<code>std::call_once</code>的替代。</p><h3 id="Protecting-rarely-updated-data-structures"><a href="#Protecting-rarely-updated-data-structures" class="headerlink" title="Protecting rarely updated data structures"></a>Protecting rarely updated data structures</h3><p>用mutex来保护较少更新的数据结构不合适，当没有进行更新的时候，它消除了并发读的可能。</p><p><strong>reader-writer mutex</strong></p><p>允许：</p><ol><li>互斥的写或共享；</li><li>并发的的读。</li></ol><p>C++标准库没有提供这种锁，这里使用的是boost库。这种锁不是万能的，它的性能依赖于处理器的数量和读写线程相对的工作负载。</p><p><strong><code>boot::shared_mutex</code></strong></p><p>由boost提供。</p><h3 id="Recursive-locking"><a href="#Recursive-locking" class="headerlink" title="Recursive locking"></a>Recursive locking</h3><p>可以在同一个线程中从同一个<code>std::recursive_lock</code>的实例获得多次lock。在其他线程获得lock前，当前线程<code>lock()</code>了多少次，就必须<code>unlock()</code>多少次。</p><p>但是并不建议使用<code>std::recursive_lock</code>，当持有lock的时候，invariant很可能是broke的。继续lock，意味着要在invariant broken的情况下做操作。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="http://stackoverflow.com/questions/18047413/is-this-an-exception-safe-implementation-of-swapmultithread">Is this an exception safe implementation of swap(multithread)?</a></li><li><a href="http://stackoverflow.com/questions/22794382/are-c11-thread-local-variables-automatically-static">Are C++11 thread_local variables automatically static?</a></li><li><a href="http://en.cppreference.com/w/cpp/concept/Lockable">C++ concepts: Lockable</a></li><li><a href="http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization">双重检查锁定与延迟初始化</a></li><li>C++ Concurrency in Action</li></ol>]]></content>
    
    
    <summary type="html">Sharing data between threads的笔记。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="cpp" scheme="https://chaomai.github.io/tags/cpp/"/>
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="cpp11" scheme="https://chaomai.github.io/tags/cpp11/"/>
    
    <category term="c++ concurrency in action" scheme="https://chaomai.github.io/tags/c-concurrency-in-action/"/>
    
    <category term="mutex" scheme="https://chaomai.github.io/tags/mutex/"/>
    
  </entry>
  
  <entry>
    <title>转 - 字符集和字符编码</title>
    <link href="https://chaomai.github.io/2015/2015-05-27-reproduce-character-encoding/"/>
    <id>https://chaomai.github.io/2015/2015-05-27-reproduce-character-encoding/</id>
    <published>2015-05-27T14:20:14.000Z</published>
    <updated>2021-06-27T14:57:29.258Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>原文：<a href="http://cenalulu.github.io/linux/character-encoding/">十分钟搞清字符集和字符编码</a></p></blockquote><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>字符集就规定了某个文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>字符集只是一个规则集合的名字，对应到真实生活中，字符集就是对某种语言的称呼。</p><p>对于一个字符集来说要正确编码转码一个字符需要三个关键元素：字库表（character repertoire）、编码字符集（coded character set）、字符编码（character encoding form）</p><h3 id="字库表"><a href="#字库表" class="headerlink" title="字库表"></a>字库表</h3><p>一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。</p><h3 id="编码字符集"><a href="#编码字符集" class="headerlink" title="编码字符集"></a>编码字符集</h3><p>用一个编码值<strong>code point</strong>来表示一个字符在字库中的位置。</p><h3 id="字符编码-1"><a href="#字符编码-1" class="headerlink" title="字符编码"></a>字符编码</h3><p>将编码字符集和实际存储数值之间的转换关系。</p><p>一般来说都会直接将code point的值作为编码后的值直接存储。例如在ASCII中<code>A</code>在表中排第65位，而编码后<code>A</code>的数值是<code>0100 0001</code>也即十进制的65的二进制转换结果。</p><ul><li>为什么还要多此一举通过字符编码把序号转换成另外一种存储格式？</li></ul><p>统一字库表的目的是为了能够涵盖世界上所有的字符，但实际使用过程中会发现真正用的上的字符相对整个字库表来说比例非常低。而如果把每个字符都用字库表中的序号来存储的话，每个字符就需要3个字节（这里以Unicode字库为例），这样对于原本用仅占一个字符的ASCII编码的英语地区国家显然是一个额外成本（存储体积是原来的三倍）。于是就出现了UTF-8这样的变长编码。在UTF-8编码中原本只需要一个字节的ASCII字符，仍然只占一个字节。而像中文及日语这样的复杂字符就需要2个到3个字节来存储。</p><h2 id="UTF-8和Unicode的关系"><a href="#UTF-8和Unicode的关系" class="headerlink" title="UTF-8和Unicode的关系"></a>UTF-8和Unicode的关系</h2><p>Unicode就是上文中提到的编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。</p><p>Unicode标准几乎涵盖了各个国家语言可能出现的符号和文字，并将为他们编号。详见：Unicode on Wikipedia。Unicode的编号从<code>0000</code>开始一直到<code>10FFFF</code>共分为16个Plane，每个Plane中有65536个字符。而UTF-8则只实现了第一个Plane，可见UTF-8虽然是一个当今接受度最广的字符集编码，但是它并没有涵盖整个Unicode的字库，这也造成了它在某些场景下对于特殊字符的处理困难。</p><h2 id="UTF-8编码简介"><a href="#UTF-8编码简介" class="headerlink" title="UTF-8编码简介"></a>UTF-8编码简介</h2><h3 id="UTF-8的物理存储和Unicode序号的转换关系"><a href="#UTF-8的物理存储和Unicode序号的转换关系" class="headerlink" title="UTF-8的物理存储和Unicode序号的转换关系"></a>UTF-8的物理存储和Unicode序号的转换关系</h3><p>UTF-8编码为变长编码。最小编码单位（<code>code unit</code>）为一个字节。一个字节的前1-3个bit为描述性部分，后面为实际序号部分。</p><ul><li>如果一个字节的第一位为0，那么代表当前字符为单字节字符，占用一个字节的空间。0之后的所有部分（7个bit）代表在Unicode中的序号。</li></ul><table><thead><tr><th>Byte 1</th></tr></thead><tbody><tr><td>0xxx xxxx</td></tr></tbody></table><table><thead><tr><th>实际字符</th><th>在Unicode字库序号的十六进制</th><th>在Unicode字库序号的二进制</th><th>UTF-8编码后的二进制</th><th>UTF-8编码后的十六进制</th></tr></thead><tbody><tr><td>$</td><td>0024</td><td>010 0100</td><td>0<strong>010 0100</strong></td><td>24</td></tr></tbody></table><ul><li>如果一个字节以110开头，那么代表当前字符为双字节字符，占用2个字节的空间。110之后的所有部分（5个bit）加上后一个字节的除10外的部分（6个bit）代表在Unicode中的序号。且第二个字节以10开头。</li></ul><table><thead><tr><th>Byte 1</th><th>Byte 2</th></tr></thead><tbody><tr><td>0xxx xxxx</td><td>10xx xxxx</td></tr></tbody></table><table><thead><tr><th>实际字符</th><th>在Unicode字库序号的十六进制</th><th>在Unicode字库序号的二进制</th><th>UTF-8编码后的二进制</th><th>UTF-8编码后的十六进制</th></tr></thead><tbody><tr><td>¢</td><td>00A2</td><td>000 1010 0010</td><td>110<strong>0 0010</strong> 10<strong>10 0010</strong></td><td>C2 A2</td></tr></tbody></table><ul><li>如果一个字节以1110开头，那么代表当前字符为三字节字符，占用2个字节的空间。1110之后的所有部分（5个bit）加上后两个字节的除10外的部分（12个bit）代表在Unicode中的序号。且第二、第三个字节以10开头。</li></ul><table><thead><tr><th>Byte 1</th><th>Byte 2</th><th>Byte 3</th></tr></thead><tbody><tr><td>0xxx xxxx</td><td>10xx xxxx</td><td>10xx xxxx</td></tr></tbody></table><table><thead><tr><th>实际字符</th><th>在Unicode字库序号的十六进制</th><th>在Unicode字库序号的二进制</th><th>UTF-8编码后的二进制</th><th>UTF-8编码后的十六进制</th></tr></thead><tbody><tr><td>€</td><td>20AC</td><td>0010 0000 1010 1100</td><td>1110 <strong>0010</strong> 10<strong>00 0010</strong> 10<strong>10 1100</strong></td><td>E2 82 AC</td></tr></tbody></table><ul><li><p>如果一个字节以10开头，那么代表当前字节为多字节字符的第二个字节。10之后的所有部分（6个bit）和之前的部分一同组成在Unicode中的序号。</p></li><li><p>3个字节的UTF-8十六进制编码一定是以<code>E</code>开头的。</p></li><li><p>2个字节的UTF-8十六进制编码一定是以<code>C</code>或<code>D</code>开头的。</p></li><li><p>1个字节的UTF-8十六进制编码一定是以比<code>8</code>小的数字开头的。</p></li></ul><h2 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h2><p>编码和解码时用了不同或者不兼容的字符集。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://cenalulu.github.io/linux/character-encoding/">十分钟搞清字符集和字符编码</a></li><li><a href="http://cenalulu.github.io/python/python-encoding/">关于Python的默认字符集</a></li><li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode和UTF-8</a></li><li><a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></li><li><a href="http://www.chi2ko.com/tool/CJK.htm">字体编辑用中日韩汉字Unicode编码表</a></li></ol>]]></content>
    
    
    <summary type="html">原文是十分钟搞清字符集和字符编码，这里我简化了一些说明，稍微修改了原文的例子。</summary>
    
    
    
    <category term="linux" scheme="https://chaomai.github.io/categories/linux/"/>
    
    
    <category term="character encoding" scheme="https://chaomai.github.io/tags/character-encoding/"/>
    
  </entry>
  
  <entry>
    <title>Pattern matching相关算法小结</title>
    <link href="https://chaomai.github.io/2015/2015-05-25-summary-of-pattern-matching/"/>
    <id>https://chaomai.github.io/2015/2015-05-25-summary-of-pattern-matching/</id>
    <published>2015-05-25T03:33:43.000Z</published>
    <updated>2021-06-27T14:57:29.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h1><p>Pattern matching的算法有很多，这里做一个简单的总结。</p><p>问题：给定一个字符串<code>txt[0...n-1]</code>和另一个字符串<code>pat[0...m-1]</code>，假设n &gt; m，实现一个函数<code>search(char pat[], char txt[])</code>，完成在<code>txt</code>中找到所有<code>pat</code>出现的位置。</p><p>例子：</p><ul><li>Input:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] &#x3D; &quot;THIS IS A TEST TEXT&quot;</span><br><span class="line">pat[] &#x3D; &quot;TEST&quot;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern found at index 10</span><br></pre></td></tr></table></figure><ul><li>Input:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] &#x3D; &quot;AABAACAADAABAAABAA&quot;</span><br><span class="line">pat[] &#x3D; &quot;AABA&quot;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern found at index 0</span><br><span class="line">Pattern found at index 9</span><br><span class="line">Pattern found at index 13</span><br></pre></td></tr></table></figure><h1 id="Naive-Pattern-Searching"><a href="#Naive-Pattern-Searching" class="headerlink" title="Naive Pattern Searching"></a>Naive Pattern Searching</h1><p>也叫Bruce Force。</p><p>方法很简单，对于<code>txt</code>中的每个index i，检查<code>pat</code>的每个字符是否匹配。如果有匹配不上的字符，或者匹配成功，都move到下一个index。</p><p>最坏时间复杂度，$O(mn)$。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-1-naive-pattern-searching/">Naive Pattern Searching</a></li></ul><h1 id="A-Better-Naive-Pattern-Searching"><a href="#A-Better-Naive-Pattern-Searching" class="headerlink" title="A Better Naive Pattern Searching"></a>A Better Naive Pattern Searching</h1><p>这个方法需要有一个前提条件：<code>pat</code>里所有字符都不相同。</p><p>在这个前提下，如果在匹配了j个字符之后出现了mismatch，那么<code>pat</code>就不是后移一个位置，而是后移j个位置。当然如果是首字符就不匹配，那么仍然是后移一个位置。</p><h2 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://www.geeksforgeeks.org/pattern-searching-set-4-a-naive-string-matching-algo-question/">A Naive Pattern Searching Question</a></li></ul><h1 id="KMP-Algorithm"><a href="#KMP-Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h1><p>Naive Pattern Searching在这样的情况下，效率是很低的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txt[] &#x3D; &quot;AAAAAAAAAAAAAAAAAB&quot;</span><br><span class="line">pat[] &#x3D; &quot;AAAAB&quot;</span><br></pre></td></tr></table></figure><p>因为<code>pat</code>每次在比较到不同的字符B的时候，仅仅向后移动一位，搜索位置又要退回，重新比较已经比较过的字符。</p><p>同时这也是Naive Pattern Searching的改进方法无法处理的，因为里面出现了重复的字符。如果再回去看Naive Pattern Searching的改进方法，其实本质上就是为了避免搜索位置的退回。</p><p>KMP可以利用已经比较过的字符这一信息来避免搜索位置退回。至于怎么利用，就是部分匹配表。</p><p>部分匹配表是KMP的关键，生成的方式是对pat的每个前缀，计算该前缀的前缀和后缀的最长的共有元素的长度。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pat                 A B C D A B D</span><br><span class="line">partial match value 0 0 0 0 1 2 0</span><br></pre></td></tr></table></figure><p>有了部分匹配表，在发现不同的字符的时候，就不直接把<code>pat</code>后移一位，而是根据下面的公式，</p><p>$$<br>移动位数 = 已匹配的字符数 - 对应的部分匹配值<br>$$</p><p>这里对应的部分匹配值指的是，在<code>pat</code>中，最后已匹配字符对应的部分匹配值。</p><p>如果是首字符就不匹配，那么仍然是后移一个位置。</p><p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，<code>&quot;ABCDAB&quot;</code>之中有两个<code>&quot;AB&quot;</code>，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个<code>&quot;AB&quot;</code>向后移动4位（$字符串长度-部分匹配值$），就可以来到第二个<code>&quot;AB&quot;</code>的位置。</p><p>最坏时间复杂度，$O(n)$。</p><p>看完KMP，可以发现Naive Pattern Searching的改进方法实际上是KMP的特例，由于pat中所有字符都不相同，因此部分匹配表中所有的对应的部分匹配值都是0，</p><p>$$<br>移动位数 = 已匹配的字符数<br>$$</p><h2 id="References-2"><a href="#References-2" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/">KMP Algorithm</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法</a></li></ul><h1 id="Rabin-Karp-Algorithm"><a href="#Rabin-Karp-Algorithm" class="headerlink" title="Rabin-Karp Algorithm"></a>Rabin-Karp Algorithm</h1><p>Bruce Force在<code>txt</code>上每次把<code>pat</code>后移一位，每次移动之后，检查<code>pat</code>的每个字符是否匹配。Rabin-Karp也是类似的，每次把pat后移一位，不同的是Rabin-Karp比较的是<code>pat</code>的hash值和当前对应的<code>txt</code>子串的hash值。如果hash值相等，然后再去逐个检查子串的字符。</p><p>最直接的方法莫过于计算<code>h(pat)</code>和<code>txt</code>中所有子串的hash，然后一一比较。但光是计算<code>txt</code>中所有子串的hash就需要O(mn)的时间，这样一来，相比起Naive Pattern Searching，这个方法就毫无优势了。</p><p>如何计算hash值是Rabin-Karp的关键，最好是能够利用当前<code>txt</code>子串的hash值，计算后移一位以后的，以减少计算的开销。Rabin-Karp使用的hash叫做Rolling hash，基本实现是刚刚的方法实际上重复计算了很多重叠的部分，而Rolling hash就要利用当前子串的hash值，来计算后移一个位置之后子串的hash值。</p><p>Intro to Algorithms的Lecture Note举了一个很形象的例子来说明Rolling hash。</p><p>在最坏情况下，每次移动后hash值都相等（因为子串相同或hash冲突），因此移动后都要逐个检查子串的字符。</p><p>最坏时间复杂度，$O(mn)$。</p><h2 id="References-3"><a href="#References-3" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://en.wikipedia.org/wiki/Rolling_hash">Rolling hash</a></li><li><a href="http://courses.csail.mit.edu/6.006/spring11/rec/rec06.pdf">Rolling Hash (Rabin-Karp Algorithm)</a></li><li><a href="http://stellar.mit.edu/S/course/6/fa13/6.006/courseMaterial/topics/topic6/lectureNotes/L09-Hashing-II/L09-Hashing-II.pdf">Hashing-II</a></li><li><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-3-rabin-karp-algorithm/">Rabin-Karp Algorithm</a></li></ul><h1 id="Finite-Automata"><a href="#Finite-Automata" class="headerlink" title="Finite Automata"></a>Finite Automata</h1><p>基于有限状态机实现pattern searching，就是用pattern来构建一个状态表，构建完成以后就可以根据txt的每个字符，来在有限状态机的各个状态之间转移，如果到达终态，那就是匹配到了。</p><p>这个算法的关键就是基于pattern构建状态表。</p><h2 id="References-4"><a href="#References-4" class="headerlink" title="References"></a>References</h2><p><a href="http://www.geeksforgeeks.org/searching-for-patterns-set-5-finite-automata/">http://www.geeksforgeeks.org/searching-for-patterns-set-5-finite-automata/</a></p>]]></content>
    
    
    <summary type="html">Pattern matching的算法有很多，这里做一个简单的总结。</summary>
    
    
    
    <category term="algorithms" scheme="https://chaomai.github.io/categories/algorithms/"/>
    
    
    <category term="pattern matching" scheme="https://chaomai.github.io/tags/pattern-matching/"/>
    
  </entry>
  
  <entry>
    <title>译 - Locks, Mutexes, and Semaphores: Types of Synchronization Objects</title>
    <link href="https://chaomai.github.io/2015/2015-05-23-translation-locks-mutexes-and-semaphores-types-of-synchronization-objects/"/>
    <id>https://chaomai.github.io/2015/2015-05-23-translation-locks-mutexes-and-semaphores-types-of-synchronization-objects/</id>
    <published>2015-05-23T14:12:13.000Z</published>
    <updated>2021-06-27T14:57:29.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h1><p>lock是一个抽象的概念。一个基本的前提就是一个lock保护着某种共享资源的访问。如果你own一个lock，那么你就能访问被保护的共享资源。如果你没有own lock，那么你就不能够访问这个共享资源。</p><p>为了own一个lock，你首先需要某种lockable对象。然后你从那个对象获得lock。这个操作精确的术语可能会有很多。例如，如果你有一个lockable对象XYZ，你可以：</p><ul><li>acquire the lock on XYZ,</li><li>take the lock on XYZ,</li><li>lock XYZ,</li><li>take ownership of XYZ,</li><li>or some similar term specific to the type of XYZ</li></ul><p>lock的概念也意味着某种exclusion：有时，你可能不能获得ownership of a lock，接着将要执行的操作将会fail、或block。就前者而言，操作将会返回某些错误码或异常，以指明take ownership的操作尝试失败。而后者，只有当这个操作take ownership，它才会返回，而这需要系统里的其他线程完成一些工作才能使得这个发生。</p><p>exclusion最常见的形式是一个简单的计数：lockable对象有最大数目的owners。如果达到了这个数目，那么接下来任何尝试获取a lock on it都不会成功。因此，这需要我们有某种机制（当我们完成操作的时候，放弃ownership）。这通常叫做unlocking，但是同样的术语可能不同。例如，你可以：</p><ul><li>release the lock on XYZ,</li><li>drop the lock on XYZ,</li><li>unlock XYZ,</li><li>relinquish ownership of XYZ,</li><li>or some similar term specific to the type of XYZ</li></ul><p>当你以合适的方式relinquish ownership，如果所需的条件都满足了，那么一个被block的尝试获得锁的操作现在将会继续。</p><p>例如一个lockable对象只允许有3个owners，那么第4个尝试获得lock的操作将block。当3个中的某个owner 释放了lock，那么第4个尝试获得lock的操作将会成功。</p><h1 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h1><p>“own” a lock的意思视lockable对象确切的类型而定。某些lockable对象会对ownership有非常严格的定义：this specific thread owns the lock, through the use of that specific object, within this particular scope.</p><p>在其他情况下，这个定义会更不稳定，ownership of the lock会更抽象。在这些情况下，ownership can be relinquished by a different thread or object than the thread or object that acquired the lock.</p><p>注：其实就想看这篇文章里说Ownership的部分，后面的就不翻译了:)</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li>原文：<a href="https://www.justsoftwaresolutions.co.uk/threading/locks-mutexes-semaphores.html">Locks, Mutexes, and Semaphores: Types of Synchronization Objects</a></li></ul>]]></content>
    
    
    <summary type="html">C++ Concurrency in Action作者的文章，介绍了一些关于并发的基础概念：锁、互斥量和信号量。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="cpp" scheme="https://chaomai.github.io/tags/cpp/"/>
    
    <category term="synchronize" scheme="https://chaomai.github.io/tags/synchronize/"/>
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="cpp11" scheme="https://chaomai.github.io/tags/cpp11/"/>
    
  </entry>
  
  <entry>
    <title>C++ Concurrency in Action (2) - Managing threads</title>
    <link href="https://chaomai.github.io/2015/2015-05-18-cpp-concurrency-in-action-2/"/>
    <id>https://chaomai.github.io/2015/2015-05-18-cpp-concurrency-in-action-2/</id>
    <published>2015-05-18T11:35:23.000Z</published>
    <updated>2021-06-27T14:57:29.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Managing-threads"><a href="#Managing-threads" class="headerlink" title="Managing threads"></a>Managing threads</h1><p><code>std::thread</code>：线程管理的相关类和函数。</p><p>对于那些不是那么简单的任务，库提供了可以让你从基本的代码来构建你需要的东西的灵活性。</p><h2 id="Basic-thread-management"><a href="#Basic-thread-management" class="headerlink" title="Basic thread management"></a>Basic thread management</h2><p>每个C++程序都至少有一个线程，这个线程是由C++运行时启动的：运行<code>main()</code>的那个线程。</p><h3 id="Launching-a-thread"><a href="#Launching-a-thread" class="headerlink" title="Launching a thread"></a>Launching a thread</h3><p>启动一个线程需要构造<code>std::thread</code>对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>; <span class="comment">//此时新线程已经启动</span></span><br></pre></td></tr></table></figure><p>在C++标准库中，<code>std::thread</code>可以适用于任何callable类型。如果是一个带有函数调用操作符的类的实例，那么对象会被copy到新线程的存储空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">background_task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        do_something();</span><br><span class="line">        do_something_else();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task f;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure><p>但要注意的是，如果传入的是一个临时对象，而不是已经命名的对象，那么这样的语法就和函数调用没有区别，编译器也不会把它看作是callable对象。<br>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(background_task())</span></span>;</span><br></pre></td></tr></table></figure><p>这里声明了一个my_thread函数，接受一个参数，参数是一个函数指针（这个函数不接受任何参数，返回的是background_task对象），返回一个<code>std::thread</code>对象。</p><p>避免这样问题的方法：</p><ol><li>命名函数对象</li><li>使用额外的括号</li><li>使用新的统一的初始化语法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">((background_task()))</span></span>;    <span class="comment">//prevent interpretation as a function</span></span><br><span class="line"><span class="built_in">std</span>::thread my_thread&#123;background_task()&#125;;</span><br></pre></td></tr></table></figure><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">([](</span></span></span><br><span class="line"><span class="function"><span class="params">    do_something();</span></span></span><br><span class="line"><span class="function"><span class="params">    do_something_else();</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;);</span></span></span><br></pre></td></tr></table></figure><p>在线程启动以后，需要决定是等待线程结束，还是任其运行。这个决定只需要在线程destroy之前完成即可，因为有可能在你join或detach前，线程就运行完成了。</p><p>如果不想等待线程结束，那么必须保证线程所访问的数据，直到该线程结束时都是合法的。下面就是一个反例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; i;</span><br><span class="line">    func(<span class="keyword">int</span>&amp; i_):i(i_)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            do_something(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    my_thread.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，因为调用了<code>detach()</code>，所以<code>oops()</code>结束时，新线程仍然有可能还在运行。如果仍然在运行，那么<code>do_something(i)</code>将会访问一个已经destroyed的变量。</p><p>一种常用的方式是，使得thread function self-contained，并且是copy数据到线程，（这里指的应该是function object），而不是共享数据（指针或引用）。除非可以保证线程在函数结束前运行完，否则不要创建一个可以访问所在函数局部变量的线程。当然，也可以join。</p><h3 id="Waiting-for-a-thread-to-complete"><a href="#Waiting-for-a-thread-to-complete" class="headerlink" title="Waiting for a thread to complete"></a>Waiting for a thread to complete</h3><p>对与线程相关联的<code>std::thread</code>对象调用<code>join()</code>。</p><p>在上例中，可以换成<code>join()</code>。但是换了以后就失去了多线程的意义，因为原始线程除了wait，什么都没法做。</p><p><code>join()</code>是一种简单粗暴的方法。如果需要细粒度的控制wait，那么就需要其他的机制。</p><p>调用<code>join()</code>还会清除与线程相关的任何storage，因此<code>std::thread</code>对象不再和任何已结束的线程关联，换句话说就是，对于给定线程，<code>join()</code>只能调用一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func my_func;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure><p>这里加断点可以验证，t在join前，thread id的值不为0，join后变为0。</p><h3 id="Waiting-in-exceptinal-circumstances"><a href="#Waiting-in-exceptinal-circumstances" class="headerlink" title="Waiting in exceptinal circumstances"></a>Waiting in exceptinal circumstances</h3><p><code>detach()</code>可以在线程开始后马上调用，但是<code>join()</code>意味着wait。如果想要在wait前做些其他事情，那么就必须考虑<code>join()</code>放置的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        do_something_in_current_thread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        t.join();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码保证了在异常或者无异常的情况下，都能够<code>join()</code>。无论是什么原因导致要<code>join()</code>，都必须保证在所有exit可能的情况里，都有<code>join()</code>，而上面的代码太复杂，容易出错。</p><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_guard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::thread&amp; t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(<span class="built_in">std</span>::thread&amp; t_)</span>:</span></span><br><span class="line"><span class="function">        <span class="title">t</span><span class="params">(t_)</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">    ~thread_guard()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t.joinable())</span><br><span class="line">        &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread_guard(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但f exit时，局部对象的销毁顺序是与构造顺序相反的。因此无论是什么情况导致f exit，只要t是joinable的，就可以保证join。</p><p>之所以要disable copy和assign，是因为如果enalbe，那么对象的生命周期可能会超过thread应该join的作用域。</p><h3 id="Runing-threads-in-the-background"><a href="#Runing-threads-in-the-background" class="headerlink" title="Runing threads in the background"></a>Runing threads in the background</h3><p>在一个<code>std::thread</code>对象上调用<code>detach()</code>。</p><p>一旦调用<code>detach()</code>，就再也无法wait for that thread（不能获得reference到that thread的<code>std::thread</code>对象，也不能<code>join()</code>）。</p><p>被<code>detach()</code>的线程（也被叫做demon thread）会在后台运行，拥有权和控制权会交给C++ Runtime library，它能保证当线程结束时，相关的资源会被回收。这样的线程可能会是long-running的线程，执行监视、清理和优化的工作。</p><p>为了从一个<code>std::thread</code>对象上<code>detach()</code>线程，必须要有线程来detach。调用<code>detach()</code>的要求和<code>join()</code>一样，joinable的<code>std::thread</code>对象才可以detach()。</p><h2 id="Passing-arguments-to-a-thread-function"><a href="#Passing-arguments-to-a-thread-function" class="headerlink" title="Passing arguments to a thread function"></a>Passing arguments to a thread function</h2><p>可以用前面的方法，用一个带有data成员的函数对象，但更简便的是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,”hello”)</span></span>;</span><br></pre></td></tr></table></figure><p>在上例中，要注意的是，std::string是以char const*的形式传入的，只有在新线程的context中才会被转为<code>std::string</code>。</p><p>在默认情况下，参数是被copy的。我猜这样设计的原因也是出于之前提到过的原因，如果线程point to或reference to的local variable所在的scope结束，local variable就会被销毁，那么线程将会访问一个已经destroyed的变量。除非使用额外的<code>join()</code>，但这无疑增加了用户编码的复杂度。</p><h3 id="Just-want-reference"><a href="#Just-want-reference" class="headerlink" title="Just want reference"></a>Just want reference</h3><p>如果我就是要修改原始数据，怎么办？对于pointer，这个倒是好说，直接传pointer即可，地址会被copy，但是reference就不一样了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    widget_data data;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,data)</span></span>;</span><br><span class="line">    display_status();</span><br><span class="line">    t.join();</span><br><span class="line">    process_widget_data(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，虽然<code>update_data_for_widget()</code>期望的是第二个参数传入引用，但是<code>std::thread</code>并不知道。<code>update_data_for_widget()</code>被调用时，data实际上是reference to线程内部的copy过来的data，而不是原始的data。线程结束时，这些对data的操作都会随着线程内部copy的销毁而丢失，<code>process_widget_data()</code>接受的还是没有修改的data。</p><p>但是我在clang++-3.6，libstdc++的环境下编译的时候，以上代码是无法通过编译的，错误如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: no type named &#x27;type&#x27; in &#x27;std::result_of&lt;void (*(int, double))(int, double &amp;)&gt;&#x27;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> result_of&lt;_Callable(_Args...)&gt;::type result_type;</span><br></pre></td></tr></table></figure><p>加入std::ref后编译通过，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,<span class="built_in">std</span>::ref(data))</span></span>;</span><br></pre></td></tr></table></figure><h3 id="std-thread-and-std-bind"><a href="#std-thread-and-std-bind" class="headerlink" title="std::thread and std::bind"></a><code>std::thread</code> and <code>std::bind</code></h3><p><code>std::thread</code>的构造函数和<code>std::bind</code>的操作有相同的机制，可以这样构造<code>std::thread</code>对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_lengthy_work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(&amp;X::do_lengthy_work,&amp;my_x)</span></span>;</span><br></pre></td></tr></table></figure><p>如果成员函数有参数，那么可以作为构造函数的第三个参数，以此类推。</p><h3 id="objects-cannot-be-copied"><a href="#objects-cannot-be-copied" class="headerlink" title="objects cannot be copied"></a>objects cannot be copied</h3><p>有的对象不能够被copy，比如<code>std::unique_ptr</code>对象。这时需要用<code>std::move()</code>来transfer ownership到另一个<code>std::unique_ptr</code>对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_big_object</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;big_object&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;big_object&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> big_object)</span></span>;</span><br><span class="line">p-&gt;prepare_data(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(process_big_object,<span class="built_in">std</span>::move(p))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Transferring-ownership-of-a-thread"><a href="#Transferring-ownership-of-a-thread" class="headerlink" title="Transferring ownership of a thread"></a>Transferring ownership of a thread</h2><p>虽然<code>std::thread</code>不像<code>std::unique_ptr</code>动态的拥有一个对象，但是<code>std::thread</code>的确是拥有资源：每个<code>std::thread</code>实例负责管理一个线程的执行。由于<code>std::thread</code>对象不是copyable，而是moveable，因此对象的ownership可以在对象间transfer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::thread t2=<span class="built_in">std</span>::move(t1);    <span class="comment">//t1不再与运行some_function()的线程关联</span></span><br><span class="line">t1=<span class="built_in">std</span>::thread(some_other_function);    <span class="comment">//如果是临时对象，move自动并且隐式的发生</span></span><br><span class="line"><span class="built_in">std</span>::thread t3；    <span class="comment">//默认构造，没有和任何执行线程关联</span></span><br><span class="line">t3=<span class="built_in">std</span>::move(t2);</span><br><span class="line">t1=<span class="built_in">std</span>::move(t3);</span><br></pre></td></tr></table></figure><p>在上例中的最后一个move，t1原本是和运行<code>some_other_function()</code>的线程关联的，但是运行着<code>some_function()</code>的线程的ownership被transfer给了t1，这将导致程序终止。<br>因为在线程运行结束并销毁前，要么<code>join()</code>，要么<code>detach()</code>，但是绝对不能够简单的通过向管理它的<code>std::thread</code>对象赋值(move)而丢掉它。“野线程”不允许存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::thread(some_function);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(some_other_function,<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，实际上是在transfer ownership。</p><p>在这里，<code>std::move</code>的另一个作用可以简化<code>thread_gurad</code>。在原来的<code>thread_gurad</code>中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_gurad(<span class="built_in">std</span>::thread(do_work, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>这样是不允许的，因为<code>thread_gurad</code>构造函数接受的参数是引用，因此传入的必须是左值，而unnamed <code>std::thread</code> object并不是左值对象。</p><p>使用<code>std::move</code>后，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scoped_thread</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(<span class="built_in">std</span>::thread t_)</span> :</span></span><br><span class="line"><span class="function">      <span class="title">t</span><span class="params">(<span class="built_in">std</span>::move(t_))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t.joinable()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;No thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~scoped_thread() &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scoped_thread(scoped_thread <span class="keyword">const</span> &amp;p) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  scoped_thread &amp;<span class="keyword">operator</span>=(scoped_thread <span class="keyword">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">scoped_thread(<span class="built_in">std</span>::thread(do_work, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>上述操作就可以了。这样做还避免了<code>thread_gurad</code>对象的生命周期可能超过它引用的线程所在的scope，并且transfer以后，没有其他关联的<code>std::thread</code>对象可以join或detach。</p><h2 id="Choosing-the-number-of-threads-at-runtime"><a href="#Choosing-the-number-of-threads-at-runtime" class="headerlink" title="Choosing the number of threads at runtime"></a>Choosing the number of threads at runtime</h2><p><code>std::thread::hardware_concurrency()</code>，这个函数返回可以真正并行执行的线程数目。但这只是个hint，换句话说，就算可以并发多个线程，如果没有可用的信息，它可能会返回0。</p><p>C++ Concurrency in Action书中，在并行累加例子的后面有并行算法要求的共性的总结：</p><ul><li>at least forward iterators</li><li>single-pass input iterators</li><li>T must be default constructiable</li></ul><p>到目前位置，由于不能够直接从线程中返回值，因此必须传入reference。</p><h2 id="Identifying-threads"><a href="#Identifying-threads" class="headerlink" title="Identifying threads"></a>Identifying threads</h2><p>线程识别符是<code>std::thread::id</code>类型的，获得方式有：</p><ul><li>通过成员函数<code>get_id()</code>，从关联该线程的<code>std::thread</code>对象获得（如果对象没有关联任何线程，则会返回默认构造函数生成的<code>std::thread::id</code>对象，表示not any thread）</li><li>对于当前线程，使用<code>std::thread::get_id()</code></li></ul><p><code>std::thread::id</code>对象可以被copy，并且该类型提供了完整的比较操作（全序的）。如果一致，那么他们代表同一线程，或者<em>not any thread</em>。该类型对象还可以作为key用于关联容器、排序，同时标准库还提供了<code>std::hash&lt;std::thread::id&gt;</code>，因此还能用于无序关联容器。</p><p><code>std::thread::id</code>对象常用于检查线程是否需要做某些操作。</p>]]></content>
    
    
    <summary type="html">Managing threads的笔记。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="cpp" scheme="https://chaomai.github.io/tags/cpp/"/>
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="cpp11" scheme="https://chaomai.github.io/tags/cpp11/"/>
    
    <category term="c++ concurrency in action" scheme="https://chaomai.github.io/tags/c-concurrency-in-action/"/>
    
    <category term="threads" scheme="https://chaomai.github.io/tags/threads/"/>
    
  </entry>
  
  <entry>
    <title>C++ Concurrency in Action (1) - Hello, world of concurrency in C++!</title>
    <link href="https://chaomai.github.io/2015/2015-05-17-cpp-concurrency-in-action-1/"/>
    <id>https://chaomai.github.io/2015/2015-05-17-cpp-concurrency-in-action-1/</id>
    <published>2015-05-17T11:35:23.000Z</published>
    <updated>2021-06-27T14:57:29.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于此系列文章"><a href="#关于此系列文章" class="headerlink" title="关于此系列文章"></a>关于此系列文章</h1><p>最近在看这本书，这个系列文章是我在看书过程中的笔记，记录了一些我觉得关键的地方和自己的思考。如果能帮助到你，I will be very happy :).</p><h1 id="关于C-Concurrency-in-Action"><a href="#关于C-Concurrency-in-Action" class="headerlink" title="关于C++ Concurrency in Action"></a>关于C++ Concurrency in Action</h1><blockquote><p>本书是一本基于C++11新标准的并发和多线程编程深度指南。从std::thread、std::mutex、std::future和std::async等基础类的使用，到内存模型和原子操作、基于锁和无锁数据结构的构建，再扩展到并行算法、线程管理，最后还介绍了多线程代码的测试工作。本书的附录部分还对C++11新语言特性中与多线程相关的项目进行了简要的介绍，并提供了C++11线程库的完整参考。</p><footer><strong>并发编程网</strong><cite><a href="http://ifeve.com/c-plus-plus-concurrency-in-action/">《C++ Concurrency in Action》中文版</a></cite></footer></blockquote><p>2014年初要出的中文版，只是到现在还没有，看英文吧。</p><h1 id="Hello-world-of-concurrency-in-C"><a href="#Hello-world-of-concurrency-in-C" class="headerlink" title="Hello, world of concurrency in C++"></a>Hello, world of concurrency in C++</h1><p>在C++中实现多线程，可以写出行为有保证的可移植的代码。</p><h3 id="Appraoches-to-concurrency"><a href="#Appraoches-to-concurrency" class="headerlink" title="Appraoches to concurrency"></a>Appraoches to concurrency</h3><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>消息传递由进程间通信实现，但是，</p><ul><li>由于操作系统的有很多保护机制来避免一个进程难以修改另一个的数据，因此实现通讯的方式复杂或者慢；</li><li>有固有的开销，启动进程需要时间（系统需要分配资源等）。</li></ul><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>操作系统要做的更少，灵活的共享内存是有代价的。</p><ul><li>内存一致性</li></ul><h2 id="Why-use-concurrency"><a href="#Why-use-concurrency" class="headerlink" title="Why use concurrency"></a>Why use concurrency</h2><ul><li>separation of concerns</li><li>performance</li></ul><h3 id="Ways-to-use-concurrency"><a href="#Ways-to-use-concurrency" class="headerlink" title="Ways to use concurrency"></a>Ways to use concurrency</h3><ul><li>task parallelism, data parallelism；</li><li>使用现有的并行计算能力来解决更大的问题；</li><li>（两种方式有着不同的关注点：一个是利用并行来缩短任务的时间；另一个是在任务处理时间一定的情况下，并行的运行多个任务来加大处理量。）</li></ul><h3 id="When-not-to-use-concurrency"><a href="#When-not-to-use-concurrency" class="headerlink" title="When not to use concurrency"></a>When not to use concurrency</h3><ul><li>实现并发的cost&gt;收益；</li><li>线程的启动需要时间来给os分配相关的内核资源和栈空间，如果线程完成的时间很短，那可能启动的时间就占据了运行时间的大部分；</li><li>由于系统的资源有限，线程是一种有限的资源,线程越多，os必须进行更多的context switching。</li></ul>]]></content>
    
    
    <summary type="html">Hello, world of concurrency in C++!的笔记。</summary>
    
    
    
    <category term="concurrency" scheme="https://chaomai.github.io/categories/concurrency/"/>
    
    
    <category term="cpp" scheme="https://chaomai.github.io/tags/cpp/"/>
    
    <category term="reading" scheme="https://chaomai.github.io/tags/reading/"/>
    
    <category term="cpp11" scheme="https://chaomai.github.io/tags/cpp11/"/>
    
    <category term="c++ concurrency in action" scheme="https://chaomai.github.io/tags/c-concurrency-in-action/"/>
    
  </entry>
  
  <entry>
    <title>Clang++中C++11 thread的支持</title>
    <link href="https://chaomai.github.io/2015/2015-05-15-compile-c-11-thread-with-clang/"/>
    <id>https://chaomai.github.io/2015/2015-05-15-compile-c-11-thread-with-clang/</id>
    <published>2015-05-15T11:35:23.000Z</published>
    <updated>2021-06-27T14:57:29.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在Ubuntu中使用Clang++，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++-3.7 -std=c++11 test.cpp</span><br></pre></td></tr></table></figure><p>编译C++11编写的多线程代码时，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">  t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现如下问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/test-9606ba.o: In <span class="keyword">function</span> `std::thread::thread&lt;void (&amp;)()&gt;(void (&amp;)())<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">test.cpp:(.text[_ZNSt6threadC2IRFvvEJEEEOT_DpOT0_]+0x21): undefined reference to `pthread_create&#x27;</span></span><br><span class="line">clang: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li><p>在Linux中，Standard C++ library的默认实现是libstdc++。虽然安装了clang，但是编译时使用的仍然是GNU的libstdc++。</p></li><li><p>执行clang++ -v以后，可以知道使用的线程模型是posix。</p></li></ol><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>既然底层使用了posix来实现C++11的线程，那么编译的时候必然要有-pthread</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++-3.7 -std=c++11 -pthread test.cpp</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在Linux下编译C++11的多线程代码时，提示pthread_create为定义。最后发现clang++在Linux在使用的是posix来实现C++11的线程，编译的时候需要加上-pthread。</summary>
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="thread" scheme="https://chaomai.github.io/tags/thread/"/>
    
    <category term="clang" scheme="https://chaomai.github.io/tags/clang/"/>
    
  </entry>
  
  <entry>
    <title>编译时，-pthread and -lpthread的区别</title>
    <link href="https://chaomai.github.io/2015/2015-05-14-difference-between-pthread-and-lpthread/"/>
    <id>https://chaomai.github.io/2015/2015-05-14-difference-between-pthread-and-lpthread/</id>
    <published>2015-05-14T11:31:30.000Z</published>
    <updated>2021-06-27T14:57:29.256Z</updated>
    
    <content type="html"><![CDATA[<p>-pthread告诉编译器，要链接到pthread库，同时配置线程的编译。</p><p>下面的例子就显示了在使用-pthread时，定义了不同的宏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -pthread -E -dM test.c &gt; dm.pthread.txt</span><br><span class="line">$ gcc          -E -dM test.c &gt; dm.nopthread.txt</span><br><span class="line">$ diff dm.pthread.txt dm.nopthread.txt</span><br><span class="line">152d151</span><br><span class="line">&lt; <span class="comment">#define _REENTRANT 1</span></span><br><span class="line">208d206</span><br><span class="line">&lt; <span class="comment">#define __USE_REENTRANT 1</span></span><br></pre></td></tr></table></figure><p>-lpthread只会告诉编译器，要链接到pthread库，但是这些宏不会被定义。</p><p>编译时，应该使用-pthread。</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ol><li> <a href="http://stackoverflow.com/questions/23250863/difference-between-pthread-and-lpthread-while-compiling">difference-between-pthread-and-lpthread-while-compiling</a></li></ol>]]></content>
    
    
    <summary type="html">gcc编译多线程代码时，参数不同导致结果的不同。</summary>
    
    
    
    <category term="linux" scheme="https://chaomai.github.io/categories/linux/"/>
    
    
    <category term="pthread" scheme="https://chaomai.github.io/tags/pthread/"/>
    
    <category term="thread" scheme="https://chaomai.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>从汇编的角度分析C++引用</title>
    <link href="https://chaomai.github.io/2015/2015-03-10-analysis-reference-in-cpp-from-the-perspective-of-assembly/"/>
    <id>https://chaomai.github.io/2015/2015-03-10-analysis-reference-in-cpp-from-the-perspective-of-assembly/</id>
    <published>2015-03-10T09:35:29.000Z</published>
    <updated>2021-06-27T14:57:29.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>C++中，引用为对象起了另外一个名字，引用类型refers to另外一种类型。定义引用时，把引用和初始值绑定在一起，而不是将初始值拷贝给引用。定义了引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。但是引用本身不是一个对象。</p><p>说到这里，其实会发现引用和指针有点像，但实际上它们是不同的。首先引用在绑定到对象以后，就不能再绑定到另外一个对象；其次，引用本身不是一个对象，但是指针是一个对象。</p><h1 id="汇编的角度"><a href="#汇编的角度" class="headerlink" title="汇编的角度"></a>汇编的角度</h1><p>更深入到底层，可以汇编的角度来看引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ra = a;</span><br><span class="line">ra++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> *pa = &amp;b;</span><br><span class="line">pa++;</span><br><span class="line">(*pa)++;</span><br></pre></td></tr></table></figure><p>以上代码的反汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 3;</span><br><span class="line">012E33F8  mov         dword ptr [a],3</span><br><span class="line">int &amp;ra &#x3D; a;</span><br><span class="line">012E33FF  lea         eax,[a]</span><br><span class="line">012E3402  mov         dword ptr [ra],eax</span><br><span class="line"></span><br><span class="line">int b &#x3D; 4;</span><br><span class="line">012E3405  mov         dword ptr [b],4</span><br><span class="line">int *pa &#x3D; &amp;b;</span><br><span class="line">012E340C  lea         eax,[b]</span><br><span class="line">012E340F  mov         dword ptr [pa],eax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ra++;</span><br><span class="line">013F4475  mov         eax,dword ptr [ra]</span><br><span class="line">013F4478  mov         ecx,dword ptr [eax]</span><br><span class="line">013F447A  add         ecx,1</span><br><span class="line">013F447D  mov         edx,dword ptr [ra]</span><br><span class="line">013F4480  mov         dword ptr [edx],ecx</span><br><span class="line"></span><br><span class="line">pa++;</span><br><span class="line">013F448F  mov         eax,dword ptr [pa]</span><br><span class="line">013F4492  add         eax,4</span><br><span class="line">013F4495  mov         dword ptr [pa],eax</span><br><span class="line">(*pa)++;</span><br><span class="line">013F4498  mov         eax,dword ptr [pa]</span><br><span class="line">013F449B  mov         ecx,dword ptr [eax]</span><br><span class="line">013F449D  add         ecx,1</span><br><span class="line">013F44A0  mov         edx,dword ptr [pa]</span><br><span class="line">013F44A3  mov         dword ptr [edx],ecx</span><br></pre></td></tr></table></figure><p>可以看到，首先把3放入地址为[a]的内存，然后把a的地址放入eax，最后把eax的值放入地址为[ra]的内存。实际上，就是把a的地址放入了ra里。而b和pa也同样是这样步骤。</p><p>然后再来看++操作的部分，在汇编的角度，引用和指针在内存中都是地址，在对指针指向的变量进行++时，需要手动的来进行解引用；但对于引用，解引用这个操作是编译器帮你完成了，只需要直接++即可。</p><p>从汇编的角度来看，引用是通过指针来实现的。</p><h1 id="实现引用类型与被引用对象分离"><a href="#实现引用类型与被引用对象分离" class="headerlink" title="实现引用类型与被引用对象分离?"></a>实现引用类型与被引用对象分离?</h1><p>C++中规定了引用在绑定到对象以后，就不能再绑定到另外一个对象，既然了解了C++中引用的底层的实现，能否通过底层的方法来绕过这个限制？答案是可以的。</p><p>先来看这么几行代码，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ra = a;</span><br></pre></td></tr></table></figure><p>对ra进行的所有操作都是在与之绑定的变量a上进行的，因此直接操作ra来修改绑定是无法实现的。由于定义以上几个变量时，它们应该是处于相邻的内存空间中，因此可以通过ra相邻的内存，来更改ra，进而分离ra与被引用对象a。</p><p>这是在执行以上3条语句之后的内存情况，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x0078F750  cc cc cc cc 6c f7 78 00  ????l?x.</span><br><span class="line">0x0078F758  cc cc cc cc cc cc cc cc  ????????</span><br><span class="line">0x0078F760  04 00 00 00 cc cc cc cc  ....????</span><br><span class="line">0x0078F768  cc cc cc cc 03 00 00 00  ????....</span><br><span class="line">0x0078F770  cc cc cc cc 96 d1 e4 4e  ???????N</span><br><span class="line">0x0078F778  c8 f7 78 00 69 69 18 00  ??x.ii..</span><br></pre></td></tr></table></figure><p>其中EBP=其中EBP=0x007EFA7C，可以看到EBP之前的12byte的位置才是第一个变量，再往前12byte是第二个变量，继续往前12byte是引用。因此b的地址减3就是存储引用的内存，修改这个地方即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(&amp;b - <span class="number">3</span>) = (<span class="keyword">int</span>)&amp;b;</span><br><span class="line">ra++;</span><br></pre></td></tr></table></figure><p>继续执行下面代码以后，b被增加成5。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>C++ Primer 第5版</li></ol>]]></content>
    
    
    <summary type="html">C++中，引用为对象起了另外一个名字，引用类型refers to另外一种类型。引用和指针是不同的，可以汇编的角度来看引用。</summary>
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="cpp reference" scheme="https://chaomai.github.io/tags/cpp-reference/"/>
    
  </entry>
  
  <entry>
    <title>C++中typedef的使用和类型安全</title>
    <link href="https://chaomai.github.io/2015/2015-02-06-type-safe-typedef-in-cpp/"/>
    <id>https://chaomai.github.io/2015/2015-02-06-type-safe-typedef-in-cpp/</id>
    <published>2015-02-06T15:06:00.000Z</published>
    <updated>2021-06-27T14:57:29.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于typedef"><a href="#关于typedef" class="headerlink" title="关于typedef"></a>关于<code>typedef</code></h1><p>传统的<code>typedef</code>机制允许对已存在的type提供synonym或者alias，我们把这种的传统的<code>typedef</code>（包括c++11中的alias声明）描述为“透明类型机制”：这种声明引入了新的类型名称，但不是新的类型。被定义为新引入的alias的类型与被定义为原来类型的变量，完全一样，不会有一丁点行为上的差别。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>但是这种特性在某些场景下会有缺陷。</p><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> score = <span class="keyword">unsigned</span>;</span><br><span class="line"><span class="function">score <span class="title">penalize</span><span class="params">(score n)</span> </span>&#123; <span class="keyword">return</span> n &gt; <span class="number">5u</span> ? n - <span class="number">5u</span> : score &#123; <span class="number">0u</span> &#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> serial_number = <span class="keyword">unsigned</span>;</span><br><span class="line"><span class="function">serial_number <span class="title">next_id</span><span class="params">(serial_number n)</span> </span>&#123; <span class="keyword">return</span> n + <span class="number">1u</span>; &#125;</span><br></pre></td></tr></table></figure><p>使用新的alias可以很明显的了解以上代码的意图，但实际上这样的使用意图在错误使用alias的情况下，是无法保证的，或者说是不可实行的(unenforceable)。</p><p><code>unsigned</code>, <code>next_id</code>和<code>serial_number</code>是可以互换的。<code>penalize()</code>所penalize的不一定是<code>score</code>，也可以是<code>serial_number</code>。这样虽然编译器不会报错，但是代码没有意义。编码的时候如果错误的使用了alias，还会导致难以track的问题。</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> sound_id;</span><br><span class="line"><span class="function">sound_id <span class="title">create_sound</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_sound</span><span class="params">(sound_id id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> sprite_id;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_sprite</span><span class="params">(sprite_id)</span></span>;</span><br><span class="line"></span><br><span class="line">sound_id fx = create_sound(...);</span><br><span class="line">destroy_sprite(fx);  <span class="comment">// An honest mistake!</span></span><br></pre></td></tr></table></figure><p>这里的问题也是类似问题1。或许你可以认为自己能够小心的编码，来保证alias的正确使用，但是这种欺骗自己的想法，并不能100%的保证问题不会发生。If they can happen, they will happen!</p><h2 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h2><p>这个问题也是类似，但不仅仅会有误用的风险，同时还导致了类型系统的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> X, Y, Z; <span class="comment">// Cartesian 3D coordinate types</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Rho, Theta, Phi; <span class="comment">// spherical 3D coordinate types</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhysicsVector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PhysicsVector(X, Y, Z);</span><br><span class="line">    PhysicsVector(Rho, Theta, Phi);</span><br><span class="line">    · · ·</span><br><span class="line">&#125;; <span class="comment">// PhysicsVector</span></span><br></pre></td></tr></table></figure><p>在上述例子中，<code>typedef</code>的大量使用实际上破坏了类型系统（问题域中的类型和构造函数中的类型）。笛卡尔坐标系的三个坐标值和球坐标系中的，虽然都是<code>double</code>，但明显意义是不一样的。尽管误用编译器不会报错，但是程序是有bug的。</p><p>另一个问题是，两个构造函数实际上就是一个，它接受三个<code>double</code>类型的参数。但这里的意图是，分别为两种坐标系建立构造函数。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="opaque-type-clang-3-5-1-g-4-8-2和VS2013都不支持"><a href="#opaque-type-clang-3-5-1-g-4-8-2和VS2013都不支持" class="headerlink" title="opaque type(clang++ 3.5.1, g++4.8.2和VS2013都不支持)"></a>opaque type(clang++ 3.5.1, g++4.8.2和VS2013都不支持)</h2><p>引入opaque（不透明的） typedef，在发生误用时，由编译器来检查。</p><p>opaque typedef定义了一种新的类型，这种新的类型与它的underlying type不同，并且与它的underlying type是可区分的，同时还保证了与它的underlying type的layout compatibility。</p><h2 id="Type-tags"><a href="#Type-tags" class="headerlink" title="Type tags"></a>Type tags</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Tag</span>, <span class="keyword">class</span> <span class="title">impl</span>, <span class="title">impl</span> <span class="title">default_value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ID <span class="title">invalid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ID(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defaults to ID::invalid()</span></span><br><span class="line">    ID() : m_val(default_value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicit constructor:</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ID</span><span class="params">(impl val)</span> : <span class="title">m_val</span><span class="params">(val)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicit conversion to get back the impl:</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">impl</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_val; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(ID a, ID b) &#123; <span class="keyword">return</span> a.m_val == b.m_val; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(ID a, ID b) &#123; <span class="keyword">return</span> a.m_val != b.m_val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    impl m_val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个方法相当与简单的包装了一下。参数Tag其实并没有在模板里面使用，它的使用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sound_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> ID&lt;sound_tag, <span class="keyword">int</span>, <span class="number">-1</span>&gt; sound_id;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sprite_tag</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> ID&lt;sprite_tag, <span class="keyword">int</span>, <span class="number">-1</span>&gt; sprite_id;</span><br></pre></td></tr></table></figure><p>tag保证了<code>sound_id</code>和<code>sprite_id</code>是不同的type，换句话说，只要函数声明了不同了type，它们就不会被误用。</p><h2 id="BOOST-STRONG-TYPEDEF"><a href="#BOOST-STRONG-TYPEDEF" class="headerlink" title="BOOST_STRONG_TYPEDEF"></a><code>BOOST_STRONG_TYPEDEF</code></h2><p>如果使用boost库，那么boost提供了<code>BOOST_STRONG_TYPEDEF</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BOOST_STRONG_TYPEDEF(<span class="keyword">int</span>, a);</span><br><span class="line">BOOST_STRONG_TYPEDEF(T, D);</span><br></pre></td></tr></table></figure><p>这个宏为类型<code>T</code>创建了新的类型名<code>D</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><p><a href="http://www.ilikebigbits.com/blog/2014/5/6/type-safe-identifiers-in-c">Type safe handles in C++</a></p></li><li><p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3741.pdf">Toward Opaque Typedefs for C++1Y, v2</a></p></li></ol>]]></content>
    
    
    <summary type="html">传统的`typedef`机制允许对已存在的type提供synonym或者alias，被定义为新引入的alias的类型与被定义为原来类型的变量，完全一样，不会有一丁点行为上的差别，但是这种特性在某些场景下会有缺陷。</summary>
    
    
    
    <category term="programming" scheme="https://chaomai.github.io/categories/programming/"/>
    
    
    <category term="cpp" scheme="https://chaomai.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>入手KBC Poker 2</title>
    <link href="https://chaomai.github.io/2014/2014-12-11-kbc-poker-2-briefly-reivew/"/>
    <id>https://chaomai.github.io/2014/2014-12-11-kbc-poker-2-briefly-reivew/</id>
    <published>2014-12-11T15:20:42.000Z</published>
    <updated>2021-06-27T14:57:29.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KBC-Poker-2"><a href="#KBC-Poker-2" class="headerlink" title="KBC Poker 2"></a>KBC Poker 2</h1><p>用倦Thindpad T420自带的键盘，也想尝试一下机械键盘的手感如何，就入手了一个机械键盘，KBC Poker 2。</p><p>入手Poker 2的原因不仅仅是Filco Minila Air和HHKB的价格有点高，还有一点吸引我的原因就是Poker 2支持全键位硬件可编程。</p><p>Poker 2已经是第二代了，相比起第一代，带来了许多的改进，网上的总结有这么几点：</p><blockquote><ul><li>保留了经典的US配列</li><li>增加了数控钢板，使得茶轴、青轴和红轴的手感大大增强，黑轴基本不变</li><li>内置7级亮度调节的DIY灯控支持，插上LED就会亮</li><li>全新加厚PBT键帽，带来目前最为细腻的PBT触感</li><li>增加了实用和进阶的附件六颗RGB加厚PBT套装和钢丝拔键器</li><li>换代的卫星轴进一步提升了手感，彻底让卫星轴翻身做主人</li><li>仍然保持一代的价格，加量完全不加价，499元</li><li>USB任意6键无冲</li><li>自带延时编程的全键位硬件可编程</li></ul></blockquote><p>键盘从淘宝上购买，只是中通快递，等得我整个人都不好了。。。</p><p>除了键盘外，还随带附送的配件：分离式可拆卸的USB数据线，一个钢丝拔键器，一套RGB的PBT材质键帽。换下原来的键帽，把六个RGB键帽装上以后，就是这样了。</p><p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_192835.jpg"></p><p>因为是60%尺寸的设计，省去了方向键和其他的一些功能键，改用Fn的组合键和Pn的编程键实现相应的功能，因此键盘更加玲珑小巧、方便携带。在文章的后面会给出自己修改键位的办法。</p><p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_192808.jpg"></p><p>键帽由于是PBT材质的，而且还是加厚的键帽，手感很不错，空格键上的”Enjoy your feeling”正是说明了这一点。</p><p>但是细节处的做工就不是那么精细了，键帽边缘有少许的毛刺。但我不是强迫症，平时使用根本看不见，So it doesn’t matter.</p><p>这次入手的Poker 2是茶轴的，网上茶轴的介绍如下：</p><blockquote><p>全面兼顾：茶轴</p><p>茶轴的手感比较均衡，也可说是较为中庸，带有段落感，触发键程为2.0mm。另外，其压力克数比较小，只有60g，敲击显得非常轻松，能兼顾打字和游戏使用。</p><p>敲击茶轴的感觉如同小范围内的极速轻金属碰撞，很神秘的那么一下，结合了青轴和黑轴的特点，或者看成它是最没有特点的一种特殊轴，这也是手感最类似于传统键盘的机械键盘，压力在黑轴和青轴中间。</p><p>它的段落感，你按下一个键后段落感可以给你确认感，同时压力不太大，适合那种瞬间飚快捷键的快手。</p></blockquote><p>由于没有使用过其他机械键盘，我只能和T420的键盘做对比。使用下来的感觉是，和T420的键盘相比，不需要多大的力量就可以触发，按下去的时候有段落感，触发段落感的力量也不大。用了Poker 2以后，感觉就是“回不去了。。。”。</p><p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_193448.jpg"></p><p>USB数据线的接口，看着像micro USB的，但其实不是，有点像以前老式的好记星的接口。</p><p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_193043.jpg"></p><p>背面有四个橡胶脚垫，不支持角度的调节，不过键盘正面的有弧度的设计，比较符合人体工程学，因此还是很舒适的。</p><p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_193117.jpg"></p><p>这里就是DIP开关。最早见到这个DIP开关是在HHKB上，Poker 2的DIP开关与HHKB的还是有所区别的。记得当初关注HHKB并不是因为机械键盘的缘故，而是Caps和Control键可以互换，加上当时在Ubuntu下开发，所以一直眼馋HHKB，只是价格的原因，一直没入手。</p><p><img data-src="/images/2014/kbcpoker2openboxIMG_20150211_193231.jpg"></p><h2 id="Poker-2总结"><a href="#Poker-2总结" class="headerlink" title="Poker 2总结"></a>Poker 2总结</h2><p>Poker 2使用了小尺寸的设计，精简了多余的按键，加上分离式可拆卸的USB，大大提升了便携性。总体来说，做工中规中矩，PBT加厚键帽，内置钢板，但不足的是小细节的地方，比如键帽的边缘。</p><h1 id="键位修改"><a href="#键位修改" class="headerlink" title="键位修改"></a>键位修改</h1><p>首先，用键盘编程在V键上，把Win键编程为：Pn+V。因为后面需要用开关把做Win改为左Fn，还有就是目前是在Windows下工作，Win键不可少，所以这里要提前设置Win的替代键位。</p><p>接下来，用键盘编程在L上，把Win+L键编程为：Pn+L；在，键上，把Win+Space编程为：Pn+，。其实这里不是必须的，我只是为了方便。</p><p>然后就是设置键盘后面的几个开关，背面的4个DIP开关的功能分别是：</p><ul><li>开关1：Caps与左Win切换</li><li>开关2：右Ctrl与`~切换</li><li>开关3：左Win与Fn切换</li><li>开关4：键盘写保护，键位编程</li></ul><p>将开关1和3都拨到ON的位置，效果：Caps变成了Fn，左Win变成了Caps。</p><p>到这里键位修改就完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;KBC-Poker-2&quot;&gt;&lt;a href=&quot;#KBC-Poker-2&quot; class=&quot;headerlink&quot; title=&quot;KBC Poker 2&quot;&gt;&lt;/a&gt;KBC Poker 2&lt;/h1&gt;&lt;p&gt;用倦Thindpad T420自带的键盘，也想尝试一下机械键盘的手感</summary>
      
    
    
    
    <category term="life" scheme="https://chaomai.github.io/categories/life/"/>
    
    
    <category term="keyboard" scheme="https://chaomai.github.io/tags/keyboard/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象程序设计</title>
    <link href="https://chaomai.github.io/2014/2014-03-31-cpp-object-oriented-programming/"/>
    <id>https://chaomai.github.io/2014/2014-03-31-cpp-object-oriented-programming/</id>
    <published>2014-03-31T08:14:25.000Z</published>
    <updated>2021-06-27T14:57:29.255Z</updated>
    
    <content type="html"><![CDATA[<p>基类中类型相关的函数与派生类不做改变直接继承的函数是不同的，当希望派生类定义合适自身的版本，此时基类就将这些函数声明为虚函数。</p><h1 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h1><p>基类<strong>通常都应该</strong>定义一个虚析构函数，即使该函数不执行任何实际操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Quote() = <span class="keyword">default</span>;</span><br><span class="line">  Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price)</span><br><span class="line">      : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h2><p>基类有两种成员函数，</p><ol><li>希望派生类进行覆盖的<ul><li>当使用指针或引用调用虚函数时，该调用将被动态绑定</li><li>任何<strong>除构造函数之外的非静态函数</strong>都可以是虚函数</li><li>如果某个函数在基类中被声明为虚函数，那么在派生类中<strong>隐式地</strong>也是虚函数</li></ul></li><li>希望派生类直接继承而不需要改变的<ul><li>如果不是虚函数，则其解析过程发生在编译时而非运行时</li></ul></li></ol><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>派生类能访问公有成员和受保护的成员，但<strong>不能访问私有成员</strong>（继承了，但无权限访问）。</p><h1 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h1><p>类派生列表中的访问说明是控制派生类从基类继承而来的成员<strong>是否对派生类的用户可见</strong>。如果一个派生类是公有的，则基类的公有成员也是派生类接口的组成部分。可以将<strong>公有派生类型</strong>的对象绑定到基类的引用或指针上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkQuote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BulkQuote() = <span class="keyword">default</span>;</span><br><span class="line">  BulkQuote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h2><p>派生类经常，<strong>但不总是</strong>，覆盖继承的虚函数。如果没有覆盖，则虚函数行为类似其他的普通成员，直接使用基类中的版本。</p><p>派生类必须对<strong>需要覆盖的</strong>重新声明，派生类可以在这样的函数前加上<code>virtual</code>，但<strong>并非必须</strong>。C++11允许显式地在声明的<strong>最后</strong>用<code>override</code>注明覆盖。</p><h2 id="派生类向基类的类型转换"><a href="#派生类向基类的类型转换" class="headerlink" title="派生类向基类的类型转换"></a>派生类向基类的类型转换</h2><p>一个派生类对象中，继承自基类的部分和派生类的部分<strong>不一定是连续存储的</strong>。</p><p>由于派生类对象中<strong>含有与其基类对应</strong>的组成部分，因此能将派生类对象当成基类对象来使用，能将基类指针或引用<strong>绑定到派生类对象中基类的部分上</strong>。这叫做<strong>派生类到基类的类型转换</strong>。</p><p>由于一个基类对象可能是派生类对象的一部分，也可能不是，因此<strong>不存在</strong>从基类到派生类的自动类型转换，<strong>即使</strong>一个基类的指针或引用已经绑定在一个派生类对象上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;</span><br><span class="line">BulkQuote bulk;</span><br><span class="line">Quote *p = &amp;item;</span><br><span class="line">p = &amp;bulk;</span><br><span class="line">Quote &amp;r = bulk;</span><br></pre></td></tr></table></figure><h2 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h2><p>每个类控制它自己的成员初始化过程。派生类并<strong>不能直接初始化</strong>继承自基类的成员。初始化时，<strong>先初始化基类的部分</strong>，然后<strong>按照声明的顺序</strong>（与初始化列表顺序无关）依次初始化派生类的成员。</p><p>如果不明确指明初始化，派生类的<strong>基类部分</strong>会像数据成员一样<strong>执行默认初始化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BulkQuote::BulkQuote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty,</span><br><span class="line">                     <span class="keyword">double</span> disc)</span><br><span class="line">    : Quote(book, p), min_qty(qty), discount(disc) &#123;&#125;</span><br></pre></td></tr></table></figure><p>每个类负责定义各自的接口，要想与类对象交互，必须使用该类的接口，<strong>即使</strong>这个对象是派生类的基类部分也是如此。因此应当调用基类的构造函数初始化从基类继承而来的成员。</p><p>派生类的作用域<strong>嵌套</strong>在基类的作用域之内。</p><h2 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h2><p>如果基类定义了静态成员，则在<strong>整个继承体系中</strong>只存在该成员的<strong>唯一定义</strong>，每个静态成员只存在<strong>唯一的实例</strong>。</p><h2 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h2><p>派生类的声明<strong>不能包含</strong>派生列表。</p><h2 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h2><p>某个类要用作基类，必须<strong>已经定义</strong>，而非仅仅声明。因为派生类中，要使用继承自基类的成员，派生类必须知道他们是什么。</p><p>防止继承可以使用<code>final</code>。</p><h2 id="静态类型和动态类型"><a href="#静态类型和动态类型" class="headerlink" title="静态类型和动态类型"></a>静态类型和动态类型</h2><p>变量或表达式的静态类型：编译时总是已知的，变量声明时类型或表达式生成的类型。动态类型：变量或表达式表示的内存中对象的类型，运行时才可知。</p><p>基类指针或引用的静态类型<strong>可能与其</strong>动态类型<strong>不一致</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> ret = item.net_price(n);</span><br><span class="line">  os &lt;&lt; <span class="string">&quot;ISBN: &quot;</span> &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot;# sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; total due: &quot;</span> &lt;&lt; ret</span><br><span class="line">     &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面item的静态类型是<code>Quote&amp;</code>，动态类型直到运行时调用函数时才会知道。如果传入的是BulkQuote，则动态类型是BulkQuote。</p><p>由于一个基类对象可能是派生类对象的一部分，也可能不是，因此<strong>不存在</strong>从基类到派生类的自动类型转换，<strong>即使</strong>一个基类的指针或引用已经绑定在一个派生类对象上。如果需要转换，</p><ul><li>如果基类中有<strong>一个或多个虚函数</strong>，则可以使用dynamic_cast<strong>请求</strong>一个转换，该转换的安全检查将在运行时执行</li><li>如果已知转换时安全的，则可以使用static_cast强制覆盖编译器的检查</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BulkQuote <span class="title">bulk</span><span class="params">(<span class="string">&quot;awqef&quot;</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">0.5</span>)</span></span>;</span><br><span class="line">Quote *pq = &amp;bulk;</span><br><span class="line">BulkQuote *pb = pq; <span class="comment">// 错误</span></span><br><span class="line">BulkQuote *pb1 = <span class="keyword">dynamic_cast</span>&lt;BulkQuote *&gt;(pq);</span><br><span class="line">BulkQuote *pb2 = <span class="keyword">static_cast</span>&lt;BulkQuote *&gt;(pq);</span><br></pre></td></tr></table></figure><h2 id="派生类类型到基类类型的转换"><a href="#派生类类型到基类类型的转换" class="headerlink" title="派生类类型到基类类型的转换"></a>派生类类型到基类类型的转换</h2><p>派生类类型到基类类型的转换是<strong>不存在的</strong>。但可以向基类的拷贝/移动操作传递一个派生类对象，<strong>实际运行</strong>构造/赋值的运算符<strong>将是基类中定义的</strong>，此时只能处理基类自己的成员，忽略派生类定义的成员，派生类的部分被<strong>slice down</strong>。</p><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>由于<strong>运行时才知道</strong>调用了哪个版本的虚函数，因此<strong>所有虚函数必须有定义</strong>。被调用的函数是<strong>与绑定到指针或引用上的对象的动态类型相匹配的那个</strong>。</p><p>动态绑定<strong>只有</strong>当通过指针或引用调用虚函数时才会发生，只有在这种情况下对象的静态类型才可能会与动态类型不同。</p><h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><p>C++中的引用或指针的静态类型与动态类型不同，是C++支持多态性的<strong>根本</strong>所在。</p><p>当通过基类的指针或引用调用基类中的一个函数时，如果是虚函数，则运行时才会<strong>依据所绑定对象的真实类型</strong>（动态类型）来决定到底执行哪个版本。如果不是虚函数，则解析过程发生在编译时而非运行时。类似的，<strong>通过对象</strong>进行的函数调用（虚函数或非虚函数）也在编译时绑定。</p><h2 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h2><p>一旦某个函数被声明为虚函数，则在<strong>所有派生类中都是</strong>虚函数。</p><p>一个派生类的函数如果覆盖类某个继承而来的虚函数，这它的<strong>形参类型</strong>必须与被它覆盖的基类函数<strong>完全一致</strong>。同时，<strong>返回值</strong>也必须<strong>相同</strong>。但有下述例外，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> B* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function">D* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果虚函数的<strong>返回类型是类本身的指针或引用时</strong>，返回值可以不同，但要求<strong>从D到B的类型转换是可访问的</strong>。</p><h2 id="final和override"><a href="#final和override" class="headerlink" title="final和override"></a>final和override</h2><ul><li>如果派生类中的函数与虚函数<strong>名字相同</strong>、<strong>形参列表不同</strong>（返回值都ok），那么这是合法的，但这个函数与原有虚函数<strong>相互独立，并未覆盖</strong>。</li><li>如果派生类中的函数与虚函数<strong>名字相同</strong>、<strong>形参列表相同</strong>、<strong>返回值不同</strong>，那么这是错误。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  D();</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125; <span class="comment">// 错误</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">double</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125; <span class="comment">// ok，但与原有虚函数相互独立</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了避免出现上述的<code>double net_price(double n) const</code>，可以使用override来说明派生类中的虚函数。</p><p>只有基类出现过的虚函数，且派生类中的函数声明与虚函数一致时，才能override，否则就会报错。<br>如果某个函数被指定为final，则之后的<strong>任何尝试覆盖该函数的操作</strong>都将引发错误。</p><p>final和override出现在形参列表（包括const和引用修饰符 ）和位置返回类型**之后。</p><h2 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h2><p>如果某次函数调用使用了默认实参，则<strong>该实参值</strong>有本次调用的<strong>静态类型</strong>（基类中定义默认实参）决定。</p><h2 id="回避虚函数机制"><a href="#回避虚函数机制" class="headerlink" title="回避虚函数机制"></a>回避虚函数机制</h2><p>有时需要强制执行虚函数某个<strong>特定的版本</strong>，而<strong>不进行动态绑定</strong>。这时可以使用作用域运算符，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>调用将在编译时完成解析。</p><p>通常只有<strong>成员函数（或友元）中</strong>的代码才需要使用作用域运算符来回避虚函数机制。<br>下面的调用中，派生类的虚函数调用了基类的版本，如果不回避虚函数机制，那么将会导致无限递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">D::net_price</span><span class="params">(<span class="keyword">double</span> n)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Quote::net_price(n);</span><br><span class="line">  <span class="keyword">return</span> n * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>一个纯虚函数无须定义，其中<code>=0</code><strong>只能</strong>出现在<strong>类内部的虚函数声明的语句</strong>处。但<strong>也可以</strong>为纯虚函数<strong>提供定义</strong>，不过函数体<strong>必须定义在类外部</strong>。</p><p>含有（或者未经覆盖直接继承）的纯虚函数的类似<strong>抽象基类</strong>。</p><ul><li>抽象基类负责<strong>定义接口</strong>，而后续的其他类可以覆盖这个接口</li><li><strong>不能直接创建</strong>一个抽象基类的对象</li><li>如果<strong>派生类覆盖了纯虚函数</strong>，那么可以创建派生类的对象，否则不能。</li></ul><h2 id="派生类构造函数-1"><a href="#派生类构造函数-1" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h2><p>派生类构造函数只能<strong>初始化它的直接基类</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkQuote1</span> :</span> <span class="keyword">public</span> DiscQuote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BulkQuote1() = <span class="keyword">default</span>;</span><br><span class="line">  BulkQuote1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty,</span><br><span class="line">             <span class="keyword">double</span> disc)</span><br><span class="line">      : DiscQuote(book, price, qty, disc) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BulkQuote1包含三个子对象：空的BulkQuote1，DiscQuote和Quote。</p><h1 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h1><p>派生类的成员或友元<strong>只能通过派生类对象</strong>来访问基类受保护成员（只能访问派生类对象中的<strong>基类部分的</strong>受保护成员），派生类对于一个<strong>普通的基类对象</strong>中的受保护成员<strong>没有任何访问特权</strong>。</p><h2 id="public、private和protected继承"><a href="#public、private和protected继承" class="headerlink" title="public、private和protected继承"></a>public、private和protected继承</h2><p>派生访问说明符对于派生类的成员（及友元）<strong>能否访问</strong>其直接基类的成员<strong>没有什么影响</strong>，这是由<strong>基类中的访问说明符</strong>决定的。</p><p>派生访问说明符控制了派生类用户<strong>对于基类成员的访问权限</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivD</span> :</span> <span class="keyword">private</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrivD d;</span><br><span class="line">d.pub_mem(); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><ul><li>public继承，成员将<strong>遵循原有的</strong>访问说明符</li><li>private继承，B的成员是<strong>私有的</strong></li><li>protected继承，B的成员是<strong>受保护的</strong></li></ul><p>继承自派生类（上面的PrivD）的新类，基类（B）成员的访问权限由派生类（PrivD）的访问说明符决定。即如果是private的，那么新类人不能访问基类（B）的成员。</p><h2 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h2><ul><li>对于用户代码，只有当D<strong>public继承</strong>B，时，用户代码才能使用D向B的转换</li><li>对于直接继承，<strong>无论是什么继承</strong>，<strong>D的成员函数和友元都能</strong>使用D向B的转换</li><li>对于间接继承，只有当D<strong>public或protected继承</strong>B时，<strong>D的派生类的成员函数和友元</strong>才能使用D向B的转换</li></ul><h2 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h2><p>友元不能传递和继承。</p><h2 id="改变成员的可访问性"><a href="#改变成员的可访问性" class="headerlink" title="改变成员的可访问性"></a>改变成员的可访问性</h2><p>可以用using将类的直接或间接基类中任何<strong>可访问成员</strong>（非私有）<strong>标记出来</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> prvi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivD</span> :</span> <span class="keyword">private</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">using</span> <span class="title">B::pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">using</span> B::prvi; <span class="comment">// 错误</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrivD d;</span><br><span class="line">d.pub_mem(); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><h2 id="默认继承保护级别"><a href="#默认继承保护级别" class="headerlink" title="默认继承保护级别"></a>默认继承保护级别</h2><ul><li>派生类是struct，默认public继承</li><li>派生类是class，默认是private继承</li></ul><h1 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h1><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><p>每个类都会定义自己的作用域。<br>Outside the class scope, ordinary data and function members may <strong>be accessed only through an object, a reference, or a pointer using a member access operator</strong> (§ 4.6, p.150). We access <strong>type members from the class using the scope operator</strong>. In either case, the name that follows the operator must be a member of the associated class.</p><h3 id="定义在类外部的成员"><a href="#定义在类外部的成员" class="headerlink" title="定义在类外部的成员"></a>定义在类外部的成员</h3><p>一旦遇到类名，定义的剩余部分就在类的作用域之内（参数列表和函数体）。返回类型中使用的名字都位于类的作用域之外。</p><h3 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h3><p>类的定义分作，</p><ol><li>编译类的声明</li><li>直到类全部可见后才编译函数体</li></ol><p>这种两阶段处理的方式<strong>只适用于成员函数中使用的名字</strong>，<strong>声明中</strong>使用的名字（包括返回值或参数列表中使用的名字），都必须确保在<strong>使用前可见</strong>。</p><p>要注意的是，如果成员使用了外层作用域中的某个名字，且该名字代表一种类型，这内层作用域<strong>不能</strong>重定义这个名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> M;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">M <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">double</span> M; <span class="comment">// 错误</span></span><br><span class="line">  M bal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员函数中使用的名字查找顺序，</p><ol><li>成员函数内查找</li><li>类内查找</li><li>成员函数定义前的作用域内查找（包括<strong>类定义之前的</strong>全局作用域和<strong>成员函数定义前的</strong>全局作用域）</li></ol><h2 id="派生类的作用域"><a href="#派生类的作用域" class="headerlink" title="派生类的作用域"></a>派生类的作用域</h2><p>派生类的作用域<strong>嵌套</strong>在基类的作用域之内，如果一个名字在派生类的作用域内无法正确解析，则编译器将<strong>继续在外层的基类作用域</strong>中寻找改名字的定义。</p><h2 id="编译时进行名字查找"><a href="#编译时进行名字查找" class="headerlink" title="编译时进行名字查找"></a>编译时进行名字查找</h2><p>一个对象、引用或指针的<strong>静态类型</strong>决定了该对象的哪些成员是可见的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiscQuote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  std::pair&lt;std::size_t, double&gt; discount_policy() const &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;quantity, discount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BulkQuote bulk;</span><br><span class="line">BulkQuote *pbulk = &amp;bulk;</span><br><span class="line">Quote *pitem = &amp;bulk;</span><br><span class="line">pbulk-&gt;discount_policy(); <span class="comment">// ok</span></span><br><span class="line">pitem-&gt;discount_policy(); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>这与动态绑定不同。</p><h2 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h2><p>如果派生类重用定义在其直接基类或间接基类中的名字，则定义在内层作用域（派生类）的名字将<strong>隐藏</strong>定义在外层作用域（基类）中的名字。</p><p>但可以使用作用域运算符覆盖原有的查找规则。一般来说，除了覆盖继承而来的虚函数外，派生类<strong>最好不要</strong>重用其他定义在基类中的名字。</p><h2 id="名字查找先于类型检查"><a href="#名字查找先于类型检查" class="headerlink" title="名字查找先于类型检查"></a>名字查找先于类型检查</h2><p>查找顺序，</p><ol><li>先确定静态类型</li><li>在静态类型中查找member，找不到则顺着继承链向上找，最后没找到则报错</li><li>找到后检查函数调用是否合法</li><li>如果合法，<ul><li>是虚函数且通过引用或指针调用，编译器进行动态绑定</li><li>不是，编译器产生一个常规函数调用</li></ul></li></ol><p>声明在内层作用域的函数<strong>并不会重载</strong>声明在外层作用域的函数，派生类中的函数<strong>也不会重载</strong>基类中的成员，而是<strong>隐藏</strong>基类的成员，<strong>即使</strong>它们的<strong>形参列表不一致</strong>。</p><h2 id="虚函数的作用域"><a href="#虚函数的作用域" class="headerlink" title="虚函数的作用域"></a>虚函数的作用域</h2><p>假设形参列表不同，会发生隐藏，进而无法通过基类的引用或指针调用派生类的虚函数。</p><p>对应于之前提到的两个情况，</p><ul><li>如果派生类中的函数与虚函数<strong>名字相同</strong>、<strong>形参列表不同</strong>（返回值都ok），那么这是合法的，此时隐藏了原有虚函数。</li><li>如果派生类中的函数与虚函数<strong>名字相同</strong>、<strong>形参列表相同</strong>、<strong>返回值不同</strong>，那么这是错误，因为内层作用域中已经存在一个同名且同形参列表的函数了，不允许两个函数除返回值，其他要素都相同。</li></ul><h2 id="覆盖重载的函数"><a href="#覆盖重载的函数" class="headerlink" title="覆盖重载的函数"></a>覆盖重载的函数</h2><p>成员函数无论是否是虚函数都可被重载，派生类可以覆盖基类中重载函数的<strong>0个或多个实例</strong>。如果派生类希望<strong>所有的重载版本</strong>对于它来说<strong>都是可见的</strong>，那么派生类就必须<strong>覆盖所有的版本，或者一个也不覆盖</strong>。（如果只覆盖部分，此时会<strong>隐藏</strong>基类的重载函数）</p><p>简便的方法是<code>using + 名字</code>（不需要形参列表）。需要保证基类函数的每个实例在派生类中都是<strong>可访问的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> B::fcn; <span class="comment">// 如果没有，则下面的d.fcn()是错误的</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;derive &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line">d.fcn();</span><br><span class="line">d.fcn(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h1><p>如果一个类（基类或派生类）没有定义拷贝控制操作，则编译器会为它合成一个版本。</p><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>由于基类的引用或指针指向继承体系中的某个类型，有可能出现指针的静态类型与被删除对象的动态类型不符的情况。因此需要将析构函数定义为虚函数，以确保<strong>执行正确的析构函数</strong>版本。</p><p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生<strong>未定义的行为</strong>（只释放了基类部分的内存）。</p><p>基类的析构函数<strong>并不需要遵循三/五法则</strong>。虚析构函数（即使通过default的形式）将<strong>阻止合成移动操作</strong>。</p><h2 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h2><p>合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似，它们对类本身的成员依次进行初始化、赋值或销毁。这些合成的成员还负责<strong>使用基类中对应的操作</strong>对一个对象的<strong>直接基类部分</strong>进行初始化、赋值或销毁。</p><p>无论是基类的合成版本还是自定义版本，都有上述的行为，唯一的要求是<strong>新颖的成员是可访问的</strong>，且<strong>不是一个被删除</strong>的函数。</p><h3 id="删除拷贝控制"><a href="#删除拷贝控制" class="headerlink" title="删除拷贝控制"></a>删除拷贝控制</h3><ul><li>如果<strong>基类</strong>的构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是<strong>被删除的</strong>，则派生类中的相应成员也是<strong>被删除的</strong></li><li>如果<strong>基类的析构函数</strong>是不可访问或删除的，则派生类的默认和拷贝构造函数是被删除的</li><li>如果<strong>派生类中</strong>显式请求编译器生成一个无法合成的移动操作，且基类中的对应操作是删除或不可访问的，派生类中的移动操作将是被删除的</li><li>如果基类的析构函数是删除或不可访问的，则派生类中的移动构造函数将是被删除的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  B() = <span class="keyword">default</span>;</span><br><span class="line">  B(<span class="keyword">const</span> B &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~B() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">b = b; <span class="comment">// ok</span></span><br><span class="line">b = <span class="built_in">std</span>::move(b); <span class="comment">// ok</span></span><br><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(b)</span></span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="function">B <span class="title">b2</span><span class="params">(<span class="built_in">std</span>::move(b))</span></span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>由于虚析构函数的存在，编译器不会合成移动操作，因此<strong>所有左值和右值的情况</strong>（即<code>b = b</code>，<code>b = std::move(b)</code>，<code>B b1(b)</code>和<code>B b2(std::move(b))</code>）都将用拷贝操作处理。又因为拷贝构造函数是删除的，因此两个对拷贝构造函数的调用是错误的。</p><p>如果基类没有默认、拷贝或移动构造函数，则一般派生类也不会定义（可以，但必须考虑如何处理基类部分的成员）。</p><h3 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h3><p>由于基类虚析构函数的存在，编译器不会合成移动操作。如果需要移动操作，则应该<strong>首先在基类中定义</strong>，与此同时必须<strong>显式地定义拷贝操作</strong>（否则会默认被定义为删除）。</p><h2 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h2><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动<strong>基类部分的成员</strong>。而析构函数只负责<strong>销毁派生类自己分配的资源</strong>，派生类对象的基类部分是自动销毁的。</p><h3 id="派生类的拷贝和构造函数"><a href="#派生类的拷贝和构造函数" class="headerlink" title="派生类的拷贝和构造函数"></a>派生类的拷贝和构造函数</h3><p>定义派生类的拷贝或移动构造函数时，通常<strong>使用对应基类的构造函数</strong>处理对象的基类部分。</p><p>如果未处理使用基类的拷贝或移动构造函数，则基类部分被默认初始化。</p><h3 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h3><ul><li>与拷贝和移动构造函数一样，必须<strong>显式</strong>地<strong>为基类部分赋值</strong></li><li>基类的运算符要能<strong>正确处理自赋值</strong>的情况</li><li>基类运算符将<strong>释放</strong>左侧运算对象的<strong>基类部分的旧值</strong></li></ul><h3 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h3><p>在析构函数执行完成以后，对象的成员会被隐式销毁，对象的<strong>基类部分</strong>也是<strong>隐式销毁</strong>的（基类的析构函数被自动调用执行），派生类<strong>只负责</strong>销毁由<strong>派生类自己分配的资源</strong>。</p><p>对象的销毁顺序<strong>与创建顺序相反</strong>，派生类的析构函数先执行。</p><h3 id="在构造函数和析构函数中调用虚函数"><a href="#在构造函数和析构函数中调用虚函数" class="headerlink" title="在构造函数和析构函数中调用虚函数"></a>在构造函数和析构函数中调用虚函数</h3><p>在构造或析构派生类对象的过程中，（从基类部分开始构造，派生类部分开始销毁）对象的类型就像是<em>发生了改变一样</em>。当前的构造函数或析构函数不能够调用未构造或已销毁的派生类版本的虚函数（可能会访问派生类部分的成员）。</p><p>如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数<strong>所属类型相对应</strong>的虚函数版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Erdos</span> &#123;</span></span><br><span class="line">  Erdos() &#123; whoAmIReally(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">whoAmIReally</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I really am Erdos\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fermat</span> :</span> <span class="keyword">public</span> Erdos &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">whoAmIReally</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I really am Fermat\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Erdos s; <span class="comment">// I really am Erdos</span></span><br><span class="line">Fermat f; <span class="comment">// I really am Erdos</span></span><br></pre></td></tr></table></figure><p>上述代码中，<strong>并非是</strong>构造函数发生了继承。</p><h2 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h2><p>这里的构造函数<strong>并非以常规的方式继承</strong>而来，且类<strong>不能继承默认、拷贝和移动构造函数</strong>。如果派生类含有自己的数据成员，则它们被<strong>默认初始化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkQuote2</span> :</span> <span class="keyword">public</span> DiscQuote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> DiscQuote::DiscQuote;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的的using<strong>并不是</strong>令DiscQuote的构造函数在这里可见，而是令编译器生成一个与DiscQuote的构造函数对应的派生类构造函数，即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BulkQuote2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty,</span><br><span class="line">           <span class="keyword">double</span> disc)</span><br><span class="line">    : DiscQuote(book, price, qty, disc) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>构造函数的using声明<strong>并不会改变该构造函数的访问级别</strong></li><li>一个using声明<strong>不能指定explicit或constexpr</strong>，基类的是什么，继承后的也是什么</li><li>当一个基类构造函数含有默认实参，这些<strong>实参并不会被继承</strong>，而是派生类会获得<strong>多个继承的构造函数</strong>，其中每个构造函数<strong>分别省略掉</strong>一个含有默认实参的形参。</li></ul><h3 id="何时不继承"><a href="#何时不继承" class="headerlink" title="何时不继承"></a>何时不继承</h3><ul><li>如果派生类定义的构造函数与基类的构造函数具有<strong>相同的参数列表</strong>，则该构造函数不会被继承</li><li>类<strong>不能继承默认、拷贝和移动构造函数</strong>，而是按照正常规则被合成。继承的构造函数<strong>不会被视为用户定义的构造函数</strong>（如果是，则不会合成默认构造函数），因此<strong>只包含</strong>继承的构造函数（无拷贝和移动构造函数）的类也会有合成的默认构造函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  C(<span class="keyword">const</span> C &amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C c; <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkQuote2</span> :</span> <span class="keyword">public</span> DiscQuote &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> DiscQuote::DiscQuote;</span><br><span class="line">  <span class="comment">// BulkQuote2(const BulkQuote2&amp; b) : DiscQuote(b) &#123;</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; &quot;copy BulkQuote2&quot; &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BulkQuote2 b; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>由于上面的BulkQuote2只有继承的构造函数，因此编译器会合成一个默认构造函数，故<code>BulkQuote2 b</code>正确。</p><h1 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; vq;</span><br><span class="line">vq.push_back(make_shared&lt;Quote&gt;(<span class="string">&quot;joininnaw&quot;</span>, <span class="number">15</span>));</span><br><span class="line">vq.push_back(make_shared&lt;BulkQuote&gt;(<span class="string">&quot;awfawnn&quot;</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">0.4</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;q : vq) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; q-&gt;net_price(<span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用vector存储Quote对象是不行的，因为会使用Quote的拷贝构造函数，派生类对象的派生类部分会被<strong>截断</strong>。</p><p>派生类的智能指针可以转换为基类的智能指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基类中类型相关的函数与派生类不做改变直接继承的函数是不同的，当希望派生类定义合适自身的版本，此时基类就将这些函数声明为虚函数。&lt;/p&gt;
&lt;h1 id=&quot;基类&quot;&gt;&lt;a href=&quot;#基类&quot; class=&quot;headerlink&quot; title=&quot;基类&quot;&gt;&lt;/a&gt;基类&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
  <entry>
    <title>C++重载运算与类型转换</title>
    <link href="https://chaomai.github.io/2014/2014-03-20-cpp-overload-operator-and-type-conversion/"/>
    <id>https://chaomai.github.io/2014/2014-03-20-cpp-overload-operator-and-type-conversion/</id>
    <published>2014-03-20T12:01:13.000Z</published>
    <updated>2021-06-27T14:57:29.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>重载的运算符是具有<strong>特殊名字的函数</strong>，除函数调用运算符外，其他重载运算符<strong>不能含有默认实参</strong>。</p><ul><li>一个运算符函数，或者<strong>类的成员</strong>，或者<strong>至少含有一个类类型的参数</strong>。也就是说不能为内置类型重载运算符。</li><li>只能重载<strong>已有的</strong>运算符。</li><li>一个重载的运算符，其优先级和结合律与对应的内置运算符<strong>保持一致</strong>。</li><li>由于使用重载的运算符本质上是<strong>函数调用</strong>，因此对象求值顺序的规则<strong>无法应用</strong>到重载的运算符上。尤其是<code>&amp;&amp;</code>，<code>||</code>和<code>,</code>，两个运算对象<strong>总是会</strong>被求值。</li><li>通常情况下，不应该重载<code>&amp;&amp;</code>，<code>||</code>，<code>&amp;</code>和<code>,</code>，运算符。</li><li>一般来说，提供了某个重载运算符，也应该提供<strong>与此运算符相关的</strong>一系列运算符，如：算术运算符-&gt;对应的复合赋值运算符。</li></ul><h2 id="成员或者非成员"><a href="#成员或者非成员" class="headerlink" title="成员或者非成员"></a>成员或者非成员</h2><ul><li><p><code>=</code>，<code>[]</code>，<code>()</code>和<code>-&gt;</code>运算符**必须是成员。</p></li><li><p>复合赋值运算符<strong>一般来说应该是</strong>成员，但非必须。</p></li><li><p>改变对象状态或与给定类型密切相关的运算符，应该是成员。如：递增、解引用。</p></li><li><p>具有对称性的运算符可能转换任意一端的运算对象，通常应该是非成员。如：算术、相等性、关系和位运算符。如果想提供<strong>含有类对象的混合类型表达式</strong>，运算符必须是非成员函数。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> u = <span class="string">&quot;hi&quot;</span> + s; <span class="comment">// 如果是成员函数，则&quot;hi&quot;.operator+(s)，错误</span></span><br></pre></td></tr></table></figure></li></ul><p>对于友元要注意，在类内部虽然有友元声明，但这<strong>并非真正意义上的函数声明</strong>，因此在类外部还需要有函数声明。</p><h1 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h1><h2 id="lt-lt"><a href="#lt-lt" class="headerlink" title="&lt;&lt;"></a>&lt;&lt;</h2><ul><li><code>ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;item);</code></li><li>必须是<strong>非成员函数</strong>，否则左侧运算对象将是类的一个对象<br>  就算要是某个类的成员，也只能是istream或ostream的，然而并不能为标准库中的类添加成员，因此只能是非成员函数</li><li>不应该打印换行符</li></ul><h2 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h2><ul><li><p><code>istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;item);</code></p></li><li><p>必须处理输入可能失败的情况</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item) &#123;</span><br><span class="line">  <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">  is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">  <span class="keyword">if</span> (is) &#123;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    item = Sales_data();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有时需要标识<strong>流的条件状态</strong></p></li></ul><h1 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h1><ul><li><p>通常把算术和关系运算符定义为非成员函数，使得左侧或右侧的运算对象可以转换</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> u = <span class="string">&quot;hi&quot;</span> + s; <span class="comment">// 如果是成员函数，则&quot;hi&quot;.operator+(s)，错误</span></span><br></pre></td></tr></table></figure></li><li><p>这些运算符一般不需要改变运算对象的状态，所以形参是常量引用</p></li><li><p>一般使用<strong>复合赋值来实现</strong>算术运算符</p></li></ul><h2 id=""><a href="#" class="headerlink" title="=="></a>==</h2><ul><li>相等运算符应该具有<strong>传递性</strong></li><li>定义了<code>==</code>，也应该定义<code>!=</code></li></ul><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符应该，</p><ol><li>定义顺序关系，且与关联容器中对关键字的要求一致</li><li>Define a relation that is consistent with <code>==</code> if the class has both operators. In particular, if two objects are <code>!=</code>, then one object should be <code>&lt;</code> the other.</li></ol><p>如果存在唯一一种逻辑可靠的&lt;语义，才考虑定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</p><h2 id="-1"><a href="#-1" class="headerlink" title="="></a>=</h2><ul><li>必须为成员函数</li><li><strong>必须先释放</strong>当前内存空间</li><li>如果不是拷贝赋值运算符和移动赋值运算符，则<strong>不必检查自赋值</strong>的情况。</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h2><ul><li>必须为成员函数</li><li>返回元素的引用</li><li>通常定义const和非const版本</li></ul><h1 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h1><p>由于改变了对象的状态，一般应为<strong>成员函数</strong>，且应该<strong>同时定义</strong>前置版本和后置版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回递增或递减后对象的引用</span></span><br><span class="line">StrBlobPtr &amp;<span class="keyword">operator</span>++();</span><br><span class="line">StrBlobPtr &amp;<span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的原值</span></span><br><span class="line">StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">// 形参不会被使用，仅仅是和前置版本进行区分</span></span><br><span class="line">StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="keyword">operator</span>--(<span class="number">0</span>); <span class="comment">// 调用后置版本的</span></span><br><span class="line">p.<span class="keyword">operator</span>--(); <span class="comment">// 调用前置版本的</span></span><br></pre></td></tr></table></figure><h1 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> &amp;StrBlobPtr::<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> p = check(curr, <span class="string">&quot;deference past end&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *StrBlobPtr::<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*(); &#125;</span><br></pre></td></tr></table></figure><ul><li><code>-&gt;</code><strong>必须是类成员</strong>，<code>*</code>非必需，但<strong>通常也是</strong>。</li><li>定义为const是因为获取一个元素并不会改变对象的状态。</li><li>虽然可以让解引用返回任何想要的值或打印（不建议），但箭头运算符<strong>必须有成员访问的含义</strong>。重载箭头运算符时，可以改变的是箭头从哪个对象中获取成员。</li></ul><h1 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h1><p>函数调用运算符<strong>必须是</strong>成员函数。如果类定义了调用运算符，那么该类的对象叫做函数对象。调用函数对象实际上是在运行重载的调用运算符。</p><h2 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h2><p>编写lambda后，编译器将生成一个<strong>未命名类的未命名对象</strong>。这个类中有一个重载的函数调用运算符，且默认情况下这个成员是const（lambda不能改变捕获的变量），除非lambda被声明为mutable。</p><ul><li><p>引用捕获<br>  由程序确保lambda执行时所引用的对象确实存在，生成的类中无须保存为数据成员。</p></li><li><p>值捕获<br>  生成的类中需建立对象的数据成员，同时创建构造函数，用捕获的变量来初始化数据成员。</p></li></ul><p>lambda产生的类中，<strong>不包含默认构造函数、赋值运算符和默认析构函数</strong>，默认拷贝和默认移动构造函数视捕获的数据成员类型而定。</p><h1 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h1><p>标准库规定的函数<strong>对于指针同样适用</strong>。直接比较两个无关的指针将产生未定义的行为，但通过标准库定义的函数对象来比较是<strong>定义良好的</strong>。</p><p>关联容器使用<code>less&lt;key_type&gt;</code>对元素排序，因此可以直接定义一个指针的set或map，而无须声明<code>less</code>。</p><h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><p>C++中的可调用对象多种有，它们的类型是不同的，</p><ul><li>函数和函数指针<br>  类型由返回值类型和实参类型决定</li><li>lambda表达式<br>  每个lambda有唯一的未命名类类型</li><li>bind创建的对象</li><li>重载了函数调用运算符的类</li></ul><p>类型不同的可调用对象<strong>可能共享</strong>同一种调用形式。调用形式指明了<strong>调用返回的类型</strong>以及<strong>传递给调用的实参类型</strong>。一种调用形式对应一个函数类型。</p><p>定义<code>funcion</code>类型时，需要指明调用形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = &#123;&#123;<span class="string">&quot;+&quot;</span>, plus&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">                                               &#123;<span class="string">&quot;-&quot;</span>, minus&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">                                               &#123;<span class="string">&quot;*&quot;</span>, multiplies&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">                                               &#123;<span class="string">&quot;/&quot;</span>, divides&lt;<span class="keyword">int</span>&gt;()&#125;,</span><br><span class="line">                                               &#123;<span class="string">&quot;%&quot;</span>, modulus&lt;<span class="keyword">int</span>&gt;()&#125;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="重载、类型转换"><a href="#重载、类型转换" class="headerlink" title="重载、类型转换"></a>重载、类型转换</h1><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类型的<strong>隐式转换</strong>机制，这种构造函数叫做转换构造函数。</p><p><strong>转换构造函数</strong>和<strong>类型转换运算符</strong>共同定义类类型转换，也叫用户定义的类型转换。</p><p>编译器<strong>一次只能执行一个</strong>用户定义的类型转换。</p><h2 id="隐式类型转换运算符"><a href="#隐式类型转换运算符" class="headerlink" title="隐式类型转换运算符"></a>隐式类型转换运算符</h2><ul><li><code>operator int() const;</code><br>  从类类型转换为int</li><li>无显示的返回类型和形参</li><li>返回一个对应类型的值</li><li>必须定义为成员函数</li><li>通常不应该改变转换对象的内容，一般被定义为const</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  S(<span class="keyword">const</span> S &amp;s) : val(s.val) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  S(S &amp;&amp;s) : val(s.val) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;move&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  S &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> S &amp;s) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy assign&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    val = s.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  S &amp;<span class="keyword">operator</span>=(S &amp;&amp;s) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;move assign&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    val = s.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;conversion-&gt;int&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S s; <span class="comment">// construct</span></span><br><span class="line">s = <span class="number">4</span>; <span class="comment">// construct， move assign</span></span><br><span class="line">s + <span class="number">3</span>; <span class="comment">// conversion-&gt;int</span></span><br><span class="line">s - s; <span class="comment">// conversion-&gt;int, conversion-&gt;int</span></span><br></pre></td></tr></table></figure><p>S虽然没有定义<code>-</code>，但隐式转换为int，可以执行内置的<code>-</code>。</p><p>虽然编译器一次只能执行一个用户定义的类型转换，但<strong>隐式的用户定义类型转换</strong>可以至于一个<strong>标准（内置）类型转换之前或之后</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double-&gt;int-&gt;S</span></span><br><span class="line">s = <span class="number">3.14</span>; <span class="comment">// construct， move assign</span></span><br><span class="line"><span class="comment">// S-&gt;int-&gt;double</span></span><br><span class="line">s + <span class="number">3.14</span>; <span class="comment">// conversion-&gt;int</span></span><br></pre></td></tr></table></figure><h2 id="显式类型转换运算符"><a href="#显式类型转换运算符" class="headerlink" title="显式类型转换运算符"></a>显式类型转换运算符</h2><p><code>explicit operator int() const;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S s;</span><br><span class="line">s + <span class="number">3</span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(s) + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当表达式<strong>作为条件</strong>时，编译器会将显式类型转换<strong>自动应用</strong>于它（仅仅是自动应用<code>explicit operator bool() const</code>，以转换为bool）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  S(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S s;</span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h2><p>必须确保类类型和目标类型之间<strong>只存在唯一一种</strong>转换方式。<strong>无法</strong>通过使用强制类型转换来解决二义性问题，强制类型转换也会面临二义性问题。</p><p>多重转换路径可能由于，</p><ul><li><p>两个类提供相同的类型转换</p></li><li><p>类定义了一组类型转换，它们的转换源（或者转换目标）类型本身可以通过其他类型转换联系在一起，由于<strong>所有算术类型转换的级别都一样</strong>，选择转换序列时会有<strong>多个转换序列</strong>，将会导致二义性。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  S();</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">S s;</span><br><span class="line"><span class="keyword">int</span> a = s; <span class="comment">// 精确匹配</span></span><br><span class="line"><span class="keyword">float</span> b = s; <span class="comment">// 两个“可行函数”</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果已经定义了一个转换为算术类型的类型转换，<strong>不要</strong>再定义<strong>接受算术类型的重载运算符</strong>。在不定义以后，如果用户需要使用这样的运算符，则类型转换操作会转换此类型的对象，然后使用<strong>内置的运算符</strong>。</p></blockquote><h3 id="重载函数与转换构造函数"><a href="#重载函数与转换构造函数" class="headerlink" title="重载函数与转换构造函数"></a>重载函数与转换构造函数</h3><p>当调用重载的函数时，如果两个或多个类型转换都提供了可行的匹配，则这些类型转换一样好。</p><h3 id="重载函数与用户定义的类型转换"><a href="#重载函数与用户定义的类型转换" class="headerlink" title="重载函数与用户定义的类型转换"></a>重载函数与用户定义的类型转换</h3><p>当调用重载的函数时，如果两个或多个类型用户定义的转换都提供了可行的匹配，则这些类型转换一样好。此时，不考虑任何可能出现的标准类型转换级别。</p><p><strong>只有</strong>当重载函数能通过同一个类型转换函数得到匹配时（所有可行函数都请求同一个用户定义的类型转换），才考虑标准类型转换级别。</p><h2 id="函数匹配与重载运算符"><a href="#函数匹配与重载运算符" class="headerlink" title="函数匹配与重载运算符"></a>函数匹配与重载运算符</h2><p>表达式中运算符的候选函数集包括<strong>成员函数</strong>和<strong>非成员函数</strong>。</p><p>如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到<strong>重载运算符和内置运算符的二义性问题</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运算符重载&quot;&gt;&lt;a href=&quot;#运算符重载&quot; class=&quot;headerlink&quot; title=&quot;运算符重载&quot;&gt;&lt;/a&gt;运算符重载&lt;/h1&gt;&lt;p&gt;重载的运算符是具有&lt;strong&gt;特殊名字的函数&lt;/strong&gt;，除函数调用运算符外，其他重载运算符&lt;strong</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
  <entry>
    <title>C++拷贝控制</title>
    <link href="https://chaomai.github.io/2014/2014-03-13-cpp-copy-control/"/>
    <id>https://chaomai.github.io/2014/2014-03-13-cpp-copy-control/</id>
    <published>2014-03-13T12:41:20.000Z</published>
    <updated>2021-06-27T14:57:29.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拷贝、赋值和销毁"><a href="#拷贝、赋值和销毁" class="headerlink" title="拷贝、赋值和销毁"></a>拷贝、赋值和销毁</h1><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数的第一个参数必须是一个引用类型，且几乎总是一个const引用。由于拷贝构造函数在多个情况下会被隐式使用，因此不能是explict的。</p><figure class="highlight plain"><figcaption><span>F &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public:</span><br><span class="line">  Foo();</span><br><span class="line">  Foo(const Foo&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h3><p>如果没有定义拷贝构造函数，编译器会定义一个合成拷贝构造函数。不同于合成默认构造函数r，即使自己定义了其它的拷贝构造函数，编译器也会合成一个拷贝构造函数。</p><p>合成拷贝构造函数会将<strong>参数的每个非static成员逐个拷贝</strong>到正在创建的对象中。拷贝方式依据成员类型而定，</p><ul><li>对于类类型，会使用其拷贝构造函数；</li><li>对于内置类型，会直接拷贝；</li><li>如果成员有数组类型，合成拷贝构造函数会<strong>逐元素</strong>的拷贝。</li></ul><p>合成的函数会被<strong>隐式地声明为内联的</strong>。</p><h3 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h3><p>直接初始化会选择<strong>与参数最匹配的构造函数</strong>。拷贝初始化是件右侧运算对象拷贝到正在创建的对象中。</p><p>拷贝初始化<strong>通常</strong>使用拷贝构造函数来完成，以下情况会发生拷贝初始化，</p><ul><li>用<code>=</code>定义变量；</li><li>将对象作为实参传递给一个非引用类型的形参；</li><li>用一个返回类型为非引用类型的函数返回一个对象；</li><li>用列表初始化一个数组中的元素或一个聚合类中的成员；</li><li>某些类类型会对它们所分配的对象使用拷贝初始化（如：容器的insert）。</li></ul><p>在进行拷贝初始化时，编译器<strong>可以跳过</strong>拷贝/移动构造函数，直接创建对象，但此时拷贝/移动构造函数必须<strong>存在且可访问</strong>。</p><p>如上文所说，拷贝构造函数会被隐式使用，下面是几个例子，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">C c;</span><br><span class="line"><span class="built_in">vector</span>&lt;C&gt; vc&#123;c&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中，对vector使用列表初始化时，c会被copy两次。1. initializer_list的构造函数会<a href="http://stackoverflow.com/questions/20501638/stdvector-init-with-braces-call-copy-constructor-twice">copy一次</a>，2. 从initializer_list到设计存储位置还会copy一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(C c)</span> </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  tmp = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fr</span><span class="params">(C &amp;c)</span> </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">  tmp = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C obj;</span><br><span class="line"></span><br><span class="line">f(obj);</span><br><span class="line">f(C(<span class="number">1</span>));</span><br><span class="line">fr(obj);</span><br><span class="line">fr(C(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><ul><li>第一个f调用，首先会用obj对形参c做拷贝初始化，然后用拷贝赋值，将c赋值给tmp；</li><li><strong>第二个f调用，这里并没有用临时对象对形参c做拷贝初始化，而是用临时对象C(1)对tmp进行复制。</strong>因为有copy elision。</li><li>第一个fr调用，直接拷贝赋值，将obj赋值给tmp；</li><li>第二个fr调用是错误的，问题类似<a href="http://stackoverflow.com/questions/4301179/why-is-taking-the-address-of-a-temporary-illegal">取临时对象的地址</a>，这里C(4)是rvalue表达式，而fr()需要一个左值作为参数。</li></ul><h2 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h2><p>拷贝赋值运算符执行与<strong>析构函数和拷贝构造函数</strong>相同的工作。<br>如果没有定义拷贝赋值运算符，编译器会定义一个合成拷贝赋值运算符。</p><h3 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h3><p>赋值运算符就是一个名为<strong>operator=**的函数，其参数表示要收费的运算对象。定义为成员函数的运算符，其左侧运算对象就绑定到</strong>隐式的this参数<strong>。返回值通常为</strong>左侧运算对象的引用**。</p><p>拷贝赋值运算符参数应为<strong>与所在类相同类型的参数</strong>。</p><h3 id="合成拷贝赋值运算符"><a href="#合成拷贝赋值运算符" class="headerlink" title="合成拷贝赋值运算符"></a>合成拷贝赋值运算符</h3><p>合成拷贝赋值运算符会将右侧运算对象的<strong>每个非static</strong>成员赋予左侧运算对象的相应成员。类似拷贝构造函数逐个拷贝成员，这一工作是由<strong>成员类型的拷贝赋值运算符</strong>完成的。如果是数组类型的成员，则<strong>逐个赋值数组元素</strong>。</p><p>如果<strong>自己定义的</strong>拷贝赋值运算符或拷贝构造函数<strong>没有处理成员中的数组</strong>，逐个拷贝/赋值不会发生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  HasPtr(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s = <span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  HasPtr(<span class="keyword">const</span> HasPtr &amp;rhs) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps)), i(rhs.i) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> *ps;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; sarr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HasPtr <span class="title">a</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">a.arr[<span class="number">0</span>] = <span class="number">232</span>;</span><br><span class="line">a.arr[<span class="number">1</span>] = <span class="number">232</span>;</span><br><span class="line">a.sarr[<span class="number">0</span>] = <span class="number">232</span>;</span><br><span class="line">a.sarr[<span class="number">1</span>] = <span class="number">232</span>;</span><br><span class="line"></span><br><span class="line">HasPtr b = a;</span><br><span class="line">HasPtr c;</span><br><span class="line">c = a;</span><br><span class="line">(*b.ps).append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *a.ps &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *b.ps &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *c.ps &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// abc abca abc</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b.arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b.sarr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// user defined copy constructor</span></span><br><span class="line"><span class="comment">// 232 32627 32627</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.sarr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c.arr[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c.sarr[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// synthesized copy-assignment operator</span></span><br><span class="line"><span class="comment">// 232 232 232</span></span><br></pre></td></tr></table></figure><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>销毁对象的<strong>非static</strong>成员。没有返回值，不接受参数（因此不能够被重载）。对于一个给定类，只会有唯一一个析构函数。</p><p>销毁顺序按照初始化顺序的<strong>逆序</strong>进行，销毁内置类型成员不需要做什么，销毁类类型成员需要<strong>执行成员自己的</strong>析构函数，销毁内置指针类型的成员<strong>不会delete</strong>所指向的对象。</p><p>析构函数在以下情况进行调用，</p><ul><li>变量离开其作用域；</li><li>一个对象呗销毁时，其成员也被销毁；</li><li>容器（标准库容器和数组）被销毁时，其元素被销毁；</li><li>对动态分配的对象，其指针使用delete；</li><li>对于临时对象，当创建它的完整表达式结束时被销毁。</li></ul><h3 id="合成析构函数"><a href="#合成析构函数" class="headerlink" title="合成析构函数"></a>合成析构函数</h3><p>合成析构函数函数体为空，当其函数体执行完以后，成员会被自动销毁。析构函数函数体并<strong>不直接销毁成员</strong>，成员是在析构函数函数体之后<strong>隐含的析构阶段</strong>中被销毁的。</p><h2 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h2><ul><li>需要析构函数的类也需要拷贝构造函数和拷贝赋值运算符。</li><li>需要拷贝操作的类也需要赋值操作，反之亦然，但<strong>不必然意味着也需要析构函数</strong>。</li><li>拷贝操作会带来额外的开销，在拷贝不必须的情况下，应加入移动操作。</li></ul><h2 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h2><p>类似<code>=default</code>，使用<code>=delete</code>可以定义删除的函数。<code>=delete</code>必须出现在函数第一次声明的时候，且可以回任何函数指定<code>=delete</code>。</p><p>如果一个类的析构函数或者一个成员的析构函数是<code>=delete</code>，那么将<strong>无法定义该类型的变量或创建该类的临时对象</strong>，可以new但无法delete。</p><p>关于合成拷贝控制成员，当<strong>不可能拷贝、赋值或销毁类的成员</strong>时，类的合成拷贝控制成员就被定义为删除的。</p><h1 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h1><h2 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h2><p>行为像值的类有自己状态，副本和原对象是完全独立的。</p><p>由于赋值操作会<strong>销毁左侧运算对象的资源</strong>，在对如下类定义拷贝赋值运算符时，需要考虑将一个对象赋值给自身的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr1</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  HasPtr1(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s = <span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  HasPtr1(<span class="keyword">const</span> HasPtr1 &amp;rhs) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps)), i(rhs.i) &#123;&#125;</span><br><span class="line">  HasPtr1 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr1 &amp;rhs);</span><br><span class="line">  ~HasPtr1() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">string</span> *ps;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果拷贝赋值运算符是这样的，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HasPtr1 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr1 &amp;rhs) &#123;</span><br><span class="line">  <span class="keyword">delete</span> ps;</span><br><span class="line">  ps = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">  ai = rhs.i;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">HasPtr1 h;</span><br><span class="line">h = h;</span><br></pre></td></tr></table></figure><p>将一个对象赋值给自身时，解引用<code>*rhs.ps</code>就是错误的，因为ps所指向的对象已经被delete了。因此需要<strong>用一个局部临时对象先保存右侧运算符对象的资源</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr1 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr1 &amp;rhs) &#123;</span><br><span class="line">  <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">  <span class="keyword">delete</span> ps;</span><br><span class="line">  ps = newp;</span><br><span class="line">  ai = rhs.i;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h2><p>行为像值的类共享状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr2</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  HasPtr2(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s = <span class="built_in">string</span>())</span><br><span class="line">      : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">  HasPtr2(<span class="keyword">const</span> HasPtr2 &amp;rhs) : ps(rhs.ps), i(rhs.i), use(rhs.use) &#123; ++*use; &#125;</span><br><span class="line">  HasPtr2 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr2 &amp;rhs);</span><br><span class="line">  ~HasPtr2() &#123;</span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ps;</span><br><span class="line">      <span class="keyword">delete</span> use;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> *ps;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">size_t</span> *use;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于以上类的拷贝构造函数，需要递增右侧运算对象的引用计数，递减左侧运算对象的引用计数。这里同样需要考虑同一个对象给自身赋值的情况，应该先递增右侧运算对象的引用计数，然后递减左侧的并检查，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HasPtr2 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr2 &amp;rhs) &#123;</span><br><span class="line">  ++*rhs.use;</span><br><span class="line">  <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">delete</span> use;</span><br><span class="line">  &#125;</span><br><span class="line">  ps = rhs.ps;</span><br><span class="line">  i = rhs.i;</span><br><span class="line">  use = rhs.use;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h1><p>如果一个类没有定义自己的swap，需要的时候将调用标准库的swap。一般来说，一次swap需要一次copy和两次assign，但这并不是必须要的。如果一个类有动态分配的内存，可以交换指针，而不是既copy又assign。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  swap(lhs.ps, rhs.ps);</span><br><span class="line">  swap(lhs.i, rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是：</p><ol><li>HasPtr的成员是内置类型，并没有特定版本的swap，因此上述swap中调用的是标准库的swap；</li><li>如果一个<strong>类的成员有自己类型特定的swap</strong>，那么调用std::swap就是错误的，标准库swap会进行不必要的copy。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  swap(lhs.h, rhs.h); <span class="comment">// 使用HasPtr的swap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果存在类型特定的swap，其匹配程度会优于std中定义的版本。上面的<code>using std::swap;</code><strong>并未隐藏</strong>HasPtr的swap。</li></ol><h2 id="copy-and-swap"><a href="#copy-and-swap" class="headerlink" title="copy and swap"></a>copy and swap</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs) &#123;</span><br><span class="line">  swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的赋值运算符是用传值的方式。swap左侧运算对象和副本，然后销毁副本。</p><p>copy and swap天然就是<strong>异常安全</strong>的，因为可能抛出异常的情况就是传值时候的copy，如果此时抛出异常，左侧对象不会被修改。同时保证了<strong>自赋值的正确</strong>，因为是copy。</p><h1 id="move"><a href="#move" class="headerlink" title="move"></a>move</h1><h2 id="lvalue和rvalue"><a href="#lvalue和rvalue" class="headerlink" title="lvalue和rvalue"></a>lvalue和rvalue</h2><p>lvalue：有持久的状态，可以取地址。<br>rvalue：字面值常量或临时对象，不可以取地址。</p><h2 id="rvalue-reference"><a href="#rvalue-reference" class="headerlink" title="rvalue reference"></a>rvalue reference</h2><p>必须绑定到右值，即要求转换的表达式、字面值常量或返回右值的表达式。但<strong>不能直接绑定</strong>到一个左值上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i * <span class="number">42</span>; <span class="comment">// 错误i*42是右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i * <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = i * <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>由于rvalue reference只能绑定到临时对象，因此这个对象，</p><ul><li>将要被销毁</li><li>没有其他用户</li></ul><p>这意味着使用rvalue reference可以自由地<strong>接管</strong>所引用对象的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = i * <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h2 id="右值引用类型变量"><a href="#右值引用类型变量" class="headerlink" title="右值引用类型变量"></a>右值引用类型变量</h2><p>进行右值引用后，得到的<strong>右值引用类型变量是左值</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = i * <span class="number">32</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0x71d77768be28</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;rr1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0x71d77768be2c</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误rr1是左值</span></span><br></pre></td></tr></table></figure><p>要将右值引用绑定到一个左值，应该显示地转换或move，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rri = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> &amp;&amp;&gt;(i);</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rri1 = <span class="built_in">std</span>::move(i);</span><br><span class="line"><span class="comment">// int &amp;&amp;rri2 = i;</span></span><br></pre></td></tr></table></figure><p>使用move后，不能对移后源对象的值做任何假设，<strong>不能使用移后源对象的值</strong>。<strong>除了对rri赋值或销毁外</strong>，不能再使用它。</p><h1 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h1><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>参数是一个右值引用，且<strong>任何额外的参数</strong>都必须有默认实参。完成移动后，必须保证<strong>销毁源对象是无害的</strong>。一旦完成移动，源对象必须<strong>不能再指向被移动的资源</strong>，资源所有权已归属新创建的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : elements(s.elements), first_free(s.first_free), cap(s.cap) &#123;</span><br><span class="line">  s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动构造函数通常<strong>不分配</strong>任何新内存，因此通常不抛出异常。为避免标准库<strong>为了处理可能抛出异常而做的额外工作</strong>，一种通知标准库的方法是指明<code>noexcept</code>。</p><h3 id="移动操作和异常"><a href="#移动操作和异常" class="headerlink" title="移动操作和异常"></a>移动操作和异常</h3><ul><li>虽然移动操作通常不抛出异常，但是抛出异常是允许的。</li><li>标准库能够对异常发生是其自身的行为提供保障。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;StrVec&gt; vs;</span><br><span class="line"><span class="comment">// reallocate vecotr</span></span><br><span class="line"><span class="built_in">std</span>::move(vs[i]);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><ul><li>上面的代码中，如果在reallocate时，<strong>移动了部分元素</strong>后抛出异常，那么问题就会发生，源vector已经改变，但是新空间有的元素还不存在。</li><li>如果vector使用拷贝构造函数且发生了异常，那么不会影响源vector。</li></ul><p>基于上面两点，<strong>除非vector知道</strong>元素类型的移动构造函数不会抛出异常，否则在reallocate时，就必须使用拷贝构造函数（即前面所说的，<em>为了处理可能抛出异常而做的额外工作</em>）。如果希望在类似reallocate 的情况下使用移动而非拷贝，就必须<strong>显式的告诉标准库</strong>移动构造函数可以安全使用。</p><h2 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h2><p>移动赋值运算符执行与<strong>析构函数和移动构造函数</strong>相同的工作。如果不抛出异常，则应该标记为<code>noexcept</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123; <span class="comment">// 处理自赋值</span></span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = rhs.elements;</span><br><span class="line">    first_free = rhs.first_free;</span><br><span class="line">    cap = rhs.cap;</span><br><span class="line">    rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里必须check是否是同一对象，因为<strong>此右值可能是move调用返回的结果</strong>，再者不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源。</p><h2 id="移后源对象必须可析构"><a href="#移后源对象必须可析构" class="headerlink" title="移后源对象必须可析构"></a>移后源对象必须可析构</h2><p>从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁，因此需确保移后源对象必须可析构。</p><p>移动操作还应保证对象仍是<strong>有效的</strong>，即可以安全地为其<strong>赋予新值</strong>或可以<strong>安全地使用</strong>而<strong>不依赖其当前值</strong>。</p><p>移动后，源对象的值是没有保证的，不应依赖移后源对象中的数据。</p><h1 id="合成移动操作"><a href="#合成移动操作" class="headerlink" title="合成移动操作"></a>合成移动操作</h1><h2 id="何时定义"><a href="#何时定义" class="headerlink" title="何时定义"></a>何时定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasX</span> &#123;</span></span><br><span class="line">  X mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x, x2 = <span class="built_in">std</span>::move(x); <span class="comment">// 合成移动构造函数</span></span><br><span class="line">hasX hx, hx2 = <span class="built_in">std</span>::move(hx); <span class="comment">// 合成移动构造函数</span></span><br></pre></td></tr></table></figure><p>只有当一个类<strong>没有定义任何自己版本的拷贝控制成员</strong>，且类的<strong>每个非static数据成员都可以移动构造或移动赋值</strong>时，编译器才会合成移动构造函数和移动赋值运算符。</p><h2 id="何时删除"><a href="#何时删除" class="headerlink" title="何时删除"></a>何时删除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">  Y(<span class="keyword">const</span> Y &amp;y) &#123;&#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasY</span> &#123;</span></span><br><span class="line">  hasY() = <span class="keyword">default</span>;</span><br><span class="line">  hasY(hasY &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Y mem;</span><br><span class="line">&#125;;</span><br><span class="line">hasY hy, hy2 = <span class="built_in">std</span>::move(hy); <span class="comment">// call to implicitly-deleted default constructor of &#x27;hasY&#x27;</span></span><br></pre></td></tr></table></figure><p>移动操作永远<strong>不会隐式定义</strong>为delete。但如果<strong>显式地</strong>要求编译器生成=default的移动操作，且编译器<strong>不能移动所有成员</strong>时，移动操作会被定义为delete。</p><p>定义了一个移动构造函数或移动赋值运算符的类<strong>必须也定义</strong>拷贝操作，否则这些成员<strong>默认定义为delete</strong>。</p><h2 id="如果未定义"><a href="#如果未定义" class="headerlink" title="如果未定义"></a>如果未定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Foo() = <span class="keyword">default</span>;</span><br><span class="line">  Foo(<span class="keyword">const</span> Foo &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copied&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo;</span><br><span class="line"><span class="function">Foo <span class="title">foo1</span><span class="params">(foo)</span></span>; <span class="comment">// copied</span></span><br><span class="line"><span class="function">Foo <span class="title">foo2</span><span class="params">(<span class="built_in">std</span>::move(foo1))</span></span>; <span class="comment">// copied</span></span><br></pre></td></tr></table></figure><p>如果没有移动构造函数，就算试图调用move来移动，对象也会被拷贝。</p><p>这里与上面的hasY不同，hasY的移动构造函数是delete的（由于显式地要求生成，但编译器无法生成）。而这里的仅仅是未定义，函数匹配保证该类型的对象会被copy。</p><h2 id="copy-and-swap-again"><a href="#copy-and-swap-again" class="headerlink" title="copy and swap again"></a>copy and swap again</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hp</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Hp() = <span class="keyword">default</span>;</span><br><span class="line">  Hp(<span class="keyword">const</span> Hp &amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copied&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  Hp(Hp &amp;&amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;moved&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  Hp &amp;<span class="keyword">operator</span>=(Hp rhs) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;assign&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Hp hp1;</span><br><span class="line">Hp hp2 = hp1; <span class="comment">// copied，拷贝构造函数</span></span><br><span class="line">Hp hp3 = <span class="built_in">std</span>::move(hp1); <span class="comment">// moved，移动构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">hp1 = hp3; <span class="comment">// copied assign，拷贝赋值运算符</span></span><br><span class="line">hp2 = <span class="built_in">std</span>::move(hp3); <span class="comment">// moved assign，移动赋值运算符</span></span><br></pre></td></tr></table></figure><p>这里除了拷贝构造函数，还有移动构造函数和赋值运算符。对于之前未定义移动构造函数的情况下，调用赋值运算符，初始化形参时<strong>总是进行拷贝</strong>。</p><p>现在拷贝初始化依赖于实参的类型，</p><ul><li>左值-&gt;使用<strong>拷贝构造函数</strong>进行初始化，赋值运算符为<strong>拷贝赋值运算符</strong></li><li>右值-&gt;使用<strong>移动构造函数</strong>进行初始化，赋值运算符为<strong>移动赋值运算符</strong></li></ul><p>从而单一的赋值运算符，实现了两种功能。</p><h2 id="copy-and-swap-idiom"><a href="#copy-and-swap-idiom" class="headerlink" title="copy and swap idiom"></a>copy and swap idiom</h2><p>上面的将拷贝赋值运算符和移动赋值运算符“合并”到一起的方式叫做copy and swap idiom。如果按照上面的方式实现了拷贝赋值运算符和移动赋值运算符，就<strong>不能</strong>再单独写两个拷贝赋值运算符和移动赋值运算符。</p><p>而两种实现拷贝赋值运算符和移动赋值运算符的<strong>效率</strong>是有区别的（C++ Primer 5th Chinese Edition, Exercise 15.53）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr3</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr3&amp;, HasPtr3&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> HasPtr3&amp; lhs, <span class="keyword">const</span> HasPtr3&amp; rhs);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  HasPtr3(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s = <span class="built_in">std</span>::<span class="built_in">string</span>())</span><br><span class="line">      : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  HasPtr3(<span class="keyword">const</span> HasPtr3&amp; hp) : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*hp.ps)), i(hp.i) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copied&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  HasPtr3(HasPtr3&amp;&amp; hp) <span class="keyword">noexcept</span> : ps(hp.ps), i(hp.i) &#123;</span><br><span class="line">    hp.ps = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;moved&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// = 4s</span></span><br><span class="line">  <span class="comment">// mixed 4.8s</span></span><br><span class="line">  HasPtr3&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr3&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = newp;</span><br><span class="line">    i = rhs.i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy assigned&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move 0.7s</span></span><br><span class="line">  <span class="comment">// mixed 4.8s</span></span><br><span class="line">  HasPtr3&amp; <span class="keyword">operator</span>=(HasPtr3&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ps;</span><br><span class="line">      ps = rhs.ps;</span><br><span class="line">      i = rhs.i;</span><br><span class="line">      rhs.ps = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;move assigned&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// = 6s</span></span><br><span class="line">  <span class="comment">// move 2.5s</span></span><br><span class="line">  <span class="comment">// mixed 8.8s</span></span><br><span class="line">  <span class="comment">// HasPtr3&amp; operator=(HasPtr3 rhs) &#123;</span></span><br><span class="line">  <span class="comment">// swap(*this, rhs);</span></span><br><span class="line">  <span class="comment">// #ifndef NDEBUG</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; &quot;assigned&quot; &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="comment">// #endif</span></span><br><span class="line">  <span class="comment">// return *this;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  ~HasPtr3() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>* ps;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr3&amp; lhs, HasPtr3&amp; rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  swap(lhs.ps, rhs.ps);  <span class="comment">// swap the pointers, not the string data</span></span><br><span class="line">  swap(lhs.i, rhs.i);    <span class="comment">// swap the int members</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;swapped&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下，这里最好<strong>不要</strong>把对象的创建放到循环中去，<strong>每次构造和销毁的开销</strong>会使得两种拷贝和移动的区别不太明显，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HasPtr3 hp;</span><br><span class="line">HasPtr3 hp1;</span><br><span class="line">HasPtr3 hp2;</span><br><span class="line"><span class="keyword">auto</span> t0 = high_resolution_clock::now();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; ++i) &#123;</span><br><span class="line">  hp = hp1;</span><br><span class="line">  hp = <span class="built_in">std</span>::move(hp2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> t1 = high_resolution_clock::now();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; duration_cast&lt;milliseconds&gt;(t1 - t0).count() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下（VMware 12, Archlinux x64, Intel i7-2620m），</p><table><thead><tr><th></th><th><code>hp = hp1;</code></th><th><code>hp = std::move(hp2);</code></th><th>mixed</th></tr></thead><tbody><tr><td><code>HasPtr3&amp; operator=(const HasPtr3&amp; rhs)</code></td><td>4s</td><td>N/A</td><td>4.8s</td></tr><tr><td><code>HasPtr3&amp; operator=(HasPtr3&amp;&amp; rhs) noexcept</code></td><td>N/A</td><td>0.7s</td><td>4.8s</td></tr><tr><td><code>HasPtr3&amp; operator=(HasPtr3 rhs)</code></td><td>6s</td><td>2.5s</td><td>8.8s</td></tr></tbody></table><p>可看出copy and swap idiom的效率是不如分开写好。</p><h1 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h1><p>一个移动迭代器通过改变给定迭代器的解引用运算符的行为来<strong>适配</strong>此迭代器。对移动迭代器<strong>解引用</strong>生成的是一个<strong>右值</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newe = uninitialized_copy(make_move_iterator(elements), make_move_iterator(cap), newb);</span><br></pre></td></tr></table></figure><p>通过调用<code>make_move_iterator</code>可将一个普通迭代器转换为一个移动迭代器。上面的代码中，传递给<code>uninitialized_copy</code>的是一个移动迭代器，解引用后得到的是右值，因此<code>uninitialized_copy</code>将使用移动构造函数来构造元素。</p><p>标准库<strong>不保证</strong>哪些算法适用于移动迭代器。只有确认对象在传递给函数后<strong>不再访问</strong>，才能将移动迭代器传递给算法。</p><h1 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h1><p>类似构造函数和赋值运算符，成员函数同样可以提供拷贝版本和移动版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>; <span class="comment">// 拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>; <span class="comment">// 移动</span></span><br></pre></td></tr></table></figure><p>拷贝版本接受能够<strong>转换</strong>为类型X的<strong>任何对象</strong>。使用<code>const X&amp;</code>是因为拷贝操作<strong>不应该改变该对象</strong>。</p><p>而移动版本接受<strong>非const右值</strong>，对于非const右值是精确匹配。从源对象移动数据时，显然需要更改源对象，所以是<code>X&amp;&amp;</code>。</p><h2 id="右值和左值引用成员函数"><a href="#右值和左值引用成员函数" class="headerlink" title="右值和左值引用成员函数"></a>右值和左值引用成员函数</h2><p>对于赋值运算符，为了<strong>强制左侧运算对象</strong>是一个左值，可以类似const，在参数列表后使用引用限定符，引用限定符可以是<code>&amp;</code>或<code>&amp;&amp;</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) &amp;; <span class="comment">// 只能向可修改的左值赋值</span></span><br></pre></td></tr></table></figure><p>const改变了this指针的类型，指明了this是指向常量的指针，这里类似，引用限定符说明了this<strong>可以指向</strong>一个<strong>左值还是右值</strong>。const和引用限定符只能用于<strong>非static</strong>成员函数。</p><h2 id="重载和引用函数"><a href="#重载和引用函数" class="headerlink" title="重载和引用函数"></a>重载和引用函数</h2><ul><li><p>当定义const成员函数是，可以根据有无const，定义两个重载版本。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>当定义有引用限定符的成员函数时，如果定义<strong>两个或两个以上</strong>具有相同<strong>名字和参数列表</strong>的成员函数，就必须对*<em>所有重载函数</em>都加上引用限定符。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span> &amp;&amp;</span>;</span><br><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span> <span class="keyword">const</span></span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span> <span class="keyword">const</span> &amp;</span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;拷贝、赋值和销毁&quot;&gt;&lt;a href=&quot;#拷贝、赋值和销毁&quot; class=&quot;headerlink&quot; title=&quot;拷贝、赋值和销毁&quot;&gt;&lt;/a&gt;拷贝、赋值和销毁&lt;/h1&gt;&lt;h2 id=&quot;拷贝构造函数&quot;&gt;&lt;a href=&quot;#拷贝构造函数&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
  <entry>
    <title>C++动态内存</title>
    <link href="https://chaomai.github.io/2014/2014-03-03-cpp-dynamic-memory/"/>
    <id>https://chaomai.github.io/2014/2014-03-03-cpp-dynamic-memory/</id>
    <published>2014-03-03T10:31:05.000Z</published>
    <updated>2021-06-27T14:57:29.253Z</updated>
    
    <content type="html"><![CDATA[<p>静态内存：存储局部static对象、类static数据成员和定义在函数之外的变量。<br>static对象：使用之前分配，程序结束时销毁。</p><p>栈内存：保存定义在函数内部的非static对象。<br>栈对象：仅在定义的程序块运行时才存在。</p><p>动态内存（free store或heap）：存储动态分配的对象，需要<strong>显示地销毁</strong>，分配和销毁由<code>new</code>和<code>delete</code>完成。</p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>最安全的分配和使用动态内存的方法是调用<code>make_shared</code>，返回指向在动态内存分配的对象的<code>shared_ptr</code>。<code>make_shared</code>类似<code>emplace</code>，使用<strong>参数来构造</strong>指定类型的对象，如果没有参数，则进行值初始化。</p><p>当进行copy或assign时，<strong>每个</strong><code>shared_ptr</code>会记录有多少个其他<code>shared_ptr</code>指向相同的对象。可看作<code>shared_ptr</code>有reference count，</p><ul><li><p>当发生以下情况时，count递增；</p><ol><li>copy或assign； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li>作为参数传给一个函数；</li><li>作为函数的返回值；</li></ol></li><li><p>当发生以下情况时，count递减；</p><ol><li>给<code>shared_ptr</code>赋予一个新的值； <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// 1</span></span><br><span class="line">r = q; <span class="comment">// ++q指向对象的ref count，--r指向对象的ref count；销毁r原来指向对象</span></span><br></pre></td></tr></table></figure></li><li><code>shared_ptr</code>被销毁；</li></ol></li></ul><p>count的递减由<code>shared_ptr</code>的析构函数完成，如果count<strong>变为0</strong>，<code>shared_ptr</code>会释放所管理的对象。</p><p>在某个scope中，只要能够使用<code>shared_ptr</code>，那么它的引用计数<strong>至少为1</strong>。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.get() <span class="comment">// 返回内置的指针</span></span><br><span class="line">p.use_count() <span class="comment">// 返回引用计数</span></span><br><span class="line">p.unique() <span class="comment">// 若引用计数为1，则返回true；否则false</span></span><br><span class="line">p.reset() <span class="comment">// 将p置空，若p是唯一指向对象的，则释放此对象</span></span><br><span class="line">p.reset(q) <span class="comment">// 令p指向内置指针q，若p是唯一指向对象的，则释放此对象</span></span><br><span class="line">p.reset(q, d) <span class="comment">// 同上，释放q时调用d</span></span><br></pre></td></tr></table></figure><p>使用<code>new</code>和<code>delete</code>会使得类对象的copy、assign和destroy<strong>不能依赖任何默认定义</strong>。</p><h3 id="自定义释放操作"><a href="#自定义释放操作" class="headerlink" title="自定义释放操作"></a>自定义释放操作</h3><p>默认情况下，shared_ptr指向的是动态内存，因此被销毁时，默认调用delete。可以自定义释放操作，提供其他的deleter。deleter的参数必须为<strong>该shared_ptr的内置指针类型</strong>。</p><h2 id="直接管理动态内存"><a href="#直接管理动态内存" class="headerlink" title="直接管理动态内存"></a>直接管理动态内存</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>默认情况下，new的对象是<strong>默认初始化</strong>的。也可以使用值初始化的方式来初始化new的对象（圆括号+参数），还可以使用列表初始化，以及值初始化（空括号）。</p><h3 id="自动推断类型"><a href="#自动推断类型" class="headerlink" title="自动推断类型"></a>自动推断类型</h3><p>可以使用auto从initializer来推断将要分配的对象类型，由于编译器<strong>需要从initializer来获得类型</strong>，因此圆括号中仅能有一个initializer，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="keyword">auto</span>(obj);</span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a, b, c&#125;; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">auto</span> p3 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h3 id="const对象"><a href="#const对象" class="headerlink" title="const对象"></a>const对象</h3><p>和其他const对象相同，必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *pcs = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>; <span class="comment">// 调用默认构造函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 只能显示初始化</span></span><br></pre></td></tr></table></figure><h3 id="bad-alloc"><a href="#bad-alloc" class="headerlink" title="bad_alloc"></a>bad_alloc</h3><p>如果内存不足，new失败，就会抛出<code>bad_alloc</code>，但可以告知不抛出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 失败则返回nullptr</span></span><br></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>传递给delete的必须是指针，且必须指向动态分配的内存，或是一个<code>nullptr</code>。如果是动态分配的内存，或释放同一个指针多次，行为未定义。对const动态对象，销毁的方法也是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用clang++ 3.7编译</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line"><span class="keyword">delete</span> pi; <span class="comment">// segmentation fault</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> pi2; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> *pd = <span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">double</span> *pd1 = pd;</span><br><span class="line"><span class="keyword">delete</span> pd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// pd不会被置为nullptr，空悬指针</span></span><br><span class="line"><span class="keyword">delete</span> pd; <span class="comment">// core dumpped</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">delete</span> pci;</span><br></pre></td></tr></table></figure><p>可以在delete后手动赋值为<code>nullptr</code>。但也仅仅只解决了<code>pd</code>的问题，多个指针指向同一个内存区域时，仍然有问题，<code>pd1</code>仍然指向原内存区域，还是空悬指针。</p><h2 id="shared-ptr和new"><a href="#shared-ptr和new" class="headerlink" title="shared_ptr和new"></a>shared_ptr和new</h2><p>可以用new返回的指针来初始化<code>shared_ptr</code>。由于接受智能指针的构造函数是explicit的，因此必须使用<strong>直接初始化</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误，此语句首先需要在int*和shared_ptr之间做隐式转换，然后再把临时的shared_ptr拷贝给p1。</span></span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>定义了<code>get</code>函数，可以获得内置指针，指向<code>shared_ptr</code>管理的对象。通过这种方式得到的指针<strong>不能被delete</strong>，必须保证代码不会delete的情况下，才能使用get。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用clang++ 3.7编译</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>))</span></span>;</span><br><span class="line"><span class="keyword">int</span> *q = p.get();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sq</span><span class="params">(q)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *sq &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">delete</span> q; <span class="comment">// double free or corruption</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 错误，p指向的内存已被销毁</span></span><br><span class="line"><span class="comment">// double free or corruption</span></span><br></pre></td></tr></table></figure><p>上述代码在内部的scope中手动删除了p指向的内存，当这个scope结束时，sq被销毁，那部分内存<strong>还会被shared_ptr销毁一次</strong>。编译时不会报错，但运行时出现double free or corruption。<br><strong>就算没有delete</strong>，内部的scope结束，那部分内存被销毁，这段代码结束时，又一次被销毁，同样也会有double free or corruption。</p><h2 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h2><p>无论是函数正常结束或者发生异常，局部对象都会被销毁。智能指针被销毁时，如果引用计数为0，则释放内存。但new得到的内存不会被自动释放，如果有指向这块内存的指针，只有指针会被销毁。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr<strong>拥有</strong>指向的对象。没有类似make_shared的函数，只能将其绑定到new返回的指针上。也是必须使用直接初始化。</p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>除了将被销毁的unique_ptr外，<strong>不支持copy和assignment</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="literal">nullptr</span> <span class="comment">// 释放u指向的对象，并置空</span></span><br><span class="line">u.release() <span class="comment">// 放弃对指针的控制权，返回指针并将u置空</span></span><br><span class="line">u.reset() <span class="comment">// 类似shared_ptr，只是无需判断引用计数</span></span><br><span class="line">u.reset(q)</span><br><span class="line">u.reset(<span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure><h3 id="自定义释放操作-1"><a href="#自定义释放操作-1" class="headerlink" title="自定义释放操作"></a>自定义释放操作</h3><p>不同于shared_ptr，unique_ptr在重载deleter时，需要<strong>提供deleter的类型</strong>。重载unique_ptr的deleter，会影响到unique_ptr的类型和如何构造或reset该类型的对象。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;objT, delT&gt; p(new objT, fcn);</span><br></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><ul><li><strong>不控制</strong>所指向对象的生命周期；</li><li>weak_ptr指向shared_ptr管理的对象；</li><li>将一个weak_ptr绑定到一个shared_ptr<strong>不会改变shared_ptr的引用计数</strong>；</li><li>一旦shared_ptr被销毁，所指对象就被释放。</li></ul><h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">w = p <span class="comment">// p可以是weak_ptr或shared_ptr</span></span><br><span class="line">w.reset() <span class="comment">// 将w置空</span></span><br><span class="line">w.use_count()</span><br><span class="line">w.expired() <span class="comment">// 若w.use_count()为0，返回true，否则false</span></span><br><span class="line">w.lock() <span class="comment">// 若w.expired()为true，返回空的shared_ptr，否则返回指向w的对象的shared_ptr</span></span><br></pre></td></tr></table></figure><h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><p>分配动态数组的类必须<strong>定义自己的版本</strong>的操作来管理<strong>拷贝，复制以及销毁</strong>。</p><h2 id="new数组"><a href="#new数组" class="headerlink" title="new数组"></a>new数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br></pre></td></tr></table></figure><p><code>pia</code>中的元素是进行默认初始化的。但此时pia并<strong>不是一个数组</strong>类型的对象，只是一个数组元素类型的指针，因此不能够调用begin和end（它们<strong>使用数组的维度</strong>来得到首元素和尾后元素指针），也不能使用for。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>new的数组和单个对象一样，默认情况下，new的数组是<strong>默认初始化</strong>的。可以对数组中的元素进行值初始化和列表初始化，也和单个对象一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]();</span><br><span class="line"><span class="keyword">auto</span> *psa1 = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>](<span class="string">&quot;abd&quot;</span>, <span class="string">&quot;abc&quot;</span>, ...); <span class="comment">// 不能再这里提供initializer，因此不能用auto</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span>[<span class="number">10</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 剩下的元素进行值初始化</span></span><br></pre></td></tr></table></figure><p>如果new失败，类似bad_alloc，这里会抛出bad_array_new_length。</p><h3 id="new空数组"><a href="#new空数组" class="headerlink" title="new空数组"></a>new空数组</h3><p>这样做是合法的，得到的是一个合法的非空指针，相当与数组的尾后指针，不能解引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]; <span class="comment">// 合法，但不可以解引用</span></span><br></pre></td></tr></table></figure><h3 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 未定义</span></span><br></pre></td></tr></table></figure><p>释放时，按逆序销毁。p还可以为nullptr。</p><h3 id="智能指针和动态数组"><a href="#智能指针和动态数组" class="headerlink" title="智能指针和动态数组"></a>智能指针和动态数组</h3><p>标准库提供了一个管理new分配的数组的unique_ptr，但此unique_ptr<strong>不支持成员访问运算符</strong>。unique_ptr被销毁时，会自动使用<code>delete []</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T[]&gt; u</span><br><span class="line">unique_ptr&lt;T[]&gt; u(p)</span><br><span class="line">u[i]</span><br></pre></td></tr></table></figure><p>如果使用shared_ptr来管理，则必须<strong>提供自定义的删除器</strong>。如果没有提供，则shared_ptr会默认调用delete，行为未定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span> [] p; &#125;)</span></span>;</span><br><span class="line">*(sp.get() + <span class="number">5</span>) = <span class="number">2</span>; <span class="comment">// shared_ptr未定义下标运算符，且智能指针不支持指针算术运算</span></span><br></pre></td></tr></table></figure><h2 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  C(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : a_(a), b_(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C *<span class="keyword">const</span> pc = <span class="keyword">new</span> C[<span class="number">10</span>]; <span class="comment">// 错误</span></span><br><span class="line">C *<span class="keyword">const</span> pc1 = <span class="keyword">new</span> C[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>new把<strong>内存分配和对象构造</strong>组合在了一起，可能造成外的开销；同时若类没有默认构造函数，则不能够分配动态数组。</p><p>allocator<strong>分离</strong>内存分配和对象构造，避免不必要的开销。所分配的内存是原始的，未构造的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;C&gt;::size_type n = <span class="number">10</span>;</span><br><span class="line">allocator&lt;C&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); <span class="comment">// C *const p1 = alloc.allocate(10);</span></span><br><span class="line"><span class="keyword">auto</span> q = p;</span><br><span class="line">alloc.construct(q++, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 类似make_shared</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;a_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;b_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q-&gt;a_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q-&gt;b_ &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 错误，q指向的内存未构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">  alloc.destroy(--q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alloc.deallocate(p, n); <span class="comment">// 大小应和allocate时的一样</span></span><br></pre></td></tr></table></figure><h3 id="拷贝和填充未初始化内存"><a href="#拷贝和填充未初始化内存" class="headerlink" title="拷贝和填充未初始化内存"></a>拷贝和填充未初始化内存</h3><p>下列操作所需的内存是由<code>allocate</code>分配的，而<strong>不是系统分配</strong>的，因此<code>alloc_b</code>指向的内存必须足够大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uninitialized_copy(b, e, alloc_b); <span class="comment">// 返回最后一个构造的元素之后的位置</span></span><br><span class="line">uninitialized_copy_n(b, n, alloc_b); <span class="comment">// 返回最后一个构造的元素之后的位置</span></span><br><span class="line">uninitialized_fill(alloc_b, alloc_e, t);</span><br><span class="line">uninitialized_fill_n(alloc_b, n, t);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;静态内存：存储局部static对象、类static数据成员和定义在函数之外的变量。&lt;br&gt;static对象：使用之前分配，程序结束时销毁。&lt;/p&gt;
&lt;p&gt;栈内存：保存定义在函数内部的非static对象。&lt;br&gt;栈对象：仅在定义的程序块运行时才存在。&lt;/p&gt;
&lt;p&gt;动态内存（</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
  <entry>
    <title>C++关联容器</title>
    <link href="https://chaomai.github.io/2014/2014-02-28-cpp-associative-container/"/>
    <id>https://chaomai.github.io/2014/2014-02-28-cpp-associative-container/</id>
    <published>2014-02-28T10:56:17.000Z</published>
    <updated>2021-06-27T14:57:29.253Z</updated>
    
    <content type="html"><![CDATA[<p>关联容器支持普通容器操作，不支持，</p><ul><li>顺序容器位置相关的操作，<code>push_back</code>等；</li><li>构造函数或插入操作接受一个元素值和一个数量值得操作。</li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>定义一个map时必须指定<strong>关键字类型和值类型</strong>，set只需<strong>关键字类型</strong>。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>可以用下面的方式来初始化，</p><ul><li>同类型容器的copy；</li><li>指定值范围（begin和end）；</li><li>列表初始化。</li></ul><h1 id="有序关联容器关键字类型的要求"><a href="#有序关联容器关键字类型的要求" class="headerlink" title="有序关联容器关键字类型的要求"></a>有序关联容器关键字类型的要求</h1><p>有序关联容器关键字类型必须定义<strong>元素比较的方法</strong>。默认情况下，使用<code>&lt;</code>进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list的iterator并无&lt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">int</span>&gt; ml; <span class="comment">// 声明不会报错</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line">ml[li.begin()] = <span class="number">0</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>对于有序容器，有序容器的关键字必须是<strong>严格弱序</strong>的，可看做“小于等于”。</p><h2 id="自定义比较操作"><a href="#自定义比较操作" class="headerlink" title="自定义比较操作"></a>自定义比较操作</h2><p>用于组织一个容器中元素的<strong>操作的类型</strong>也是容器类型的一部分，如果需要自定义操作，则在定义容器的时候就指明。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boo <span class="title">compare</span><span class="params">(...)</span> </span>&#123; ... &#125;</span><br><span class="line">multiset&lt;Sales_sata, decltype(compare) *&gt; bookstore(compare);</span><br></pre></td></tr></table></figure><p>创建对象时，提供的操作类型（<strong>函数指针</strong>）必须与尖括号中的类型吻合。规则与函数的const形参和实参的规则一致，忽略top const。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> comp = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(const int, const int)&gt; m(comp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp1 = [](<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(int, int)&gt; m1(comp1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp2 = [](<span class="keyword">int</span>* <span class="keyword">const</span> a, <span class="keyword">int</span>* <span class="keyword">const</span> b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(int*, int*)&gt; m2(comp2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp3 = [](<span class="keyword">int</span>* a, <span class="keyword">int</span>* b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(int* const, int* const)&gt; m3(comp3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> comp4 = [](<span class="keyword">int</span>* a, <span class="keyword">int</span>* b) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</span><br><span class="line">multiset&lt;int, bool (*)(const int*, const int*)&gt; m4(comp4); // 错误</span><br></pre></td></tr></table></figure><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>模板，接受两个类型名，pair的数据成员将有对应的类型，两个类型不要求一样。</p><p>创建对象时，pair的默认构造函数对数据成员进行<strong>值初始化</strong>（vector也可以）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br></pre></td></tr></table></figure><p>若函数返回pair，可<strong>对返回值</strong>进行列表初始化，不必显式构造返回值。</p><h1 id="关联容器的操作"><a href="#关联容器的操作" class="headerlink" title="关联容器的操作"></a>关联容器的操作</h1><p>map中，每个元素就是一个pair对象，由于关键字不可变，因此pair的<strong>关键字部分是const</strong>。set的关键字也是<code>const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type v1; <span class="comment">// pair&lt;const string, int&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::key_type v2; <span class="comment">// string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::map_type v3; <span class="comment">// int</span></span><br></pre></td></tr></table></figure><h2 id="关联容器的迭代器"><a href="#关联容器的迭代器" class="headerlink" title="关联容器的迭代器"></a>关联容器的迭代器</h2><p>对关联容器迭代器解引用，可得到容器的<code>value_type</code>的引用。</p><p>对于set，虽然set定义了<code>iterator</code>和<code>const_iterator</code>，但是都不能改变set中的元素。</p><p>当迭代器遍历一个map，multimap，set或multiset时，按关键字升序遍历。</p><h2 id="关联容器和算法"><a href="#关联容器和算法" class="headerlink" title="关联容器和算法"></a>关联容器和算法</h2><p>由于关键字是<code>const</code>，因此不能用于修改或重排容器的算法（都需要向元素写入值）。只可用于读取元素的算法。</p><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p><code>insert</code>和<code>emplace</code>可以对关联容器进行插入，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c.insert(v)</span><br><span class="line">c.emplace(args)</span><br><span class="line"><span class="comment">// map和set返回pair&lt;iterator, bool&gt;，iterator指向有此关键字的元素，bool说明是否元素是否已经存在，即是否插入成功。multimap和multiset总是进插入，只返回bool。</span></span><br><span class="line"></span><br><span class="line">c.insert(b, e)</span><br><span class="line">c.insert(li)</span><br><span class="line"><span class="comment">// 返回void</span></span><br><span class="line"></span><br><span class="line">c.insert(p, v)</span><br><span class="line">c.emplace(p, args)</span><br><span class="line"><span class="comment">// p指明了从哪里开始新元素的存储位置</span></span><br></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>关联容器有三个版本的erase，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c.erase(k)</span><br><span class="line"><span class="comment">// 删除所有key为k的元素，返回size_type，表明删除的数量</span></span><br><span class="line"></span><br><span class="line">c.erase(p)</span><br><span class="line"><span class="comment">// 返回被删除元素后的迭代器</span></span><br><span class="line"></span><br><span class="line">c.erase(b, e)</span><br><span class="line"><span class="comment">// 返回e</span></span><br></pre></td></tr></table></figure><h2 id="map的下标"><a href="#map的下标" class="headerlink" title="map的下标"></a>map的下标</h2><p>由于set并无关联值，下标操作对set无意义，故set不支持。multimap和multiset可能存在多个与某个key关联的值，故也不支持。</p><p>下标操作返回<code>mapped_type</code>，是左值。如果关键字不在map中，下标操作会，</p><ol><li><strong>创建一个元素并插入</strong>，关联值将进行<strong>值初始化</strong>；</li><li>提取元素并赋值。</li></ol><p>注意，</p><ol><li>与vector和string不同，map的下标操作和解引用返回的类型（<code>mapped_type</code>和<code>value_type</code>）不一样；</li><li>如果元素不存在，<code>at</code>并不会创建，而是抛出<code>out_of_range</code>；</li><li>下标操作可能会改变map，对const的map无法使用；</li><li>对于const的map，只要<code>at</code>不修改元素，就可以用。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m.at(<span class="string">&quot;hello&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m[<span class="string">&quot;hello&quot;</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 错误，即使是普通访问</span></span><br><span class="line">m.at(<span class="string">&quot;hello&quot;</span>) = <span class="number">1</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><p>使用hash function和<code>==</code>来组织元素，用<code>hash&lt;key_type&gt;</code>类型的对象生成每个元素的hash值，有序关联容器的操作可以用于无序容器。</p><p>标准库为<strong>内置类型（包括指针类型）和部分标准库类型（包括string和智能指针）类型</strong>定义了hash。但不能直接把自定义类型作为key来定义无序容器，可以</p><ol><li>提供自己的hash模板版本；</li><li>定义hash function和<code>==</code>运算符。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; sd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;() (sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; lhs, <span class="keyword">const</span> Sales_data&amp;rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_multiset&lt;Sales_data, decltype(hasher)*, decltype(eqOp)*&gt; set(42, hasher,  eqOp);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关联容器支持普通容器操作，不支持，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序容器位置相关的操作，&lt;code&gt;push_back&lt;/code&gt;等；&lt;/li&gt;
&lt;li&gt;构造函数或插入操作接受一个元素值和一个数量值得操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
  <entry>
    <title>C++顺序容器</title>
    <link href="https://chaomai.github.io/2014/2014-02-24-cpp-sequential-container/"/>
    <id>https://chaomai.github.io/2014/2014-02-24-cpp-sequential-container/</id>
    <published>2014-02-24T06:53:06.000Z</published>
    <updated>2021-06-27T14:57:29.253Z</updated>
    
    <content type="html"><![CDATA[<p>首先介绍顺序容器操作基本相同的部分，然后分别是每种容器要注意的地方。</p><h1 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h1><ul><li><code>C c</code><br>  默认构造函数</li><li><code>C c1(c2)</code>，<code>C c1 = c2</code><br>  c1初始化为c2的copy。c1和c2必须是相同的容器类型，且保存相同类型的元素。</li><li><code>C c&#123;a, b, c, ...&#125;</code>，<code>C c = &#123;a, b, c, ...&#125;</code><br>  列表初始化</li><li><code>C c(b, e)</code></li></ul><p>除array外，还有以下两种，</p><ul><li><code>C seq(n)</code></li><li><code>C seq(n, t)</code></li></ul><h2 id="C-c1-c2-和C-c-b-e"><a href="#C-c1-c2-和C-c-b-e" class="headerlink" title="C c1(c2)和C c(b, e)"></a><code>C c1(c2)</code>和<code>C c(b, e)</code></h2><p><code>C c1(c2)</code>要求两个容器必须是相同的类型，且元素类型也是相同的；但<code>C c(b, e)</code>就只需要元素类型可以<strong>转换</strong>为要初始化的容器的元素类型即可。</p><h1 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h1><p>所有容器都支持赋值<code>=</code>，赋值后，左边容器的元素为右边容器元素的copy，且大小与右边容器相同。</p><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><ul><li><code>swap</code>会交换两个容器的元素，两个容器必须有<strong>相同的</strong>类型；</li><li>通常来说<code>swap</code>只是交换了容器内部的数据结构，但也有例外，对array进行操作时，会真正交换它们的元素；</li><li><code>swap</code>完成以后，<strong>除string外</strong>，指向容器的迭代器、引用和指针都不会失效。</li></ul><h2 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h2><ul><li><code>seq.assign(b, e)</code></li><li><code>seq.assign(il)</code></li><li><code>seq.assign(n, t)</code></li></ul><p>要注意的有，</p><ul><li>参数非常像初始化的；</li><li><code>assign</code>不适用于关联容器的array；</li><li>可以从一个<strong>不相同但相容的</strong>类型assign。</li></ul><h1 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h1><p>除了forward_list，每个容器都支持<code>size()</code>、<code>empty()</code>和<code>max_size()</code>；forward_list只支持<code>empty()</code>和<code>max_size()</code>。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>每种容器都支持<code>==</code>和<code>!=</code>。</p><p>除了无序关联容器，所有容器都支持<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>和<code>&lt;=</code>。</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="push…和insert"><a href="#push…和insert" class="headerlink" title="push…和insert"></a>push…和insert</h2><p><code>push_back</code>，<code>insert</code>和<code>push_front</code>放入容器的是元素的copy。</p><h2 id="emplace…"><a href="#emplace…" class="headerlink" title="emplace…"></a>emplace…</h2><p><code>emplace_front</code>，<code>emplace</code>和<code>emplace_back</code>分别对应<code>push_back</code>，<code>insert</code>和<code>push_front</code>。不支持push…或insert的容器，也不支持相应的<code>emplace</code>。</p><p>与<code>push_back</code>，<code>push_front</code>和<code>insert</code>放入元素的copy不同，<code>emplace</code>会见参数传递给元素类型的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  C2() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">C2</span><span class="params">(<span class="keyword">int</span> a)</span> : <span class="title">a_</span><span class="params">(a)</span> </span>&#123;&#125;</span><br><span class="line">  C2(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : a_(a), b_(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> b_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;C2&gt; cs2;</span><br><span class="line"><span class="comment">// 由于是explicit，不存在从int到C2的隐式转换</span></span><br><span class="line"><span class="comment">// cs2.push_back(1);</span></span><br><span class="line"><span class="comment">// cs2.push_back(); // 错误</span></span><br><span class="line"><span class="comment">// cs2.push_back(1, 2); // 错误</span></span><br><span class="line"></span><br><span class="line">cs2.push_back(C2());</span><br><span class="line">cs2.push_back(C2(<span class="number">1</span>));</span><br><span class="line">cs2.push_back(C2(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用了C2的构造函数，对应以三个push_back</span></span><br><span class="line">cs2.emplace_back();</span><br><span class="line">cs2.emplace_back(<span class="number">1</span>);</span><br><span class="line">cs2.emplace_back(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><code>emplace</code>在容器中直接构造元素，由于参数是传递给元素的构造函数，因此实参的类型必须和构造函数匹配。</p><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>可用以下方法访问顺序容器的元素：</p><ul><li><code>c.back()</code></li><li><code>c.front()</code></li><li><code>c[n]</code></li><li><code>c.at(n)</code></li></ul><p>下标操作和at实际上就是进行随机访问，因而只能用于支持随机访问的顺序容器（string、vector、deque和array）。两个随机访问中，只有at能够保证安全的随机访问，下标越界时，会抛出out_of_range异常。</p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><ul><li><code>c.pop_back()</code></li><li><code>c.pop_front()</code></li><li><code>c.erase(p)</code></li><li><code>c.erase(b, e)</code></li><li><code>c.clear()</code></li></ul><p><code>pop_back</code>和<code>pop_front</code>返回<code>void</code>，<code>erase</code>返回一个迭代器，位置为最后一个被删除元素的下一个。</p><p>如果<code>b</code>和<code>e</code>相等（即使都为<code>c.end()</code>），那么不会删除任何元素。</p><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>适配器是一种机制，使得某种事物的行为看起来像另外一个事物。容器、迭代器和函数都有适配器。</p><p>每个适配器有两个构造函数，</p><ul><li><code>A a</code></li><li><code>A a(c)</code>，拷贝容器c来初始化a</li></ul><p>顺序容器适配器有，</p><ul><li>stack，默认情况下基于queue实现；</li><li>queue，默认情况下基于queue实现；</li><li>priority_queue，默认情况下基于vector实现；</li></ul><p>一般来说，用于构造适配器的容器是有限制的，</p><ul><li>能添加和删除元素；</li><li>访问尾元素；</li></ul><p>具体到每个适配器，</p><ul><li>stack<br> <code>push_back</code>，<code>pop_back</code>，<code>back</code></li><li>queue<br>  <code>push_back</code>，<code>push_front</code>，<code>back</code>，<code>front</code></li><li>priority_queue<br>  <code>front</code>，<code>push_back</code>，<code>pop_back</code>，随机访问</li></ul><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="capacity和size"><a href="#capacity和size" class="headerlink" title="capacity和size"></a>capacity和size</h2><p>vector支持快速随机访问，元素是连续存储的。这意味着添加元素时，需要移动已有的元素，以保证连续的存储。如果没有空间容纳新元素，则需要分配新的内存，并把已有元素从旧的位置移动到新的位置。为了减少内存的分配和释放的代价，分配策略一般为实在是没法存时，才获取新的内存。只要没有操作使得vector的capacity不够，就不会重新分配内存。</p><p>以下几个操作是管理容器大小的，</p><ul><li><code>c.shrink_to_fit()</code><br>  请求把capacity减少为size。这里仅仅是一个请求，shrink_to_fit<strong>不保证</strong>退还内存。</li><li><code>c.capacity()</code><br>  在不重新分配内存的情况下，最多能存储的元素数目。</li><li><code>c.reserve(n)</code><br>  分配至少能容纳n个元素的内存。n如果小于等于当前capacity，那么什么都不发生。</li></ul><p>要注意的是，reserve和resize不同，reserve改变（至少是变大）的是capacity，size并未变化；而resize改变了size的同时，capacity（如果n大于当前的capacity）也有可能改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t23</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>; <span class="comment">// size: 10 capacity: 10</span></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>; <span class="comment">// size: 10 capacity: 10</span></span><br><span class="line">  v1.resize(<span class="number">15</span>); <span class="comment">// size: 15 capacity: 20</span></span><br><span class="line">  v2.reserve(<span class="number">15</span>); <span class="comment">// size: 10 capacity: 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>添加元素的情况下，</p><ul><li>如果添加前<code>capacit = size</code>，那么会导致内存重新分配，从而vector相关的迭代器、引用或指针都会失效；<br>如果不发生内存分配，有可能会发生元素移动（插入中间位置），插入位置之后的迭代器、引用或指针都会失效。</li></ul><p>对于删除元素，不会发生内存重新分配，被删除元素前的迭代器、引用或指针都还有效。</p><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><p>添加元素的情况下，<br>如果插入到<strong>首尾</strong>之外的位置，都会导致迭代器、引用或指针失效；</p><p>删除元素的情况下，</p><ul><li>如果在<strong>首尾</strong>之外的位置删除，都会导致迭代器、引用或指针失效；</li><li>如果删除了<strong>尾元素</strong>，<strong>尾后迭代器也会失效</strong>，但其他的迭代器、引用或指针不受影响。</li></ul><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><p>string也支持上述提及的大部分操作，但同样有例外，且某些操作有特殊局限，</p><ul><li><code>swap</code>会导致相关的迭代器、引用或指针失效；</li><li>与vector一样，front相关的操作不支持；<ul><li>不支持<code>push_front</code>和<code>emplace_front</code>；</li><li>不支持<code>pop_front</code>;</li></ul></li><li><code>insert</code>、<code>erase</code>、<code>assign</code>和<code>replace</code>重载函数，p323和p324；<ul><li>额外的<code>insert</code>、<code>erase</code>、<code>assign</code>；</li><li><code>append</code>在末尾插入；</li><li><code>replace</code>，等价于<code>erase</code>+<code>insert</code>。</li></ul></li><li>搜索，p325和p326；<ul><li>返回值均为<code>string::size_type()</code>，是一个<code>unsigned</code>类型，如果找不到，这返回<code>string::npos</code>；</li><li><code>s.find(args)</code>，返回第一个匹配args的下标；</li><li><code>s.rfind(args)</code>，返回最后一个匹配args的下标；</li><li><code>s.find_first_of(args)</code>，返回args中任何一个字符<strong>首次出现在args中</strong>的下标；</li><li><code>s.find_last_of(args)</code>；</li><li><code>s.find_first_not_of(args)</code>，返回首个<strong>不在args中</strong>字符的下标；</li><li><code>s.find_last_not_of()</code>。</li></ul></li><li>compare同样有多个重载，p327；</li><li>数值转换，p328；<ul><li><code>to_string(val)</code>；</li><li><code>sto...</code>；<ul><li>string中的第一个非空白字符必须是数值中可能出现的字符，即+或-，或数字，数字可以是0x或0X开头表示的十六进制数；</li><li>如果是转换为浮点数的，开头可以为.，且包含e或E表示指数；</li><li>如果是转换为整型的，根据不同的基数，可以有字母；</li><li>如果不能转换，则抛出<code>invallid_argument</code>；</li><li>如果得到的数值无法用任何类型表示，则抛出<code>out_of_range</code>。</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先介绍顺序容器操作基本相同的部分，然后分别是每种容器要注意的地方。&lt;/p&gt;
&lt;h1 id=&quot;定义和初始化&quot;&gt;&lt;a href=&quot;#定义和初始化&quot; class=&quot;headerlink&quot; title=&quot;定义和初始化&quot;&gt;&lt;/a&gt;定义和初始化&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
  <entry>
    <title>C++泛型算法</title>
    <link href="https://chaomai.github.io/2014/2014-02-23-cpp-generic-algorithm/"/>
    <id>https://chaomai.github.io/2014/2014-02-23-cpp-generic-algorithm/</id>
    <published>2014-02-23T06:10:17.000Z</published>
    <updated>2021-06-27T14:57:29.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><ul><li>一般泛型算法不直接操作容器，而是运行于迭代器之上，由迭代器来进行操作；</li><li>迭代器令算法不依赖于容器，但是某些算法使用的操作需要元素的类型；</li><li>算法不会直接改变底层容器的大小；</li><li>算法可能改变元素的值或移动元素，但不会直接添加或删除元素。</li></ul><h1 id="按使用元素的方式分类"><a href="#按使用元素的方式分类" class="headerlink" title="按使用元素的方式分类"></a>按使用元素的方式分类</h1><h2 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h2><h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><p><code>accumulate</code>的第三个参数类型决定了函数中使用那个加法运算符以及返回值的类型。</p><ul><li>如果这个类型不支持+运算符，则会发生编译错误；</li><li>如果元素类型与这个类型不匹配，且能够类型转换，无论哪个类型宽窄，只会发生<strong>元素类型-&gt;第三个参数类型</strong>。</li></ul><h3 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h3><p>按元素比较，第二个序列<strong>至少与第一个序列一样长</strong>。</p><p>如果两个序列类型分别为，<code>vector&lt;const char*&gt;</code>和<code>list&lt;const char*&gt;</code>，则比较的是地址，不是字符串的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; vcc&#123;<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; lcc&#123;<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于编译器优化，vcc和lcc实际上共享了字面值常量，故下面的地址相同。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; equal(vcc.begin(), vcc.end(), lcc.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(vcc.front())) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 0x40c951</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(lcc.front())) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 0x40c951</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> b[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;cd&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; vcc1&#123;begin(a), end(a)&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; lcc1&#123;begin(b), end(b)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; equal(vcc1.begin(), vcc1.end(), lcc1.begin()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(vcc1.front())) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 0x40c908</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(lcc1.front())) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 0x40c911</span></span><br></pre></td></tr></table></figure><h2 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h2><p>这类算法并不检查写操作。由于算法不会改变底层容器的大小，因此必须保证<strong>目的位置迭代器开始</strong>序列足够容纳要写入的元素。</p><p><code>copy</code>返回的是目的位置迭代器递增后的值。</p><h2 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h2><p><code>unique</code>“移除”了<strong>相邻重复</strong>元素，把不重复的元素移动到了序列前面，并非删除。返回不重复元素范围末尾的下一个迭代器。</p><h1 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h1><h2 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h2><p>某些算法需要进行元素间的比较，如果需要使用与定义行为不同的比较，或者元素类型未定义<code>&lt;</code>运算符，则需要通过提供谓词，重载算法的默认行为。</p><p>谓词是可调用的表达式，返回结果是一个能用着条件的值，分为，</p><ul><li>一元谓词；</li><li>二元谓词。</li></ul><p>序列中的元素作为实参传入谓词，因此需要满足函数匹配规则。</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>是可调用对象，callable object有，</p><ul><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>lambda表达式</li><li>bind创建的对象</li></ul><p>使用lambda，要注意的是，</p><ul><li><p>lambda必须使用尾置返回，可以忽略参数列表和返回类型（忽略时，从代码中推断）；</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure></li><li><p>lambda不能有默认参数；</p></li><li><p>对于lambda所在函数体的<strong>非static局部变量</strong>，只能使用在<strong>捕获列表</strong>中捕获后，才能使用；</p></li><li><p>对于<strong>局部static变量和lambda所在函数体之外声明的名字</strong>，可以<strong>直接使用</strong>。</p></li></ul><p>如果lambda捕获列表为空，那么lambda可以转换为函数指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="comment">// f自动转换为pointer</span></span><br><span class="line"><span class="keyword">int</span> (*pf)(<span class="keyword">int</span>, <span class="keyword">int</span>) = f;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pf(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>定义lambda时，编译器生成一个与lambda对应的未命名类类型。用auto定义一个用lambda初始化的变量时，就定义了一个相应的未命名类类型的对象。lambda的数据成员在lambda对象创建时被初始化。</p><p>类似函数的参数传递，捕获方式有，</p><p>每种方式都可以进行，</p><ul><li><p>值捕获</p><p>  被捕或的变量的值是在lambda创建时拷贝，而不是像函数调用时才拷贝。能使用值捕获的前提是<strong>变量可拷贝</strong>。</p></li><li><p>引用捕获</p><p>  <code>&amp;</code>表示以引用的方式捕获。<br>  引用捕获与返回引用有相同的问题和限制，必须保证引用的对象在<strong>lambda执行时存在</strong>，且在执行时是所期望的（可能在被捕或后和执行前，引用的对象的值改变了）。如果函数返回lambda，则不能包含局部非static变量的捕获。</p></li></ul><p>按是否显示列出希望使用的变量，可分为，</p><ul><li><p>显式捕获</p><p>  <code>[v1, ...]</code>或<code>[&amp;v1, ...]</code></p></li><li><p>隐式捕获</p><ul><li>值捕获，<code>[&amp;]</code></li><li>引用捕获，<code>[=]</code></li></ul></li><li><p>混合使用显式和隐式捕获</p><p>  当混合使用显式和隐式捕获时，显示捕获的变量必须使用<strong>与隐式捕获不</strong>同的方式。</p><ul><li><p><code>[&amp;, identifier_list]</code></p><p>  任何<strong>隐式捕获</strong>的变量都采用<strong>引用捕获</strong>，<strong>identifier_list</strong>采用<strong>值捕获</strong>的方式，且identifier_list中的名字**不能使用<code>=</code>**。</p></li><li><p><code>[=, identifier_list]</code></p><p>  任何<strong>隐式捕获</strong>的变量都采用<strong>值捕获</strong>，<strong>identifier_list</strong>采用<strong>引用捕获</strong>的方式，且identifier_list中的名字**必须使用<code>&amp;</code>**。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> l = [=, &amp;c]()&#123;&#125;;</span><br><span class="line"><span class="comment">// auto l = [=, c]()&#123;&#125;; 错误</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h3><p> 默认情况下，<strong>值捕获的变量</strong>，lambda不会改变被捕获变量的值（并非改变原始变量），如果需要改变，加入<code>mutable</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> l2 = [a]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">  ++a; <span class="comment">// 如果无mutable，则错误</span></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1， 并非改变原始变量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l2() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>引用捕获无此限制，能够更改依赖于被引用变量是否为<code>const</code>。</p><h3 id="lambda的返回值"><a href="#lambda的返回值" class="headerlink" title="lambda的返回值"></a>lambda的返回值</h3><p>默认情况下，如果一个lambda包含return之外的任何语句，编译器假定此lambda返回void。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>由于<code>find_if</code>接受的是一个一元谓词，因此含有两个形参的函数是不可用的。</p><p><code>bind</code>生成一个新的可调用对象，可看做一个通用的函数适配器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list)</span><br></pre></td></tr></table></figure><p>arg_list可包含<code>_n</code>，表示<code>newCallable</code>的参数，参数的类型就是callable中<code>_n</code>处的类型。其中n代表了占位符<code>_n</code>在<code>newCallable</code>的位置，调用<code>newCallable</code>时，<code>_n</code>处的参数最终会传递到callable中<code>_n</code>相应的位置。</p><p><code>_n</code>定义在<code>placeholders</code>的namespace中，使用时需，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br></pre></td></tr></table></figure><p>默认情况下，<strong>不是占位符的参数</strong>是被<strong>拷贝</strong>到bind返回的可调用对象中的。如果想传递引用，就必须显式的指明，使用<code>ref</code>。<code>ref</code>返回的对象包含给定的引用，是<strong>可拷贝</strong>的。类似的还有<code>cref</code>，返回<code>const</code>引用。</p><h1 id="额外的迭代器"><a href="#额外的迭代器" class="headerlink" title="额外的迭代器"></a>额外的迭代器</h1><p>除每个容器的定义的迭代器外，还有以下几种，</p><h2 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h2><p>是一种迭代器适配器，对插入迭代器赋值时，该迭代器<strong>调用容器的操作</strong>来进行插入。<code>*</code>和前置后置<code>++</code>会直接返回迭代器，<strong>并不会修改</strong>。</p><p>插入迭代器有以下几种，</p><ul><li><p><code>back_inserter</code></p><p>  创建使用<code>push_back</code>的迭代器，始终在尾部插入。</p></li><li><p><code>front_inserter</code></p><p>  创建使用<code>push_front</code>的迭代器，始终在首部插入。</p></li><li><p><code>inserter</code></p><p>  创建使用<code>insert</code>的迭代器，始终在迭代器it指定位置前插入。插入后it还是指向一开始指定的位置。</p></li></ul><h2 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h2><h3 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a><code>istream_iterator</code></h3><p>读取输入流，必须指定迭代器将要读写的对象类型，且要读取的类型必须支持<code>&gt;&gt;</code>（由于是调用<code>&gt;&gt;</code>来读取）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof; <span class="comment">// 默认初始化，尾后迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (int_it != eof) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(int_it, eof)</span></span>;</span><br></pre></td></tr></table></figure><p>当绑定到流时，标准库并不保证迭代器立即从流中读取数据，而是<strong>保证在首次解引用前，完成了数据的读取</strong>。</p><h3 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a><code>ostream_iterator</code></h3><p>类似<code>istream_iterator</code>，使用<code>&lt;&lt;</code>写入输出流（类型必须支持<code>&lt;&lt;</code>）。<strong>必须</strong>绑定到一个输入流，可指定一个每次写入时都输出的字符。<code>*</code>和前置后置<code>++</code>会直接返回迭代器，<strong>并不会修改</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out</span><span class="params">(<span class="built_in">cout</span>)</span></span>;</span><br><span class="line"><span class="comment">// ostream_iterator&lt;int&gt; out(cout, &quot; &quot;); 字面值常量或指向C风格的字符串</span></span><br><span class="line"></span><br><span class="line">out = <span class="number">5</span>; <span class="comment">// 类型必须与out定义的类型兼容</span></span><br></pre></td></tr></table></figure><h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><p>也是一种迭代器适配器。只能从一个支持++和–的迭代器来定义反向迭代器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    cbegin()                                     cend()</span><br><span class="line">     |                                            |</span><br><span class="line">    [], [], [], [], [], [], [], [], [], [], [], []</span><br><span class="line">   |                                             |</span><br><span class="line">crend()                                         crbegin()</span><br><span class="line"></span><br><span class="line">cbegin()                 rit.base()         cend()</span><br><span class="line"> |                           |                |</span><br><span class="line">[], [], [], [], [], [], [], [], [], [], [], []</span><br><span class="line">                         |                   |</span><br><span class="line">                        rit               crbegin()</span><br><span class="line"></span><br><span class="line"> [crbegin(), rit)和[rit.base(), cend())指向相同的范围。</span><br></pre></td></tr></table></figure><p>可以对反向迭代器调用<code>base()</code>来得到普通的迭代器。<code>base()</code>得到的是相邻的位置。</p><h2 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h2><p>一个移动迭代器通过改变给定迭代器的解引用运算符的行为来<strong>适配</strong>此迭代器。对移动迭代器<strong>解引用</strong>生成的是一个<strong>右值</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newe = uninitialized_copy(make_move_iterator(elements), make_move_iterator(cap), newb);</span><br></pre></td></tr></table></figure><p>通过调用<code>make_move_iterator</code>可将一个普通迭代器转换为一个移动迭代器。上面的代码中，传递给<code>uninitialized_copy</code>的是一个移动迭代器，解引用后得到的是右值，因此<code>uninitialized_copy</code>将使用移动构造函数来构造元素。</p><h1 id="泛型算法的结构"><a href="#泛型算法的结构" class="headerlink" title="泛型算法的结构"></a>泛型算法的结构</h1><h2 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h2><p>按算法所要求的迭代器操作，可将迭代器分为下面几类，<strong>除了输出迭代器外</strong>，高层类别的迭代器支持低层类别迭代器的所有操作。C++标准指明了泛型和数值算法的每个迭代器参数的<strong>最小类别</strong>。</p><ol><li><p>输入迭代器</p><p> <strong>只读，不写；单遍扫描，只能递增</strong></p><p> 支持，</p><ul><li><p><code>==</code>，<code>!=</code></p></li><li><p>前置后置<code>++</code>，可能导致所有其他指向流的迭代器<strong>失效</strong>，不能保证输入迭代器的状态可以保存下来，即只能单遍扫描</p></li><li><p><code>*</code>，只能在赋值运算的<strong>右侧</strong></p></li><li><p><code>-&gt;</code></p><p>例子：<code>find</code>，<code>accumulate</code>。</p></li></ul></li><li><p>输出迭代器</p><p> <strong>只写，不读；单遍扫描，只能递增</strong></p><p> 支持，</p><ul><li><p>前置后置<code>++</code></p></li><li><p><code>*</code>，只能在赋值运算的<strong>左侧</strong></p><p>例子：用作目的位置的迭代器，如<code>copy</code>。</p></li></ul></li><li><p>前向迭代器</p><p> <strong>可读写；多遍扫描，只能递增</strong></p><p> 支持，</p><ul><li><p>所有输入和输出迭代器的操作</p><p>例子：<code>replace</code>，<code>forward_list</code>的迭代器。</p></li></ul></li><li><p>双向迭代器</p><p> <strong>可读写；多遍扫描，可递增递减</strong></p><p> 支持，</p><ul><li><p>所有前向迭代器的操作</p></li><li><p>前置后置<code>--</code></p><p>例子：<code>reverse</code>，除了<code>forward_list</code>的迭代器，其他标准库容器的迭代器都符合双向迭代器。</p></li></ul></li><li><p>随机访问迭代器</p><p> <strong>可读写；多遍扫描，支持全部迭代器的运算</strong></p><p> 支持，</p><ul><li><p><code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code></p></li><li><p>和整数的<code>+</code>，<code>-</code>，<code>+=</code>，<code>-=</code></p></li><li><p>两个迭代器的<code>-</code></p></li><li><p><code>iter[n]</code>，等价于<code>*(iter[n])</code></p><p>例子：<code>sort</code>，<code>array</code>、<code>deque</code>、<code>string</code>和<code>vector</code>的迭代器。</p></li></ul></li></ol><h2 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h2><ul><li><code>alg(beg, end, other, args);</code></li><li><code>alg(beg, end, dest, other, args);</code></li><li><code>alg(beg, end, beg2, other, args);</code></li><li><code>alg(beg, end, beg2, end2, other, args);</code></li></ul><p>向输出迭代器<code>dest</code>写入数据的算法都假设，目标位置有足够的空间。<br>接受单独<code>beg2</code>的算法假定从<code>beg2</code>开始的序列与<code>[beg, end)</code>所表示的范围至少一样大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;泛型算法&quot;&gt;&lt;a href=&quot;#泛型算法&quot; class=&quot;headerlink&quot; title=&quot;泛型算法&quot;&gt;&lt;/a&gt;泛型算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一般泛型算法不直接操作容器，而是运行于迭代器之上，由迭代器来进行操作；&lt;/li&gt;
&lt;li&gt;迭代器令算法不依赖于容</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ 初始化</title>
    <link href="https://chaomai.github.io/2014/2014-02-17-cpp-initialization/"/>
    <id>https://chaomai.github.io/2014/2014-02-17-cpp-initialization/</id>
    <published>2014-02-17T12:56:12.000Z</published>
    <updated>2021-06-27T14:57:29.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表初始化（list-initialization）"><a href="#列表初始化（list-initialization）" class="headerlink" title="列表初始化（list initialization）"></a>列表初始化（list initialization）</h1><p>注：对于内置类型的变量，如果使用列表初始化且初始化存在丢失信息的风险，则编译器将报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> i&#123;d&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h1 id="默认初始化（default-initialization）"><a href="#默认初始化（default-initialization）" class="headerlink" title="默认初始化（default initialization）"></a>默认初始化（default initialization）</h1><p>如果定义变量时没有指定初值，则变量被默认初始化，具体值由变量类型决定。对象被默认初始化时自动执行默认构造函数。</p><h2 id="何时发生"><a href="#何时发生" class="headerlink" title="何时发生"></a>何时发生</h2><ul><li>当在块作用域中不使用任何初始值定义一个非静态变量或者数组时；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">double</span> b[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>当一个类本身含有类类型的成员且使用合成的默认构造函数时；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  A a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>当类类型的成员没有在构造函数初始值列表中显示地初始化时。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  A(<span class="keyword">int</span> a) : a_(a) &#123;&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> a_;</span><br><span class="line">  <span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h1><p>对于内置类型，则元素初始值自动设为0；如果是类类型，则由类来默认初始化。</p><h2 id="何时发生-1"><a href="#何时发生-1" class="headerlink" title="何时发生"></a>何时发生</h2><ul><li>在数组初始化时，提供的初始值的数量少于数组的大小；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// a[] = &#123;1, 2, 3, 0, 0&#125;</span></span><br></pre></td></tr></table></figure></li><li>不使用初始值定义一个局部静态变量时；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> s; <span class="comment">// s值为0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用<code>T()</code>来显示地请求值初始化时;</li><li>使用列表初始化来初始化聚合类，列表中元素数量少于类的成员数量时，后续成员被值初始化。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aggre</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Aggre aggre = &#123;<span class="number">1</span>&#125; <span class="comment">// d和c都是0</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol><li><a href="https://www.zhihu.com/question/36735960">C++值初始化，默认初始化，以及其他初始化类型的区别</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;列表初始化（list-initialization）&quot;&gt;&lt;a href=&quot;#列表初始化（list-initialization）&quot; class=&quot;headerlink&quot; title=&quot;列表初始化（list initialization）&quot;&gt;&lt;/a&gt;列表初始化（li</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
  <entry>
    <title>C++IO库</title>
    <link href="https://chaomai.github.io/2014/2014-02-16-cpp-io-library/"/>
    <id>https://chaomai.github.io/2014/2014-02-16-cpp-io-library/</id>
    <published>2014-02-16T14:10:25.000Z</published>
    <updated>2021-06-27T14:57:29.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a><code>iostream</code></h1><h2 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h2><p><code>strm::iostate</code>是<strong>机器相关</strong>的位类型，用来标识流错误状态，有4个值，<code>strm::badbit</code>，<code>strm::failbit</code>，<code>strm::eofbit</code>和<code>strm::goodbit</code>。可用<code>ios::bad()</code>，<code>ios::fail()</code>，<code>ios::eof()</code>和<code>ios::good()</code>来得知各个flag是否置位；用<code>ios::rdstate()</code>来获取流的当前状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">badbit: 0001</span><br><span class="line">failbit: 0100</span><br><span class="line">eofbit: 0010</span><br><span class="line">goodbit: 0000</span><br></pre></td></tr></table></figure><p>不同的错误会导致不同的flag被置位，</p><ul><li>eof -&gt; eofbit，failbit</li><li>fail -&gt; failbit</li><li>bad -&gt; badbit，且fail()返回true</li></ul><p>用<code>ios::clear()</code>和<code>ios::setstate()</code>可以对flag进行置位，两者区别在于，<code>ios::clear()</code>会先将原先的所有flag先复位，而后者不会，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ios::setstate</span> <span class="params">(iostate state)</span> </span>&#123;</span><br><span class="line">  clear(rdstate() | state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出缓冲"><a href="#输出缓冲" class="headerlink" title="输出缓冲"></a>输出缓冲</h2><p>每个输出流都管理一个缓冲区。</p><h3 id="缓冲刷新"><a href="#缓冲刷新" class="headerlink" title="缓冲刷新"></a>缓冲刷新</h3><p>即数据真正写到输出设备或文件，会有以下原因，</p><ul><li>程序正常结束，main函数return；</li><li>缓冲区满，需要刷新才能写入后续数据；</li><li>使用操纵符；<ul><li><code>endl</code>：换行并刷新缓冲区；</li><li><code>flush</code>：刷新缓冲区，不附加任何额外字符；</li><li><code>ends</code>：附加一个空字符，刷新缓冲区。</li></ul></li><li><code>unitbuf</code>和<code>nounitbuf</code>；<br>  使用<code>unitbuf</code>后，接下来的每次写操作都进行一次flush；使用<code>nounitbuf</code>返回正常的缓冲方式。</li><li>关联输入流和输出流。<br>  关联一个输入流到输出流时，从输入流读取数据，会先刷新关联的输出流，<code>cin</code>和<code>cout</code>是被关联的。使用<code>tie</code>进行关联。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tie的两个重载版本</span></span><br><span class="line"><span class="comment">// 两个版本都返回已经tied ostream，如果没有，则返回nullptr</span></span><br><span class="line">ostream* os = <span class="built_in">cin</span>.tie();</span><br><span class="line">(*os) &lt;&lt; <span class="string">&quot;tie version 1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ostream* old_os = <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">ostream* null_os = <span class="built_in">cin</span>.tie();</span><br><span class="line">(*old_os) &lt;&lt; <span class="string">&quot;tie version 2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; (old_os == &amp;<span class="built_in">cout</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; (null_os == <span class="literal">nullptr</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="comment">// 此时上面的两个true并不会输出</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h1 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a><code>fstream</code></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: iostream</span><br><span class="line">op2&#x3D;&gt;operation: fstream</span><br><span class="line"></span><br><span class="line">op2(right)-&gt;op1</span><br></pre></td></tr></table></figure><p>继承自<code>iostream</code>，</p><ul><li>接受一个<code>iostream</code>类型引用或指针参数的函数，可用一个对应的<code>fstream</code>类型来调用；</li><li>支持<code>iostream</code>的所有操作。</li></ul><p><code>fstream</code>也有自己特有的行为和操作，</p><ul><li><code>fstream::fstream(s)</code>：创建对象并打开文件<code>s</code>；</li><li><code>fstream::open()</code>：打开文件，并与<code>fstream</code>对象关联；</li><li><code>fstream::close()</code>：关闭与<code>fstream</code>对象关联的文件；</li><li><code>fstream::is_open()</code>：与<code>fstream</code>对象关联的文件是否成功打开，且未关闭；</li><li>对于已打开的<code>fstream</code>对象，再次<code>open()</code>会失败；</li><li><code>open()</code>失败-&gt;failbit；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (ifs) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>当<code>fstream</code>对象被销毁，<code>close()</code>会被自动调用。</li></ul><h2 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h2><p>对于<code>ofstream</code>，</p><ul><li>未指定打开模式时，以<code>out</code>打开；</li><li>通常<code>out</code>意味着同时使用<code>trunc</code>；</li><li><code>app</code>不能与<code>trunc</code>同时设置；</li><li><code>app</code>和<code>ate</code>；<ul><li><code>app</code>，所有的输出操作都在文件末尾，不能seek around；</li><li><code>ate</code>，初始位置在文件末尾，可以seed around。</li></ul></li></ul><h1 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a><code>sstream</code></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">op1&#x3D;&gt;operation: iostream</span><br><span class="line">op2&#x3D;&gt;operation: sstream</span><br><span class="line"></span><br><span class="line">op2(right)-&gt;op1</span><br></pre></td></tr></table></figure><p>类似<code>fstream</code>，<code>sstream</code>也包含特有的操作，</p><ul><li><code>sstream::sstream(s)</code>：创建对象，并保存<code>s</code>的copy；</li><li><code>sstream::str()</code>：返回保存的string的copy；</li><li><code>sstream::str(s)</code>：copy<code>s</code>到对象中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iostream&quot;&gt;&lt;a href=&quot;#iostream&quot; class=&quot;headerlink&quot; title=&quot;iostream&quot;&gt;&lt;/a&gt;&lt;code&gt;iostream&lt;/code&gt;&lt;/h1&gt;&lt;h2 id=&quot;条件状态&quot;&gt;&lt;a href=&quot;#条件状态&quot; class=</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
  <entry>
    <title>C++Primer - 第1章 开始</title>
    <link href="https://chaomai.github.io/2014/2014-02-06-cpp-primer-ch1/"/>
    <id>https://chaomai.github.io/2014/2014-02-06-cpp-primer-ch1/</id>
    <published>2014-02-06T15:06:00.000Z</published>
    <updated>2021-06-27T14:57:29.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓冲区（bufer）"><a href="#缓冲区（bufer）" class="headerlink" title="缓冲区（bufer）"></a>缓冲区（bufer）</h1><p>一个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的。我们可以显式地刷新输出缓冲，以便强制将缓冲区中的数据写入输出设备。默认情况下，读cin会刷新cout；程序非正常终止时也会刷新cout。</p><h1 id="cerr"><a href="#cerr" class="headerlink" title="cerr"></a>cerr</h1><p>一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到cerr的数据是不缓冲的。cerr通常用于输出错误信息或其他不属于程序正常逻辑的输出内容。</p><h1 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h1><p>一种定义自己的数据结构及其相关操作的机制。</p><h1 id="类类型（class-type）"><a href="#类类型（class-type）" class="headerlink" title="类类型（class type）"></a>类类型（class type）</h1><p>类定义的类型。类名即为类型名。</p><h1 id="clog"><a href="#clog" class="headerlink" title="clog"></a>clog</h1><p>一个ostream对象，关联到标准错误。默认情况下，写到clog的数据是被缓冲的。clog通常用于报告称程序的执行信息，存入一个日志文件中。</p><p>未初始化的变量（uninitialized variable）</p><p>未赋予初值的变量。类类型的变量如果未指定初值，则按类定义指定的方式进行初始化。定义在函数内部的内置类型变量默认是不初始化的，除非有显式的初始化语句。</p><h1 id="变量（variable）"><a href="#变量（variable）" class="headerlink" title="变量（variable）"></a>变量（variable）</h1><p>具名对象。</p><h1 id="运算符（-opeartor）"><a href="#运算符（-opeartor）" class="headerlink" title="()运算符（()opeartor）"></a>()运算符（()opeartor）</h1><p>调用运算符。跟随在函数名字之后的一对括号“()”，起到调用函数的效果，传递给函数的实参放置在括号内。</p><h1 id="运算符（-operator）"><a href="#运算符（-operator）" class="headerlink" title=".运算符（.operator）"></a>.运算符（.operator）</h1><p>点运算符。左侧运算符必须是一个类类型对象，右侧运算对象必须是此对象的一个成员的名字。运算结果即为该对象的这个成员。</p><h1 id="运算符（-operator）-1"><a href="#运算符（-operator）-1" class="headerlink" title="::运算符（::operator）"></a>::运算符（::operator）</h1><p>作用域运算符。其用处之一是访问命名空间中的名字。</p><h1 id="lt-lt-和-gt-gt-运算符（-lt-lt-operator-gt-gt-operator）"><a href="#lt-lt-和-gt-gt-运算符（-lt-lt-operator-gt-gt-operator）" class="headerlink" title="&lt;&lt;和&gt;&gt;运算符（&lt;&lt;operator, &gt;&gt;operator）"></a>&lt;&lt;和&gt;&gt;运算符（&lt;&lt;operator, &gt;&gt;operator）</h1><p>输出和输入运算符。它们的计算结果均是其左侧的运算对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓冲区（bufer）&quot;&gt;&lt;a href=&quot;#缓冲区（bufer）&quot; class=&quot;headerlink&quot; title=&quot;缓冲区（bufer）&quot;&gt;&lt;/a&gt;缓冲区（bufer）&lt;/h1&gt;&lt;p&gt;一个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区</summary>
      
    
    
    
    <category term="cpp" scheme="https://chaomai.github.io/categories/cpp/"/>
    
    
    <category term="c++ primer" scheme="https://chaomai.github.io/tags/c-primer/"/>
    
  </entry>
  
</feed>
