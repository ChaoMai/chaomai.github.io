# 数据结构和算法整理
# 排序
|      | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性 | 特点 |
|------|------------|-------|-------|-------|-------|--------------------|
| 冒泡排序 | $O(n^2)$ | $O(n)$ | $O(n^2)$ | $O(1)$ | 稳定 |                    |
| 选择排序 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 不稳定 | 运行时间与数组是否有序无关，数据移动是最少的 |
| 插入排序 | $O(n^2)$ | $O(n)$ | $O(n^2)$ | $O(1)$ | 稳定 | 对于接近有序的数组，运行时间接近$O(n)$ |
| 希尔排序 | - | - | - | $O(1)$ | 不稳定 | 步长序列的选择会[影响时间复杂度](https://en.wikipedia.org/wiki/Shellsort)  |
| 归并排序 | $O(n\log n)$ | $O(n\log n)$ | $O(n\log n)$ | $O(n)$ | 稳定 |                    |
| 快速排序 | $O(n\log n)$ | $O(n\log n)$ | $O(n^2)$ | $O(\log n)$ | 不稳定 |                    |
|  堆排序  | $O(n\log n)$ | $O(n\log n)$ | $O(n\log n)$ || 不稳定 | 很少用，因为数组元素很少与相邻的元素比较，cache miss较高，甚至高于shell sort |

## 相关题目
* leetcode [147] Insertion Sort List
* leetcode [148] Sort List
* leetcode [215] Kth Largest Element in an Array

## 冒泡排序
数组分为两个部分，左边无序的，右边有序的，每次都选择无序部分的最大元素，与无序部分的最后一个交换，并将这个元素归入有序，重复直到无序部分长度为0。

```cpp
for (int i = 0; i < nums.size(); i++) {
    for (int j = 1; j < nums.size() - i; j++) {
        if (nums[j - 1] > nums[j]) {
            swap(nums[j - 1], nums[j]);
        }
    }
}
```

## 选择排序
数组分为两个部分，左边有序的，右边无序的，每次都选择无序部分最小的元素，与无序部分的第一个交换，并将这个元素归入有序，重复直到无序部分长度为0。

```cpp
for (int i = 0; i < nums.size(); i++) {
    int min_idx = i;
    int min = INT_MAX;
    for (int j = i; j < nums.size(); j++) {
        if (nums[j] < min) {
            min_idx = j;
            min = nums[j];
        }
    }
    swap(nums[i], nums[min_idx]);
}
```

## 插入排序
### 数组版本
数组分为两个部分，左边有序的，右边无序的，每次取无序的部分的第一个元素，插入有序部分，重复直到无序部分长度为0。

```cpp
for (int i = 0; i < nums.size(); i++) {
    for (int j = i; j > 0; j--) {
        if (nums[j - 1] > nums[j]) {
            swap(nums[j - 1], nums[j]);
        } else {
            break;
        }
    }
}
```

### 链表版本
* 加入一个dummy head，便于处理需要在头结点之前插入的情况。
* 内部循环只找出待插入的位置，不进行插入操作。
    * 如果在内部循环进行插入，那么当需要在新队列末尾插入的时候，就需要进行[特殊处理](https://github.com/chaomai/data_structure_and_algorithms/blob/master/leetcode/147.insertion-sort-list.cpp#L108)，因为此时`pj = nullptr`，是无法开始下一次循环的。
* 返回`dummy_head->next`，不要在声明`dummy_head`的时候，`new_head = dummy_head->next`，最后返回`new_head`，因为可能在`dummy_head`后面插入。

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* insertionSortList(ListNode* head) {
    if (head == nullptr) {
        return nullptr;
    }

    // new_head: sorted list
    // insert pi into new_head
    ListNode* dummy_head = new ListNode(INT_MIN);
    dummy_head->next = head;
    ListNode* pi = head->next;
    dummy_head->next->next = nullptr;

    while (pi != nullptr) {
        ListNode* pj = dummy_head->next;
        ListNode* pj_prev = dummy_head;

        while (pj != nullptr) {
            if (pj->val > pi->val) {
                break;
            }

            pj_prev = pj;
            pj = pj->next;
        }

        pj_prev->next = pi;
        pi = pi->next;
        pj_prev->next->next = pj;
    }

    ListNode* new_head = dummy_head->next;
    delete dummy_head;
    return new_head;
}
```

## 希尔排序
基于插入排序，使数组间隔为`h`的元素都是有序的，当`h`减少到1时，整个数组就是有序的。

```cpp
for (int h = nums.size(); h > 0; h >>= 1) {
    for (int i = h; i < nums.size(); i++) {
        for (int j = i; j > 0 && j - h >= 0; j -= h) {
            if (nums[j - h] > nums[j]) {
                swap(nums[j - h], nums[j]);
            } else {
                break;
            }
        }
    }
}
```

加上`j - h >= 0`是因为，
1. `j`每次走`h`，`h`不一定是1，因此可能会走过头，出现`j`小于0。
2. 当`h = 1`的时候，如果`j = 1`，则`j - h > 0`不成立，但是此时是需要检查`j[0]`与`j[1]`的大小的。

## 归并排序
### 数组版本
关键点是把两个有序数据合并为一个有序数组。使用分治的思想，递归地拆分数组，当分到不可再分的时候（单个元素时），逐级返回进行合并。

注意的点：
* 我下标的使用习惯是`[b, e)`，前开后闭，这样选取`mid`以后，两个子数组的可以表示为`[b, mid)`和`[mid, e)`，没有+1和-1，比较简洁方便。
* 递归过程中，对小数组使用插入排序可以减少10%~15%的运行时间。

```cpp
vector<int> tmp(nums.size());
merge_sort(nums, tmp, 0, nums.size());

// merge sort [b, e)
void merge_sort(vector<int>& nums, vector<int>& tmp, int b, int e) {
    // [b, e)是待排序数组，如果e - b <= 1，那么区间内将没有元素或只有一个元素，因此直接返回
    if (e - b <= 1) {
        return;
    }

    int mid = b + (e - b) / 2;
    merge_sort(nums, tmp, b, mid);
    merge_sort(nums, tmp, mid, e);

    for (int i = b; i < e; i++) {
        tmp[i] = nums[i];
    }

    int i = b;
    int b1 = b;
    int b2 = mid;
    while (b1 < mid && b2 < e) {
        if (tmp[b1] < tmp[b2]) {
            nums[i] = tmp[b1];
            b1++;
        } else {
            nums[i] = tmp[b2];
            b2++;
        }
        i++;
    }

    while (b1 < mid) {
        nums[i] = tmp[b1];
        b1++;
        i++;
    }

    while (b2 < e) {
        nums[i] = tmp[b2];
        b2++;
        i++;
    }
}
```

### 链表版本
* 主要难点在于找到中点，由于无法事先知道总长度，因此无法避免需要遍历一次链表。采用双指针的方式，分别是每次走一步和两步，走两步的到达结尾，走一步的就处于中点位置。每次寻找中点的时候都需要做一次。
* 链表进行归并比数组简单，而且只需要$O(1)$的额外空间。

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
```

## 快速排序
快速排序也是采用了分治的思想，选取一个pivot以后，将数组分为`<= pivot`和`> pivot`的部分，然后递归的执行这个过程。

### 数组版本1
`[b + 1, m)`表示`<= pivot`的部分，`[m, e)`表示`> pivot`的部分，初始时，两个区间都是空的。遍历`[b, e)`，并调整`<= pivot`的部分。

要注意的是，
* 数组分区结束后，pivot应该与`m`，`m - 1`还是`m + 1`交换？
    1. 当选择`nums[0]`作为pivot的时候，如果选择`m`，`[m, e)`内是`> pivot`的，不可行；只能选择`m - 1`。
    2. 类似的当选择`nums[nums.size() - 1]`作为pivot的时候，应该是`m`。
* pivot不再参与后续的排序。
    由于已经数组分为`<= pivot`和`> pivot`的部分，pivot的位置已经是正确的了，不需要再参与排序。
    
```cpp
quick_sort(nums, 0, nums.size());

// quick sort [b. e)
void quick_sort(vector<int>& nums, int b, int e) {
    if (b >= e) {
        return;
    }

    // partition [b, e)
    // b: pivot
    // [b + 1, m): <= pivot
    // [m, e): > pivot
    int pivot = nums[b];
    int m = b + 1;
    for (int i = b + 1; i < e; i++) {
        if (nums[i] <= pivot) {
            swap(nums[i], nums[m]);
            m++;
        }
    }

    swap(nums[b], nums[m - 1]);

    // m - 1不再参与接下来的排序
    quick_sort(nums, b, m-1);
    quick_sort(nums, m, e);
}
```

### 数组版本2
从`[b, e)`的两侧来进行处理，`[b + 1, i)`表示`<= pivot`的部分，`(j, e)`表示`> pivot`的部分。

```cpp
// quick sort [b. e)
void quick_sort(vector<int>& nums, int b, int e) {
    if (b >= e) {
        return;
    }

    // partition [b, e)
    // b: pivot
    // [b + 1, i): <= pivot
    // (j, e): > pivot
    int pivot = nums[b];
    int i = b + 1;
    int j = e - 1;
    while (true) {
        while (i < e) {
            if (nums[i] > pivot) {
                break;
            }
            i++;
        }

        while (j > b) {
            if (nums[j] <= pivot) {
                break;
            }
            j--;
        }

        if (i >= j) {
            break;
        }

        swap(nums[i], nums[j]);
    }

    swap(nums[b], nums[j]);

    // j不再参与接下来的排序
    quick_sort(nums, b, j);
    quick_sort(nums, j + 1, e);
}
```

### 链表版本
* 思路类似数组版本1，分为`<= pivot`和`> pivot`的两个部分。这里由于是链表，划分就简单了很多。
* 难点在于，何时返回、以及返回什么，以及如何把两个部分的排序结果组合起来。
    1. 何时返回？
        * 头指针为空时。
        * 链表只有一个元素时。
    2. 返回什么？
        考虑到需要组合两次排序的结果，因此需要返回链表的头尾节点。
    3. 如何组合两个部分的排序结果？
        需要分情况。先看`<= pivot`部分，此时需要判断最后返回的头结点是什么，
        1. `<= pivot`不为空时，应该组合`<= pivot` + `pivot`的部分，头结点为`<= pivot`的头结点。
        2. `<= pivot`为空时，只保留`pivot`，头结点为`pivot`。
        
        再看`> pivot`部分，此时需要判断最后返回的尾结点是什么，
        
        1. `> pivot`不为空，前面结果 + `> pivot`的部分，尾节点为`> pivot`的为节点。
        2. `> pivot`为空，尾节点为`pivot`。

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode* r_b = nullptr;
ListNode* r_e = nullptr;
quick_sort(head, &r_b, &r_e);

void quick_sort(ListNode* head, ListNode** ret_b, ListNode** ret_e) {
    if (head == nullptr) {
        *ret_b = nullptr;
        *ret_e = nullptr;
        return;
    }

    if (head->next == nullptr) {
        *ret_b = head;
        *ret_e = head;
        return;
    }

    ListNode* pivot = head;
    ListNode* pi = pivot->next;
    // <= pivot
    ListNode* dummy_head1 = new ListNode(INT_MIN);
    ListNode* di = dummy_head1;
    // > pivot
    ListNode* dummy_head2 = new ListNode(INT_MIN);
    ListNode* dj = dummy_head2;

    while (pi != nullptr) {
        if (pi->val <= pivot->val) {
            di->next = pi;
            di = di->next;
        } else {
            dj->next = pi;
            dj = dj->next;
        }
        pi = pi->next;
    }

    di->next = nullptr;
    dj->next = nullptr;
    di = dummy_head1->next;
    dj = dummy_head2->next;
    delete dummy_head1;
    delete dummy_head2;

    ListNode* ri_b = nullptr;
    ListNode* ri_e = nullptr;
    ListNode* rj_b = nullptr;
    ListNode* rj_e = nullptr;
    quick_sort(di, &ri_b, &ri_e);
    quick_sort(dj, &rj_b, &rj_e);

    // ri_e -> pivot -> rj_b
    if (ri_b != nullptr) {
        *ret_b = ri_b;
        ri_e->next = pivot;
        pivot->next = rj_b;
    } else {
        *ret_b = pivot;
        pivot->next = rj_b;
    }

    if (rj_b != nullptr) {
        *ret_e = rj_e;
    } else {
        *ret_e = pivot;
    }
}
```

## 堆排序
堆排序一般基于二叉堆来实现，子节点的键值小于父节点的。

堆的操作主要有两个，
* `sink`：如果子节点的键值比当前节点的大，那么交换两个节点。重复直到到达叶子节点。
* `swim`：如果父节点的键值比当前节点的小，那么交换两个节点。重复直到到达根节点。

排序需要进行下面两个步骤，
1. 整理数组以满足二叉堆的性质。
    * 从下至上：每个叶子节点可以看做是一个二叉堆，因此从倒数第一个非叶子节点开始，调用`sink`操作。
    * 从上至下：遍历数组，对每个元素调用`swim`操作。
2. 将数组分为两个部分，二叉堆和有序部分，有序部分初始时为空。交换二叉堆的收尾两个元素，并把尾部元素归入有序部分，对首元素调用`sink`使其满足二叉堆的性质。重复以上过程直到二叉堆为空。

```cpp
heap_sort(nums);

void sink(vector<int>& nums, int k, int n) {
    for (int i = k; 2 * i + 1 < n;) {
        int left_child = 2 * i + 1;
        int right_child = left_child + 1;
        int max = i;

        if (nums[max] < nums[left_child]) {
            max = left_child;
        }

        if (right_child < n && nums[max] < nums[right_child]) {
            max = right_child;
        }

        if (i != max) {
            swap(nums[i], nums[max]);
            i = max;
        } else {
            break;
        }
    }
}

void heap_sort(vector<int>& nums) {
    for (int i = int((nums.size() - 2) / 2); i >= 0; i--) {
        sink(nums, i, nums.size());
    }

    for (int i = 0; i < nums.size(); i++) {
        sink(nums, 0, nums.size() - i);
        swap(nums[0], nums[nums.size() - 1 - i]);
    }
}
```

# 查找
# 图
