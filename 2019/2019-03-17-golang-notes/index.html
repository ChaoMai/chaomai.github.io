<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/default_avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/default_avatar.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;chaomai.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;right&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:true,&quot;pangu&quot;:true,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;Searching...&quot;,&quot;empty&quot;:&quot;We didn&#39;t find any results for the search: ${query}&quot;,&quot;hits_time&quot;:&quot;${hits} results found in ${time} ms&quot;,&quot;hits&quot;:&quot;${hits} results found&quot;}}</script><script src="/js/config.js"></script>
<meta name="description" content="文档和资源 语言规范 go命令行文档 包列表 go wiki The Go Blog  要注意的点 关于引用类型 Slice的内部存储 Slice的for range method sets和calls  Packages每个go程序都由package构成。 Exported name在一个包中，如果一个name是以大写字母开头的，那么这个name将会被从这个包中导出。 当import一个包的时候">
<meta property="og:type" content="article">
<meta property="og:title" content="Go笔记">
<meta property="og:url" content="https://chaomai.github.io/2019/2019-03-17-golang-notes/index.html">
<meta property="og:site_name" content="chaomai&#39;s blog">
<meta property="og:description" content="文档和资源 语言规范 go命令行文档 包列表 go wiki The Go Blog  要注意的点 关于引用类型 Slice的内部存储 Slice的for range method sets和calls  Packages每个go程序都由package构成。 Exported name在一个包中，如果一个name是以大写字母开头的，那么这个name将会被从这个包中导出。 当import一个包的时候">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-03-17T06:22:40.000Z">
<meta property="article:modified_time" content="2021-06-27T14:57:29.276Z">
<meta property="article:author" content="Chao Mai">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://chaomai.github.io/2019/2019-03-17-golang-notes/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;en&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;chaomai.github.io&#x2F;2019&#x2F;2019-03-17-golang-notes&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;2019-03-17-golang-notes&#x2F;&quot;,&quot;title&quot;:&quot;Go笔记&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Go笔记 | chaomai's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-34179929-2"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{&quot;tracking_id&quot;:&quot;UA-34179929-2&quot;,&quot;only_pageview&quot;:false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="chaomai's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">chaomai's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>Rss</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E5%92%8C%E8%B5%84%E6%BA%90"><span class="nav-number">1.</span> <span class="nav-text">文档和资源</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">要注意的点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Packages"><span class="nav-number">3.</span> <span class="nav-text">Packages</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Exported-name"><span class="nav-number">3.1.</span> <span class="nav-text">Exported name</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">4.3.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%8E%A8%E6%96%AD"><span class="nav-number">4.5.</span> <span class="nav-text">类型转换和推断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">4.6.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">4.7.</span> <span class="nav-text">全局变量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.</span> <span class="nav-text">语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#for"><span class="nav-number">5.1.</span> <span class="nav-text">for</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if"><span class="nav-number">5.2.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch"><span class="nav-number">5.3.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer"><span class="nav-number">5.4.</span> <span class="nav-text">defer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">其他类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">6.1.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Struct"><span class="nav-number">6.2.</span> <span class="nav-text">Struct</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array"><span class="nav-number">6.3.</span> <span class="nav-text">Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slice"><span class="nav-number">6.4.</span> <span class="nav-text">Slice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">6.5.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.6.</span> <span class="nav-text">字符和字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rune"><span class="nav-number">6.6.1.</span> <span class="nav-text">rune</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">6.6.2.</span> <span class="nav-text">string</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function-values"><span class="nav-number">6.7.</span> <span class="nav-text">Function values</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.</span> <span class="nav-text">方法和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%9B%86%EF%BC%88method-sets%EF%BC%89%E5%92%8C%E8%B0%83%E7%94%A8"><span class="nav-number">7.1.</span> <span class="nav-text">方法集（method sets）和调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.3.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%86%85%E7%BD%AE%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.4.</span> <span class="nav-text">一些内置的接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">8.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Goroutines"><span class="nav-number">8.1.</span> <span class="nav-text">Goroutines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channels"><span class="nav-number">8.2.</span> <span class="nav-text">Channels</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.3.</span> <span class="nav-text">并发模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.4.</span> <span class="nav-text">内存模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">9.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA"><span class="nav-number">10.</span> <span class="nav-text">构建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#static-build"><span class="nav-number">10.1.</span> <span class="nav-text">static build</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">11.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">12.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chao Mai</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chaomai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chaomai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:loneymai@gmail.com" title="E-Mail → mailto:loneymai@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/chaomai" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;chaomai" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://laike9m.com/" title="https:&#x2F;&#x2F;laike9m.com" rel="noopener" target="_blank">laike9m's blog</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chaomai.github.io/2019/2019-03-17-golang-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chao Mai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chaomai's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-03-17 14:22:40" itemprop="dateCreated datePublished" datetime="2019-03-17T14:22:40+08:00">2019-03-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-06-27 22:57:29" itemprop="dateModified" datetime="2021-06-27T22:57:29+08:00">2021-06-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/2019-03-17-golang-notes/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/2019-03-17-golang-notes/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="文档和资源"><a href="#文档和资源" class="headerlink" title="文档和资源"></a>文档和资源</h1><ul>
<li><a target="_blank" rel="noopener" href="https://golang.org/ref/spec">语言规范</a></li>
<li><a target="_blank" rel="noopener" href="https://golang.org/doc/cmd">go命令行文档</a></li>
<li><a target="_blank" rel="noopener" href="https://golang.org/pkg/">包列表</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki">go wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.golang.org/index">The Go Blog</a></li>
</ul>
<h1 id="要注意的点"><a href="#要注意的点" class="headerlink" title="要注意的点"></a>要注意的点</h1><ul>
<li><a href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B">关于引用类型</a></li>
<li><a href="#Slice">Slice的内部存储</a></li>
<li><a href="#Slice">Slice的for range</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E5%8F%A3">method sets和calls</a></li>
</ul>
<h1 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h1><p>每个go程序都由package构成。</p>
<h2 id="Exported-name"><a href="#Exported-name" class="headerlink" title="Exported name"></a>Exported name</h2><p>在一个包中，如果一个name是以大写字母开头的，那么这个name将会被从这个包中导出。</p>
<p>当import一个包的时候，只能引用<strong>被导出</strong>的name。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数名称在前，类型在后，<a target="_blank" rel="noopener" href="https://blog.golang.org/gos-declaration-syntax">Go’s Declaration Syntax</a>。</p>
<p>当多个连续的函数参数有共同的类型是，可以省略不写除最后一个外的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>一个函数可以返回任意个数的结果。</p>
<p>返回值可以是有名字的。当<code>return</code>不带任何参数时，函数返回named return values，这叫做”naked” return。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">	y = sum - x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>var</code>声明多个变量时，只能写最后一个的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c, python <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="comment">// var c int, python bool</span></span><br></pre></td></tr></table></figure>

<p>如果声明时给出了初始值，那么会以初始值的类型作为变量的类型，此时声明中的类型可省略。</p>
<p>在函数内部可以用短变量声明<code>:=</code>来声明变量，类型由值的类型来决定。但在函数外部，由于所有语句都需要以关键字开头，因此不可用这个方法。</p>
<p><strong>初始化</strong><br>在声明变量的时候，变量的值总是会被初始化，要么是用指定的值，要么是零值（变量类型的默认值）。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line">     <span class="comment">// represents a Unicode code point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure>

<p>声明变量但不显式给出初始值，变量会被赋予零值。数值类型：<code>0</code>，bool类型：<code>false</code>，string：<code>&quot;&quot;</code>。</p>
<h2 id="类型转换和推断"><a href="#类型转换和推断" class="headerlink" title="类型转换和推断"></a>类型转换和推断</h2><p>在进行类型转换时，go只能使用<strong>显式</strong>类型转换。</p>
<p>使用<code>:=</code>或<code>var =</code>声明变量、未指明类型、但给出初始值时，变量的类型由对初始值进行类型推断得到。如果右侧是数值常量，那么变量的类型可能是<code>int</code>，<code>float64</code>，<code>complex128</code>。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>只可以用<code>const</code>来声明。数值常量可表示任意精度，且不会溢出。一个未指定类型的常量由上下文来决定其类型。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在程序运行期间，始终存在。声明和初始化方式与普通变量相同，需要在函数外部声明。</p>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比c语言，括号可选、大括号必须</span></span><br><span class="line"><span class="comment">// 不可以使用var的方式声明</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化语句和循环的每次更新可省略</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可当做while使用</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限循环</span></span><br><span class="line"><span class="keyword">for</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比c语言，括号可选、大括号必须</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用短语句，在判断之前执行，语句中声明的变量仅在if和后续的else语句块中可用</span></span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// else不能换行写</span></span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>求值顺序，按case的顺序，自上向下进行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比c语言，</span></span><br><span class="line"><span class="comment">// break可选，不写时自动提供</span></span><br><span class="line"><span class="comment">// case不必是integer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">     fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"> <span class="keyword">case</span> ...</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不带条件的switch相当于switch true</span></span><br><span class="line"> <span class="keyword">switch</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">     fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>使用<code>defer</code>时，被<code>defer</code>的函数会被push到一个stack，参数会<strong>立即计算</strong>，但函数结束时，stack中的函数才会被pop出来执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">t</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;in func t: %s\n&quot;</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(t(<span class="string">&quot;you&quot;</span>))</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// in func t: you</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// you</span></span><br></pre></td></tr></table></figure>

<p><code>defer</code>的函数可以读取和赋值到函数的返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c返回2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c1</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c1返回1</span></span><br></pre></td></tr></table></figure>

<p><strong>defer、panic和recover</strong><br>当调用<code>panic</code>时，所有<code>defer</code>的函数都被正常执行。然后函数返回到调用者。</p>
<p><code>recover</code>仅在<code>defer</code>的函数中有用，正常执行时调用，只会返回<code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from f.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// g发生panic后，这个deferred的函数会执行，并捕获panic</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered in f&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Calling g.&quot;</span>)</span><br><span class="line">    g(<span class="number">0</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from g.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Panicking!&quot;</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Defer in g&quot;</span>, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Printing in g&quot;</span>, i)</span><br><span class="line">    g(i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><p>关于slice，map和channel，某些书中会将它们描述为引用，但从实现上看（例如：<a target="_blank" rel="noopener" href="https://golang.org/src/runtime/slice.go">slice</a>、<a target="_blank" rel="noopener" href="https://golang.org/src/runtime/map.go">map</a>、<a target="_blank" rel="noopener" href="https://golang.org/src/runtime/chan.go">chan</a>），这些类型不过只是封装了底层指针的struct，且go spec也早就在文档中<a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/b34f0551387fcf043d65cd7d96a0214956578f94">移除</a>了reference一词的使用，而在THE WAY TO GO一书中虽然使用了reference一词，但也明确指出，</p>
<blockquote>
<p>A reference type variable r1 contains the address (a number) of the memory location where the value of r1 is stored.<br>…<br>When assigning r2 = r1, only the reference (the address) is copied.<br>…<br>In Go pointers (see § 4.9) are reference types, as well as slices (ch 7), maps (ch 8) and channels (ch 13). ……</p>
</blockquote>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>存储了内存地址，零值为<code>nil</code>。<code>&amp;</code>获得变量的地址，<code>*</code>解引用。</p>
<p>对比c的指针，go的指针无法进行算数运算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure>

<p><strong>指针的类型转换</strong><br><code>unsafe.Pointer</code>：<code>type Pointer int</code>，代表了变量的内存地址，可以将任意变量的内存地址与<code>Pointer</code>指针相互转换。<br><code>uintptr</code>：<code>type uintptr int</code>，<code>Pointer</code>无法进行加减运算，需要转换为<code>uintptr</code>才可以，可以将<code>Pointer</code>与<code>uintptr</code>指针相互转换。<br><code>unsafe.Offsetof</code>：可以得到字段在结构体内的偏移量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*T &lt;=&gt; unsafe.Pointer &lt;=&gt; <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = Vertex &#123;<span class="number">50</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// *Vertex =&gt; Pointer =&gt; *int =&gt; int</span></span><br><span class="line"><span class="keyword">var</span> x = *(*<span class="keyword">int</span>)(unsafe.Pointer(&amp;v))</span><br><span class="line"><span class="comment">// *Vertex =&gt; Pointer =&gt; uintptr =&gt; Pointer =&gt; *int =&gt; int</span></span><br><span class="line"><span class="keyword">var</span> y = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span><br><span class="line"><span class="keyword">var</span> y = *(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;v)) + unsafe.Offsetof(v.Y))</span><br></pre></td></tr></table></figure>

<h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><p>字段的集合，使用<code>.</code>来访问字段。首字母大写和小写分别代表公开和私有。私有变量只有同一个package才可以访问。</p>
<p>对于struct指针，可以使用<code>(*p).X</code>或直接使用<code>p.X</code>来进行访问。对比c，go不能用<code>-&gt;</code>来访问成员。</p>
<p><strong>初始化</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用多行的形式指定一个或多个字段的值的时候，最后的逗号不可以省略。如果只是一行，最后的逗号的可选</span></span><br><span class="line"><span class="comment">// 如果没有指定字段值，那么会使用相应类型默认的零值进初始化。</span></span><br><span class="line"><span class="keyword">var</span> v1 = Vertex &#123;</span><br><span class="line">    X: <span class="number">1</span>,</span><br><span class="line">    Y: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v2 = Vertex &#123;</span><br><span class="line">    X: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v3 = Vertex &#123; X: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 零值结构体实际分配了结构体的内存空间</span></span><br><span class="line"><span class="keyword">var</span> v4 = Vertex &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> v5 = Vertex &#123; <span class="number">1</span>, <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> v6 *Vertex = &amp;Vertex &#123; <span class="number">1</span>,<span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> v7 *Vertex = <span class="built_in">new</span>(Vertex)</span><br><span class="line"><span class="keyword">var</span> v8 Vertex</span><br><span class="line"></span><br><span class="line"><span class="comment">// nil结构体不会分配结构体内存</span></span><br><span class="line"><span class="keyword">var</span> v9 *Vertex = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p><strong>copy</strong></p>
<ul>
<li>结构体之间的copy是深拷贝，不共享结构体内部字段。</li>
<li>结构体指针的copy是浅拷贝，共享内部字段。</li>
</ul>
<p><strong>组合</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    v Vertex</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名组合，此时外部的结构体在使用时，可以直接使用内部结构体的成员和方法。如果内部和外部存在相同名字的方法，会调用外部结构体的方法。</span></span><br><span class="line"><span class="keyword">type</span> Circle2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Vertex</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>和c一样，数组的大小也是数组类型的一部分，声明数组时必须有大小，通过下标访问数组中的元素。</p>
<p>程序执行时，go会检查访问是否越界。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a[<span class="number">10</span>] <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">6</span>] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b[<span class="number">6</span>] <span class="keyword">int</span> = [<span class="number">6</span>] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">c := [<span class="number">6</span>] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">d := [...] <span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125; <span class="comment">// 自动推断长度</span></span><br><span class="line">e := [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">2</span>: <span class="number">20</span>&#125; <span class="comment">// len(e) = 5, e[1] = 10, e[2] = 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组字面值</span></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同类型（长度和元素类型）的数组可以相互赋值，会copy数组的内容</span></span><br><span class="line"><span class="keyword">var</span> e[<span class="number">6</span>] <span class="keyword">int</span></span><br><span class="line">e = a</span><br></pre></td></tr></table></figure>

<p><strong>内部存储</strong><br>连续分配的内存区域。</p>
<p><strong>copy</strong><br>数组的类型由元素的类型和数组的大小决定，相同类型的数组之间才可以copy。拷贝一个数组，数组的内部的元素也会被逐一拷贝，因此作为变量传递时，需要注意copy的开销。</p>
<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>slice的类型为<code>[]int</code>，对数组进行，</p>
<ul>
<li><code>a[low_index:high_index]</code>后得到，区间是前闭后开，可以省略<code>low_index</code>或<code>high_index</code>，默认值分别为<code>0</code>和数组长度。<br>  <code>cap(a)</code> = <code>len(array) - low_index</code></li>
<li><code>a[low_index:high_index:cap_index]</code>后得到，区间是“闭、开、开”。<code>cap_index</code>代表可用到的底层数组的最大index，必须小于<code>len(array)</code>。<br>  <code>cap(a)</code> = <code>cap_index - low_index</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a[<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">4</span>]</span><br><span class="line">a[:]</span><br><span class="line">b := []<span class="keyword">string</span> &#123;<span class="number">99</span>: <span class="string">&quot;&quot;</span>&#125; <span class="comment">// len(b) = 100, cap(b) = 100</span></span><br></pre></td></tr></table></figure>

<p><strong>内部存储</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       +---------------+</span><br><span class="line">slice: |pointer|len|cap|</span><br><span class="line">       +--+------------+</span><br><span class="line">          |</span><br><span class="line">          |</span><br><span class="line">       +--v--------------+</span><br><span class="line">array: |item1|item2|...  |</span><br><span class="line">       +-----------------+</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> address = (**[<span class="number">10</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;s)) <span class="comment">// 底层数组的地址</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">len</span> = (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">8</span>)))</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">cap</span> = (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;s)) + <span class="keyword">uintptr</span>(<span class="number">16</span>)))</span><br></pre></td></tr></table></figure>

<p><strong>slice和array</strong><br>slice本身并不存储任何数据，仅仅是数组选定区间的描述，和数组共享底层的数据。<code>len()</code>和<code>cap()</code>对应了slice的长度，和底层数组从<code>low</code>起的大小，即：<code>len(array) - low</code>。</p>
<p>对已有slice再做一次slice，实际上是改变slice对底层数组的引用范围。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125; <span class="comment">// len(s)=6, cap(s)=6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice the slice to give it zero length.</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend its length.</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>slice字面值类似数组的，区别是没有大小。底层实际上创建了相同大小的数组，然后再创建slice。</p>
<p><strong>nil slice</strong><br>一个nil slice，是未初始化的slice，<code>len</code>和<code>cap</code>都为0，且不会分配底层的数组，数组指针为<code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p><strong>空slice</strong><br>一个空slice的<code>len</code>和<code>cap</code>都为0，且不会分配底层的数组，数组指针值不为空，但是也未分配底层数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">b := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当想声明一个空的slice时，nil slice和空slice都可以，两者在功能上完全等价，但是更<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices">推荐</a>nil slice。但二者进行序列化的时候，结果会不同，nil slice会编码为null，而空slice是<code>[]</code>。</p>
<p><strong>make slice</strong><br>通过<code>make</code>来创建动态长度的数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5, cap(a)=5</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><strong>append</strong><br><code>append</code>函数能够将相同类型元素追加至现有slice，若底层数组大小不够，则会重新分配内存，并将slice指向新数组。</p>
<p>如果发生了扩容，且有另一个slice存在，那么另一个slice的仍然指向老的数组。</p>
<p>扩容时，如果<code>cap &lt; 1024</code>，那么会扩100%，否则扩25%。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure>

<p><strong>range</strong><br>除了普通方法遍历slice，还能使用<code>range</code>，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i是index，v是相应元素的copy。</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可忽略i或v的赋值</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>当使用<code>range</code>返回的值，<code>v</code>时，<strong>要注意的是</strong><code>range</code>返回的是<strong>元素的copy</strong>，而不是引用，如果对齐进行<code>&amp;</code>，那么得不到期望的结果。具体来说，Go会使用<strong>同一个</strong>变量，在每轮迭代中保存元素的copy。可以使用<a target="_blank" rel="noopener" href="https://github.com/kyoh86/scopelint">kyoh86/scopelint</a>来检查代码中的unpinned variables。</p>
<ol>
<li><p>取地址。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Println(&amp;v, &amp;a[i]) <span class="comment">// v的地址保持不变，且不等于a中任意元素的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个原因还有可能导致使用goroutine时出现<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/CommonMistakes#using-goroutines-on-loop-iterator-variables">意外</a>。</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于closure已经绑定到了val，又因为goroutine可能在for结束后才执行</span></span><br><span class="line"><span class="comment">// 因此打印出的可能全都是values的最后一个值。</span></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">for</span> _, val := <span class="keyword">range</span> values &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> valslice &#123;</span><br><span class="line">	val := valslice[i] <span class="comment">// val在每次迭代中都会分配新的</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>copy</strong><br>slice的copy是浅拷贝，两个slice共享底层数组。本质上copy的是：指向底层数组的指针、<code>len</code>和<code>cap</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125; <span class="comment">// len(s)=6, cap(s)=6</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br></pre></td></tr></table></figure>

<p>go还提供了一个函数<code>copy</code>来实现数组内容的copy，copy时，会以目的切片的容量为准。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(dst, src []T)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>结合slice的内部存储、<code>append</code>和拷贝，有的使用场景不注意可能导致意料之外的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncSlice</span><span class="params">(s []<span class="keyword">int</span>, t <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[<span class="number">0</span>]++</span><br><span class="line">	s = <span class="built_in">append</span>(s, t)</span><br><span class="line">	s[<span class="number">0</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	FuncSlice(a, <span class="number">4</span>)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1 1 2 3]</span></span><br></pre></td></tr></table></figure>

<p>具体过程分析如下：</p>
<ol>
<li><code>s[0]++</code>：<code>a</code>和<code>s</code>都指向同一个底层数组<code>arr1</code>，此时<code>a-&gt;arr1</code>，<code>s-&gt;arr1</code>，修改了<code>arr1</code>。</li>
<li><code>append</code>：由于扩容，<code>append</code>返回了一个新的底层数组<code>arr2</code>，<code>a-&gt;arr1</code>，<code>s-&gt;arr2</code>。</li>
<li><code>s[0]++</code>：修改了<code>arr2</code>，<code>arr1</code>不变。</li>
</ol>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>一个仅做了声明的map是<code>nil</code>，需要使用<code>make</code>来进行初始化。切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的key，使用这些类型会造成编译错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line">fmt.Println(m == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line">    <span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map字面值和struct字面值类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123; <span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当最上层的类型只是类型名的时候，可以省略。</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">    <span class="string">&quot;Bell Labs&quot;</span>: &#123; <span class="number">40.68433</span>, <span class="number">-74.39967</span>,&#125;, <span class="comment">//最后的逗号不可缺少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mil map</strong><br>nil map未进行初始化，不能用于存储key-value。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br></pre></td></tr></table></figure>

<p><strong>make map</strong><br>通过<code>make</code>来创建map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p><strong>range</strong><br>类似slice，且slice中存在的问题，map中也同样存在。由于无法获取index，因此只能通过每轮迭代创建变量来解决。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k是key，v是相应元素的copy。</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可忽略k或v的赋值</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> s &#123; ... &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作</strong></p>
<ul>
<li>新增和更新：<code>m[key] = elem</code></li>
<li>访问key的值：<code>elem = m[key]</code>，如果不存在，那么<code>elem</code>为此类型的零值，但如果值真的是零值，那通过这个方法来判断key是否存在就失效了。</li>
<li>删除：<code>delete(m, key)</code></li>
<li>test：<code>var elem, ok = m[key]</code>，如果不存在，那么<code>elem</code>为此类型的零值。</li>
</ul>
<h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><h3 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h3><p>rune字面值代表一个rune常量，是一个标识Unicode code point的整型值。<code>alias for int32</code>。</p>
<p>rune字面值可以用<code>&#39;单个字符&#39;</code>来表示，可以用<code>\</code>转义的多个字符来表示，具体见<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Rune_literals">Rune literals</a>。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string字面值代表了包含一系列字符的string常量，只读。有两种形式：raw string字面值和interpreted string字面值。</p>
<ul>
<li>raw string字面值，是经过未转义处理的，在raw string内部，可以出现任意字符。string中出现的<code>&#39;\r&#39;</code>会被忽略。</li>
<li>interpreted string字面值，go会进行转义处理。具体见<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#String_literals">String literals</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&quot;\U000065e5\U0000672c\U00008a9e&quot;)    \\ 日本語</span><br><span class="line"></span><br><span class="line">fmt.Println(&#96;\U000065e5\U0000672c\U00008a9e&#96;)    \\ \U000065e5\U0000672c\U00008a9e</span><br></pre></td></tr></table></figure>

<p><strong>内部存储</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            +---------------+</span><br><span class="line">byte slice: |pointer|len|cap|</span><br><span class="line">            +--+------------+</span><br><span class="line">               |</span><br><span class="line">               |</span><br><span class="line">            +--v------------+</span><br><span class="line">array:      |item1|item2|...|</span><br><span class="line">            +---^-----------+</span><br><span class="line">                |</span><br><span class="line">            +---+-----------+</span><br><span class="line">string:     |pointer|len|cap|</span><br><span class="line">            +---------------+</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello，你好&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, *(*[<span class="number">2</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;a)))    \\ [<span class="number">4</span>b9f3c e]</span><br><span class="line"></span><br><span class="line">b := a</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, *(*[<span class="number">2</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;b)))    \\ [<span class="number">4</span>b9f3c e]</span><br></pre></td></tr></table></figure>

<p>由于底层存储是数组，因此可以做slice，但要注意的是，这里本质上是对字节来做slice，因此如果slice的Unicode code point不是一个完整的字符，那么打印的时候，是不会正确显示的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello，你好&quot;</span></span><br><span class="line">b := a[<span class="number">0</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(b)    \\ Hello，�</span><br></pre></td></tr></table></figure>

<p>从字符串得到字节slice或者从字节slice得到字符串，会发生底层数组的copy。如果想避免copy，可以手动一个string或slice，获得一个原始string或者slice的“reference”，这种方式不可以通过slice修改string，因为修改后，“reference”到的原有string失效了，可能会被gc回收。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">&quot;Hello，World&quot;</span></span><br><span class="line">b := []<span class="keyword">byte</span>(a) <span class="comment">// copy</span></span><br><span class="line">c := <span class="keyword">string</span>(b) <span class="comment">// copy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动构造</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str2bytes</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> strhead = *(*[<span class="number">2</span>]<span class="keyword">int</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">    <span class="keyword">var</span> slicehead [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    slicehead[<span class="number">0</span>] = strhead[<span class="number">0</span>]</span><br><span class="line">    slicehead[<span class="number">1</span>] = strhead[<span class="number">1</span>]</span><br><span class="line">    slicehead[<span class="number">2</span>] = strhead[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;slicehead))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2str</span><span class="params">(bs []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历</strong></p>
<ul>
<li>按字节遍历：通过下标。</li>
<li>按字符遍历：range方式遍历。</li>
</ul>
<h2 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h2><p>函数也是值，可作为参数传递，作为返回值返回。</p>
<p>闭包（closure）是function value引用了函数体外部的变量，函数可以访问和修改这些变量。换句话说，闭包包含了<strong>函数、以及所在的环境的上下文</strong>。</p>
<h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><h2 id="方法集（method-sets）和调用"><a href="#方法集（method-sets）和调用" class="headerlink" title="方法集（method sets）和调用"></a>方法集（method sets）和调用</h2><p><a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Method_sets">方法集</a>和<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Calls">函数调用</a>的规范明确了一个类型<strong>有哪些方法</strong>，以及<strong>在什么时候可以调用</strong>什么样的方法。go wiki上关于这两个概念有比较详细的<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/MethodSets">例子</a>。</p>
<p><strong>method set</strong></p>
<ol>
<li><p>对于一个接口类型，接口是方法集。</p>
</li>
<li><p>对于一个类型<code>T</code>，所有receiver为T的方法是方法集。</p>
<p> 对于类型T对应的指针类型<code>*T</code>，所有receiver为<code>T</code>或<code>*T</code>的方法是方法集。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Type</th>
<th>method sets</th>
</tr>
</thead>
<tbody><tr>
<td>interface type</td>
<td>interface</td>
</tr>
<tr>
<td>T</td>
<td>func (T) f()</td>
</tr>
<tr>
<td>*T</td>
<td>func (*T) f(), func (T) f()</td>
</tr>
</tbody></table>
<p>一个类型<code>T</code>的方法集决定了，这类型<code>T</code>的接口类型的实现，和使用<code>T</code>作为receiver时可以被调用的方法。</p>
<p><strong>call</strong><br>对于一个方法调用<code>x.m()</code>，</p>
<ol>
<li><p>如果<code>x</code>的method set包含<code>m()</code>，且调用时的参数列表合法，那么这个调用是合法的。</p>
</li>
<li><p>如果<code>x</code>可以<a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Address_operators">取地址的</a>，并且<code>&amp;x</code>的method set包含<code>m()</code>，那么<code>x.m()</code>等价于<code>(&amp;x).m()</code>。</p>
<p> <em>map元素和interface存储的具体值不可取地址。</em></p>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法是带有特殊receiver参数（<code>func</code>和函数名之间）的函数。这个receiver不必是struct，但要求receiver的类型定义必须在同一个package里面，且不能直接将内置类型作为receiver。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Point receiver</strong><br>若要修改字段，则必须使用point receiver，<strong>无论变量本身是否是指针类型</strong>，<strong>非指针receiver调用时发生了copy</strong>。</p>
<p>从这里可以得出使用point receiver的场景：1. 避免copy；2. 修改值本身。一般来说，某个类型的receiver应该<strong>统一</strong>，要么是point receive，要么是普通receiver。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123; v.X = v.X * f ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Scale2</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123; v.X = v.X * f ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若v不是指针类型，那么go会把<code>v.Scale</code>自动转换为<code>（&amp;v）.Scale</code>。</li>
<li>反过来，若v是指针类型，在调用<code>Scale2</code>时，go会把<code>v.Scale2</code>转换为<code>（*v).Scale2</code>。</li>
</ul>
<p>对比c++的成员函数，<code>this</code>指针类似于point receiver，但go的普通receiver是不同于c++的。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是方法签名的集合。</p>
<p>接口的实现是隐式的，无需类似<code>implement</code>的关键字。隐式实现<strong>解耦</strong>接口的定义和实现，在package中，接口的定义可以出现在方法和类型定义之后。注意方法的实现<strong>区分普通receiver和point receiver</strong>。</p>
<p>一个接口值可以被赋值为<strong>任何实现了接口中所有方法的值</strong>。接口值底层实际包含了具体值的类型，接口值可以看做是值和具体类型的元组。调用接口值的方法，实际上会调用具体类型的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123; Abs() <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyInt)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">int64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(<span class="number">1</span>)</span><br><span class="line">i := MyInt(<span class="number">2</span>)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f</span><br><span class="line">a = i</span><br><span class="line">a = &amp;v</span><br><span class="line"></span><br><span class="line"><span class="comment">// a = v</span></span><br><span class="line"><span class="comment">// error，Vertex没有实现Abs()，*Vertex才实现了Abs()</span></span><br></pre></td></tr></table></figure>

<p>对比c++的多态，c++中通过继承基类，并覆盖基类的虚函数，在运行时进行动态绑定，以此实现多态。go的接口方法定义可以看做是基类和虚函数，而<code>a = f</code>相当于将子类的指针赋值给基类指针，这样完成了动态绑定。</p>
<p>不同的点还是receiver，实现接口的方法时，go区分了point receiver和普通receiver。</p>
<p><strong>内部存储</strong><br>实现上，一个接口值底层包含了指向类型和数据的指针。</p>
<p>接口类型之间的赋值和类型转换是共享数据的，而结构体之间的赋值、结构体转接口、接口转结构体，都会导致数据的copy。</p>
<p><strong>空的具体类型值</strong><br>如果接口的具体类型值是空的，那么将会使用<code>nil</code> receiver来调用方法，不引发空指针异常。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123; Abs() <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i Abser</span><br><span class="line"><span class="keyword">var</span> v *Vertex</span><br><span class="line">i = v</span><br><span class="line"></span><br><span class="line">i.Abs()</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">v.Abs()</span><br></pre></td></tr></table></figure>

<p><strong>空的接口值</strong><br>会发生运行时错误，没有具体的<code>Abs</code>方法可以调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123; Abs() <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="keyword">var</span> i Abser</span><br><span class="line">i.Abs()</span><br></pre></td></tr></table></figure>

<p><strong>空接口</strong><br>空接口的值可以包含任何类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var i interface &#123;&#125;</span><br><span class="line">i &#x3D; 32</span><br><span class="line">i &#x3D; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; i &#x3D; 100000000000000000000000000</span><br><span class="line">&#x2F;&#x2F; overflows int</span><br></pre></td></tr></table></figure>

<p><strong>接口变量的赋值</strong><br>对于数值类型，底层的具体类型<strong>只能是</strong><code>int</code>，<code>float64</code>，<code>complex128</code>。</p>
<p><strong>类型断言</strong><br>类型断言提供了访问接口底层具体类型值的能力。</p>
<ul>
<li><code>t := i.(T)</code>断言接口<code>i</code>拥有具体类型<code>T</code>，并把类型<code>T</code>的值赋值给<code>t</code>。如果不是类型<code>T</code>，则触发panic。</li>
<li>test：<code>t, ok := i.(T)</code>断言不正确的情况，不触发panic，而是<code>ok</code>为false，且t为类型<code>T</code>的零值。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">100000000000000000000000000</span> <span class="comment">// overflow</span></span><br><span class="line">a := i.(<span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">100000</span></span><br><span class="line">a := i.(<span class="keyword">int64</span>) <span class="comment">// int</span></span><br></pre></td></tr></table></figure>

<p>Type swtiches是允许断言多个类型的结构。类似switch语句，但是每个case是特定的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果test成功，那么v会转换为相应的类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> T:</span><br><span class="line">    <span class="comment">// here v has type T</span></span><br><span class="line"><span class="keyword">case</span> S:</span><br><span class="line">    <span class="comment">// here v has type S</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// no match; here v has the same type as i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比scala的pattern matching，go的type swtiches像，但不是pattern matching。scala的pattern matching会检查值和pattern是否匹配，能够把值解构为构成值的各部分。<strong>猜测</strong>go的type swtiches是类型字符串是否相等的test。</p>
<h2 id="一些内置的接口"><a href="#一些内置的接口" class="headerlink" title="一些内置的接口"></a>一些内置的接口</h2><p><strong>Stringer</strong><br>类似python的<code>__str__</code>，定义在<code>fmt</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A ...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">a := A()</span><br><span class="line">fmt.Println(a) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p><strong>error</strong><br>类似Stringer，fmt在print的时候也会查找<code>error</code>接口。从fmt的实现上看，是error<strong>优先</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>error</code>更适合用于专门定义的错误类型。否则功能上，<code>stringer</code>和<code>error</code>就冗余了。</p>
<p>可以使用<code>fmt.Errorf</code>或<code>errors.New</code>来创建<code>error</code>类型的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Errorf(<span class="string">&quot;math: square root of negative number %g&quot;</span>, f)</span><br></pre></td></tr></table></figure>

<p><strong>Reader</strong><br>io包定义了<code>io.Reader</code>接口，代表读取stream，有多个实现（文件、网络等）。</p>
<p>其中<code>func (T) Read(b []byte) (n int, err error)</code>方法使用现有数据填充<code>b</code>，并返回填充的字节数和<code>error</code>。stream结束时，<code>error</code>为<code>io.EOF</code>。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><p>由go运行时管理的轻量级线程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure>

<p>参数的计算在当前goroutine中完成，函数<code>f</code>的调用发生在新的goroutine。所有子协程都是平级的关系（包括在子协程内部启动另一个协程）。</p>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>channel是带类型的管道（typed conduit），每次只能发送或接受一个元素。默认情况下，发送方和接收方会一直阻塞到另一方ready，每次只能唤醒一个发送或接受方。</p>
<p><strong>方向</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T <span class="comment">// 可以发送和接受类型为T的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- T <span class="comment">// 可以发送类型为T的数据</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> T <span class="comment">// 可以接受类型为T的数据</span></span><br></pre></td></tr></table></figure>

<p><strong>unbuffered channel</strong><br>unbuffered channel必须保证先有goroutine正在接收，否则发送方会一直阻塞到有goroutine来接收为止。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// len(ch) == 0, cap(ch) == 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// block</span></span><br><span class="line">v := &lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先有goroutine正在接收</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := &lt;-ch</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>buffered channel</strong><br><code>ch := make(chan int, 100)</code>，buffered channel在满或空的情况下，分别会导致发送方和接收方阻塞。</p>
<p><strong>range</strong><br><code>for i := range ch</code>可以从channel逐个接收值，直到channel被关闭。</p>
<p><strong>close</strong></p>
<ul>
<li>发送方可以通过<code>close(ch)</code>来告诉接收方没有后续的值会发送。如果向关闭的channel发送元素，那么会导致抛出异常。</li>
<li>接收方可以使用<code>v, ok := &lt;-ch</code>判断channel是否被关闭。如果从一个已经关闭的channel接收元素，会返回channel类型的零值，因此是不能用这个方式来判断channel是否关闭的。</li>
</ul>
<p><strong>select</strong><br>select语句可以让goroutine等待多个通信操作（发送或接受都可以），block直到其中某个case能执行。如果同时有多个case能执行，则随机选择一个。</p>
<p>若存在default，则当没有case ready的时候，执行default，因此可以通过default实现非阻塞式的发送或接受。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// receiving from c would block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go Concurrency Patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a></li>
</ul>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>go内存模型</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><h2 id="static-build"><a href="#static-build" class="headerlink" title="static build"></a>static build</h2><p><code>go build</code>启用race，也需要启用cgo。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>抛开go的运行时环境和gc不说，go很像c，同时还有着少量函数式语言的特性。</p>
<p>go中，我很喜欢的几点是：</p>
<ol>
<li>变量和函数的声明简洁清晰</li>
<li>goroutine</li>
<li>提供了CSP来实现goroutine之间的通信</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/2019-03-05-python-symtable-module-package/" rel="prev" title="python符号表、module和package">
                  <i class="fa fa-chevron-left"></i> python符号表、module和package
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/2019-05-12-night-sky-in-kunming-and-baotou/" rel="next" title="云南昆明和内蒙包头的星空">
                  云南昆明和内蒙包头的星空 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2014 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chao Mai</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{&quot;enable&quot;:true,&quot;tags&quot;:&quot;none&quot;,&quot;js&quot;:{&quot;url&quot;:&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;mathjax@3.1.4&#x2F;es5&#x2F;tex-mml-chtml.js&quot;,&quot;integrity&quot;:&quot;sha256-ncNI9OXOS5Ek4tzVYiOMmN&#x2F;KKCPZ6V0Cpv2P&#x2F;zHntiA&#x3D;&quot;}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{&quot;enable&quot;:true,&quot;shortname&quot;:&quot;chaomaisblog&quot;,&quot;count&quot;:true,&quot;i18n&quot;:{&quot;disqus&quot;:&quot;disqus&quot;}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
